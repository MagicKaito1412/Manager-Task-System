'use strict';
var fs      = require('fs');
var path 	= require('path');
var util 	= require('util');
var chalk 	= require('chalk');
var mkdirp 	= require('mkdirp');
var exec    = require('child_process').exec;
var https   = require('https');
var Generator = require('yeoman-generator');
var common 	= require('./../common/common');

// consts
var BOWER_REPO_URL_ART = "artifacts.croc.ru/api/bower/bower-virtual";
var BOWER_REPO_URL_GIT = "http://bower.rnd.croc.ru";

var CrocWebclientClientGenerator = Generator.extend({
	constructor: function (args, options, config) {
		Generator.call(this, args, options);
		common.initVersion(this);

		this.nested  = this.options.nested;
		if (this.options.serverProjectDir) {
			this.serverProjectPath = "../" + this.options.serverProjectDir;
		}
		this.clientProjectDir = this.options.clientProjectDir;
	},

	prompting : function () {
		if (!this.nested) {
			common.welcome(this);
		}

		this.log('\n' + chalk.green.bold('\nGenerating client project') +
			" in " + (this.clientProjectDir ? "'" + this.clientProjectDir + "' folder" : "the current folder")
		);

		var cb = this.async();

		var prompts = [];
		if (!this.appName) {
			prompts.push({
				name: 'appName',
				message: 'Enter your app name',
				default: this.options.appName || "MyApp"
			});
		}
		if (!this.serverProjectPath) {
			prompts.push({
				name: 'serverProjectPath',
				message: 'Enter relative path to the server project',
				default: '../Server'
			});
		}

		prompts.push({
			type: 'confirm',
			name: 'useTypeScript',
			message: 'Would you like to use TypeScript (you can continue to code in js, it just installs tsc locally)?',
			default: true
		});

		prompts.push({
			type: 'confirm',
			name: 'useLess',
			message: 'Would you like to use LESS (or just old good CSS)?',
			default: true
		});
		/*
		prompts.push({
			type: 'confirm',
			name: 'useCrocProxy',
			message: 'Would you like to use croc proxy (if you are inside CROC)?',
			default: true
		});
		*/

		prompts.push({
			type: 'list',
			name: 'distrType',
			message: 'What type of package manager and repository for WebClient would you like to use?',
			choices: [{
					value: 'npm',
					name: 'npm'
				}, {
					value: 'bower_art',
					name: 'bower via Artifactory (authentication via bower and Artifactory)'
				}, {
					value: 'bower_git',
					name: 'bower via git (authentication via git)'
				}
			],
			default: 'npm'
		});

		prompts.push({
			name: "useLocalBowerrc",
			type: 'confirm',
			message: "Would you like to use local .bowerrc (if NO then we'll need to setup global .bowerrc before running `bower install`",
			when: function(answers) {
				return answers.distrType === 'bower_art' || answers.distrType === 'bower_git';
			},
			default: true
		});

		prompts.push({
		    name: "bowerUserName",
		    message: "Enter user name for accessing bower registry (your CROC AD account name or 'crocdev'), leave empty for using environment vars",
			when: function (answers) {
				return answers.distrType === 'bower_art' && answers.useLocalBowerrc;
			},
			store: true
		});
		prompts.push({
		    name: "bowerUserPwd",
		    type: "password",
		    message: "Enter user password for accessing bower registry (It won't be kept in cleartext)",
			when: function (answers) {
				return !!answers.bowerUserName && answers.useLocalBowerrc;
			}
		});

		prompts.push({
			type: 'confirm',
			name: 'installDeps',
			message: 'Would you like to install all dependencies (npm & bower packages)?',
			default: true
		});

		this.prompt(prompts).then(function (props) {
			this.appName = this.appName || props.appName;
			this.appNameLower = this.appName.toLowerCase();
			this.serverProjectPath = this.serverProjectPath || props.serverProjectPath;
			this.installDeps 	= props.installDeps;
			this.useTypeScript 	= props.useTypeScript;
			this.useLess 		= props.useLess;
			this.useCrocProxy 	= false; //props.useCrocProxy;
			this.distrType 		= props.distrType;
			this.useBower 		= false;
			this.useBowerArt 	= false;
			this.useBowerGit 	= false;
			this.useLocalBowerrc= props.useLocalBowerrc;
			this.useGit 		= false;
			this.useNpm 		= false;
			this.bowerRegistryUrl = "";

			switch(this.distrType) {
				case "bower_art":
					this.useBower = true;
					this.bowerUserName = (props.bowerUserName||"").toLowerCase();
					this.bowerUserPwd  = props.bowerUserPwd;
					if (this.bowerUserName && this.bowerUserPwd) {
						this.bowerRegistryUrl = "https://" + this.bowerUserName + ":" + this.bowerUserPwd + "@" + BOWER_REPO_URL_ART;
					} else {
						this.bowerRegistryUrl = "https://${BOWER_USR}:${BOWER_PWD}@" + BOWER_REPO_URL_ART;
					}
					this.useBowerArt = true;
					break;
				case "bower_git":
					this.useBower = true;
					this.useBowerGit = true;
					this.useGit = true;
					this.bowerRegistryUrl = BOWER_REPO_URL_GIT;
					break;
				case "npm":
					this.useBower = false;
					this.useNpm = true;
					break;
			}
			if (this.useBower) {
				this.wcDistrRoot = "vendor_components/croc.webClient";
			} else if (this.useNpm) {
				this.wcDistrRoot = "node_modules/@croc/webclient";
			}
			cb();
		}.bind(this));
	},

	configuring: {
		fetchSecureArtPwd: function () {
			if (!this.useBowerArt) return;
			if (!this.bowerUserName || !this.bowerUserPwd) return;

			var done = this.async();
			var that = this;
			var opt = {
				host: 'artifacts.croc.ru',
				auth: this.bowerUserName + ":" + this.bowerUserPwd,
				path: '/api/security/encryptedPassword'
			};
			that.log("Fetching secure password for " + that.bowerUserName + " from Artifactory for bower registry url");
			https.get(opt, function(res) {
				var data = "";
				res.on('data', function (chunk) {
					return data += chunk;
				});
				res.on('end', function () {
					if (res.statusCode == 200) {
						that.bowerRegistryUrl = "https://" + that.bowerUserName + ":" + data + "@" + BOWER_REPO_URL_ART;
					} else {
						that.log("Fetching secure password failed, see response: " + data);
						that.bowerRegistryUrl = "https://" + that.bowerUserName + ":TODO@" + BOWER_REPO_URL_ART;
					}
					//that.log(that.bowerRegistryUrl);
					done();
				});
			});
		}
	},

	writing: function () {
		var _root;
		if (this.clientProjectDir) {
			_root = this.destinationRoot();
			this.destinationRoot(this.clientProjectDir);
		}

		mkdirp.sync('node_modules');

		if (this.useBower) {
			mkdirp.sync('vendor_components');
			this.fs.copyTpl(this.templatePath('_bowerrc'), '.bowerrc', this);
			this.fs.copyTpl(this.templatePath('_bower.json'), 'bower.json', this);
		}

		this.fs.copyTpl(this.templatePath('_package.json'), 'package.json', this);
		this.fs.copyTpl(this.templatePath('Gruntfile.js'), 'Gruntfile.js', this);

		this.fs.copy(this.templatePath('src/content/'), 'src/content/', {dot: true});

		this.fs.copyTpl(this.templatePath('src/_main.config.json'), 'src/main.config.json', this);
		this.fs.copy(this.templatePath('src/main.js'), 'src/main.js');
		this.fs.copy(this.templatePath('src/report-main.js'), 'src/report-main.js');

		//this.directory('src/app', 'src/app');
		this.fs.copy(this.templatePath('src/app/'), 'src/app/', {dot: true});
		if (this.useTypeScript) {
			this.fs.copyTpl(this.templatePath('_tsconfig.json'), 'tsconfig.json', this);
			this.fs.copy(this.templatePath('src/app.ts/'), 'src/app/', {dot: true});
			this.fs.copy(this.templatePath('.idea/typescript-compiler.xml'), '.idea/typescript-compiler.xml');
		} else {
			this.fs.copy(this.templatePath('src/app.js/'), 'src/app/', {dot: true});
		}

		if (this.useLess) {
			this.fs.copyTpl(this.templatePath('src/_styles/root.less'), 'src/app/ui/styles/root.less', this);
			this.fs.copyTpl(this.templatePath('src/_styles/fonts.less'), 'src/app/ui/styles/fonts.less', this, {});
		} else {
			this.fs.copyTpl(this.templatePath('src/_styles/root.css'), 'src/app/ui/styles/root.css', this);
		}

		if (_root) {
			this.destinationRoot(_root);
		}

		/* че-то не работает:
		var done = this.async();
		if (this.useTypeScript) {
			this.env.run(
				'@croc/webclient:client-classes', {
					"model": "src/app/domain/model-meta.js",
					"output": this.destinationRoot() + '/src/app/domain/model',
					"nested": true,
					"typed-meta": false
				},
				done()
			);
		}
		*/
	},

	install: function () {
		var result;
		if (this.installDeps) {
       		// NOTE: стандартный метод installDependencies игнорирует текущую директорию в destinationRoot
			// this.installDependencies({ npm: true, bower: true, skipInstall: this.options['skip-install'] });
			// чтобы переопределить npm install:
			this.log("\n" + chalk.green.bold("\nInstalling npm modules\n"));
			// TODO: мы тут терям интерактивность npm
			result = this.spawnCommandSync('npm', ['install'], {cwd: this.clientProjectDir}, { stdio: 'pipe' });
			if (result.stdout) {
				this.log('    ' + result.stdout.toString());
			}
			if (result.error) {
				this.log("\n" + chalk.red.bold("\nnpm install seems failed. Try running `npm install` manually\n"));
			}

			if (this.useBower) {
				this.log("\n" + chalk.green.bold("Installing bower modules\n"));

				if (this._checkBower() && this._checkGit() ) {
					if (this.useBowerArt && !this.bowerUserName) {
						// installing from Artifactory requires credintials which where not set up, skip
						this.log("Skipped run " + chalk.yellow.bold("bower install") +" as no username/pwd were specified, define environment vars BOWER_USR and BOWER_PWD and run " + chalk.yellow.bold("bower install") + " manually\n")
					} else {
						result = this.spawnCommandSync('bower', ['install'], {cwd: this.clientProjectDir}, { stdio: 'pipe' });
						if (result.stdout) {
							this.log('\t' + result.stdout.toString());
						}	
						if (result.error) {
							this.log("\n" + chalk.red.bold("\nbower install seems failed. Ensure you have installed bower globally (`npm install bower -g`). Run `bower install` in client project folder\n"));
						}
					}
				}
			}
		} else {
			this._checkBower();
			this._checkGit();
		}

		this._checkGrunt();
	},

	end: function () {
		if (this.useTypeScript) {
			this.log('\n' + chalk.yellow("You'll need to generate domain.d.ts from domain metadata with client-class generator: "));
			this.log("  - run: " + chalk.yellow.bold("yo @croc/webclient:client-classes") + " in the folder with model-meta.js");
		}
		if (!this.installDeps) {
			this.log('\n' + chalk.yellow('Next steps for client project: '));
			this.log("  - run: " + chalk.yellow.bold("npm install"));
			if (this.useBower) {
				this.log("  - run: " + chalk.yellow.bold("bower install"));
			}
		}
	},

	_checkBower: function () {
		if (!this.useBower) return true;
		this.log(chalk.gray.bold('checking Bower:'));
		var result = this.spawnCommandSync('bower', ['--version'], { stdio: 'pipe' });
		if (result.stdout) {
			this.log(result.stdout.toString());
		}	
		if (result.error) {
			this.log(chalk.yellow.bold('WARNING!') + ' bower is not found on your computer.\n',
					' Install bower using npm command: ' + chalk.yellow('npm install -g bower')
			);
			return false;
		}
		return true;
	},

	_checkGit: function () {
		if (!this.useGit) return true;
		this.log(chalk.gray.bold('checking Git:'));
		var result = this.spawnCommandSync('git', ['--version'], { stdio: 'pipe' });
		if (result.stdout) {
			this.log(result.stdout.toString());
		}	
		if (result.error) {
			this.log(chalk.yellow.bold('WARNING!') + ' git is not found on your computer.\n',
            		' Install git: ' + chalk.yellow('http://git-scm.com/')
            );
            return false;
		}
		return true;
	},

	_checkGrunt: function () {
		var that = this;
		this.log(chalk.gray.bold('checking Grunt:'));
		var result = this.spawnCommandSync('grunt', ['--version'], { stdio: 'pipe' });
		if (result.stdout) {
			this.log(result.stdout.toString());
		}	
		if (result.error) {
			this.log(chalk.yellow.bold('WARNING!') + ' Grunt is not found on your computer.\n',
					' Install Grunt CLI using npm command: ' + chalk.yellow('npm install -g grunt-cli')
			);
			return false;
		}
		return true;
	}
});
module.exports = CrocWebclientClientGenerator;
