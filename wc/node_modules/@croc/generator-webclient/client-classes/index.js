'use strict';
var path    = require('path');
var chalk   = require('chalk');
var mkdirp  = require('mkdirp');
var fs      = require('fs');
var Generator = require('yeoman-generator');
var common 	= require('./../common/common');
var requirejs = require('requirejs');
var TSGenerator = require('./typescript/Generator');

function parseOptionBoolean(options, name) {
	var val = options[name];
	if (val != null && val !== true && val !== false) {
		options[name] = (val.toString().toLowerCase() !== "false");
	}
}

var DomainClassesGenerator = Generator.extend({
	constructor: function (args, options, config) {
		Generator.call(this, args, options);
		common.initVersion(this);

		this.option("model",  { type: String, alias: "m", desc: "Relative path to AMD-module model.js in RequireJS format" });
		this.option("output", { type: String, alias: "o", desc: "Outfile file name without extension (e.g. 'model')" });
		this.option("typed-meta", { type: Boolean, alias: "meta", desc: "Generate typed metadata as well (XxxMeta interface for every entity)"});
		this.option("typed-array-accessors", { type: Boolean, defaults: true, desc: "Generate typed accessors for navigation array props"});
		this.option("typed-create-methods",  { type: Boolean, defaults: true, desc: "Generate typed createXxx methods in UnitOfWork for every entity"});
	},

	prompting : function () {
		var prompts = [];
		if (!this.options.nested) {
			common.welcome(this);
		}

		this.log(
			"Running " + chalk.yellow.bold("TypeScript domain classes generator for CROC WebClient.\n") 
			);

		if (this.options["model"] === undefined) {
			// model option wasn't specififed, if there's no 'model-meta' in current folder then add a prompt
			try {
				fs.readFileSync("./model-meta.js");
				// ok, will use default name
				this.options.model = "model-meta";
				console.log("Found local 'model-meta.js', will use it as the model metadata file");
			} catch(e) {
				// no file, so add the prompt
				prompts.push({
					name: 'model',
					message: 'Enter path to a js-file (AMD-module) with domain model metadata',
					default: "model-meta"
				});
			}
		}

		if (this.options["typed-meta"] === undefined) {
			prompts.push({
				type: 'confirm',
				name: 'typedMeta',
				message: 'Would you like to generate entities typed metadata (XxxMeta interface for every Xxx entity)?',
				default: true
			});
		}
		parseOptionBoolean(this.options, "typed-meta");
		parseOptionBoolean(this.options, "typed-array-accessors");
		parseOptionBoolean(this.options, "typed-create-methods");

		if (prompts.length > 0) {
			return this.prompt(prompts).then(function (props) {
				this.options["typed-meta"] = props.typedMeta;
				if (props.model) {
					this.options.model = props.model;
				}
			}.bind(this));
		}
	},

	configuring: function() {
		var that = this;
		requirejs.config({
		    baseUrl: this.destinationRoot(),
		    "paths": {
		    	"i18n": __dirname + "/lib/i18n"
		    }
		});
		requirejs.onError = function (err) {
			var modelFile = that.options.model;
			that.log(err);
			that.log( chalk.red.bold("Make sure model module " + modelFile + " is in the current dir or specified via --model option.\n") );
			that.log("Example: yo @croc/webclient:client-classes --model src/app/domain/model-meta");
			process.exit(-1);
		}

		var done = this.async();
		var path = this.options.model;
		if (!path) {
			path = "model-meta";
		} else if (path.endsWith(".js")) {
			path = path.substring(0, path.indexOf(".js"));
		}
		path = path.replace(/\\/g, "/");
		requirejs([path], function (meta) {
			var options = {
				typedMeta: that.options["typed-meta"],
				typedArrayAccessors: that.options["typed-array-accessors"],
				typedCreateMethods:  that.options["typed-create-methods"]
			};
			var tsGen = new TSGenerator(meta);
			that.classesCode = tsGen.generateDeclaration(options);
			that.unitofworkCode = tsGen.generateUnitOfWorkMethods(options);
			done();
		});
	},

	writing: function () {
		var outputFile = this.options.output;	// || "model";
		if (!outputFile) {
			// output path wasn't specified explicitly - place it near model file
			outputFile = path.join(path.dirname(path.resolve(this.options.model)), "model");
		}
		if (!outputFile.endsWith(".d.ts")) {
			outputFile = outputFile + ".d.ts";
		}
		this.fs.copyTpl(
			this.templatePath("_model.d.ts"),
			this.destinationPath(outputFile),
			{ 
				classesCode: this.classesCode,
				unitofworkCode: this.unitofworkCode,
				version: this.version
			}
		);
	}
});

module.exports  = DomainClassesGenerator;