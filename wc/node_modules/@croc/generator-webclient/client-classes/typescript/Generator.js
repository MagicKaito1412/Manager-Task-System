var utils   = require('./../../common/utils');


function preProcessEntities(meta) {
	var name;
	for(name in meta.entities) {
		var typedef = meta.entities[name];
		for(var propName in typedef.props) {
			var propMeta = typedef.props[propName];
			propMeta.name = propName;
			if (propMeta.vt === "complex") {
				processComplexProp(propMeta, typedef, meta);
			}
		}
	}
}

function processComplexProp(complexProp, entity, meta) {
	var complex = meta.complex[complexProp.ref];
	for(var propName in complex.props) {
		var name = complexProp.name + "." + propName;
	}

	utils.forEach(complex.props, function (prop, name) {
		name = complexProp.name + "." + name;
		var clonedProp = utils.append({
			name: name,
			// новое свойство должно быть nullable, если исходное комплексное свойство nullable
			nullable: complexProp.nullable || prop.nullable
		}, prop);

		if (prop.vt !== "complex") {
			entity.props[name] = clonedProp;
		} else {
			// рекурсивно разворачиваем вложенные комплексные свойства
			processComplexProp(clonedProp, entity, meta);
		}
	});
}


function Generator(meta) {
	this.meta = meta;

	preProcessEntities(meta);
}

Generator.prototype.generateDeclaration = function (options) {
	var code = "";

	// enums (meta interface + enum/type)
	code += this.generateDeclarationEnums(options);

	// complex type (meta interface + class)
	code += this.generateDeclarationComplexTypes(options);

	// enities (meta interface + class)
	code += this.generateDeclarationEntities(options);

	// type metadata
	code += this.generateDeclarationMeta(options);

	return code;
}

Generator.prototype.generateDeclarationEnums = function (options) {
	var code = "";
	var name;
	for(name in this.meta.enums) {
		code += (options.typedMeta ? this.getDeclarationEnumMeta(name) : "") + this.getDeclarationEnum(name, options);
	}
	return code;
}

Generator.prototype.getDeclarationEnumMeta = function (name) {
	var meta = this.meta;
	var enumType = meta.enums[name];
	var metaTypeName = name + "Meta";
	var code  = "\nexport interface " + metaTypeName + " extends metadata.EnumMeta {\n";
	code += "\tmembers: {\n";
	for(var memberName in enumType.members) {
		code += "\t\t\"" + memberName + "\": metadata.EnumMember;\n";
	}
	code += "\t};\n";
	code += "}\n";

	return code;
}

Generator.prototype.getDeclarationEnum = function (name, options) {
	var meta = this.meta;
	var enumType = meta.enums[name];
	var vt = enumType.vt;
	var code = "";
	if (vt === "ui1" || vt === "i2" || vt === "i4" || vt === "i8" || vt === "decimal") {
		// numeric enum:
		/*	export enum UserRole {
				Guest = 1,
				Admin = 2,
				User = 4,
			}
		*/
		code = "\nexport enum " + name + " {\n";
		for(var propName in enumType.members) {
			var member = enumType.members[propName];
			code += "\t" + propName  + " = " + member.value + ",\n";
		}
		code += "}\n";
		// for native enum cannot contains static fields, so declare namespace
		if (options.typedMeta) {		
			/*
			export namespace UserRole {
				export const meta: UserRoleMeta;
			}
			*/
			code += "export namespace " + name + " {\n";
			code += "\texport const meta: " + name + "Meta;\n";
			code += "}\n";
		}
	} else {
		// other types (string/dates)
		/*  export type UserRole = "Admin" | "Guest" | "User";
			export declare const UserRole: {
				meta: UserRoleMeta;
				Admin: UserRole;
				Guest: UserRole;
				User: UserRole;
			};
		 */
		code += "\nexport type " + name + " = ";
		var first = true;
		for(var propName in enumType.members) {
			if (first) {
				first = false;
			} else {
				code += " | ";
			}
			code += "\"" + propName + "\"";
		}
		code += ";\n";
		code += "export declare const " + name + ": {\n";
		code += "\tmeta: " + (options.typedMeta ? name + "Meta" : "metadata.EntityMeta") + ";\n";
		for(var propName in enumType.members) {
			code += "\t" + propName + ": " + name + ";\n";
		}
		code += "};\n"
	}
	return code;
}

Generator.prototype.generateDeclarationComplexTypes = function (options) {
	var code = "";
	var name;
	for(name in this.meta.complex) {
		code += (options.typedMeta ? this.getDeclarationComplexMeta(name, options) : "") + this.getDeclarationComplexClass(name, options);
	}
	return code;
}

Generator.prototype.getDeclarationComplexMeta = function (name, options) {
	var type = this.meta.complex[name];
	var codeMeta  = "\nexport interface " + name + "Meta extends metadata.ComplexTypeMeta {\n";
	codeMeta += "\tprops: {\n";
	for(var propName in type.props) {
		codeMeta += "\t\t\"" + propName + "\": metadata.PropertyMeta;\n";
	}
	//codeMeta += "\t\t[key: string]: metadata.PropertyMeta;\n";
	codeMeta += "\t};\n";
	codeMeta += "}\n";
	return codeMeta;
}

Generator.prototype.getDeclarationComplexClass = function (name, options) {
	var meta = this.meta;
	var type = meta.complex[name];
	var metaTypeName = options.typedMeta ? name + "Meta" : "metadata.ComplexTypeMeta";
	var codeClass = "\nexport class " + name + " extends ComplexValue {\n";
	codeClass += "\tstatic meta: " + metaTypeName + ";\n";
	codeClass += "\tmeta: " + metaTypeName + ";\n";
	for(var propName in type.props) {
		var propMeta = type.props[propName];
		propMeta.name = propName;
		codeClass += "\t" + this.getDeclarationClassProperty(propMeta, options) + "\n";
	}
	codeClass += "}\n";
	return codeClass;
}

Generator.prototype.generateDeclarationEntities = function (options) {
	var code = "";
	var name;
	for(name in this.meta.entities) {
		code += (options.typedMeta ? this.getDeclarationEntityMeta(name, options) : "") + this.getDeclarationEntityClass(name, options);
	}
	return code;
}

Generator.prototype.getDeclarationEntityMeta = function (name, options) {
	/*
	export interface SurveyMeta extends metadata.EntityMeta {
		props: { 
			"имя_свойства": metadata.PropertyMeta;
		}
	}
	 */
	var entity = this.meta.entities[name];
	var metaTypeName = name + "Meta";	
	var codeMeta  = "\nexport interface " + metaTypeName + " extends metadata.EntityMeta {\n";

	var valueProps = "";
	var complexProps = "";
	for(var propName in entity.props) {
		if (entity.props[propName].vt !== "complex") {
			valueProps += "\t\t\"" + propName + "\": metadata.PropertyMeta;\n";
		}  else {
			complexProps += "\t\t\"" + propName + "\": metadata.ComplexPropertyMeta;\n";
		}
	}

	if (valueProps || entity.base) {
		codeMeta += "\tprops: ";
		if (entity.base) {
			// join with props from parent
			codeMeta += entity.base + "Meta" + "[\"props\"] "
			if (valueProps) {
				codeMeta += "& ";
			}
		}
		if (valueProps) {
			codeMeta += "{\n" + valueProps + "\t}";
		}
		codeMeta += ";\n";
	}

	if (complexProps || entity.base) {
		codeMeta += "\tcomplex: ";
		if (entity.base) {
			// join with props from parent
			codeMeta += entity.base + "Meta" + "[\"complex\"] "
			if (complexProps) {
				codeMeta += "& ";
			}
		}
		// add local complex props
		if (complexProps) {
			codeMeta += "{\n" + complexProps + "\t}";
		}
		codeMeta += ";\n";
	}

	// close interface
	codeMeta += "}\n";

	/*
	export type XxxNames = {
    	readonly [P in keyof XxxMeta["props"] | XxxMeta["complex"]]: string;
	};
	*/
	codeMeta += "export type " + name + "Names = {\n";
	codeMeta += "\treadonly [P in keyof " + name + "Meta[\"props\"] | keyof " + name + "Meta[\"complex\"]";
	codeMeta += "]: string;\n";
	
	codeMeta += "};\n";
	
	return codeMeta;
}

Generator.prototype.getDeclarationEntityClass = function (name, options) {
	var name;
	var meta = this.meta;
	var entity = meta.entities[name];
	var metaTypeName = options.typedMeta ? name + "Meta" : "metadata.EntityMeta";
	var baseClass = entity.base ? entity.base : "DomainObject";
	var codeClass = "\nexport class " + name + " extends " + baseClass + " {\n";
	codeClass += "\tstatic meta: " + metaTypeName + ";\n";
	if (options.typedMeta) {
		codeClass += "\tstatic NAMES: " + name + "Names;\n";
	}
	codeClass += "\tmeta: " + metaTypeName + ";\n";
	for(var propName in entity.props) {
		var propMeta = entity.props[propName];
		propMeta.name = propName;
		codeClass += "\t" + this.getDeclarationClassProperty(propMeta, options) + "\n";
	}
	codeClass += "}\n";
	return codeClass;
}

Generator.prototype.getDeclarationClassProperty = function (propMeta, options) {
	var propType = this.getPropType(propMeta, options);
	return "\"" + propMeta.name + "\": " + propType + ";";
}

Generator.prototype.getPropType = function (propMeta, options) {
	var type;
	switch(propMeta.vt) {
		case "enum":
			return "lang.ObservableProperty<" + propMeta.ref + ">";
		case "complex":
			return "lang.ObservableGetter<" + propMeta.ref + ">";
		case "object":
			// NOTE: requires import IDomainCollection from "lib/domain/.domain"
			if (options.typedArrayAccessors) {
				return (propMeta.many)
					? "lang.ObservableGetter<IDomainCollection<" + propMeta.ref + ">>"
					: "lang.ObservableProperty<" + propMeta.ref + ">";
			}
			return (propMeta.many)
				? "lang.ObservableGetter<INavigationPropSet>"
				: "lang.ObservableProperty<" + propMeta.ref + ">";

		default:
			return "lang.ObservableProperty<" + this.getPropSimpleType(propMeta) + ">";
	}
}

Generator.prototype.getPropSimpleType = function (propMeta) {
	var vt = propMeta.vt;
	switch(vt) {
		case "ui1":
		case "i2":
		case "i4":
		case "float":
		case "double":
			return "number";
		case "i8":
		case "decimal":
			return propMeta.useNumber ? "number" : "Big";
		case "dateTime":
		case "date":
		case "time":
		case "dateTimeTz":
		case "timeTz":
			return "Date";
		case "string":
		case "text":
			return "string";
		case "boolean":
			return "boolean";
		case "binary":
			// NOTE: requires import "lib/domain/support"
			return "LobPropValue";
		case "uuid":
			return "string";
		case "timeSpan":
			return "number";
		case "smallBin":
			return "string";	
		default:
			return "__UnknownType__";
	}
}

Generator.prototype.generateDeclarationMeta = function (options) {
	var code = "";
	var name;
	var meta = this.meta;
	if (options.typedMeta) {
		code += "\nexport interface ModelMeta extends metadata.ModelMeta {\n";
		code += "\tenums: {\n";
		//code += "\t\t[key: string]: metadata.EnumMeta;\n";
		for(name in meta.enums) {
			code += "\t\t" + name + ": " + name + "Meta;\n";
		}
		code += "\t};\n";
		code += "\tcomplex: {\n";
		//code += "\t\t[key: string]: metadata.ComplexTypeMeta;\n";
		for(name in meta.complex) {
			code += "\t\t" + name + ": " + name + "Meta;\n";
		}
		code += "\t};\n";
		code += "\tentities: {\n";
		//code += "\t\t[key: string]: metadata.EntityMeta;\n";
		for(name in meta.entities) {
			code += "\t\t" + name + ": " + name + "Meta;\n";
		}
		code += "\t};\n";
		code += "}\n";
		code += "export const meta: ModelMeta;"
	} else {
		code += "\nexport const meta: metadata.ModelMeta;";
	}
	return code;
}

Generator.prototype.generateUnitOfWorkMethods = function (options) {
	// code: createUser(props?: lang.Map<any>): User;
	var code = "";
	if (options.typedCreateMethods) {
		var name;
		for(name in this.meta.entities) {
			code += "\tcreate" + name + "(props?: lang.Map<any>): " + name + ";\n";
		}
		return code;
	}
}

module.exports  = Generator;
