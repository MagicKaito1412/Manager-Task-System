import $ = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import template = require("xhtmpl!./templates/NotificationProcess.hbs");
import lang = core.lang;

class NotificationProcess extends View {
	static defaultOptions: NotificationProcess.Options = {
		template: template,
		timeout: 1000,
		speed: 300,
		container: document.body
	};
	options: NotificationProcess.Options;
	_timeout: number;
	_rendering: boolean;

	/**
	 * @constructs NotificationProcess
	 * @extends View
	 */
	constructor(options?: NotificationProcess.Options) {
		options = NotificationProcess.mixOptions(options, NotificationProcess.defaultOptions);
		super(options);
	}

	render (): void {
		let that = this;

		if (that.viewModel.promise.state() !== "pending") {
			return;
		}

		that.viewModel.promise.always(() => {
			that.close();
		});

		if (that.options.timeout) {
			that._timeout = window.setTimeout(that._doRender.bind(that), that.options.timeout);
		} else {
			that._doRender();
		}
	}

	_doRender (): void {
		let that = this;

		if (that.viewModel.promise.state() !== "pending") {
			return;
		}

		let $element = $("<div style='display: none' class='x-process-container'></div>").appendTo(that.options.container);
		View.prototype.render.call(this, $element);
		that._rendering = true;
		$element.fadeTo(that.options.speed, 1, () => {
			that._rendering = true;
		});
		$element.find("a").on("click", function () {
			that.close();
			return false;
		});
		that.$domElement = $element;
		that.domElement = $element[0];
	}

	/**
	 * Animated closing notification.
	 * NOTE: If notification wasn't rendered (as timer hasn't fired yet) it clears the timer.
	 * NOTE: It removes UI from DOM on animation completes .
	 */
	close (): void {
		let that = this,
			$element = that.$domElement;
		if (that._timeout) {
			window.clearTimeout(that._timeout);
			that._timeout = undefined;
		}
		if ($element) {
			if (that._rendering) {
				// fadeTo animation hasn't completed yet, it unsafe to schedule another concurrent animation
				that.unload();
			} else {
				$element.fadeOut(that.options.speed, () => {
					that.unload();
				});
			}
		}
	}

	unload (): void {
		let that = this,
			$element = that.$domElement;
		if (that._timeout) {
			window.clearTimeout(that._timeout);
		}
		super.unload();
		if ($element) {
			$element.remove();
		}
	}
}
namespace NotificationProcess {
	export interface Options extends View.Options {
		speed?: number;
		timeout?: number;
		container?: JQuery|HTMLElement;
	}
}
NotificationProcess.mixin({
	defaultOptions: NotificationProcess.defaultOptions
});

core.ui.NotificationProcess = NotificationProcess;

export = NotificationProcess;
