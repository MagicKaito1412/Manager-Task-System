import $ = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import Menu = require("lib/ui/menu/Menu");
import template = require("xhtmpl!./templates/Notification.hbs");
import "vendor/notify/jquery.notify";
import "xcss!./styles/module-notifications.css";
import lang = core.lang;

class Notification extends View {
	static defaultOptions: Notification.Options = {
		template: template,
		unbound: true,
		timeout: 5000,
		speed: 500
	};
	private _isClosed: boolean;
	private _notification: JQueryNotifyInstance;

	// common container for jquery.notify
	@lang.decorators.constant($("<div style='display:none' class='noprint'><div></div></div>").appendTo(document.body).notify())
	_container: JQueryNotifyWidget;

	persist: boolean;
	options: Notification.Options;

	/**
	 * @constructs Notification
	 * @extends View
	 */
	constructor(options?: Notification.Options) {
		options = Notification.mixOptions(options, Notification.defaultOptions);
		super(options);
	}

	render (): void {
		super.render(null);
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;

		if (that._isClosed) {
			return;
		}

		that._notification = that._container.notify(
			"create",
			{}, // empty parameters
			{
				close: () => {
					that.dispose();
				},
				open: () => {
					that._onShown();
				},
				expires: that.persist ? 0 : that.options.timeout,
				speed: that.options.speed
			}
		);

		super.doRender(that._notification.element);

		// add a hook for links with special class, clicking on that links will execute corresponding commands
		if (that.viewModel.menu) {
			$(that._notification.element).on("click", ".x-cmd-link", function (e) {
				if (core.commands.tryToExecuteHtmlCommand($(this), that.viewModel.menu)) {
					e.preventDefault();
				}
			});
		}

		// hook clicking on little cross - we'll close notification
		that._notification.element.find(".ui-notify-close").click(function (e) {
			e.preventDefault();
			that.close(/*archive=*/true);
			return false;
		});
	}

	/**
	 *
	 * @param {SystemEvent} sysEvent
	 */
	setViewModel(sysEvent: core.SystemEvent): void {
		let that = this;
		super.setViewModel(sysEvent);
		that.persist = (sysEvent.priority === "high");
		if (that.viewModel.menu) {
			that.viewModel.menu.onceExecuted(that._onCmdExecuted.bind(that));
		}
		// if event is removed via EventLog (while UI-notification is still open) then we should close (not dispose as we want to be sure to close UI)
		sysEvent.bind("change:state", (sender, state) => {
			if (state === "archived") {
				that.close(/*archive=*/false);
			}
		}, that);
	}

	_onShown(): void {
		if (this._isClosed) {
			return;
		}
		this.viewModel.state(core.SystemEvent.State.active);
	}

	_onCmdExecuted(args): void {
		let archive = (!args || args.result !== false);
		// If user executes any command in UI-notification it will close the UI-notification
		// (as he clicks the "cross" button)
		this.close(/*archive=*/archive);
	}

	close (archive?: boolean): void {
		let that = this,
			notification = that._notification;

		that._isClosed = true;
		if (notification) {
			that._notification = undefined;
			// notification.close will call 'dispose' later
			notification.close();
		} else {
			// closing not rendered notification
			that.dispose();
		}
		if (that.viewModel) {
			// UI-notification has been manually closed by user
			that.viewModel.unbind("change:state", null, that);
			if (archive && that.viewModel.state() === core.SystemEvent.State.active) {
				that.viewModel.state(core.SystemEvent.State.archived);
			} else if (that.viewModel.state() === core.SystemEvent.State.pending) {
				// notification is being closed even before it was shown, change its state from 'pending' to 'active' for clearance
				that.viewModel.state(core.SystemEvent.State.active);
			}
		}
	}

	dispose(): void {
		let that = this;
		that._isClosed = true;
		that.trigger("close", that);
		that._notification = undefined;
		super.dispose();
	}
}
namespace Notification {
	export interface Options extends View.Options {
		timeout?: number;
		speed?: number;
	}
}
Notification.mixin({
	defaultOptions: Notification.defaultOptions
});

core.ui.Notification = Notification;

export = Notification;
