import core = require("core");
import View = require("lib/ui/handlebars/View");
import tmplEventLogView = require("xhtmpl!./templates/EventLogView.hbs");
import resources = require("i18n!lib/nls/resources");
import lang = core.lang;
import {Menu} from "core.ui";

class EventLogView extends View {
	static defaultOptions: EventLogView.Options = {
		template: tmplEventLogView,
		unbound: false
	};

	private events: lang.ObservableCollection<core.SystemEvent>;
	commands: lang.Map<core.commands.ICommand>;
	menu: Menu.Options;

	/**
	 * @class EventLogView
	 * @extends PopupView
	 * @param {ObservableCollection} eventLog
	 * @param {Object} [options]
	 */
	constructor (eventLog?: lang.ObservableCollection<core.SystemEvent>, options?: EventLogView.Options) {
		options = EventLogView.mixOptions(options, EventLogView.defaultOptions);
		super(options);

		this.events = eventLog;
		this.commands = this.createCommands();
		this.menu = {
			items: [{
				name: "RemoveAll",
				title: resources["delete_all"],
				icon: "remove",
				command: core.createCommand({
					execute: () => {
						this._removeAllEvents();
						return false;
					}
				})
			}, {
				name: "ArchiveAll",
				title: resources["archive_all"],
				icon: "archive",
				command: core.createCommand({
					execute: () => {
						this._archiveAllEvents();
						return false;
					}
				})
			}]
		};
	}

	/**
	 * @observable-property {SystemEvent}
	 */
	@core.lang.decorators.observableAccessor()
	activeItem: core.lang.ObservableProperty<core.SystemEvent>;

	createCommands (): lang.Map<core.commands.ICommand> {
		return {
			"Dismiss": core.createCommand({
				execute: (args) => {
					// TODO:
					let item = args.item;
					if (item) {
						if (item.kind === "notification") {
							// TODO: Run animation to remove the notification
							this._removeEvent(item);
							return false;
						}
					}
				}
			}),
			"Select": core.createCommand({
				execute: (args) => {
					let item = args.item;
					if (item && item.kind === core.SystemEvent.Kinds.notification) {
						this.activeItem(item);
						if (item.state() === "active" || item.state() === "pending") {
							item.state("archived");
						}
					}
				}
			})
		};
	}

	protected _removeEvent (item: core.SystemEvent): void {
		if (this.activeItem() === item) {
			this.activeItem(null);
		}
		this.events.remove(item);
		item.state("archived");
	}

	protected _removeAllEvents (): void {
		let toRemove = [];
		this.events.forEach((item: core.SystemEvent) => {
			if (item.kind === core.SystemEvent.Kinds.notification && item.state() !== "archived") {
				item.state("archived");
			}
			if (item.state() === "archived") {
				toRemove.push(item);
			}
		});
		this.events.remove(toRemove);
	}

	protected _archiveAllEvents (): void {
		this.events.forEach((item: core.SystemEvent) => {
			if (item) {
				if (item.kind === core.SystemEvent.Kinds.notification) {
					item.state("archived");
				}
			}
		});
	}
}
namespace EventLogView {
	export interface Options extends View.Options {
	}
}
EventLogView.mixin({
	defaultOptions: EventLogView.defaultOptions
});
core.ui.EventLogView = EventLogView;

export = EventLogView;
