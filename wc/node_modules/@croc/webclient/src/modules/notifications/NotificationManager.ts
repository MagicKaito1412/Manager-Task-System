import $ = require("jquery");
import core = require("core");
import Notification = require("./ui/Notification");
import "./ui/Notification";
import NotificationBar = require("./ui/NotificationBar");
import "./ui/NotificationBar";
import NotificationProcess = require("./ui/NotificationProcess");
import "./ui/NotificationProcess";
import EventLogView = require("./ui/EventLogView");
import "./ui/EventLogView";
import PopupView = require("lib/ui/PopupView");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;

class NotificationManager extends lang.Observable {
	static defaultOptions: NotificationManager.Options = {
		partsOptions: {
			process: {},
			notification: {},
			bar: {}
		}
	};
	options: NotificationManager.Options;

	private _eventLog: lang.ObservableCollection<core.SystemEvent>;
	private _activeNotifications: lang.ObservableCollection<Notification>;
	private _activeProcesses: lang.ObservableCollection<NotificationProcess>;
	private _notifyBar: NotificationBar;
	// events which are waiting to be processed (published but not processed yet)
	private _pendingEvents: core.SystemEvent[];

	/**
	 * @constructs NotificationManager
	 * @extends Observable
	 */
	constructor (options?: NotificationManager.Options) {
		super();
		this.options = core.lang.appendEx(this.options || options || {}, NotificationManager.defaultOptions, {deep: true});

		this._eventLog = new lang.ObservableCollection<core.SystemEvent>();
		this._eventLog.bind("change", () => {
			let active = 0;
			core.lang.forEach(this._eventLog, (item) => {
				if (item.state() !== "archived") {
					active += 1;
				}
			});
			this.activeEvents(active);
		});
		this._eventLog.bind("itemChange", () => {
			let active = 0;
			core.lang.forEach(this._eventLog, (item: core.SystemEvent) => {
				if (item.state() !== "archived") {
					active += 1;
				}
			});
			this.activeEvents(active);
		});

		this._activeNotifications = new core.lang.ObservableCollection<Notification>();
		this._activeProcesses = new core.lang.ObservableCollection<NotificationProcess>();
		this._notifyBar = new core.ui.NotificationBar(this.options.partsOptions.bar);
		this._pendingEvents = [];
	}

	/**
	 * Count of active events.
	 * @observable-property {Number}
	 */
	@core.lang.decorators.observableAccessor()
	activeEvents: core.lang.ObservableProperty<number>;

	@lang.decorators.constant(lang.debounce("_processEvents", 100, "_queueEventTimer"))
	_processEventsAsync: () => void;

	/**
	 * Process published SystemEvent
	 * @param {String} name Application event name (as it was supplied to EventPublisher.publish)
	 * @param {SystemEvent} sysEvent
	 * @returns {Boolean} true if event was processed
	 */
	processEvent (name: string, sysEvent: core.SystemEvent): boolean {
		let that = this,
			eventArgs;

		if (!sysEvent || !sysEvent.isSystemEvent || sysEvent.state() !== "pending") {
			return false;
		}
		sysEvent.type = name;

		eventArgs = {event: sysEvent, publish: !!sysEvent.message};
		that.onBeforePublish(eventArgs);
		if (!eventArgs.publish) {
			return false;
		}

		that._pendingEvents.push(sysEvent);
		that._processEventsAsync();

		return true;
	}

	protected _processEvents (): void {
		let event;
		while (this._pendingEvents.length) {
			event = this._pendingEvents.shift();
			this._processEvent(event);
		}
	}

	protected _initProps (sysEvent: core.SystemEvent): void {
		if (!sysEvent.kind) {
			if (sysEvent.promise) {
				sysEvent.kind = "process";
			} else {
				sysEvent.kind = "notification";
			}
		}
		if (!sysEvent.priority) {
			sysEvent.priority = "normal";
		}
		if (!sysEvent.severity) {
			sysEvent.severity = "info";
		}
	}

	protected _processEvent (sysEvent: core.SystemEvent): void {
		let that = this;

		that._initProps(sysEvent);

		if (sysEvent.kind === "process") {
			if (!sysEvent.promise) {
				// log error
				console.warn("NotificationManager: got SystemEvent with kind='process' but w/i promise");
				return;
			}
			// process - это SystemEvent с promise'ом,
			// после завершения promise'a, нотификация должна удаляться
			// priority 'normal' won't be put in eventLog
			if (sysEvent.priority !== "normal") {
				that._addEventToLog(sysEvent);
				sysEvent.promise.always(() => {
					that._eventLog.remove(sysEvent);
				});
			}
			if (sysEvent.priority !== "low") {
				that.createProcessPart(sysEvent);
			}
		} else if (sysEvent.kind === "notification") {
			if (sysEvent.priority !== "low") {
				that._addEventToLog(sysEvent);
			}
			that.createNotificationPart(sysEvent);
		} else if (sysEvent.kind === "actionRequest") {
			if (!sysEvent.menu || sysEvent.menu.items.length === 0) {
				sysEvent.menu = core.ui.Menu.create({
					items: [{
						name: "Close", title: "Close",
						command: core.createCommand({
							execute: () => {
								// NOTE: it's empty command, but executing it will fire 'executed' event which is tracked by NotificationBar
							}
						})
					}]
				});

			}
			that._notifyBar.add(sysEvent);
		}
	}

	createNotificationPart (sysEvent: core.SystemEvent): Notification {
		let that = this,
			part = new core.ui.Notification(this.options.partsOptions.notification),
			toClose = [];

		part.setViewModel(sysEvent);

		// throttling: close active UI-notifications with the same type/priority/severity as the new one
		core.lang.forEach(that._activeNotifications, (notification) => {
			let event = notification.viewModel;
			if (event.type === sysEvent.type && event.priority === sysEvent.priority && event.severity === sysEvent.severity) {
				toClose.push(notification);
			}
		});
		if (toClose.length) {
			core.lang.forEach(toClose, (notification) => {
				notification.close(/*archive=*/false);
			});
		}
		that._activeNotifications.add(part);
		let disposable = part.subscribe("close", (sender) => {
			disposable.dispose();
			that._activeNotifications.remove(sender);
		});

		window.setTimeout(() => {
			if (!part.isDisposed) {
				part.render();
			}
		}, 0);

		return part;
	}

	createProcessPart (sysEvent: core.SystemEvent): NotificationProcess {
		let that = this,
			part = new core.ui.NotificationProcess(that.options.partsOptions.process);
		part.setViewModel(sysEvent);
		part.render();

		that._activeProcesses.add(part);
		let disposable = part.subscribe("unload", (sender) => {
			disposable.dispose();
			that._activeProcesses.remove(sender);
		});

		return part;
	}

	onBeforePublish (eventArgs: NotificationManager.PublishEventArgs): void {
		this.trigger("notificationPublishing", this, eventArgs);
	}

	protected _addEventToLog (sysEvent: core.SystemEvent): void {
		let that = this;
		// notifications are added after processes (newest top)
		if (sysEvent.kind === core.SystemEvent.Kinds.notification) {
			// find the last process and append the new one after it:
			let startIdx = 0;
			that._eventLog.some((item, i) => {
				if (item.kind !== core.SystemEvent.Kinds.process) {
					startIdx = i;
					return true;
				}
				startIdx = i + 1;
			});
			if (sysEvent.state() === "pending") {
				sysEvent.state("active");
			}
			that._eventLog.insert(sysEvent, startIdx);
		} else {
			// processes are always added at the top
			that._eventLog.insert(sysEvent, 0);
		}
	}

	/**
	 * Return a UI part for SystemMenu showing EventLog.
	 * @return {PopupView}
	 */
	getEventLogView (): PopupView {
		let eventLog = new core.ui.EventLogView(this._eventLog);
		return new PopupView({
			body: eventLog,
			title: resources["notifications.moduleName"],
			unbound: false,
			disposeOnClose: true,
			//height: "350",
			menu: eventLog.menu
		});
	}

	dispose (): void {
		let that = this;
		that._activeNotifications.forEach((item: Notification) => {
			item.close();
		});
		that._activeNotifications.clear();

		that._activeProcesses.forEach((item) => {
			item.unload();
		});
		that._activeProcesses.clear();
	}
}
namespace NotificationManager {
	export interface Options {
		partsOptions: {
			process?: any;
			notification?: any;
			bar?: any;
		};
	}

	export interface PublishEventArgs {
		event: core.SystemEvent;
		publish: boolean;
	}
}
core.ui.NotificationManager = NotificationManager;
export = NotificationManager;
