import $ = require("jquery");
import core = require("core");
import utils = require("lib/utils");
import Component = require("lib/ui/Component");
import Menu = require("lib/ui/menu/Menu");

import resources = require("i18n!lib/nls/resources");

import "lib/ui/menu/MenuButtonsPresenter";
import lang = core.lang;
import Application = core.Application;
import Command = core.commands.Command;
import Part  = require("lib/ui/Part");
import Handlebars = require("handlebars-ext");

import UriCommand = ReportPartBase.UriCommand;

class ReportPartBase extends Component {

	static defaultOptions: ReportPartBase.Options  = {
		refresh: false,
		dontCacheXslFo: false,
		bound: true,
		affixTableHeader: true,
		showTitle: true
	};

	/**
	 * @observable-property {ReportPartBase.State}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<ReportPartBase.State>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	reportContent: lang.ObservableProperty<string>;

	/**
	 * @observable-property {any}
	 */
	@lang.decorators.observableAccessor()
	lastError: lang.ObservableProperty<any>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	hintMessage: lang.ObservableProperty<string>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	stateMessage: lang.ObservableProperty<string>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	title: lang.ObservableProperty<string>;

	options: ReportPartBase.Options;
	app: Application;
	commands: ReportPartBase.KnownCommands;
	menu: Menu;
	protected _commandsAvailable: boolean;
	private _needRefresh: boolean;

	/**
	 * @constructs ReportPartBase
	 * @extends Component
	 * @param {Application} app
	 * @param {Object} options
	 */
	constructor(app: Application, options: ReportPartBase.Options) {
		if (!app)
			throw new Error("ReportPartBase.ctor: app can't be null");

		options = ReportPartBase.mixOptions(options, ReportPartBase.defaultOptions);
		super(options);

		let that = this;
		that.app = app;
		that.title(options.title);
		that.state(ReportPartBase.State.initial);
		that.userSettings = core.UserSettings.create(that.options.userSettings);

		that._initializeProps();

		that.commands = that.createCommands();
		that._initializeMenus();

		that.initPresenter();

		that.bind("change:state", function (sender, state) {
			that._stateChanged(state);
		});
	}

	tweakOptions(options) {
		core.lang.appendEx(options, {
			presenterOptions: {
				template: options.template,
				bound: options.bound,
				affixTableHeader: options.affixTableHeader
			}
		}, { deep: true });
		super.tweakOptions(options);
	}

	isGenerating(): boolean {
		return this.state() === ReportPartBase.State.generating;
	}

	isInitial(): boolean {
		return this.state() === ReportPartBase.State.initial;
	}

	protected _initializeProps(): void {
		let that = this;
		that.options.reportName = that.options.reportName || that.options.urlSuffix;
		if (!that.options.reportName) {
			throw new Error("ReportPartBase.ctor: options.reportName were not specified.");
		}
	}

	protected _initializeMenus(): void {
		let that = this;
		that.menu = that._createMenu();
		if (that.menu) {
			that.menu.bindToPart(that);
		}
	}

	protected _createMenuDefaults(): Menu.Options {
		// no default menu in base implementation
		return null;
	}

	protected _createMenu(): Menu {
		// base implementation
		return new Menu(this._createMenuDefaults(), this.options.menu);
	}

	/**
	 * Create commands
	 * @protected
	 * @returns {{Build: BoundCommand, Export: BoundCommand, OpenReport: BoundCommand}}
	 */
	protected createCommands(): ReportPartBase.KnownCommands {
		let that = this,
			commands: ReportPartBase.KnownCommands = {
				Build: new core.commands.BoundCommand(that._doBuild, that),
				Export: new core.commands.BoundCommand(that._doOpen, that),
				OpenReport: new core.commands.BoundCommand(that._doOpenReport, that)
			};

		core.lang.extend(commands, that.options.commands);
		return commands;
	}

	protected _stateChanged(state): void {
		let that = this;
		that._commandsAvailable = (state !== ReportPartBase.State.generating);
		that.invalidateCommands();
	}

	protected invalidateCommands(): void {
		let that = this,
			canExec = that._commandsAvailable;
		that.commands.Build.canExecute(canExec);
		that.commands.Export.canExecute(canExec && !that.lastError());
	}

	/**
	 * Override base getState to add current params into URL.
	 */
	getState(): any {
		if (this.options.params) {
			return { params: this.options.params || {} };
		}
	}

	/**
	 * Returns merge result of external params (passed via options) and current params.
	 * @return {Object}
	 * @protected
	 */
	protected getParams(): any {
		return  core.lang.extend({}, this.options.params || {});
	}

	protected _doBuild(): lang.Promise<void> {
		let that = this,
			params,
			query,
			task;

		that.hintMessage(undefined);
		params = that.getParams();
		// NOTE: null params mean there was an error during getting params
		if (params == null) { return; }

		try {
			that.state(ReportPartBase.State.generating);
			that.hintMessage(undefined);

			// если идет второе построение отчета - нужно обновлять в любом случае
			params.refresh = that._needRefresh || that.options.refresh;
			// в следующий раз точно обновлять
			that._needRefresh = true;
			if (that.options.dontCacheXslFo) {
				params.dontCacheXslFo = true;
			}

			query = {
				url: "api/reports/" + that.options.reportName,
				data: params
			};

			task = that.app.dataFacade.ajax(query, {
				processEvent: { message: resources["reportPart.building"]},
				supportsGetPost: true,
				contentType: "text/html"
			});

			return task.then((result) => {
				try {
					that.reportContent(result);
					return result;
				} finally {
					that.lastError(null);
					that.state(ReportPartBase.State.generated);
					that.stateMessage("");
				}
			}, (error) => {
				that._onError(error);
			});
		} catch (ex) {
			that._onError(ex);
			return core.lang.rejected(ex);
		}
	}

	protected _doOpen(cmdOptions): void {
		let that = this;

		that.hintMessage(undefined);
		let params = that.getParams();
		// NOTE: null params mean there was an error during getting params
		if (params == null) { return; }

		cmdOptions =  cmdOptions || {};

		try {
			let format = cmdOptions.format || "HTML";

			if (that.options.refresh) { params.refresh = true; }
			if (that.options.dontCacheXslFo) { params.dontCacheXslFo = true; }

			let url = (format === "HTML" ? "display/report/" : "api/reports/") +
				that.options.reportName;

			if (format !== "HTML") {
				params.format = format;
				that._downloadReport(url, params);
			} else {
				let root = that.app.config.root;
				if (root && url.indexOf(root) !== 0) {
					url = utils.combinePaths(root, url);
				}
				if (params) {
					let queryString = utils.buildUriParams({params: params});
					if (queryString ) {
						url += "?" + encodeURI(queryString);
					}
				}
				window.open(url, "_blank", "menubar=0, scrollbars=1, location=1, resizable=1", true);
			}
		} catch (ex) {
			that._onError(ex);
		}
	}

	protected _downloadReport(url: string, params: ReportPartBase.Params): lang.Promise<void> {
		let that = this;

		that.app.eventPublisher.publish("report.export.begin", core.SystemEvent.create({
			kind: core.SystemEvent.Kind.notification,
			priority: "low",
			severity: "info",
			message: resources["reportPart.buildStarted"]
		}));

		let ajaxSettings = {
			url: url,
			data: params,
			type: "GET"
		};

		return that.app.dataFacade.ajax(
			ajaxSettings,
			{fileDownload: true, processEvent: { message: resources["interop.retrieving_data"]} }
			).done((): void => {
				// файл получен на браузер. сейчас браузер предложит сохранение и тд
				that.app.eventPublisher.publish("report.export.success", core.SystemEvent.create({
					kind: core.SystemEvent.Kind.notification,
					priority: "low",
					severity: "success",
					message: resources["reportPart.reportDownloaded"]
				}));
			});
	}

	protected _onError(e: Error): void {
		let that = this;
		that.lastError(e);
		that.reportContent(null);
		that.state(ReportPartBase.State.failed);
		that.stateMessage(resources["reportPart.buildingError"] + e.message);
	}

	protected _doGoBack(): void {
		if (this.navigationService) {
			this.navigationService.close();
		}
	}

	/**
	 * Open a nested report
	 * @param {Object} cmdOptions
	 * @private
	 */
	protected _doOpenReport(cmdOptions): void {
		let that = this;
		if (that.navigationService) {
			let reportParams = core.lang.extend(cmdOptions.reportParams, {isNested: true});
			that.navigationService.navigate({
				part: that._getReportPartName() + ":" + cmdOptions.reportName,
				partOptions: reportParams
			});
		}
	}

	protected _getReportPartName(): string {
		return "ReportPart";
	}

	processLink(uri: string): boolean {
		let that = this,
			parsedUri,
			cmdName,
			cmdParams,
			cmd;

		parsedUri = that._parseUri(decodeURI(uri));
		// external link?
		if (!parsedUri) { return; }

		// it's an internal link
		cmdName = parsedUri.cmdName;
		cmd = that.commands[cmdName];
		if (!cmd) {
			return true;
		}
		cmdParams = that._getCmdParamsFromParsedUri(parsedUri);

		cmdParams = core.lang.extend(cmdParams, {name: cmdName});

		cmd.execute(cmdParams);
		return true;
	}

	/**
	 * Parse internal link determining:
	 * action name (command name), action spec (some name for command), action params (json object params for command)
	 * @param {string} uri
	 * @return {{cmdName, cmdSpec, cmdParams}}
	 * @protected
	 */
	protected _parseUri(uri: string): UriCommand {
		// parse the uri like: webclient://{name}/{spec}?{params}
		// e.g.: "webClient://OpenReport/Surveys?autoGenerate=true&params.organizer=0D60B1BB-B425-412C-A667-4A010CFA8547
		let re = /webclient:\/\/([^/]+)(?:\/([^/]+))?\?(.+)/i;

		let match = re.exec(uri);
		if (match) {
			let params: any = match[3];
			if (params) {
				params = utils.parseUriParams(params);
			}
			return {
				cmdName: match[1],
				cmdSpec: match[2],
				cmdParams: params
			};
		}
	}

	/**
	 * Returns params for command determined on parsed uri.
	 * @param {Object} parsedUri a result of _parseUri method
	 * @returns {Object}
	 * @protected
	 */
	protected _getCmdParamsFromParsedUri(parsedUri: UriCommand): any {
		switch (parsedUri.cmdName) {
			case "Navigate":
				return {
					partName: parsedUri.cmdSpec,
					partOptions: parsedUri.cmdParams
				};
			case "OpenReport":
				return {
					reportName: parsedUri.cmdSpec,
					reportParams: parsedUri.cmdParams
				};
			default:
				return parsedUri.cmdParams;
		}
	}
}
namespace ReportPartBase {
	export interface Options extends Component.Options {
		urlSuffix?: string;
		reportName?: string;
		menu?: Menu.Options;
		commands?: lang.Map<Command>;
		refresh?: boolean;
		dontCacheXslFo?: boolean;
		params?: any;
		template?: Handlebars.Template;
		bound?: boolean;
		affixTableHeader?: boolean;
		cssClass?: string;
		showTitle?: true;
		title?: string;
	}

	export interface KnownCommands extends lang.Map<Command> {
		Build?: Command;
		Export?: Command;
		OpenReport?: Command;
	}

	export interface UriCommand {
		cmdName: string;
		cmdSpec: string;
		cmdParams: Object;
	}
	export interface Params {
		refresh?: boolean;
		dontCacheXslFo?: boolean;
		format?: string;
		[key: string]: any;
	}

	export const State = {
		initial: "initial" as "initial",
		generating: "generating" as "generating",
		generated: "generated" as "generated",
		failed: "failed" as "failed"
	};
	export type State = (typeof State)[keyof typeof State];
}

ReportPartBase.mixin({
	defaultOptions: ReportPartBase.defaultOptions,
	states: ReportPartBase.State
});

//core.reporting.ReportPartBase = ReportPartBase;
export = ReportPartBase;
