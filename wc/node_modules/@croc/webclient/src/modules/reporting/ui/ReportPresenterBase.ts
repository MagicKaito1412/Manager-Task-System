import $ = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import ReportPartBase = require("./ReportPartBase");
import "xcss!./styles/reportPart.css";
import "xcss!./styles/reportStyles.css";

import lang = core.lang;
import { PartCloseOptions } from "lib/ui/.ui";
import { AffixItem, StuckBehavior } from "modules/affix/affix";

/**
 * Кастомный behavior прилипания заголовка таблицы. Полностью обрабатывает процесс прилипания:
 *  - явно устанавливает ширину столбцов в заголовке таблицы
 *  - клонирует строчку (TR) заголовка таблицы
 *  - добавляет клонированную строчку в заголовок таблицы, чтобы сохранилась ширина столбцов и высота всей таблицы
 * @param {AffixItem} item - элемент affix менеджера
 */
let stuckBehavior: StuckBehavior = {
	attach(item: AffixItem): void {
		// Set the width of TH elements explicitly
		// NOTE: setting the width of an element may change current width of next elements,
		// therefore we should calculate all widths at first
		let widths: string[] = [];
		item.$element.find("th").each((i, th) => {
			widths[i] = $(th).css("width");
		});
		item.$element.find("th").each((i, th) => {
			// NOTE: setting width is not enough, see WC-1414
			let width = widths[i];
			$(th).css({
				"min-width": width,
				"max-width": width
			});
		});

		item.$placeholder = item.$element.clone()
			.addClass("noprint")
			.insertBefore(item.$element);
	},
	detach(item: AffixItem): void {
		// reset the width of TH elements
		item.$element.find("th").css({
			"min-width": "",
			"max-width": ""
		});

		if (item.$placeholder) {
			item.$placeholder.remove();
			item.$placeholder = undefined;
		}
	}
};

class ReportPresenterBase extends View {
	static defaultOptions: ReportPresenterBase.Options = {
		bound: false,
		affixTableHeader: true
	};

	options: ReportPresenterBase.Options;
	viewModel: ReportPartBase;
	private $thead: JQuery;
	private _onDocKeyup: (eventObject: JQueryEventObject, ...args: any[]) => any;

	/**
	 * @constructs ReportPresenterBase
	 * @extends View
	 * @param {Object} options
	 */
	constructor(options: ReportPresenterBase.Options) {
		options = ReportPresenterBase.mixOptions(options, ReportPresenterBase.defaultOptions);
		super(options);
		this.options.unbound = !this.options.bound;
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;

		let menu = that.viewModel.menu;
		if (menu) {
			that._onDocKeyup = function (e: JQueryKeyEventObject): boolean {
				return !menu.executeHotkey(e);
			};
			core.$document.on("keyup", that._onDocKeyup);
		}

		super.doRender(domElement);

		that.$domElement.on("click.reportLink", ".x-report-content-container", function(event: JQueryEventObject): boolean {
			let target = $(event.target);
			let uri = target.attr("href");
			// not link
			if (!uri) { return; }
			if (that.viewModel.processLink(uri)) {
				return false;
			}
		});

		that.$domElement.on("click", ".x-report-content-container .x-cmd-link", function(): boolean {
			let cmd,
				$this = $(this),
				commands = that.viewModel.commands,
				cmdName = core.commands.dataCommandName($this);
			if (commands && cmdName) {
				cmd = commands[cmdName];
				if (cmd) {
					cmd.execute(core.commands.dataCommandParams($this));
					return false;
				}
			}
		});
	}

	protected onReady(): void {
		let that = this,
			eventPublisher = core.Application.current.eventPublisher;

		if (that.options.affixTableHeader) {
			if (that.$thead) {
				eventPublisher.publish("ui.affix.remove_element", {
					element: that.$thead
				});
			}
			// NOTE: filter out a fake table for affixed header - :not(.sticky-stub)
			let $table = $(".x-report-table:not(.sticky-stub)", that.domElement);
			that.$thead = $table.find("thead");
			eventPublisher.publish("ui.affix.add_element", {
				element: that.$thead,
				controlledBy: $table,
				stuckBehaviors: [ stuckBehavior, "default", "hscroll" ]
			});
		}

		let $title = that.$domElement.find(".x-report-appname");
		if ($title.length) {
			// report from server comes with a title, replace current part title
			if (that.viewModel.options.showTitle) {
				let title = $title.text();
				if (title) {
					that.viewModel.title(title);
					$title.remove();
				}
			}
		}

		super.onReady();
	}

	stateSeverity(): string {
		let that = this,
			model = that.viewModel,
			severity = "info";

		if (model) {
			if (model.state() === "failed")
				severity = "error";
			if (model.state() === "generated")
				severity = "success";
		}
		return severity;
	}

	unload(options?: PartCloseOptions): void {
		let that = this;
		if (that.options.affixTableHeader) {
			let eventPublisher = core.Application.current.eventPublisher;
			if (that.$thead) {
				eventPublisher.publish("ui.affix.remove_element", {
					element: that.$thead
				});
			}
		}
		if (that._onDocKeyup) {
			core.$document.off("keyup", that._onDocKeyup);
			that._onDocKeyup = undefined;
		}

		super.unload();
	}
}
namespace ReportPresenterBase {
	export interface Options extends View.Options {
		affixTableHeader?: boolean;
		bound?: boolean;
	}
}
ReportPresenterBase.mixin({
	defaultOptions: ReportPresenterBase.defaultOptions
});

//core.reporting.ReportPresenterBase = ReportPresenterBase;
export = ReportPresenterBase;
