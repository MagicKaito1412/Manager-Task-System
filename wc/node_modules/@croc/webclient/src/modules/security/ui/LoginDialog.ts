import $ = require("jquery");
import core = require("core");
import utils = require("lib/utils");
import Dialog = require("lib/ui/Dialog");
import View = require("lib/ui/handlebars/View");
import Menu = require("lib/ui/menu/Menu");
import formatters = require("lib/formatters");
import moment = require("moment");

import dialogTemplate = require("xhtmpl!./templates/LoginDialog.hbs");
import templateWindowAuth = require("xhtmpl!./templates/WindowsAuth.hbs");
import templateFormsAuth = require("xhtmpl!./templates/FormsAuth.hbs");
import templateOpenAuth = require("xhtmpl!./templates/OpenAuth.hbs");
import template2f = require("xhtmpl!./templates/2f.hbs");
import resources = require("i18n!./../nls/resources");
import globalResources = require("i18n!lib/nls/resources");

import "xcss!./styles/loginDialog.css";

import interop = require("lib/interop/.interop");
import ICommand = core.commands.ICommand;
import lang = core.lang;
import ProviderInfo = LoginDialog.ProviderInfo;
import { AuthProvider, SecurityConfig } from "../interop";

/**
 * @enum {String}
 * @memberOf LoginDialog
 */
const statusMessages = {
	loginInProgress: resources["security.logging_in"] + "...",
	loginSuccess: resources["loginDialog.loginSuccess"],
	loginFailed: resources["loginDialog.loginFailed"],
	authNotSupported: resources["loginDialog.authNotSupported"],
	dialogTitle: resources["security.authentication"],
	dialog2fTitle: resources["loginDialog.2f.title"],
	dialog2fPrompt: resources["loginDialog.2f.prompt"],
	dialog2fPromptTimeout: resources["loginDialog.2f.prompt_timeout"],
	dialog2fTimedout: resources["loginDialog.2f.timedout"]
};

class AuthView extends View {
	/**
	 * @observable-property {LoginDialog#statusMessages}
	 */
	@lang.decorators.observableAccessor()
	status: lang.ObservableProperty<string>;

	static defaultOptions: AuthView.Options = {};

	host: LoginDialog;
	cmdLogin: ICommand;

	/**
	 * @class AppNavMenu
	 * @extends Menu
	 */
	constructor(host: LoginDialog, options: AuthView.Options) {
		options = AuthView.mixOptions(options, AuthView.defaultOptions);
		super(options);
		this.host = host;
		this.cmdLogin = core.createCommand({
			execute: (args) => {
				if (!this.beforeLogin()) { return; }
                this._doLogin(args);
			}
		});
	}

	protected beforeLogin(): boolean {
		return true;
	}

	protected _doLogin(args: any): void {}
}
namespace AuthView {
	export interface Options extends View.Options, AuthProvider {}
}

class WindowsAuthView extends AuthView {
	static defaultOptions: WindowsAuthView.Options = {
		template: templateWindowAuth,
		loginUrl: undefined
	};
	options: WindowsAuthView.Options;

	constructor(host: LoginDialog, options: WindowsAuthView.Options) {
		options = WindowsAuthView.mixOptions(options, WindowsAuthView.defaultOptions);
		super(host, options);
	}

	protected _doLogin(): void {
		this.host.executeAuth({
			url: this.options.loginUrl
		});
	}
}
namespace WindowsAuthView {
	export interface Options extends AuthView.Options {
		loginUrl: string;
	}
}

class FormsAuthView extends AuthView {
	static defaultOptions: FormsAuthView.Options = {
		template: templateFormsAuth,
		loginUrl: undefined
	};

	options: FormsAuthView.Options;

	/**
	 * @observable-property {string}
	 */
	@lang.decorators.observableAccessor()
	userName: lang.ObservableProperty<string>;

	/**
	 * @observable-property {string}
	 */
	@lang.decorators.observableAccessor()
	password: lang.ObservableProperty<string>;

	constructor(host: LoginDialog, options: FormsAuthView.Options) {
		options = FormsAuthView.mixOptions(options, FormsAuthView.defaultOptions);
		super(host, options);
		this.userName("");
		this.password("");
		this.bind("change:userName", () => { this._validate("userName"); });
		this.bind("change:password", () => { this._validate("password"); });
	}

	protected beforeLogin(): boolean {
		return this._validate();
	}

	protected _validate(propName?: string): boolean {
		let that = this,
			result = true;
		if (propName === "userName" || !propName) {
			if (!that.userName()) {
				that.trigger("error:userName", resources["loginDialog.userName_missing"]);
				result = false;
			} else {
				that.trigger("error:userName", null);
			}
		}
		if (propName === "password" || !propName) {
			if (!that.password()) {
				that.trigger("error:password", resources["loginDialog.password_missing"]);
				result = false;
			} else {
				that.trigger("error:password", null);
			}
		}
		return result;
	}

	protected _doLogin(): void {
		this.host.executeAuth({
			url: this.options.loginUrl,
			data: {
				userName: this.userName(),
				password: this.password()
			}
		});
	}

	protected afterRender(): void {
		this.$domElement.on("keyup", (e: JQueryEventObject) => {
			if (e.which === core.html.keyCode.ENTER) {
				this.cmdLogin.execute();
				return false;
			}
		});
	}
}
namespace FormsAuthView {
	export interface Options extends AuthView.Options {
		loginUrl: string;
	}
}


class OpenAuthView extends AuthView {
	static defaultOptions: OpenAuthView.Options = {
		template: templateOpenAuth,
		loginUrl: undefined
	};
	options: OpenAuthView.Options;

	/**
	 * @observable-property {ObservableCollection}
	 */
	@lang.decorators.observableAccessor()
	openAuthProviders: lang.ObservableProperty<lang.ObservableCollection<any>>;

	constructor(host, options: OpenAuthView.Options) {
		options = OpenAuthView.mixOptions(options, OpenAuthView.defaultOptions);
		super(host, options);
		this.openAuthProviders(new lang.ObservableCollection(options.providers));
	}

	_doLogin (args): void {
		this.host.executeAuthExternal({
			url: this.options.loginUrl,
			data: {
				provider: args.provider
			}
		});
	}
}
namespace OpenAuthView {
	export interface Options extends AuthView.Options {
		loginUrl: string;
		providers?: any;	//TODO
	}
}

/*
		TODO: to add password hashing, add here:
	define(["cryptojs.md5", "cryptojs.base64"], function (CryptoJS, CryptoJSbase64)
		also add reguire.config.json:
	"paths": {
		"cryptojs.core": "vendor/cryptojs/components/core",
		"cryptojs.md5": "vendor/cryptojs/components/md5",
		"cryptojs.base64": "vendor/cryptojs/components/enc-base64"
	},
	"shim": {
		"cryptojs.core": {
			"exports": "CryptoJS"
		},
		"cryptojs.md5": {
			"deps": ["cryptojs.core"], "exports": "CryptoJS"
		},
		"cryptojs.base64": {
			"deps": ["cryptojs.core"], "exports": "CryptoJS"
		}
	}
	 */

class LoginDialog extends Dialog {
	static statusMessages: lang.Map<string> = statusMessages;
	static defaultOptions: LoginDialog.Options = {
		template: dialogTemplate,
		header: statusMessages.dialogTitle,
		rootCssClass: "x-login-dialog",
		providers: {
			windows: WindowsAuthView,
			forms: FormsAuthView,
			openAuth: OpenAuthView
		},
		menu: { items: [
			{
				name: "close",
				presentation: "text",
				title: globalResources.cancel
			}
		]}
	};

	private _disabled: boolean;

	@lang.decorators.observableAccessor()
	authTypes: lang.ObservableProperty<lang.ObservableCollection<ProviderInfo>>;

	/**
	 * Name of currently active auth provider.
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	currentAuthType: lang.ObservableProperty<string>;

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	currentAuthProvider: lang.ObservableProperty<AuthView>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor()
	hasOpenAuth: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	rememberMe: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {LoginDialog#statusMessages}
	 */
	@lang.decorators.observableAccessor()
	status: lang.ObservableProperty<string>;

	options: LoginDialog.Options;
	dataFacade: interop.IDataFacade;
	security: SecurityConfig;
	providers: lang.Map<AuthView>;

	/**
	 * @constructs LoginDialog
	 * @extends Dialog
	 * @param {DataFacadeBase} dataFacade
	 * @param {Object} security
	 * @param {Object} [security.windowsAuth]
	 * @param {String} security.windowsAuth.loginUrl
	 * @param {Object} [security.formsAuth]
	 * @param {String} security.formsAuth.loginUrl
	 * @param {Object} [security.openAuth]
	 * @param {String} security.openAuth.loginUrl
	 * @param {Array} security.openAuth.providers
	 * @param {Object} [options]
	 */
	constructor(dataFacade: interop.IDataFacade, security: SecurityConfig, options?: LoginDialog.Options) {
		if (!dataFacade) { throw new Error("dataFacade should be specified"); }
		if (!security) { throw new Error("Security configuration should be specified"); }

		options = LoginDialog.mixOptions(options, LoginDialog.defaultOptions);
		super(options);

		this.dataFacade = dataFacade;
		this.security = security;
		this.providers = {};
		this.initAuthTypes(security);

		if (this.authTypes().count() === 0) {
			this.status(statusMessages.authNotSupported);
		}
	}

	initAuthTypes (secCfg: SecurityConfig): void {
		var that = this,
			authTypes = new lang.ObservableCollection<ProviderInfo>();

		if (secCfg.windowsAuth) {
			authTypes.add({
				name: "windows",
				title: secCfg.windowsAuth.title || resources["loginDialog.account_type_windows"],
				isDefault: secCfg.windowsAuth.isDefault
			});
			that._createProvider("windows", secCfg.windowsAuth);
		}
		if (secCfg.formsAuth) {
			authTypes.add({
				name: "forms",
				title: secCfg.formsAuth.title || resources["loginDialog.account_type_forms"],
				isDefault: secCfg.formsAuth.isDefault
			});
			that._createProvider("forms", secCfg.formsAuth);
		}

		if (secCfg.openAuth) {
			authTypes.add({
				name: "openAuth",
				title: secCfg.openAuth.title || resources["loginDialog.account_type_oauth"],
				isDefault: secCfg.openAuth.isDefault
			});
			that._createProvider("openAuth", secCfg.openAuth);
		}
		that.authTypes(authTypes);

		let def: ProviderInfo = lang.find(authTypes.all(), (v: ProviderInfo) => { return v.isDefault; });
		if (def) {
			// make the default provider the first in the lest
			authTypes.move(authTypes.indexOf(def), 0);
		} else {
			def = authTypes.get(0);
		}
		that.bind("change:currentAuthType", (sender, value) => {
			that.currentAuthProvider(that.providers[value]);
		});
		if (def) {
			that.currentAuthType(def.name);
		}
	}

	_createProvider (name: string, options: AuthView.Options): void {
		let providerInfo = this.options.providers[name];
		if (providerInfo) {
			this.providers[name] = new providerInfo(this, options);
		}
	}

	afterRender (): void {
		let $rememberMe = $(".x-login-dialog-rememberMe");
		if ($rememberMe.length) {
			$rememberMe.find(".x-icon-help").tooltip({ trigger: "hover click" });
		}
		super.afterRender();
	}

	_enable (bEnabled: boolean): void {
		if (this.$domElement) {
			this.$domElement.find(".modal-body").blocked(!bEnabled);
		}
		this._disabled = !bEnabled;
	}

	executeAuth (ajaxSettings) {
		let that = this;
		if (this._disabled) { return; }
		that._enable(false);
		that.status(statusMessages.loginInProgress);

		//ajaxSettings.contentType = "application/x-www-form-urlencoded";
		ajaxSettings.type = "POST";

		if (that.rememberMe()) {
			ajaxSettings.data = ajaxSettings.data || {};
			ajaxSettings.data.persistentCookie = true;
		}
		/*
			TODO: here there could be passwords hashing, see http://track.rnd.croc.ru/issue/WC-950
			if (that.options.hashPasswords && CryptoJS && CryptoJS.MD5) {
				pwd = CryptoJS.MD5(pwd).toString(CryptoJS.enc.Base64);
			}
		 * */
		that.dataFacade.executeLogin(ajaxSettings, {suppressEventOnError: true, suppressEventOnSuccess: true})
			.done((response: interop.LoginResponse) => {
				if (response && response["2f"]) {
					that.on2fAuthStep2(response["2f"]);
				} else {
					that.onAuthSuccess(response.result);
				}
			})
			.fail((error) => {
				that.onAuthError(error);
			});
	}

	protected on2fAuthStep2 (result: interop.LoginConfirm2f) {
		let that = this;
		let twoFactorAuth = that.security.twoFactorAuth;
		let url = (twoFactorAuth ? twoFactorAuth.url : "") || "api/_security/login_confirm";
		if (result.type === "wait") {
			throw new Error("Not implemented");
		}
		this.promptFor2fSecret(result).always(secret => {
			if (!secret ) {
				return that.onAuthError({message: statusMessages.dialog2fTimedout });
			}
			let ajaxSettings = {
				url: url,
				data: {
					token: result.token,
					secret: secret,
					persistentCookie: that.rememberMe()
				},
				type:  "POST"
			};
			that.dataFacade.executeLogin(ajaxSettings, {suppressEventOnError: true, suppressEventOnSuccess: true})
				.done((response: interop.LoginResponse) => {
					that.onAuthSuccess(response.result);
				})
				.fail(error => {
					that.onAuthError(error);
				});
		});
	}
	protected promptFor2fSecret(result: interop.LoginConfirm2f): lang.Promise<string> {
		let dlgViewModel = lang.observe({
			hint: result.hint,
			secret: "",
			left: "",
			prompt: statusMessages.dialog2fPrompt
		});
		let timer;
		if (result.timeout) {
			let left = moment(result.timeout);
			dlgViewModel.left(left.format("mm:ss"));
			timer = setInterval(() => {
				left.subtract(1, "s");
				dlgViewModel.left(left.format("mm:ss"));
				if (left.valueOf() <= 0) {
					// time is over
					clearInterval(timer);
					dlg.close();
				}
			}, 1000);
			dlgViewModel.prompt(statusMessages.dialog2fPrompt + " " + statusMessages.dialog2fPromptTimeout + " ");
		}
		let expectedLength = result.length;
		let dlg = new Dialog({
			rootCssClass: "x-login-2f-dialog",
			body: new View({
				template: template2f,
				viewModel: dlgViewModel
			}),
			header: statusMessages.dialog2fTitle,
			menu: expectedLength > 0
				? null
				: {items: [
					{name: "ok", title: "OK", command: core.createCommand(() => {
						clearInterval(timer);
						dlg.close(dlgViewModel.secret());
					}) }]
				},
			overlay: true,
			noCloseButton: true
		});
		if (expectedLength) {
			dlgViewModel.bind("change:secret", (sender, val: string) => {
				if (val && val.length === expectedLength) {
					clearInterval(timer);
					dlg.close(val);
				} else if (val && val.length > expectedLength) {
					dlg.$dialog.find(".password-group").addClass("has-error");
				} else if (val) {
					dlg.$dialog.find(".password-group").removeClass("has-error");
				}
			});
		}
		return dlg.open();
	}

	protected onAuthSuccess(result): void {
		let that = this;
		if (!that.$dialog) { return; }
		that.status(statusMessages.loginSuccess);
		let dlgResult = {success: true, result: result};
		// TODO: Зачем timeout и 1s?
		window.setTimeout(() => {
			//that._enable(true);
			that.close(dlgResult);
		}, 1000);
	}

	protected onAuthError(error) {
		let that = this;
		if (!that.$dialog) { return; }
		that.status(statusMessages.loginFailed + (error ? ": " + error.message : undefined));
		that._enable(true);
		that.result = {success: false, error: error };
	}

	executeAuthExternal(ajaxSettings) {
		var that = this,
			width = window.screen.width / 2,
			height = window.screen.height / 2,
			uri,
			data = ajaxSettings.data || {};

		that._enable(false);
		that.status(statusMessages.loginInProgress);

		uri = that.dataFacade._interop.normalizeUrl(ajaxSettings.url);
		if (that.rememberMe()) {
			data.persistentCookie = true;
		}
		uri = uri + "?" + utils.buildUriParams(data);

		let popup = window.open(uri, "_blank", ["toolbar=no", "location=" + (window["opera"] ? "no" : "yes"), "directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no",
			"width=" + width, "height=" + height, "top=" + (window.screen.height - height) / 2, "left=" + (window.screen.width - width) / 2].join());

		let interval = window.setInterval(function () {
			if (popup.closed !== false) {
				that._enable(true);
				that.status("");

				window.clearInterval(interval);
				that._onPopupClosed();
			}
		}, 100);
	}

	protected _onPopupClosed(): void {
		let that = this;
		that.dataFacade.getCurrentUser({refreshStatus: true})
			.then((userJson) => {
				if (userJson) {
					that.status(statusMessages.loginSuccess);
					that.close({success: true, result: userJson});
				} else {
					that.status(statusMessages.loginFailed);
				}
			}, (error) => {
				that.status(error);
			});
	}
}
namespace LoginDialog {
	export interface Options extends Dialog.Options {
		providers: lang.Map<new (host: LoginDialog, options: AuthView.Options) => AuthView>;
	}
	export interface ProviderInfo {
		name: string;
		title: string;
		isDefault: boolean;
	}
}
// backward compatibility:
LoginDialog.mixin({
	defaultOptions: LoginDialog.defaultOptions,
	statusMessages: LoginDialog.statusMessages
});

core.ui.LoginDialog = LoginDialog;

export = LoginDialog;
