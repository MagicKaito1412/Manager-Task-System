import core = require("core");

import {
	AffixManager, AffixItemOptions, AffixRefreshOptions, AffixSuspendOptions, AffixRefreshMode
} from "./affix";

import scrollToElement = core.html.scrollToElement;

// augment core.Application class
declare module "lib/core" {
	export interface Application {
		affixManager?: AffixManager;
	}
}

export interface AffixModuleOptions extends AffixManager.Options {
	disabled?: boolean;
}

export interface AffixItemEvent extends core.AppEvent {
	args: AffixItemOptions|JQuery|HTMLElement;
}
export interface AffixRefreshEvent extends core.AppEvent {
	args: AffixRefreshOptions;
}
export interface AffixSuspendEvent extends core.AppEvent {
	args: AffixSuspendOptions;
}

core.createModule("affix", function (app: core.Application, options?: AffixModuleOptions): void {
	if (options && options.disabled)
		return;

	let affixManager = new AffixManager(options);
	app.affixManager = affixManager;

	app.eventPublisher.subscribe("ui.affix.add_element", (eventData: AffixItemEvent) => {
		if (eventData.args)
			affixManager.addElement(eventData.args);
	});

	app.eventPublisher.subscribe("ui.affix.remove_element", (eventData: AffixItemEvent) => {
		if (eventData.args)
			affixManager.removeElement(eventData.args);
	});

	app.eventPublisher.subscribe("ui.affix.refresh", (eventData: AffixRefreshEvent) => {
		affixManager.refresh(eventData.args);
	});

	app.eventPublisher.subscribe("ui.affix.suspend", (eventData: AffixSuspendEvent) => {
		affixManager.suspend(eventData.args);
	});

	core.platform.bind("change:printing", (sender, value: boolean) => {
		affixManager.suspend({ suspend: value });
	});

	core.composition.regionBehaviors["affix"] = {
		attach(region: core.composition.Region, regionDomEl: JQuery|HTMLElement, options: AffixItemOptions): void {
			region.bind("partRendered", () => {
				affixManager.addElement(core.lang.extend({}, options, {
					element: regionDomEl,
					suspendByHScroll: true
				}));
			});
			region.bind("partUnloaded", () => {
				affixManager.removeElement({
					element: regionDomEl
				});
			});
		}
	};

	core.$window.on("scroll", () => {
		// NOTE: on scrolling refresh synchronously to prevent lags
		affixManager.refreshSync({ mode: AffixRefreshMode.scroll });
	});

	core.html.windowResize.bind(() => {
		// Changes if window width may also change width of affixed elements. This is not supported in general.
		// So specify `force` flag to detach all elements first.
		affixManager.refresh({ mode: AffixRefreshMode.forced });
	});

	// handle BS event of closing alerts for refreshing affixed elements
	core.$document.on("close.bs.alert", () => {
		// NOTE: 'closed.bs.alert' fires after alert is removed but it's not bubbled so we can't handle it on document,
		// So we handle 'close.bs.alert', but as it fires before alert is removed we use window.setTimeout.
		window.setTimeout(() => {
			affixManager.refresh();
		}, 300);
	});

	core.$document.on("domChanged", (ev: JQueryEventObject, args?: core.html.DOMChangedEventData) => {
		// TODO: add some trace/profile console.log("domChanged");
		if (!args || !args.binding) {
			affixManager.refresh();
		}
	});

	// Overwrite core.html.scrollToElement to support affixed elements
	core.html.scrollToElement = function (options: HTMLElement|JQuery|scrollToElement.Options): void {
		if (!options) { return; }

		let opts: scrollToElement.Options;
		if (options instanceof $ || options["nodeType"] !== undefined) {
			opts = { element: options as any };
		} else {
			opts = options as any;
		}
		if (!opts.element) { return; }

		// refresh affixed items if necessary
		affixManager.refreshIfScheduled();

		let align = opts.align || "top";
		if (opts.force || !affixManager.isInViewport(opts.element, align)) {
			let scrollTo = affixManager.getScrollTop(opts.element, align);
			$.scrollTo(scrollTo, 100, { easing: "swing", onAfter: opts.onAfter} );
		} else if (opts.onAfter) {
			opts.onAfter();
		}
	};

	// Handle anchor links to support affixed elements
	core.html.$document.on("click", "a.anchor-link", (e: JQueryEventObject) => {
		if (core.html.isExternalClick(e)) { return; }

		let href = e.target.getAttribute("href");
		if (href && href[0] === "#") {
			let id = href.slice(1);
			let element = document.getElementById(id);
			if (element) {
				e.preventDefault();
				core.html.scrollToElement({
					element: element,
					align: "top",
					force: true
				});
			}
		}
	});
});
