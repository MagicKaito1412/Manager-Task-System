import * as $ from "jquery";
import * as lang from "lib/core.lang";
import * as html from "lib/core.html";
import "xcss!./styles/affix.css";

export type Direction = "top" | "bottom";

export type VerticalAlign = "top" | "bottom" | "center";

export interface AffixItemOptions {
	element: JQuery | HTMLElement;
	controlledBy?: JQuery | HTMLElement;
	affixTo?: Direction;
	stuckBehaviors?: (string | StuckBehavior)[];
	suspendByScreenWidth?: number;
	/**
	 * Size of the element can be changed. In this case rendering inside the element causes `refresh`.
	 */
	resizable?: boolean;
	[key: string]: any;
}

export interface AffixItem {
	/**
	 * @readonly
	 */
	options: AffixItemOptions;
	/**
	 * @readonly
	 */
	$element: JQuery;
	/**
	 * @readonly
	 */
	dir: Direction;
	/**
	 * Position of the element relative to the document
	 */
	pos?: Position;
	/**
	 * An optional element inserted into DOM when the real element is attached.
	 * It usually has the same size as the original element.
	 */
	$placeholder?: JQuery;
}

export const enum AffixRefreshMode {
	scroll = -1,
	normal = 0,
	forced = 1
}

export interface AffixRefreshOptions {
	mode?: AffixRefreshMode;
}

export interface AffixSuspendOptions {
	suspend?: boolean;
}

/**
 * Position of the element relative to the document
 */
export interface Position {
	top: number;
	bottom: number;
	left: number;
	right: number;
	height: number;
	width: number;
}

export interface Viewport extends Position {
	/**
	 * Top fixed offset relative to the window
	 */
	offsetTop: number;
	/**
	 * Bottom fixed offset relative to the window
	 */
	offsetBottom: number;
}

export interface StuckBehavior {
	/**
	 * Calculates and caches item data for using in other methods (e.g. 'pos')
	 * @param item
	 */
	recalc?(item: AffixItem): void;
	/**
	 * Detects whether the element should be attached.
	 * @param item
	 * @param viewport
	 */
	shouldAttach?(item: AffixItem, viewport: Viewport): boolean;
	/**
	 * Attaches detached element first time. This method is NOT called if the element is already attached.
	 * @param item
	 * @param viewport
	 */
	attach?(item: AffixItem, viewport: Viewport): void;
	/**
	 * Updates attached element. This method is called on every refreshing for every attached element.
	 * @param item
	 * @param viewport
	 */
	reflow?(item: AffixItem, viewport: Viewport): void;
	/**
	 * Detaches attached element. This method is NOT called if the element is not attached.
	 * @param item
	 */
	detach?(item: AffixItem): void;
}

export interface ViewportProvider {
	getItemViewport(item: AffixItem): Viewport;
}

export namespace utils {
	export function toElement(element: JQuery|HTMLElement): HTMLElement {
		return (!element || (element as HTMLElement).nodeType) ? element : element[0];
	}

	let _window: Position;

	export function invalidate(): void {
		_window = undefined;
	}

	/**
	 * Get the position of the element relative to the document
	 * @param element
	 * @returns {Position}
	 */
	export function pos(element: JQuery|HTMLElement): Position {
		let wndPos = windowPos();
		let rect = toElement(element).getBoundingClientRect();
		return {
			top: rect.top + wndPos.top,
			bottom: rect.bottom + wndPos.top,
			left: rect.left + wndPos.left,
			right: rect.right + wndPos.left,
			height: rect.bottom - rect.top, // rect.height may be undefined in old browsers
			width: rect.right - rect.left   // rect.width  may be undefined in old browsers
		};
	}

	/**
	 * Get the position of the window relative to the document
	 * @returns {Position}
	 */
	export function windowPos(): Position {
		if (!_window) {
			let top = html.$window.scrollTop(),
				left = html.$window.scrollLeft(),
				height = html.$window.outerHeight(),
				width = html.$window.outerWidth();
			_window = {
				top: top,
				bottom: top + height,
				left: left,
				right: left + width,
				height: height,
				width: width
			};
		}
		return _window;
	}

	export function intersectedHorz(pos1: Position, pos2: Position): boolean {
		return pos1.left < pos2.right && pos1.right > pos2.left;
	}
}

export class AffixManager implements ViewportProvider {
	static knownStuckBehaviors: lang.Map<StuckBehavior> = {
		/**
		 * Default behavior which creates a placeholder element
		 */
		"default": {
			attach(item: AffixItem): void {
				// NOTE: placeholder может создаваться внутри других stuckBehaviors
				if (!item.$placeholder) {
					item.$placeholder = $("<div class='sticky-stub noprint'></div>")
						.css({
							position: item.$element.css("position"),
							height: item.pos.height + "px"
						})
						.insertBefore(item.$element);
				}
			},
			reflow(item: AffixItem, viewport: Viewport): void {
				// NOTE: Позиция элемента могла измениться из-за прилипания/отлипания предшествующих элементов или
				// изменения их высоты. Поэтому устанавливать позицию нужно всегда, даже если элемент уже был прилеплен.
				let offset = item.dir === "top" ? viewport.offsetTop : viewport.offsetBottom;
				item.$element.css(item.dir, offset + "px");
			},
			detach(item: AffixItem): void {
				if (item.$placeholder) {
					item.$placeholder.remove();
					item.$placeholder = undefined;
				}

				item.$element.css(item.dir, "");
			}
		},
		controlledBy: {
			recalc(item: AffixItemControlled): void {
				item._ctrlByPos = undefined; // reset cached position of controlledBy element
			},
			shouldAttach(item: AffixItemControlled, viewport: Viewport): boolean {
				let ctrlBy = item.options.controlledBy;
				if (ctrlBy) {
					//let ctrlByPos = utils.pos(ctrlBy);
					let ctrlByPos = item._ctrlByPos || (item._ctrlByPos = utils.pos(ctrlBy));
					if (item.dir === "top") {
						if (ctrlByPos.bottom < viewport.top + item.pos.height || ctrlByPos.top > viewport.bottom) {
							return false;
						}
					} else {
						if (ctrlByPos.bottom < viewport.top || ctrlByPos.top > viewport.bottom - item.pos.height) {
							return false;
						}
					}
				}
				return true;
			}
		},
		preserveWidth: {
			attach(item: AffixItem): void {
				let width = item.pos.width + "px";
				item.$element.css("width", width);
				if (item.$placeholder) {
					item.$placeholder.css("width", width);
				}
			},
			detach(item: AffixItem): void {
				item.$element.css("width", "");
			}
		},
		hscroll: {
			reflow(item: AffixItem, viewport: Viewport): void {
				item.$element.css("left", (item.pos.left - viewport.left) + "px");
			},
			detach(item: AffixItem): void {
				item.$element.css("left", "");
			}
		},
		suspendByScreenWidth: {
			shouldAttach(item: AffixItem): boolean {
				let minWidth = item.options.suspendByScreenWidth;
				return !minWidth || utils.windowPos().width > minWidth;
			}
		}
	};

	static defaultOptions: AffixManager.Options = {};

	options: AffixManager.Options;

	/**
	 * @readonly
	 */
	private _items: AffixMap<AffixStack> = {
		top: new AffixStack("top"),
		bottom: new AffixStack("bottom")
	};

	private _offset: AffixMap<number>;

	private _suspended: boolean;

	private _scheduledTimeout: number;
	private _scheduledMode: AffixRefreshMode;

	constructor(options: AffixManager.Options) {
		this.options = lang.append(options || {}, AffixManager.defaultOptions);
		this.init();
	}

	init(): void {
		let that = this;
		that._offset = {
			top: that.options.topOffset || that.calcDirOffset("top"),
			bottom: that.options.bottomOffset || that.calcDirOffset("bottom"),
		};
	}

	addElement(options: AffixItemOptions|JQuery|HTMLElement): void {
		if (!(options as AffixItemOptions).element) {
			options = { element: options } as AffixItemOptions;
		}
		if (!this.validateElement((options as AffixItemOptions).element)) { return; }

		let item = new AffixItemImpl(options as AffixItemOptions);
		let stack = this._items[item.dir];
		stack.add(item);

		this.refresh();
	}

	removeElement(options: AffixItemOptions|JQuery|HTMLElement): void {
		let element: HTMLElement = $((options as AffixItemOptions).element || options)[0];
		if (!this.validateElement(element)) { return; }

		for (let stack of [ this._items.top, this._items.bottom ]) {
			let index = lang.findIndex(stack.items, item => item.$element[0] === element);
			if (index >= 0) {
				let item = stack.items[index];
				item.detach();
				stack.remove(index);
				this.refresh();
				return;
			}
		}
	}

	suspend(options: AffixSuspendOptions = { suspend: true }): void {
		this._suspended = options.suspend;
		this.runRefresh(AffixRefreshMode.forced);
	}

	/**
	 * Asynchronously refreshes affixing state for all items
	 * @params {Object} [options]
	 * @param {number} [options.mode]
	 */
	refresh(options?: AffixRefreshOptions): void {
		let that = this;
		that._scheduledMode = that.getRefreshMode(options);
		if (!that._scheduledTimeout) {
			that._scheduledTimeout = window.setTimeout(() => {
				that._scheduledTimeout = undefined;
				that.runRefresh(that._scheduledMode);
			});
		}
	}

	/**
	 * Synchronously refreshes affixing state for all items, if asynchronous refreshing was scheduling
	 */
	refreshIfScheduled(): void {
		if (this._scheduledTimeout) {
			this.runRefresh(this._scheduledMode);
		}
	}

	/**
	 * Synchronously refreshes affixing state for all items
	 * @params {Object} [options]
	 * @param {number} [options.mode]
	 */
	refreshSync(options?: AffixRefreshOptions): void {
		let mode = this.getRefreshMode(options);
		this.runRefresh(mode);
	}

	protected getRefreshMode(options?: AffixRefreshOptions): AffixRefreshMode {
		let mode = (options && options.mode) || AffixRefreshMode.normal;
		return this._scheduledMode === undefined ? mode : Math.max(this._scheduledMode, mode);
	}

	protected clearScheduled(): void {
		this._scheduledMode = undefined;
		if (this._scheduledTimeout) {
			window.clearTimeout(this._scheduledTimeout);
			this._scheduledTimeout = undefined;
		}
	}

	protected runRefresh(mode: AffixRefreshMode): void {
		let that = this;
		let stacks = [ that._items.top, that._items.bottom ];

		that.invalidate();

		if (mode === AffixRefreshMode.forced) {
			// открепляем все элементы
			stacks.forEach(stack => { stack.restore(); });
			// переинициализируем
			that.init();
		}

		if (!that._suspended) {
			// сначала пересчитываем позиции элементов
			if (mode >= AffixRefreshMode.normal) {
				stacks.forEach(stack => { stack.recalc(); });
			}
			// собственно прикрепление
			stacks.forEach(stack => { stack.refresh(that); });
		}
	}

	protected invalidate(): void {
		this.clearScheduled();
		// invalidate window position
		utils.invalidate();
	}

	getItemViewport(item: AffixItem): Viewport {
		let offsetTop = this._items.top.calcItemOffset(item) + this._offset.top;
		let offsetBottom = this._items.bottom.calcItemOffset(item) + this._offset.bottom;
		return this.createViewport(offsetTop, offsetBottom);
	}

	getElementViewport(pos: Position): Viewport {
		let offsetTop = this._items.top.calcElementOffset(pos) + this._offset.top;
		let offsetBottom = this._items.bottom.calcElementOffset(pos) + this._offset.bottom;
		return this.createViewport(offsetTop, offsetBottom);
	}

	isInViewport(element: JQuery|HTMLElement, align: VerticalAlign): boolean {
		if (!this.validateElement(element)) { return true; }

		let window = utils.windowPos();
		let pos = utils.pos(element);
		// элемент за пределами текущего окна - нет смысла вычислять viewport
		if (!this.isInside(pos, window, align)) { return false; }

		let viewport = this.getElementViewport(pos);
		return this.isInside(pos, viewport, align);
	}

	getScrollTop(element: JQuery|HTMLElement, align: VerticalAlign): number {
		let that = this;
		if (!that.validateElement(element)) { return undefined; }

		let window = utils.windowPos();
		let pos = utils.pos(element);
		let offsets = lang.clone(that._offset);

		function calcViewport(): Viewport {
			let height = window.height - offsets.top - offsets.bottom;
			let top: number;
			switch (align) {
				case "top":
					top = pos.top;
					break;
				case "bottom":
					top = Math.max(0, pos.bottom - height);
					break;
				case "center":
					top = Math.max(0, (pos.top + pos.bottom - height)/2);
					break;
			}
			return that.createViewport(offsets.top, offsets.bottom, top);
		}

		let viewport = calcViewport();

		let directions: Direction[] = [ "bottom", "top" ];
		for (let dir of directions) {
			for (let item of that._items[dir].items) {
				if (utils.intersectedHorz(item.pos, pos) && item.shouldAttach(viewport)) {
					offsets[dir] += item.pos.height;
					viewport = calcViewport();
				}
			}
		}

		return viewport.top - viewport.offsetTop;
	}

	protected validateElement(element: JQuery|HTMLElement): boolean {
		return element && (element as JQuery).length !== 0;
	}

	protected calcDirOffset(dir: Direction): number {
		let total = 0;
		$(`.x-layout-${dir}-fixed`).each((i, elem: HTMLElement) => {
			let pos = utils.pos(elem),
				windowPos = utils.windowPos(),
				offset = Math.abs(pos[dir] - windowPos[dir]) + pos.height;
			total = Math.max(total, offset);
		});
		return total;
	}

	protected isInside(pos: Position, rect: Position, align: VerticalAlign): boolean {
		if (pos.height <= rect.height) {
			// элемент меньшего размера должен быть полностью виден
			return pos.top >= rect.top && pos.bottom <= rect.bottom;
		}

		let y: number;
		switch (align) {
			case "top":
				y = pos.top;
				break;
			case "center":
				y = (pos.top + pos.bottom) / 2;
				break;
			case "bottom":
				y = pos.bottom;
				break;
		}
		return rect.top <= y && y <= rect.bottom;
	}
	
	protected createViewport(offsetTop: number, offsetBottom: number, top?: number): Viewport {
		let window = utils.windowPos();
		let height = window.height - offsetTop - offsetBottom;
		if (top === undefined) {
			top = window.top + offsetTop;
		}
		return {
			top: top,
			bottom: top + height,
			left: window.left,
			right: window.right,
			height: height,
			width: window.width,
			offsetTop: offsetTop,
			offsetBottom: offsetBottom
		};
	}
}
export namespace AffixManager {
	export interface Options {
		topOffset?: number;
		bottomOffset?: number;
	}
}

export class AffixStack {
	readonly items: AffixItemImpl[] = [];
	readonly dir: Direction;
	readonly comparer: (x: AffixItem, y: AffixItem) => number;

	constructor(dir: Direction) {
		//this.items = [];
		this.dir = dir;
		this.comparer = dir === "top" ?
			(x, y) => x.pos.top - y.pos.top :
			(x, y) => y.pos.bottom - x.pos.bottom;
	}

	add(item: AffixItemImpl): void {
		this.items.push(item);
	}

	remove(i: number): void {
		this.items.splice(i, 1);
	}

	restore(): void {
		for (let item of this.items) {
			item.detach();
		}
	}

	recalc(): void {
		for (let item of this.items) {
			item.adjustSize();
		}
		for (let item of this.items) {
			item.recalc();
		}
		this.items.sort(this.comparer);
	}

	refresh(manager: ViewportProvider): void {
		let changed = false;

		// собственно прикрепление
		for (let item of this.items) {
			let attached = item.attached;
			this.affixItem(item, manager);
			changed = changed || (attached !== item.attached);
		}

		// добавляем тень
		if (changed) {
			this.items.forEach((item, i) => {
				this.shadowItem(item, i);
			});
		}
	}

	protected affixItem(item: AffixItemImpl, manager: ViewportProvider): void {
		let viewport = manager.getItemViewport(item);
		if (item.shouldAttach(viewport)) {
			if (!item.attached) {
				item.attach(viewport);
			} else {
				item.reflow(viewport);
			}
		} else {
			if (item.attached) {
				item.detach();
			}
		}
	}

	protected shadowItem(target: AffixItemImpl, index: number): void {
		let shadow = target.attached;
		if (shadow) {
			// ищем прилепленные элементы, следующие за заданным и пересекающиеся с ним по горизонтали
			for (let i = index + 1, len = this.items.length; i < len; i++) {
				let item = this.items[i];
				if (item.attached && utils.intersectedHorz(item.pos, target.pos)) {
					shadow = false;
					break;
				}
			}
		}
		target.$element.toggleClass("affix-stuck--shadow", shadow);
	}

	// protected shadowItem(target: AffixItemImpl, index: number): void {
	// 	target.$element.css("z-index", target.attached ? 900 + index : "");
	// }

	calcItemOffset(target: AffixItem): number {
		let offset = 0;
		// ищем прилепленные элементы, предшествующие заданному и пересекающиеся с ним по горизонтали
		for (let item of this.items) {
			// NOTE: элементы отсортированы по позиции. Если нашли заданный, то все последующие идут после него и
			// могут быть проигнорированы.
			if (item === target) { break; }
			if (item.attached && utils.intersectedHorz(item.pos, target.pos)) {
				offset += item.pos.height;
			}
		}
		return offset;
	}

	calcElementOffset(pos: Position): number {
		let offset = 0;
		// ищем прилепленные элементы, пересекающиеся с заданным по горизонтали
		for (let item of this.items) {
			if (item.attached && utils.intersectedHorz(item.pos, pos)) {
				offset += item.pos.height;
			}
		}
		return offset;
	}
}

export class AffixItemImpl implements AffixItem {
	static defaultOptions: AffixItemOptions = {
		element: undefined,
		stuckBehaviors: [ "default", "preserveWidth", "hscroll" ]
	};

	/**
	 * @readonly
	 */
	options: AffixItemOptions;
	/**
	 * @readonly
	 */
	$element: JQuery;
	/**
	 * @readonly
	 */
	dir: Direction;
	/**
	 * @readonly
	 */
	stuckBehaviors: StuckBehavior[];
	/**
	 * Position of the element relative to the document
	 */
	pos: Position;
	/**
	 * An optional element inserted into DOM when the real element is attached.
	 * It usually has the same size as the original element.
	 */
	$placeholder: JQuery;

	attached: boolean;

	constructor(options: AffixItemOptions) {
		let that = this;
		that.options = options = lang.append(options, AffixItemImpl.defaultOptions);

		that.$element = $(options.element);
		that.dir = options.affixTo || "top";

		that.stuckBehaviors = [];
		if (options.stuckBehaviors) {
			for (let v of options.stuckBehaviors) {
				let behavior = lang.isString(v) ? AffixManager.knownStuckBehaviors[v] : v;
				if (behavior) {
					that.stuckBehaviors.push(behavior);
				}
			}
		}

		// Если дефолтный behavior не задан явно, то добавим его первым элементов.
		// NOTE: Он необходим, чтобы создать $placeholder, на основании которого затем будет вычисляться позиция
		// уже прилепленного элемента. Однако, можно явно создать $placeholder в кастомном behavior-е, задав
		// дефолтный behavior после кастомного.
		that._addKnownBehavior("default", true);

		// добавляем knownStuckBehaviors, наименованиями которых совпадают с наименованиями переданных опций
		for (let name of Object.keys(options)) {
			that._addKnownBehavior(name);
		}
	}

	private _addKnownBehavior(name: string, toBeginning?: boolean): void {
		let behavior: StuckBehavior = AffixManager.knownStuckBehaviors[name];
		let stuckBehaviors = this.stuckBehaviors;
		if (behavior && stuckBehaviors.indexOf(behavior) < 0) {
			if (toBeginning) {
				stuckBehaviors.unshift(behavior);
			} else {
				stuckBehaviors.push(behavior);
			}
		}
	}

	adjustSize(): void {
		if (this.options.resizable && this.$placeholder) {
			this.$placeholder.outerHeight(this.$element.outerHeight());
		}
	}

	recalc(): void {
		let that = this;
		that.pos = utils.pos(that.$placeholder || that.$element);

		for (let behavior of that.stuckBehaviors) {
			if (behavior.recalc) {
				behavior.recalc(that);
			}
		}
	}

	shouldAttach(viewport: Viewport): boolean {
		let that = this;

		if (that.dir === "top" ? that.pos.top >= viewport.top :	that.pos.bottom <= viewport.bottom) {
			return false;
		}

		for (let behavior of that.stuckBehaviors) {
			// Если хотя бы один behavior вернул false, то прилеплять не нужно
			if (behavior.shouldAttach && behavior.shouldAttach(that, viewport) === false) {
				return false;
			}
		}

		return true;
	}

	attach(viewport: Viewport): void {
		let that = this;
		if (that.attached) { return; }

		// Сначала запускаем stuckBehaviors. При этом дефолтный behavior создаст placeholder, установит ему высоту и
		// добавит его в DOM. Это приведет к увеличению высоты документа, но scrollTop должен сохраниться.
		for (let behavior of that.stuckBehaviors) {
			if (behavior.attach) {
				behavior.attach(that, viewport);
			}
		}

		// Затем добавляем css классы affix-stuck* к элементу. Это установит position: fixed, что в свою очередь
		// обратно уменьшит высоту документа. Но scrollTop по-прежнему должен сохраниться.
		that.$element.addClass("affix-stuck affix-stuck-" + that.dir);

		// NOTE: Если сначала добавить css классы, то высота документа сначала уменьшится. При этом если документ был
		// проскроллирован до самого низу, то scrollTop также уменьшится. Затем, когда после добавления заглушки
		// высота снова увеличится scrollTop будет уже меньше начального значения. Это делает невозможным
		// проскроллировать документ до конца вниз - см. WC-1328.


		// При рендеринге элемента генерируется событие domChanged, которое обрабатывается в module-affix и
		// приводит к refresh. Но как правило, affixed элементы имеют фиксированные размеры и рендеринг внутри
		// таких элементов не должен приводить к refresh. Поэтому давим эскалацию события domChanged выше.
		// Если же элемент может менять размеры, то можно указать опцию resizable.
		if (!that.options.resizable) {
			that.$element.on("domChanged.affix", () => false);
		}

		that.attached = true;

		that.reflow(viewport);

		// Уведомяем, что элемент прилепился
		// NOTE: делать это нужно после вызова reflow, чтобы элемент был уже корректно спозиционирован
		that.$element.trigger("affixStuck");
	}

	reflow(viewport: Viewport): void {
		let that = this;
		if (!that.attached) { return; }

		for (let behavior of that.stuckBehaviors) {
			if (behavior.reflow) {
				behavior.reflow(that, viewport);
			}
		}
	}

	detach(): void {
		let that = this;
		if (!that.attached) { return; }

		that.$element.removeClass("affix-stuck affix-stuck-" + that.dir);

		if (!that.options.resizable) {
			that.$element.off("domChanged.affix");
		}

		for (let behavior of that.stuckBehaviors) {
			if (behavior.detach) {
				behavior.detach(that);
			}
		}

		that.$element.trigger("affixUnstuck");

		that.attached = false;
	}
}

interface AffixMap<T> {
	top: T;
	bottom: T;
}

interface AffixItemControlled extends AffixItem {
	/**
	 * @internal
	 */
	_ctrlByPos?: Position;
}