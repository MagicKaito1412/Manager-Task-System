import core = require("core");
import "waypoints";
import "xcss!./styles/scroll-accelerators.css";
import lang = core.lang;

// начиная с какой позиции скрола появляются скрываемые акселераторы
let acceleratorsShowOnPos = -42;

const acceleratorHtml = "<a href='#' class='x-scroll-accelerator noprint' tabindex='-1'><span class='x-icon x-icon-alone'></span></a>";

const acceleratedUpClass = "x-scroll-accel-top";
const acceleratedDownClass = "x-scroll-accel-bottom";
const acceleratedUpSelector = "." + acceleratedUpClass;
const acceleratedDownSelector = "." + acceleratedDownClass;

const acceleratorClassTmpl = "x-scroll-accelerator-";
const accelIconClassTmpl = "x-icon-arrow-";

const $body = (/webkit/.exec(navigator.userAgent.toLowerCase()) || [])[0] ? $("body") : $("html");
declare type Direction = "up" | "down";

// создание акселераторов
function createAccelerator (direction: Direction, domElement: JQuery, clickHandler: (e: JQueryEventObject) => any) {
	return domElement.find("." + acceleratorClassTmpl + direction).length ||
		$(acceleratorHtml)
			.appendTo(domElement)
			.addClass(acceleratorClassTmpl + direction)
			.click(clickHandler)
			.find("span")
			.addClass(accelIconClassTmpl + direction)
			.end();
}

function upAcceleratorClick (event: JQueryEventObject): void {
	event.preventDefault();
	let // позиция для проверки при акселерировании кверху
		contextBottomPos = core.$window.scrollTop(),
		// начальная позиция куда нужно скролить
		initialScrollToPos = 0,
		isContent = false,
		checkFn = (anchorPos, posForTest, curScrollTo, visualPageTop) => {
			if (anchorPos < posForTest + visualPageTop && anchorPos > curScrollTo) {
				return anchorPos;
			}
		},
		context = $(".x-scroll-accel-context").filter(":visible").first();

	if (context.length) {
		isContent = true;
		contextBottomPos = context.height();
	} else {
		context = $body;
	}

	processAcceleration(context, "up", checkFn, initialScrollToPos, contextBottomPos, isContent /*contentScrolling*/);
}

function downAcceleratorClick (event: JQueryEventObject): void {
	event.preventDefault();
	var // позиция для проверки при акселерировании книзу
		contextBottomPos = core.$window.scrollTop() + core.$window.height(),
		// начальная позиция куда нужно скролить
		initialScrollToPos = core.$document.height(),
		isContent = false,
		checkFn = (anchorPos, posForTest, curScrollTo, visualPageTop) => {
			if (anchorPos > posForTest + visualPageTop && anchorPos < curScrollTo) {
				return anchorPos;
			}
		},
		context = $(".x-scroll-accel-context").filter(":visible").first();

	if (context.length) {
		isContent = true;
		contextBottomPos = context.scrollTop() + context.height();
		initialScrollToPos = context.prop("scrollHeight");
	} else {
		context = $body;
	}

	processAcceleration(context, "down", checkFn, initialScrollToPos, contextBottomPos, isContent /*contentScrolling*/);
}

/**
 * находит следующий элемент к которому нужно отскролится и скролится к нему
 * @param {JQuery} context - контекст скролинга
 * @param {"up"|"down"} direction - направление "up" "down"
 * @param {Function} checkFn - функция проверки элемента при поиске
 * @param {Number} initialScrollToPos - начальная позиция куда скролить (вверх или низ страницы)
 * @param {Number} contextBottomPos - координаты нижней границы
 * @param {Boolean} isContentScrolling - признак того, что скролится контент
 */
function processAcceleration (context: JQuery, direction: Direction,
							  checkFn: (anchorPos: number, posForTest: number, curScrollTo: number, visualPageTop: number) => number,
							  initialScrollToPos: number, contextBottomPos: number, isContentScrolling: boolean): void {
	let winHeight = context.height(),
		scrollTop = context.scrollTop(),
		// признак нижнего акселерирования элемента
		isScrollToBottom = false,
		// результат проверки элемента
		testResult,
		// позиция куда нужно скролить
		scrollToPos = initialScrollToPos,
		// суммарная высота понаприлипавших элементов до скрола
		stuckedHeightBeforeScroll = calcStuckedHeight(context, direction),
		// вообще все ускоренные элементы в текущей area
		rawAcceleratedElements,
		// ускоренные элементы без дочерних ускоренных элементов в текущей area (они будут видимые)
		acceleratedElements,
		// высота прилепленных элементов
		layoutPageTop = calcFixedHeight(context, direction),
		// визуальный верх страницы
		pageTop = layoutPageTop + stuckedHeightBeforeScroll,
		// признак того, что будет выполнятся скролирование контента в текущем элементе
		isContentScroll = false;


	// все ускоренные элементы в текущей area (они будут видимые)
	// и из текущего контекста
	rawAcceleratedElements = context.find(acceleratedUpSelector + "," + acceleratedDownSelector)
		.filter(":visible");
	// и без детей которые тоже ускоренные
	acceleratedElements = rawAcceleratedElements
		.filter(function(): boolean {

			let elm = $(this);
			let accelParent = elm.parents(acceleratedUpSelector + "," + acceleratedDownSelector).first();
			if (!accelParent.length) return true;

			let parentInSet = false;
			rawAcceleratedElements.each(function() {
				if (this === accelParent.get(0)) {
					parentInSet = true;
					return false;
				}
			});
			return !parentInSet;
		});

	acceleratedElements.each(function () {
		let element = $(this),
			elementTop = element.position().top;

		// в случае скролирования контента добавить положение скрола контекста
		// т.к. положение расчитывается относительно ближайшего позиционированного родителя
		isContentScrolling && (elementTop += context.scrollTop());

		let elementScrollHeight = element.prop("scrollHeight");
		// если это элемент который находится в scrollTop и
		// не отскроллен до конца (когда скролить надо вниз)
		// 		или доскролен до верха (если вверх)
		if (elementTop === scrollTop + pageTop &&
			(
				(direction === "down" && elementScrollHeight !== element.scrollTop() + element.height()) ||
				(direction === "up" && element.scrollTop() !== 0)
			)) {

			// смотрим. есть ли у него акселерированные дети
			if (element.find(acceleratedUpSelector + "," + acceleratedDownSelector).length){
				// значит нужно начинать скролить контейнер. переключаем контекст
				processAcceleration(element, direction, checkFn,
					direction === "down" ? element.prop("scrollHeight") : 0,
					direction === "down" ? element.scrollTop() + element.height() : element.scrollTop(),
					true /*isContentScrolling*/);

				// в таком случае дальнейшую обработку элементов текущего контекста нужно прекращать
				isContentScroll = true;
				return false;
			}
		}

		// элемент акселерирован кверху
		if (element.hasClass(acceleratedUpClass) && (testResult = checkFn(elementTop, scrollTop, scrollToPos, pageTop))) {
			scrollToPos = testResult;
			isScrollToBottom = false;
		}
		// элемент акселерирован к низу
		if (element.hasClass(acceleratedDownClass) &&
			(testResult = checkFn(elementTop + element.height(), contextBottomPos, scrollToPos, pageTop))) {
			scrollToPos = testResult;
			isScrollToBottom = true;
		}
	});

	if (isContentScroll)
		return;

	scrollToPos = isScrollToBottom ? (scrollToPos - winHeight) : (scrollToPos - pageTop);

	context.animate( { scrollTop: scrollToPos }, 100, function() {
		// если в процессе скролинга что-то прилипло, то нужно высчитать новую высоту прилипших
		let stuckedHeightAfterScroll = calcStuckedHeight(context, direction);
		// прилипло новое. нужно компенсировать
		if (stuckedHeightAfterScroll !== stuckedHeightBeforeScroll) {
			context.animate( { scrollTop: scrollToPos - stuckedHeightAfterScroll }, 100);
		}
	});
}

// TODO эти две функции надо куда-то вынести.
const fixedTopClass = ".x-layout-top-fixed";
const fixedBottomClass = ".x-layout-bottom-fixed";

function calcFixedHeight (context: JQuery, direction: Direction): number {
	let total = 0,
		dataHeight,
		elementHeight,
		fixedClass = direction === "up" ? fixedTopClass : fixedBottomClass;

	context.find(fixedClass).each(function(): void {
		let element = $(this);
		if (element.css("position") === "fixed") {
			elementHeight = element.outerHeight();
			(dataHeight = element.attr("data-offset-height")) &&
				dataHeight > elementHeight &&
			(elementHeight = dataHeight);

			total += elementHeight;
		}
	});
	return total;
}

const stuckedTopClass = ".affix-stuck-top";
const stuckedBottomClass = ".affix-stuck-bottom";

function calcStuckedHeight (context: JQuery, direction: Direction): number {
	let total = 0,
		stuckedClass = direction === "up" ? stuckedTopClass : stuckedBottomClass;

	context.find(stuckedClass).filter(":visible").each(function (): void {
		total += $(this).outerHeight();
	});
	return total;
}

core.createModule("scroll-accelerators", function (app: core.IApplication, options: ModuleOptions) {
	return {
		initialize: function (app: core.IApplication) {

			if (!options || !options.disabled) {
				let $container = $("<div class='x-scroll-accelerators'></div>").appendTo($body);
				createAccelerator("up", $container, upAcceleratorClick);
				createAccelerator("down", $container, downAcceleratorClick);

				core.$window.waypoint((direction: Direction) => {
					if (direction === "down") {
						$(".x-scroll-accelerators").addClass("x-scroll-accelerators--show");
					} else {
						$(".x-scroll-accelerators").removeClass("x-scroll-accelerators--show");
					}
				}, {
					offset: acceleratorsShowOnPos
				});

				core.platform.bind("change:printing", function (sender, value) {
					$(".x-scroll-accelerators").toggle(!value);
				});
			}
		}
	};
});

export interface ModuleOptions {
	disabled?: boolean;
}
