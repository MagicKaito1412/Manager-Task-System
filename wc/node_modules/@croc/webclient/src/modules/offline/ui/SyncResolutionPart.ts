import core = require("core");
import utils = require("lib/utils");
import View = require("lib/ui/handlebars/View");
import Carousel = require("lib/ui/Carousel");
import List = require("lib/ui/list/List");
import Menu = require("lib/ui/menu/Menu");
import DomainObjectMap = require("lib/domain/DomainObjectMap");
import CacheManager = require("lib/interop/CacheManager");
import ObjectResolutionPart = require("lib/ui/ObjectResolutionPart");
import defaultTemplate = require("xhtmpl!./templates/SyncResolution.hbs");
import resources = require("i18n!../nls/resources");
import resourcesCommon = require("i18n!lib/nls/resources");
import "lib/ui/ConfirmDialog";
import DataSynchronizer = require("lib/interop/DataSynchronizer");

import lang = core.lang;
import { IDomainObject, UnitOfWork } from "lib/domain/.domain";
import { LoadRule } from "lib/interop/.interop.types";
import {ICommand} from "lib/core.commands";
import {PartCloseOptions} from "lib/ui/.ui";
import {DataFacadeSmart} from "core.interop";
import {ExceptionData, InteropError, ObjectIdentity, OptimisticConcurrencyException} from "lib/interop/.interop";

class ObjectListItem extends lang.Observable {
	isLoaded: boolean;

	/**
	 * @constructs ObjectListItem
	 * @extends Observable
	 * @param object
	 */
	constructor(object: IDomainObject) {
		super();

		this.object(object);
		this.isLoaded = object.isLoaded;
	}

	/**
	 * @observable-property {DomainObject}
	 */
	@lang.decorators.observableAccessor()
	object: lang.ObservableProperty<IDomainObject>;

	/**
	 * @observable-property {ObjectListItem.statuses}
	 */
	@lang.decorators.observableAccessor()
	status: lang.ObservableProperty<ObjectListItem.Status>;

	statusInfo (): ObjectListItem.StatusInfo {
		let that = this;
		switch (that.status()) {
			case ObjectListItem.Status.violation:
				return {text: resources["sync.object_status.violation"], icon: "error", cssClass: "text-danger"};
			case ObjectListItem.Status.obsolete:
				return {text: resources["sync.object_status.obsolete"], icon: "error", cssClass: "text-danger"};
			case ObjectListItem.Status.notFound:
				return {text: resources["sync.object_status.not_found"], icon: "error", cssClass: "text-danger"};
			case ObjectListItem.Status.removed:
				return {text: resources["sync.object_status.removed"], icon: "ok", cssClass: "text-success"};
			case ObjectListItem.Status.resolved:
				return {text: resources["sync.object_status.resolved"], icon: "ok", cssClass: "text-success"};
		}
		return null;
	}

	command (): string {
		let that = this;
		switch (that.status()) {
			case ObjectListItem.Status.obsolete:
				return "Resolve";
			case ObjectListItem.Status.notFound:
			case ObjectListItem.Status.removed:
				return ""; // no command for deleted objects
			default:
				return "Edit";
		}
	}

	type (): string {
		return this.object().meta.descr;
	}

	id (): string {
		return this.object().id;
	}

	load (): lang.Promise<ObjectListItem> {
		return this.object().load({policy: LoadRule.localOnly}).then((loaded) => {
			this.isLoaded = loaded.isLoaded;
			this.object(loaded);
			return this;
		});
	}
}
namespace ObjectListItem {
	export const Status = {
		violation: "violation" as "violation",
		obsolete: "obsolete" as "obsolete",
		notFound: "notFound" as "notFound", // was deleted on server
		removed: "removed" as "removed", 	// deletion was confirmed on client
		resolved: "resolved" as "resolved"
	};
	export type Status = (typeof Status)[keyof typeof Status];

	export interface StatusInfo {
		text: string;
		icon: string;
		cssClass: string;
	}
}
ObjectListItem.mixin({
	statuses: ObjectListItem.Status
});

function getIcon (icoName: string): string {
	return (core.ui && core.ui.iconProvider && core.ui.iconProvider.getIcon(icoName)) || "";
}

class SyncResolutionPart extends View {
	static defaultOptions: SyncResolutionPart.Options = {
		template: defaultTemplate,
		unbound: false
	};

	static defaultMenu: Menu.Options = {
		items: [
			// TODO: change title dynamically
			{
				name: "Next",
				html: "<span class='x-icon x-icon-ok'></span><span id='x-sync-resolution-cmd-next'></span>",
				icon: "ok",
				hint: resources["sync.menu.next.hint"]
			},
			{name: "Undo", title: resources["sync.menu.undo"], icon: "undo", hint: resources["sync.menu.undo.hint"]},
			{
				name: "More", title: resources["sync.menu.ext"], items: [
				{name: "Retry", title: resources["sync.menu.retry"]},
				{name: "UndoAll", title: resources["sync.menu.undo_all"], icon: "undo"},
				{name: "GoOffline", title: resourcesCommon["interop.go_offline"], icon: "offline"}
			]
			}
		]
	};

	appStateRestore: core.AppState;
	menu: Menu;
	commands: lang.Map<ICommand>;
	options: SyncResolutionPart.Options;
	app: core.Application;
	list: List<ObjectListItem>;
	carousel: Carousel<DataSynchronizer.SyncFailture>;
	syncResult: DataSynchronizer.SyncFailtureEventArgs;
	uow: UnitOfWork;
	resolved: DomainObjectMap<ObjectListItem.Status>;

	/**
	 * @class SyncResolutionPart
	 * @extends View
	 * @param {Object} options
	 */
	constructor(options: SyncResolutionPart.Options) {
		options = SyncResolutionPart.mixOptions(options, SyncResolutionPart.defaultOptions);
		super(options);

		this.app = this.options.app;

		this.commands = lang.extend(this.createCommands(), this.options.commands);

		this.menu = new Menu(SyncResolutionPart.defaultMenu, this.options.menu);
		this.menu.bindToPart(this);

		this.list = this._createList();

		this.carousel = new Carousel<DataSynchronizer.SyncFailture>({
			formatter: function (failure) {
				if (failure && failure.error) {
					// TODO: надо иконочку выводить getIcon("error"), но formatter доддерживает только текст :(
					return failure.error.message;
				}
			}
		});
		this.carousel.items().bind("change", this._initListItems, this);
		this.carousel.bind("change:position", this._initListItems, this);
	}

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor()
	hasErrors: lang.ObservableProperty<boolean>;

	setViewModel (syncResult: DataSynchronizer.SyncFailtureEventArgs): void {
		let that = this;

		if (that.syncResult === syncResult) {
			return;
		}

		that.syncResult = syncResult;

		if (that.uow) {
			that.uow.dispose();
		}

		if (that.syncResult && that.syncResult.failures) {
			that.hasErrors(true);
			that.uow = that.app.createUnitOfWork();
			that.resolved = new DomainObjectMap<ObjectListItem.Status>(that.uow.model);
			that.carousel.items().reset(that.syncResult.failures);
			that.carousel.position(0);

//				that.appStateRestore = that.app.stateManager.getCurrentState();
//				if (that.appStateRestore.area === "offline") {
//					// if we're already in offline Area then return to the app root
//					that.appStateRestore = {};
//				}
		} else {
			that.hasErrors(false);
			that.carousel.items().reset([]);
			that.uow = undefined;
			that.resolved = undefined;
		}
	}

	dispose (options?: PartCloseOptions): void {
		let that = this;
		super.dispose(options);
		that.carousel.dispose();
		that.list.dispose();

		if (that.uow) {
			that.uow.dispose();
		}
		that.uow = undefined;
		that.resolved = undefined;
	}

	/**
	 * @protected
	 * @returns {{Retry: (Command), CancelAll: (Command), Cancel: (Command), Next: (Command), Close: (Command), GoOffline: (Command)}}
	 */
	createCommands (): lang.Map<ICommand> {
		let that = this;
		return {
			"Retry": core.createCommand({
				execute: () => {
					that.retrySync();
				}
			}),
			"UndoAll": core.createCommand({
				execute: () => {
					core.ui.ConfirmDialog.create({
						header: resources["sync.title"],
						text: resources["sync.menu.undo_all.confirm"]
					}).render().then((result) => {
						if (result !== "yes") {
							return;
						}

						that.app.eventPublisher.publish("interop.sync.cancel", that.syncResult || {});
						that.close();
					});
				}
			}),
			"Undo": core.createCommand({
				execute: () => {
					core.ui.ConfirmDialog.create({
						header: resources["sync.title"],
						text: resources["sync.menu.undo.confirm"]
					}).render().then((result) => {
						if (result !== "yes") {
							return;
						}

						let args = {failures: [that.carousel.current()]};
						that.app.eventPublisher.publish("interop.sync.cancel", args);
						that.removeCurrent();
					});
				}
			}),
			"Next": core.createCommand({
				execute: () => {
					that.removeCurrent();
				}
			}),
			"Close": core.createCommand({
				execute: () => {
					that.close();
				}
			}),
			"GoOffline": core.createCommand({
				execute: () => {
					(<DataFacadeSmart>that.app.dataFacade).manuallyDisconnected(true);
					that.retrySync();
				}
			})
		};
	}

	removeCurrent (): void {
		let that = this;
		that.carousel.removeCurrent();
		if (!that.carousel.count()) {
			that.retrySync();
		}
	}

	/**
	 * Return title for "Next" command (remove the current error and retry on the last one).
	 * It's used in template.
	 * @returns {String}
	 */
	getCmdNextTitle (): string {
		return this.get("carousel").count() === 1 ? resources["sync.menu.finish"] : resources["sync.menu.next"];
	}

	/**
	 * Count of errors originally in server's response. It's used in template.
	 * @returns {integer}
	 */
	errorCountOriginal (): number {
		if (this.hasErrors()) {
			return this.syncResult.failures.length;
		}
		return 0;
	}

	/**
	 * Count of errors currently in courusel. It's used in template.
	 * @returns {integer}
	 */
	errorCountCurrent (): number {
		return this.get("carousel").count();
	}

	retrySync (): void {
		let that = this;
		that.app.eventPublisher.publish("interop.sync.retry", that.syncResult || {});
		that.close();
	}

	close (): void {
		let that = this;
		that.app.stateManager.switchState(that.appStateRestore);
		that.setViewModel(null);
	}

	protected _createList (): List<ObjectListItem> {
		let that = this;
		return new List<ObjectListItem>(that.app, {
			menuList: {items: []},
			menuSelection: {items: []},
			menuRow: {items: []},
			columns: [
				{
					name: "status",
					prop: "statusInfo",
					title: resources["sync.column.status"],
					width: 20,
					formatterHtml: (info: ObjectListItem.StatusInfo) => {
						if (!info) {
							return "";
						}
						return "<span class=\"" + info.cssClass + "\">" + getIcon(info.icon) + lang.encodeHtml(info.text) + "</span>";
					}
				}, {
					name: "cmd",
					prop: "command",
					title: "*",
					width: 30,
					formatterHtml: (name: string) => {
						if (!name) {
							return "";
						}

						let menuItem = {
							name: name,
							title: resources["sync.menu." + utils.toLowerCamel(name)] || name
						};
						return "<a href='#' class='x-cmd-link' data-cmd-name='" + name + "'>" + Menu.getItemHtml(menuItem) + "</a>";
					}
				}, {
					name: "type",
					title: resources["sync.column.type"],
					width: 30
				}, {
					name: "id",
					title: resources["sync.column.id"],
					width: 50
				}, {
					name: "object",
					title: resources["sync.column.object"],
					width: 100
				}
			],
			commands: {
				"Edit": core.createCommand({
					execute: function (args) {
						let item = args.object,
							obj = item.object(),
							uow = that.app.createUnitOfWork(),
							policy = {
								loadFirst: "local",
								allowRemote: true,
								allowLocal: true,
								shouldCache: false
							},
							deferredViewModel = uow.load(obj.meta.name, obj.id, {policy: policy}); // load locally

						that.navigationService.navigate({
							part: args.partName || "ObjectEditor:" + obj.meta.name,
							partOptions: {viewModel: deferredViewModel},
							onReturn: () => {
								uow.dispose();
							}
						});
					}
				}),
				"Resolve": core.createCommand({
					execute: function (args) {
						let item = args.object,
							obj = item.object(),
							failure = that.carousel.current(),
							local = lang.find(failure.objects, (o) => {
								// TODO: inheritance
								return o.id === obj.id && o.__metadata.type === obj.meta.name;
							}),
							original = lang.find(failure.result && failure.result.originalObjects, (o) => {
								// TODO: inheritance
								return o.id === obj.id && o.__metadata.type === obj.meta.name;
							}),
							part = new ObjectResolutionPart({
								local: local,
								original: original
							});
						that.navigationService.navigate({
							part: part,
							onReturn: function (result) {
								if (!result || !result.resolved) {
									return;
								}

								// put changes to UoW to show them in UI
								that.uow.fromJson(result.changes, {partial: true});

								let removed = obj.isLoaded && (obj.isRemoved() || obj.isInvalid()),
									defer = result.changes ?
										that.app.dataFacade.save(result.changes, {suppressEventOnSuccess: true}) :
										null;
								lang.async.done(defer, () => {
									let status = removed ?
										ObjectListItem.Status.removed :
										ObjectListItem.Status.resolved;
									that.resolved.add(obj, status);
									item.status(status);
								});
							}
						});
					}
				})
			}
		});
	}

	protected _initListItems (): void {
		let that = this,
			failure = that.carousel.current(),
			objects = (failure && failure.objects) || [],
			items = objects.map((json) => {
				let obj = that.uow.get(json.__metadata.type, json.id);
				return that._createListItem(obj, failure);
			});

		that.list.setData(items);
	}

	protected _createListItem (obj: IDomainObject, failure: DataSynchronizer.SyncFailture): ObjectListItem {
		let that = this,
			item = new ObjectListItem(obj),
			status = that.resolved.find(obj.meta.name, obj.id),
			serverError;
		if (!status) {
			serverError = failure && failure.error && (<InteropError>failure.error).serverError;
			status = that._getListItemStatusFromError(obj, serverError);
		}
		item.status(status);
		return item;
	}

	protected _getListItemStatusFromError (obj: IDomainObject, serverError: InteropError): ObjectListItem.Status {
		if (!serverError || !serverError.$className) {
			return undefined;
		}

		let that = this;
		switch (serverError.$className) {
			case "XOptimisticConcurrencyException":
				if (that._findIdentity((<OptimisticConcurrencyException>serverError).obsoleteObjects, obj)) {
					return ObjectListItem.Status.obsolete;
				}
				if (that._findIdentity((<OptimisticConcurrencyException>serverError).deletedObjects, obj)) {
					return ObjectListItem.Status.notFound;
				}
				break;
			case "XIntegrityViolationException":
				// TODO:
				return ObjectListItem.Status.violation;
		}

		return undefined;
	}

	protected _findIdentity (identities: ObjectIdentity[], obj: IDomainObject): ObjectIdentity {
		if (!identities) {
			return undefined;
		}
		return lang.find(identities, (id: ObjectIdentity) => {
			return id.id === obj.id && id.type === obj.meta.name;
		});
	}
}
namespace SyncResolutionPart {
	export interface Options extends View.Options {
		app?: core.Application;
		menu?: Menu.Options;
		commands?: lang.Map<ICommand>;
	}
}
SyncResolutionPart.mixin({
	defaultOptions: SyncResolutionPart.defaultOptions,
	defaultMenu: SyncResolutionPart.defaultMenu
});

core.ui.SyncResolutionPart = SyncResolutionPart;

export = SyncResolutionPart;

