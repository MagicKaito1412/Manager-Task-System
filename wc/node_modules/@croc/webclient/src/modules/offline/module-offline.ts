import $ = require("jquery");
import core = require("core");
import resources = require("i18n!./nls/resources");
import resourcesCommon = require("i18n!lib/nls/resources");
import SyncResolutionPart = require("./ui/SyncResolutionPart");
import SlickObjectListDataPresenter = require("lib/ui/slick/SlickObjectListDataPresenter");
import DataFacadeSmart = require("lib/interop/DataFacadeSmart");
import DataSynchronizer = require("lib/interop/DataSynchronizer");
import "xcss!./ui/styles/module-offline.css";
import {DomainObjectData} from "lib/interop/.interop";
import lang = core.lang;
import { FromJsonOptions, SetPropOptions } from "lib/domain/.domain";

// extend common resources
core.lang.forEach(resources, function (value, key) {
	resourcesCommon["offline." + key] = value;
});

core.createModule("offline", function (app: core.Application, options?: ModuleOptions) {
	options = options || {};

	let area = app.areaManager.getArea("offline");
	if (!area) {
		area = app.areaManager.createArea("offline", null, {title: resources["sync.title"], hidden: true});
	}
	let element = $("<div class='row'></div>").appendTo(area.domElement);
	element = $("<div class='col-md-12'></div>").appendTo(element);
	element = $("<div class='x-region'></div>").appendTo(element);

	let region = new core.composition.Region("main");
	region.render(element);
	//region.navigable = true;
	area.regionManager.addRegion(region);

	let part = SyncResolutionPart.create({app: app});
	part.bind("change:hasErrors", function (sender, value) {
		area.hidden(!value);
	});
	area.addState({name: "", isDefault: true}, {main: part});

	lang.override((<DataFacadeSmart>app.dataFacade), {
		createSyncErrorEvent: function (base, syncResult: DataSynchronizer.SyncFailtureEventArgs): core.SystemEvent {
			let event = base.call(this, syncResult);
			event.menu.items.push({
				name: "Resolve",
				title: resourcesCommon["interop.sync.resolve"],
				command: core.createCommand({
					execute: function () {
						let appStateToReturn = app.stateManager.getCurrentState();
						if (appStateToReturn.area === "offline") {
							// if we're already in offline Area then return to the app root
							appStateToReturn = {};
						}
						part.appStateRestore = appStateToReturn;

						part.setViewModel(syncResult);
						app.stateManager.applyState({area: "offline"});
					}
				})
			});
			return event;
		}
	});

	// NOTE: add the functionality: 'unsynchronized objects in list'
	if (app.dataFacade["options"]) {
		(<DataFacadeSmart>app.dataFacade).options.forceLoadUnsync = true;
	}

	if (!options.disableTrackUnsyncState) {
		if (app.model) {
			app.model.DomainObject.prototype.hasUnsyncChanges = core.lang.Observable.accessor("hasUnsyncChanges");

			lang.override(app.model.DomainObject.prototype, {
				fromJson: function (base, json: DomainObjectData, options: FromJsonOptions, propOptions?: SetPropOptions) {
					if (json.__metadata) {
						this.hasUnsyncChanges((<any>json.__metadata).hasUnsyncChanges);
					}
					return base.call(this, json, options, propOptions);
				}
			});
		}
		lang.override(SlickObjectListDataPresenter.prototype, {
			getItemMetadata: function (base, item) {
				let itemMeta = base.call(this, item) || {};
				if (core.lang.get(item, "hasUnsyncChanges")) {
					itemMeta.cssClasses = core.html.appendCssClass(itemMeta.cssClasses, "-unsync-item");
				}
				return itemMeta;
			}
		});
	}


//		app.eventPublisher.subscribe("interop.sync.error", function (ev) {
//			var syncResult = ev.args.data;
//			part.setViewModel(syncResult);
//			//region.resetState();
//			//area.activateState("", { disablePushState: true });
//		});
//
//		["interop.sync.retry", "interop.sync.cancel"].forEach(function (eventName) {
//			app.eventPublisher.subscribe(eventName, function () {
//				part.setViewModel(null);
//				//region.resetState();
//				//area.activateState("", { disablePushState: true });
//			});
//		});
});

export interface ModuleOptions {
	disableTrackUnsyncState?: boolean;
}
