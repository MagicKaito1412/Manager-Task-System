import core = require("core");
import View = require("lib/ui/handlebars/View");
import template = require("xhtmpl!modules/transfer/ui/templates/ImportPart.hbs")
import transfer = require("modules/transfer/Transfer");
import resources = require("i18n!lib/nls/resources");
import resourcesModule = require("i18n!modules/transfer/nls/resources");
import Menu = require("lib/ui/menu/Menu");
import ObjectComparePart = require("lib/ui/ObjectComparePart");
import ObjectViewer = require("lib/ui/editor/ObjectViewer");
import "xcss!./styles/transferPart.css";

import IPart  = core.ui.IPart;
import ICommand = core.commands.ICommand;
import DomainObjectData = core.interop.DomainObjectData;
import MenuOptions = Menu.Options;
import { Part } from "core.ui";

/**
 * @enum
 */
enum ImportPartState {
	connecting = 0,
	initial = 1,
	uploading = 2,
	startingUp = 3,
	importing = 4,
	aborting = 5,
	aborted = 6,
	failed = 7,
	suspended = 8,
	completed = 9
}

class ImportPart extends View {
	static State = ImportPartState;
	static defaultOptions: ImportPart.Options = {
		template: template,
		scenario: undefined,
		client: undefined,
		commands: undefined,
		menu: {items: [
			{name: "Abort", title: resourcesModule["transfer.cmd.abort"], order: 50},
			{name: "Close", title: resourcesModule["transfer.cmd.close"], order: 100}
		]},
		menus: {
			versionConflict: {items: [
				{
					name: "VersionConflict_Overwrite",
					title: resourcesModule["transfer.cmd.overwrite"],
					params: {action: transfer.VersionConflictAction.Overwrite},
					commandName: "Resume",
					hideIfDisabled: true,
					items: [{
						name: "VersionConflict_OverwriteAll",
						title: resourcesModule["transfer.cmd.overwriteAll"],
						params: {action: transfer.VersionConflictAction.OverwriteAll},
						commandName: "Resume",
						hideIfDisabled: true
					}, {
						name: "VersionConflict_OverwriteSameType",
						title: resourcesModule["transfer.cmd.overwriteSameType"],
						params: {action: transfer.VersionConflictAction.OverwriteSameType},
						commandName: "Resume",
						hideIfDisabled: true
					}]
				}, {
					name: "VersionConflict_Skip",
					title: resourcesModule["transfer.cmd.skip"],
					params: {action: transfer.VersionConflictAction.Skip},
					commandName: "Resume",
					hideIfDisabled: true,
					items: [{
						name: "VersionConflict_SkipAll",
						title: resourcesModule["transfer.cmd.skipAll"],
						params: {action: transfer.VersionConflictAction.SkipAll},
						commandName: "Resume",
						hideIfDisabled: true
					}, {
						name: "VersionConflict_SkipSameType",
						title: resourcesModule["transfer.cmd.skipSameType"],
						params: {action: transfer.VersionConflictAction.SkipSameType},
						commandName: "Resume",
						hideIfDisabled: true
					}]
				}
			]},
			unresolvedObjects: {items: [
				{
					name: "UnresolvedObject_Skip",
					title: resourcesModule["transfer.cmd.skip"],
					params: {action: transfer.UnresolvedObjectsAction.Skip},
					commandName: "Resume",
					hideIfDisabled: true
				}
			]},
			errorOnProcessObject: {items: [
				{
					name: "ObjectProcessErrorAction_Retry",
					title: resourcesModule["transfer.cmd.retry"],
					params: {action: transfer.ObjectProcessErrorAction.Retry},
					commandName: "Resume",
					hideIfDisabled: true
				}, {
					name: "ObjectProcessErrorAction_Skip",
					title: resourcesModule["transfer.cmd.skip"],
					params: {action: transfer.ObjectProcessErrorAction.Skip},
					commandName: "Resume",
					hideIfDisabled: true,
					items: [{
						name: "ObjectProcessErrorAction_SkipAll",
						title: resourcesModule["transfer.cmd.skipAll"],
						params: {action: transfer.ObjectProcessErrorAction.SkipAll},
						commandName: "Resume",
						hideIfDisabled: true
					}]
				}
			]}
		}
	};

	app: core.Application;
	options: ImportPart.Options;
	client: transfer.ImportClient;
	isClosing: boolean;
	element: JQuery;
	inputElement: JQuery;
	inputButton: JQuery;
	resourceId: string;
	files: core.files.Module;
	messages: Array<string>;
	menu: Menu;
	suspendMenu: Menu;
	commands: core.lang.Map<ICommand>;
	private _uploadToken: any;
	private $menuContainer: JQuery;

	/**
	 * @observable-property {String}
	 */
	@core.lang.decorators.observableAccessor()
	stateTitle: core.lang.ObservableProperty<string>;

	/**
	 * @observable-property {String}
	 */
	@core.lang.decorators.observableAccessor()
	stateSeverity: core.lang.ObservableProperty<string>;

	/**
	 * @observable-property {String}
	 */
	@core.lang.decorators.observableAccessor()
	errorMessage: core.lang.ObservableProperty<string>;

	/**
	 * @constructs ImportPart
	 * @extends View
	 * @param app
	 * @param options
	 */
	constructor(app: core.Application, options: ImportPart.Options) {
		options = ImportPart.mixOptions(options, ImportPart.defaultOptions);
		super(options);

		this.app = app;
		this.stateSeverity("info");
		this.state(ImportPartState.connecting);

		if (this.options.client) {
			this.client = this.options.client;
			this._initClient();
		} else if (transfer.Transfer.Instance) {
			// create or attach to running
			this.isLoading(true);
			transfer.Transfer.Instance.getRunningOperation("import", true).always((client) => {
				this.isLoading(false);
				if (client) {
					this.client = client;
					this._initClient();
				} else {
					this.client = new transfer.ImportClient(app);
					this._initClient();
				}
			});
		}

		this.files = core.files;
		this.messages = [];
		this.commands = this.createCommands();
		this.menu = this.createMenu();
		if (this.menu) {
			this.menu.bindToPart(this);
		}
	}

	state(): ImportPartState;
	state(v: ImportPartState): void;
	/**
	 * @observable-property {ImportPart#state}
	 */
	state(v?: ImportPartState) {
		if (!arguments.length) {
			return ImportPart._get(this, "state");
		}
		if (ImportPart._set(this, "state", v)) {
			this.onStateChange(v);
		}
	}

	protected onStateChange(v: ImportPartState): void {
		let that = this;
		switch (v) {
			case ImportPartState.connecting:
				that.stateTitle(resourcesModule["transfer.import.connecting"]);
				that.stateSeverity("info");
				break;
			case ImportPartState.startingUp:
				that.stateTitle(resourcesModule["transfer.import.starting"]);
				that.stateSeverity("info");
				break;
			case ImportPartState.importing:
				that.stateTitle(resourcesModule["transfer.import.running"]);
				that.stateSeverity("info");
				break;
			case ImportPartState.uploading:
				that.stateTitle(resourcesModule["transfer.import.uploading"]);
				that.stateSeverity("info");
				break;
			case ImportPartState.suspended:
				that.stateTitle(resourcesModule["transfer.import.suspended"]);
				that.stateSeverity("info");
				break;
			case ImportPartState.initial:
				that.stateTitle(resourcesModule["transfer.import.initial"]);
				that.stateSeverity("info");
				break;
			case ImportPartState.failed:
				that.stateTitle(resourcesModule["transfer.import.failed"]);
				that.stateSeverity("danger");
				break;
			case ImportPartState.aborted:
				that.stateTitle(resourcesModule["transfer.import.aborted"]);
				that.stateSeverity("warning");
				break;
			case ImportPartState.aborting:
				that.stateTitle(resourcesModule["transfer.import.aborting"]);
				that.stateSeverity("warning");
				break;
			case ImportPartState.completed:
				that.stateTitle(resourcesModule["transfer.import.completed"]);
				that.stateSeverity("success");
				break;
		}
	}

	detailPart(): IPart;
	detailPart(v: IPart): void;
	/**
	 * @observable-property {ImportPart#detailPart}
	 */
	detailPart(v?: IPart) {
		if (!arguments.length) {
			return ImportPart._get(this, "detailPart");
		}
		let args = ImportPart._set(this, "detailPart", v);
		if (args && args.oldValue) {
			args.oldValue.dispose();
		}
	}

	progress(): number;
	progress(v: number): void;
	/**
	 * @observable-property {ImportPart#state}
	 */
	progress(v?: number) {
		if (!arguments.length) {
			return ImportPart._get(this, "progress");
		}
		if (ImportPart._set(this, "progress", v)) {
			this.onProgressChange(v);
		}
	}
	protected onProgressChange(progress: number): void {
		let that = this,
			$bar = that.$domElement.find(".progress-bar");

		$bar.css("width", progress + "%");
		$bar.text(progress + "%");
	}

	protected _initClient(): void {
		let that = this,
			status = that.client.status();

		that.client.subscribe("started", that.onImportStarted, that);
		that.client.subscribe("historyUpdated", that.onHistoryUpdated, that);
		that.client.subscribe("running", that.onRunning, that);
		that.client.subscribe("aborting", that.onAborting, that);
		that.client.subscribe("suspendedOnVersionConflict", that.onVersionConflict, that);
		that.client.subscribe("suspendedOnUnresolvedObjects", that.onUnresolvedObjects, that);
		that.client.subscribe("suspendedOnError", that.onErrorOnProcessObject, that);
		that.client.subscribe("completed", that.onImportCompleted, that);
		that.client.subscribe("failed", that.onImportFailed, that);
		that.client.subscribe("aborted", that.onImportAborted, that);

		if (status === transfer.TransferStatus.None) {
			that.state(ImportPartState.initial);
		} else if (status === transfer.TransferStatus.Running) {
			that.state(ImportPartState.importing);
		} else {
			// NOTE: in any other state we have to refetch status to correctly react on events (create menu and so on)
			that.client.fetchStatus(true);
		}
	}

	protected createCommands(): core.lang.Map<ICommand> {
		let that = this,
			commands: core.lang.Map<ICommand>;

		commands = {
			Abort: core.createCommand({
				execute: () => {
					that.abort();
				},
				canExecute: () => {
					let state = that.state();
					return state === ImportPartState.importing || state === ImportPartState.suspended;
				}
			}),
			Close: core.createCommand({
				execute: () => {
					that.close();
				}
			}),
			UploadCancel: core.createCommand({
				execute: that._uploadCancel.bind(that)
			}),
			Resume: core.createCommand({
				execute: function (args) {
					if (args.action !== undefined) {
						that.resume(args.action);
					}
				}
			})
		};

		if (that.options.commands) {
			core.lang.forEach(that.options.commands, function (command, name) {
				//commands[name] = typeof command === "function" ? (<core.commands.ICommandFactory>command)(that) : <ICommand>command;
			});
		}

		return commands;
	}

	protected createMenu(): Menu {
		return new Menu(this.options.menu);
	}

	isRunning(): boolean {
		let state = this.state();
		return state === ImportPartState.importing ||
			state === ImportPartState.suspended ||
			state === ImportPartState.startingUp ||
			state === ImportPartState.uploading;
	}

	isProgress(): boolean {
		let state = this.state();
		return state === ImportPartState.importing ||
			state === ImportPartState.suspended ||
			state === ImportPartState.uploading;
	}

	protected onReady(): void {
		let that = this,
			inputElement,
			chainId;

		let $element = that.$domElement.find(".x-pe-binary");
		inputElement = $element.find("input[name=file]");
		inputElement.fileupload({
			url: that.files.uploadUrl,
			replaceFileInput: false, // TODO
			maxChunkSize: that.files.uploadChunkSize,
			// TODO нужно заюзать DropApi и как-то подсвечивать зону вброса
			dropZone: $element,
			dataType: "json",
			formData: [
				{
					name: "X-StorageType",
					value: "resource"
				}
			],
			add: function (e, data) {
				that._upload(data);
			},
			done: function (e, data) {
				that._onUploadSuccess(data);
			},
			fail: function (e, data) {
				that._onUploadFail(data);
			},
			progress: function (e, data) {
				that._onUploadProgress(data);
			},
			chunksend: function (e, data) {
				if (chainId) {
					data.headers["X-ChunkChain"] = chainId;
				}
			},
			chunkdone: function (e, data) {
				if (data.result) {
					chainId = data.result.resourceId;
				}
			}
		});

		that.inputElement = inputElement;
		that.inputButton = $element.find(".x-pe-binary-uploadbutton");
		that.element = $element;

		that.client.isInBackground(false);
		that.app.eventPublisher.publish("transfer.ui.foreground");

		if (that.$menuContainer) {
			that.app.eventPublisher.publish("ui.affix.remove_element", {
				element: that.$menuContainer
			});
		}
		that.$menuContainer = that.$domElement.find(".x-transfer-menu-container");
		that.app.eventPublisher.publish("ui.affix.add_element", {
			element: that.$menuContainer,
			//controlledBy: container.find(".x-editor-pages"),
			affixTo: "bottom"
		});
	}

	protected _removeSuspendedMenu(): void {
		let that = this;
		that.suspendMenu = null;
		that.trigger("change:suspendMenu");

		that.detailPart(null);
		that.errorMessage(null);
	}

	resume(action): void {
		let that = this;
		that._removeSuspendedMenu();
		that.client.resume(action);
		that.state(ImportPartState.importing);
	}

	close(): void {
		let that = this;
		if (this.isRunning()) {
			that.navigationService.leave();
		} else {
			// close and destroy the part
			that.isClosing = true; // it's flag for unload to not publish notification, as we're really destroying the part
			// explicitly set option `keepAlive = false` to force part disposing
			// NOTE: omitting options at all is NOT the same, default value of `keepAlive` is undefined
			that.navigationService.close(null, {keepAlive: false});
		}
	}

	abort(): void {
		let that = this;
		that._removeSuspendedMenu();
		that.state(ImportPartState.aborting);
		that.client.abort();
	}

	protected _upload(data): void {
		let that = this;
		that.state(ImportPartState.uploading);
		that._uploadToken = data.submit();
	}

	protected _onUploadProgress(data): void {
		let that = this,
			progress = core.lang.toInteger(data.loaded / data.total * 100);

		that.progress(progress);
	}

	protected _onUploadSuccess(data): void {
		let that = this;
		let result = data.result;
		if (that._uploadToken) {
			that._uploadToken = undefined;
		}
		if (!result && !result.resourceId) {
			// throw error?
			return;
		}

		that.resourceId = result.resourceId;
		// NOTE: that fires rerender
		that.state(ImportPartState.startingUp);

		// start import
		that.startImport();
	}

	protected _onUploadFail(data): void {
		let that = this,
			error = that.files.handleUploadError(data.jqXHR, data.textStatus, data.errorThrown);

		if (that._uploadToken) {
			that._uploadToken = undefined;
		}
		if (error.isAbort) {
			that.state(ImportPartState.initial);
		} else {
			that.state(ImportPartState.failed);
		}
		that.errorMessage(error.message);
	}

	protected _uploadCancel(): void {
		let that = this;
		if (that._uploadToken) {
			that._uploadToken.abort();
		}
	}

	startImport(): void {
		let that = this;
		that.progress(0);
		that.client.startImport(that.resourceId, that.options.scenario);
	}

	protected onImportStarted(): void {
		this.state(ImportPartState.importing);
	}

	protected onHistoryUpdated(sender, args: {history: Array<transfer.TransferOperationState>}): void {
		let that = this,
			history = args.history;

		if (history.length) {
			history.forEach(function (state) {
				that.progress(state.progressPercent);
			});
		}
	}

	protected onRunning(): void {
		this.state(ImportPartState.importing);
	}

	protected onAborting(): void {
		this.state(ImportPartState.aborting);
	}

	protected onVersionConflict(sender, args: {state: transfer.TransferOperationState}): void {
		let that = this;

		/*
		 XTsVersionConflictImportSuspendedStateInfo :
			 suspendedCause = ImportSuspendedCause.VersionConflict
			 importingObject: DomainObjectData
			 existingObject: DomainObjectData
		 response: VersionConflictAction
		 * */
		that.state(ImportPartState.suspended);
		that._updateMenu(that.options.menus.versionConflict);
		that.errorMessage(args.state.errorMessage || args.state.message);
		let res = <transfer.TransferImportSuspendedStateVersionConflict>args.state.importSuspendedResult;
		if (res.importingObject && res.existingObject) {
			let part = new ObjectComparePart({
				local: res.importingObject,
				original: res.existingObject,
				hint: "",
				targetColumnTitle: resources["transfer.import.targetColumnTitle"],
				sourceColumnTitle: resources["transfer.import.sourceColumnTitle"],
				showMetadata: true
			});
			that.detailPart(part);
		}
	}

	protected onUnresolvedObjects(sender, args: {state: transfer.TransferOperationState}): void {
		let that = this;
		/*
		 XTsUnresolvedObjectsImportSuspendedStateInfo :
			 suspendedCause = ImportSuspendedCause.UnresolvedObjects
			 unresolvedObjects: []
		 response: UnresolvedObjectsAction
		* */
		that.state(ImportPartState.suspended);
		that._updateMenu(that.options.menus.unresolvedObjects);
		that.errorMessage(args.state.errorMessage || args.state.message);
		let res = <transfer.TransferImportSuspendedStateUnresolvedObject>args.state.importSuspendedResult;
		if (res.unresolvedObjects && res.unresolvedObjects.length) {
			that._openViewer(res.unresolvedObjects[0]);
		}
	}

	protected _openViewer(objData: DomainObjectData): void {
		let that = this,
			uow = that.app.createUnitOfWork();
		let obj = uow.fromJson(objData);
		let part = new ObjectViewer({
			viewModel: obj,
			menu: {items: []},
			// do not load not-loaded properties
			suppressAutoLoad: true,
			// do not allow to open in nested viewer value objects
			disableValuesNavigation: true
		});
		that.detailPart(part);
	}

	protected onErrorOnProcessObject(sender, args: {state: transfer.TransferOperationState}): void {
		let that = this;
		/*
		 XTsErrorOnProcessObjectImportSuspendedStateInfo :
			 suspendedCause = ImportSuspendedCause.ErrorOnProcessObject
			 violatingObject: DomainObjectData
			 errorMessage: String
		 response: ObjectProcessErrorAction
		* */
		that.state(ImportPartState.suspended);
		that._updateMenu(that.options.menus.errorOnProcessObject);
		let res = <transfer.TransferImportSuspendedStateErrorOnProcessObject>args.state.importSuspendedResult;
		that.errorMessage(res.errorMessage);
		if (res.violatingObject) {
			that._openViewer(res.violatingObject);
		}
	}

	protected _updateMenu(metadata: MenuOptions): void {
		let that = this,
			suspendMenu = new Menu(metadata);

		suspendMenu.bindToPart(that);
		that.suspendMenu = suspendMenu;
		//that.menu.mergeWith(menuAdd);
		that.trigger("change:suspendMenu");
	}

	protected onImportCompleted(): void {
		let that = this;
		that.state(ImportPartState.completed);
		that.progress(100);
	}

	protected onImportFailed(sender, args): void {
		let that = this;
		that.state(ImportPartState.failed);
		if (args && args.message) {
			that.stateTitle(that.stateTitle() + ": " + args.message)
		}
		that.progress(100);
	}

	protected onImportAborted(): void {
		this.state(ImportPartState.aborted);
		this.progress(100);
	}

	unload(options?: Part.CloseOptions): void {
		let that = this;
		super.unload();
		if (!options || options.reason !== "rerender") {
			if (!that.isClosing && that.state() !== ImportPartState.initial) {
				that.client.isInBackground(true);
			}
		}
		if (that.$menuContainer) {
			that.app.eventPublisher.publish("ui.affix.remove_element", {
				element: that.$menuContainer
			});
		}
	}

	dispose(options?: Part.CloseOptions): void {
		if (this.client) {
			this.client.dispose();
			this.client = undefined;
		}
		super.dispose(options);
	}
}

ImportPart.mixin(/** @lends ImportPart.prototype */{
	defaultOptions: ImportPart.defaultOptions,
});

namespace ImportPart {
	export interface Options extends View.Options {
		scenario?: string;
		client?: transfer.ImportClient;
		commands?: core.lang.Map<ICommand>;
		menu?: MenuOptions;
		menus?: {
			versionConflict: MenuOptions
			unresolvedObjects: MenuOptions
			errorOnProcessObject: MenuOptions
		};
	}

	export type State = ImportPartState;
}

export = ImportPart;
