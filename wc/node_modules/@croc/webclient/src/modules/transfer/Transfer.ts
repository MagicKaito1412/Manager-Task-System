import core = require("core");
import datetimes = require("lib/utils/datetimes");
import resources = require("i18n!lib/nls/resources");
import resourcesModule = require("i18n!modules/transfer/nls/resources");
import utils = require("lib/utils");
import interop = require("lib/interop/.interop");

import Deferred = core.lang.Deferred;
import Promise = core.lang.Promise;

// extend common resources
core.lang.forEach(resourcesModule, function (value, key) {
	resources[key] = value;
});

const traceSource = new core.diagnostics.TraceSource("transfer");

export enum TransferStatus {
	None = 0,
	StartingUp = 1,
	Running = 2,
	Aborting = 3,
	Aborted = 4,
	Failed = 5,
	Suspended = 6,
	Completed = 7,
	StreamingData = 8
}
export enum ImportSuspendedCause {
	Unknown = 0,
	UnresolvedObjects = 1,
	VersionConflict = 2,
	ErrorOnProcessObject = 3
}
export enum VersionConflictAction {
	Abort = 0,
	Overwrite = 1,
	Skip = 2,
	OverwriteAll = 3,
	SkipAll = 4,
	OverwriteSameType = 5,
	SkipSameType = 6
}
export enum UnresolvedObjectsAction {
	Abort = 0,
	Skip = 1
}
export enum ObjectProcessErrorAction {
	Abort = 0,
	Retry = 1,
	Skip = 2,
	SkipAll = 3
}
export interface TransferImportSuspendedState {
	suspendedCause: ImportSuspendedCause;
}
export interface TransferImportSuspendedStateVersionConflict extends TransferImportSuspendedState {
	importingObject: interop.DomainObjectData;
	existingObject: interop.DomainObjectData;
}
export interface TransferImportSuspendedStateUnresolvedObject extends TransferImportSuspendedState {
	unresolvedObjects: Array<interop.DomainObjectData>;
}
export interface TransferImportSuspendedStateErrorOnProcessObject extends TransferImportSuspendedState {
	violatingObject: interop.DomainObjectData;
	errorMessage: string;
}

export interface TransferOperationState {
	status: TransferStatus;
	timeStamp: Date;
	progressPercent: number;
	message: string;
	errorMessage: string;
	exportSuspendedResult: Object;	// TODO: typitify
	importSuspendedResult: TransferImportSuspendedStateVersionConflict|TransferImportSuspendedStateUnresolvedObject|TransferImportSuspendedStateErrorOnProcessObject;
}

export interface TransferOperationStatusResult {
	lastState: TransferOperationState;
	intermediateStates?: TransferOperationState[];
	//collectingDateTime?: Date; // string
}

export interface TransferOperationStartResult {
	opId: string;
}

export interface TransferOperationListResult {
	operations: {
		opId: string;
		type: string;
		isCompleted: boolean;
	}[];
}

class TransferClientBase extends core.lang.Observable {
	// TODO:
	static Events = {
		"started": "started",
		"suspended": "suspended",
		"disposed": "disposed"
	};

	dataFacade: interop.IDataFacade;
	eventPublisher: core.IEventPublisher;
	opId: string;
	status: core.lang.ObservableProperty<TransferStatus>;
	statusTitle: core.lang.ObservableProperty<string>;
	isInBackground: core.lang.ObservableProperty<boolean>;
	nextSince: Date;
	urls: {
		start: string;
		getstatus: string;
		resume: string;
		abort: string;
	};
	eventPrefix: string;
	pollingTimeout: number;
	history: Array<TransferOperationState>;
	type: string;

	protected _disposed: boolean;
	private _timerPoll: number;
	private _getStatusThis: Function;
	private _bgNotificationDeferred: Deferred<any>;

	constructor (app: core.IApplication) {
		super();

		let that = this;
		that.urls = {
			getstatus: "api/_transfer/getstatus",
			start: "",
			resume: "api/_transfer/resume",
			abort: "api/_transfer/abort"
		};
		that.eventPublisher = app.eventPublisher;
		that.dataFacade = app.dataFacade;
		that.pollingTimeout = 500;
		that.history = [];
		that._getStatusThis = that._getStatus.bind(that);

		that.status(TransferStatus.None);
		that.isInBackground(false);
		that.bind("change:status", function (sender, val) {
			that._updateTitle();
		});
		that.bind("change:isInBackground", function (sender, val) {
			if (val) {
				// we're in the background
				that._publishProcess();
			} else {
				if (that._bgNotificationDeferred) {
					// hide 'process'
					that._bgNotificationDeferred.resolve();
					that._bgNotificationDeferred = undefined;
				}
			}
		});
	}

	protected _publishProcess (): void {
		let that = this;
		if (that._bgNotificationDeferred) {
			that._bgNotificationDeferred.reject();
		}
		that._bgNotificationDeferred = core.lang.Deferred();

		// show 'process'
		that.eventPublisher.publish("transfer.running", core.SystemEvent.create({
			kind: core.SystemEvent.Kind.process,
			priority: "high",
			// TODO: нужно observable expression для шаблона нотификации, чтобы ui обновлялся
			message: that.statusTitle(),
			promise: that._bgNotificationDeferred.promise(),
			menu: {
				items: [{
					name: "Open",
					title: "Открыть",
					command: Transfer.Instance.cmdActivateOp,
					params: {client: that}
				}]
			}
		}));
	}

	protected _updateTitle (): void {
		let that = this,
			val = that.status(),
			title = "";
		switch(val) {
			case TransferStatus.StartingUp:
				title = resources[that.eventPrefix + ".starting"];
				break;
			case TransferStatus.Running:
				title = resources[that.eventPrefix + ".running"];
				break;
			case TransferStatus.Suspended:
				title = resources[that.eventPrefix + ".suspended"];
				break;
			case TransferStatus.Failed:
				title = resources[that.eventPrefix + ".failed"];
				break;
			case TransferStatus.Aborted:
				title = resources[that.eventPrefix + ".aborted"];
				break;
			case TransferStatus.Aborting:
				title = resources[that.eventPrefix + ".aborting"];
				break;
			case TransferStatus.Completed:
				title = resources[that.eventPrefix + ".completed"];
				break;
		}
		that.statusTitle(title);
	}

	connect (opId: string): Promise<TransferOperationStatusResult> {
		let that = this;
		if (!opId) { return; }
		if (that._disposed) { return; }
		if (that.status() !== TransferStatus.None) {
			throw new Error("TransferClient must be in 'TransferStatus.None' state");
		}

		// TODO: какой тут статус?
		return that._requestStatus(opId)
			.done(function (result: TransferOperationStatusResult) {
				// the operation with id=opId does exist
				that._onStarted(opId);
				that.onGetStatusSuccess(result);
			})
			.fail(function (error) {
				that.onInteropFail(error, resourcesModule[that.eventPrefix + ".connect.error"]);
			});
	}

	protected _start (params): Promise<TransferOperationStartResult> {
		let that = this;

		that.status(TransferStatus.StartingUp);
		return that.dataFacade.ajax({
			url: that.urls.start + "?" + utils.paramsToQueryString(params)
		}, {suppressEventOnError: true}).done(function (result: TransferOperationStartResult){
			that._onStarted(result.opId);
			// schedule polling
			that.scheduleGetStatus();
		}).fail(function (error) {
			that.onInteropFail(error, resourcesModule[that.eventPrefix + ".start.error"]);
		});
	}

	protected _onStarted(opId: string): void {
		let that = this;
		if (!opId) { return; }
		if (that._disposed) { return; }
		that.status(TransferStatus.Running);
		that.opId = opId;

		that.eventPublisher.publish("transfer.started", {client: that});
		window.setTimeout(function () {
			that.trigger(ExportClient.Events.started, that);
			if (that.isInBackground()) {
				that._publishProcess();
			}
		}, 0);
	}

	protected _requestStatus (opId: string, params?): Promise<TransferOperationStatusResult> {
		let that = this,
			query = "?opId=" + opId;

		if (params) {
			query = query + "&" + utils.paramsToQueryString(params);
		}
		return that.dataFacade.ajax({url: that.urls.getstatus + query}, {suppressEventOnError: true});
	}

	protected _getStatus (all?: boolean): Promise<TransferOperationStatusResult> {
		let that = this,
			params;
		if (that._disposed) { return; }
		if (that._timerPoll) {
			window.clearTimeout(that._timerPoll);
			that._timerPoll = undefined;
		}

		if (!all && that.nextSince) {
			params = {since: datetimes.toISOString(that.nextSince, false)};
		}
		return that._requestStatus(that.opId, params)
			.done(function (result) {
				that.onGetStatusSuccess(result, all);
			}).fail(function (error) {
				that.onInteropFail(error, resourcesModule["transfer.getstatus.error"]);
			});
	}

	fetchStatus (all?: boolean): Promise<TransferOperationStatusResult> {
		return this._getStatus(all);
	}

	scheduleGetStatus (): void {
		let that = this;
		if (that._disposed) { return; }
		if (that._timerPoll) {
			window.clearTimeout(that._timerPoll);
		}
		that._timerPoll = window.setTimeout(that._getStatusThis, that.pollingTimeout);
	}

	protected onGetStatusSuccess (result: TransferOperationStatusResult, allHistory?: boolean): void {
		var that = this,
			status: TransferStatus;
		if (that._disposed) { return; }
		if (!result || !result.lastState) {
			that.dispose();
			// todo: publish event
			return;
		}
		/*
		{
			"intermediateStates": [ {
					"status": 1,
					"timeStamp": "2015-06-18T20:05:02.098",
					"progressPercent": 0,
					"message": "",
					"errorMessage": null,
					"exportSuspendedResult": null,
					"importSuspendedResult": null
				}, {
					"status": 2,
					"timeStamp": "2015-06-18T20:05:02.110",
					"progressPercent": 0,
					"message": "Инициализация окружения",
					"errorMessage": null,
					"exportSuspendedResult": null,
					"importSuspendedResult": null
				},
			],
			"lastState": {
				"status": 2,
				"timeStamp": "2015-06-18T20:05:02.210",
				"progressPercent": 50,
				"message": "Выполняется экспорт, начало выполнения шага User",
				"errorMessage": null,
				"exportSuspendedResult": null,
				"importSuspendedResult": null
			},
			"collectingDateTime": "2015-06-18T20:05:02.627"
		}
		*/
		if (allHistory) {
			that.history = [];
		}
		var newHistory: TransferOperationState[] = result.intermediateStates || [];
		if (that.history.length) {
			// lastState может дублировать последнее состояние, надо его отсечь
			var lastCurState: TransferOperationState = that.history[that.history.length - 1],
				lastNewState: TransferOperationState = result.lastState;
			if (lastCurState.status !== lastNewState.status ||
				lastCurState.progressPercent !== lastNewState.progressPercent ||
				lastCurState.timeStamp !== lastNewState.timeStamp) {
				newHistory.push(result.lastState);
			}
		} else {
			newHistory.push(result.lastState);
		}
		that.history.push.apply(that.history, newHistory);

		if (newHistory.length) {
			that.trigger("historyUpdated", that, {history: newHistory});
		}

		status = result.lastState.status;
		if (status === TransferStatus.Completed ||
			status === TransferStatus.Aborted ||
			status === TransferStatus.Failed) {
			that.onFinished(result.lastState);
			that.dispose();
		} else if (status === TransferStatus.Suspended) {
			that.onSuspended(result);
		} else if (status === TransferStatus.Running) {
			that.nextSince = new Date();
			that.onRunning();
		} else if (status === TransferStatus.Aborting) {
			that.nextSince = new Date();
			that.onAborting();
		} else {
			that._onUnknownError("onGetStatusSuccess: Unknown status '" + result.lastState.status + "'. State: " + JSON.stringify(result));
		}
	}

	protected onInteropFail (error: Error, msg: string): void {
		if (this._disposed) { return; }

		// TODO: Если операция не существуте, в независимости что клиент думает, переходим в failed
		// TODO: Если ошибка вызвана interop/взаимодействием, то можно предложить повторить
		this.onFailed(error.message);
	}

	// TODO: what type of action?
	resume (action: any): void {
		let that = this;
		if (that._disposed) { return; }
		if (that.status() !== TransferStatus.Suspended) { return; }

		let query = "?opId=" + that.opId + "&action=" + action;

		that.nextSince = new Date();
		that.dataFacade.ajax({
			url: that.urls.resume + query
		}, {suppressEventOnError: true}).done(function () {
			that.onRunning();
		}).fail(function (error) {
			that.onInteropFail(error, resourcesModule[that.eventPrefix + ".resume.error"]);
		});
	}

	abort(): Promise<void> {
		let that = this;
		if (that._disposed) { return; }
		if (!that.opId) { that.dispose(); return; }
		let query = "?opId=" + that.opId;

		return that.dataFacade.ajax({
			url: that.urls.abort + query
		}, {suppressEventOnError: true}).done(function () {
			that.onAborted();
		}).fail(function (error) {
			that.onInteropFail(error, resourcesModule[that.eventPrefix + ".abort.error"]);
		});
	}

	protected onRunning (): void {
		let that = this;
		if (that.status() !== TransferStatus.Running) {
			that.status(TransferStatus.Running);
			that.trigger("running", that);
		}
		// schedule next poll
		that.scheduleGetStatus();
	}

	protected onAborting (): void {
		let that = this;
		if (that.status() !== TransferStatus.Aborting) {
			that.status(TransferStatus.Aborting);
			that.trigger("aborting", that);
		}
		// schedule next poll
		that.scheduleGetStatus();
	}

	protected onSuspended (result: TransferOperationStatusResult): void {
		let that = this;
		that.status(TransferStatus.Suspended);
		if (that.isInBackground()) {
			that.eventPublisher.publish(that.eventPrefix + ".suspended", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.notification,
				priority: "high",
				severity: "info",
				message: resourcesModule[that.eventPrefix + ".suspended"]
			}));
		}

		that.trigger(ExportClient.Events.suspended, that, {state: result.lastState});
	}

	protected onFinished (state: TransferOperationState): void {
		let that = this;
		if (state.status === TransferStatus.Failed) {
			that.onFailed(state.errorMessage || state.message);
		} else if (state.status === TransferStatus.Aborted) {
			that.onAborted();
		} else if (state.status === TransferStatus.Completed) {
			that.onCompleted(state);
		}
	}

	protected onAborted (): void {
		let that = this;
		that.status(TransferStatus.Aborted);
		if (that.isInBackground()) {
			that.eventPublisher.publish(that.eventPrefix + ".aborted", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.notification,
				priority: "high",
				severity: "info",
				message: resourcesModule[that.eventPrefix + ".aborted"]
			}));
		}
		that.trigger("aborted", that);
		that.eventPublisher.publish("transfer.finished", {client: that});
	}

	protected onFailed (message: string): void {
		let that = this;
		that.status(TransferStatus.Failed);
		if (that.isInBackground()) {
			that.eventPublisher.publish(that.eventPrefix + ".failed", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.notification,
				priority: "high",
				severity: "error",
				message: resourcesModule[that.eventPrefix + ".failed"] + ": " + message
			}));
		}

		that.trigger("failed", that, {message: message});
		that.eventPublisher.publish("transfer.finished", {client: that});
	}

	protected onCompleted (state: TransferOperationState): void {
		let that = this;
		that.status(TransferStatus.Completed);
		that.trigger("completed", that, {state: state});
		that.eventPublisher.publish("transfer.finished", {client: that});
	}

	dispose (): void {
		let that = this;
		if (that._disposed) { return; }
		that._disposed = true;
		that.nextSince = undefined;

		if (that._bgNotificationDeferred) {
			that._bgNotificationDeferred.reject();
			that._bgNotificationDeferred = undefined;
		}
		if (that._timerPoll) {
			window.clearTimeout(that._timerPoll);
			that._timerPoll = undefined;
		}
		that.trigger(ExportClient.Events.disposed, that);
	}

	protected _onUnknownError (error: string): void {
		let that = this;
		traceSource.error(error);
		that.onFailed(error);
		that.dispose();
	}

	terminate (error): void {

		// TODO: надо свести все failure к единому выходу. Причины ошибок:
		// 	- ошибка на сервере
		//	- ошибка на клиенте
		//	- ошибка во время вызова (interop)
		//	- юзер прервал операцию
		// В случае ошибки на клиенте, операция на сервере может остаться запущенной, и к ней можно будет приконектится.
		// Но в случае ошибки на сервере, клиентский парт должен всегда переходить в состояние failed
		// В случае interop-ошибки, теоретически, можно продолжать попытки
		// Главное, чтобы при переходе клиентского парта (и ImportClient) в состояние failed, при закрытии парт удалялся.
		// Для того, чтобы можно было начать новую операцию.
		this.dispose();
	}
}
TransferClientBase.prototype.isInBackground = core.lang.Observable.accessor("isInBackground");
TransferClientBase.prototype.status = core.lang.Observable.accessor("status");
TransferClientBase.prototype.statusTitle = core.lang.Observable.accessor("statusTitle");

export class ExportClient extends TransferClientBase {
	type = "export";

	constructor (app: core.IApplication) {
		super(app);
		this.urls.start = "api/_transfer/startexport";
		this.eventPrefix = "transfer.export";
	}

	startExport (scenario: string): Promise<TransferOperationStartResult> {
		if (!scenario) { return; }

		return this._start({scenario: scenario});
	}

	protected onCompleted (state: TransferOperationState): void {
		let that = this;
		if (that.isInBackground()) {
			that.eventPublisher.publish("transfer.export.completed", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.actionRequest,
				priority: "high",
				severity: "success",
				message: resourcesModule["transfer.export.completed"],
				menu: {
					items: [{
						name: "Download",
						title: resourcesModule["transfer.export.download_file"],
						command: core.createCommand(function () {
							that.downloadExport();
						})
					}, {
						name: "Close",
						title: resources["close"],
						command: core.createCommand(function () {})
					}]
				}
			}));
			/*that.eventPublisher.publish("transfer.export.completed", core.SystemEvent.create({
				kind: core.SystemEvent.Kinds.notification,
				priority: "normal",
				severity: "success",
				message: resourcesModule["transfer.export.completed"]
			}));*/
		}
		super.onCompleted(state);
	}

	downloadExport(suppressEvents?: boolean): Promise<any> {
		let that = this;
		if (!that.opId) { return; }

		return that.dataFacade.ajax({
			url: "api/_transfer/download?opId=" + that.opId
		}, {fileDownload: true}).done(() => {
			// everything is OK, exported data were download
			if (!suppressEvents) {
				that.eventPublisher.publish("transfer.export.downloaded", core.SystemEvent.create({
					kind: core.SystemEvent.Kind.notification,
					priority: "normal",
					severity: "success",
					message: resourcesModule["transfer.export.downloaded"]
				}));
			}
		}).fail((error) => {
			if (!suppressEvents) {
				core.Application.current.eventPublisher.publish("interop.error", core.SystemEvent.create({
					kind: core.SystemEvent.Kind.notification,
					priority: "high",
					severity: "error",
					message: resources["interop.download_error"] + (error.message ? ": " + error.message : ""),
					error: error
				}));
			}
		});
	}
}

export class ImportClient extends TransferClientBase {
	type = "import";
	options: ImportClient.Options;

	constructor (app: core.IApplication, options?: ImportClient.Options) {
		super(app);
		this.options = options || {};
		this.urls.start = "api/_transfer/startimport";
		this.eventPrefix = "transfer.import";
	}

	startImport(resourceId: string, scenario?: string): Promise<TransferOperationStartResult> {
		return this._start({resourceId: resourceId, scenario: scenario});
	}

	protected onSuspended (result: TransferOperationStatusResult): void {
		let that = this,
			state: TransferOperationState = result.lastState,
			actions = that.options.suspendedActions,
			unknown;

		super.onSuspended(result);
		if (state.importSuspendedResult) {
			/*
			 XTsVersionConflictImportSuspendedStateInfo :
				 suspendedCause = ImportSuspendedCause.VersionConflict
				 importingObject
				 existingObject
				 response: VersionConflictAction
			 XTsErrorOnProcessObjectImportSuspendedStateInfo :
				 suspendedCause = ImportSuspendedCause.ErrorOnProcessObject
				 violatingObject
				 errorMessage
				 response: ObjectProcessErrorAction
			 XTsUnresolvedObjectsImportSuspendedStateInfo :
				 suspendedCause = ImportSuspendedCause.UnresolvedObjects
				 unresolvedObjects: []
				 response: UnresolvedObjectsAction
			 */
			let cause = state.importSuspendedResult.suspendedCause;
			switch(cause){
				case ImportSuspendedCause.VersionConflict:
					if (actions && actions.versionConflict !== undefined) {
						that.resume(actions.versionConflict);
					} else {
						that.onVersionConflict(state);
					}
					break;
				case ImportSuspendedCause.ErrorOnProcessObject:
					if (actions && actions.error !== undefined) {
						that.resume(actions.error);
					} else {
						that.onErrorOnProcessObject(state);
					}
					break;
				case ImportSuspendedCause.UnresolvedObjects:
					if (actions && actions.unresolvedObjects !== undefined) {
						that.resume(actions.unresolvedObjects);
					} else {
						that.onUnresolvedObjects(state);
					}
					break;
				default:
					unknown = true;
					break
			}
		} else {
			unknown = true;
		}
		if (unknown) {
			that._onUnknownError("Response for suspended state doesn't contain known suspendedCause");
		}
	}

	protected onVersionConflict (state: TransferOperationState): void {
		// input:
		// 	importingObject: DomainObjectData
		// 	existingObject: DomainObjectData
		// output: VersionConflictAction
		let args = {
			state: state
		};

		this.trigger("suspendedOnVersionConflict", this, args);
	}

	protected onErrorOnProcessObject (state: TransferOperationState): void {
		// input:
		// 	violatingObject: DomainObjectData
		// 	errorMessage: string
		// output: ObjectProcessErrorAction
		let args = {
			state: state
		};

		this.trigger("suspendedOnError", this, args);
	}

	protected onUnresolvedObjects (state: TransferOperationState): void {
		// input:
		//	unresolvedObjects: Array<DomainObjectData>
		// output: UnresolvedObjectsAction
		let args = {
			state: state
		};

		this.trigger("suspendedOnUnresolvedObjects", this, args);
	}
}
namespace ImportClient {
	export interface Options {
		suspendedActions?: {
			versionConflict: VersionConflictAction
			unresolvedObjects: UnresolvedObjectsAction
			error: ObjectProcessErrorAction
		};
	}
}
export interface TransferScenario {
	name: string;
	title: string;
}
export interface TransferSysMenuOptions {
	"export"?: Array<TransferScenario>;
	"import"?: boolean|Array<TransferScenario>|TransferScenario;
}
export class Transfer extends core.lang.Observable {
	/**
	 * Singleton
	 */
	static Instance: Transfer;

	static defaultOptions: Transfer.Options = {
		updateSysMenu: true,
		fetchOpsOnInit: false,
		fetchOpsOnLogin: true
	};

	options: Transfer.Options;
	app: core.Application;
	runningOps: Array<TransferClientBase>;
	runningOpsCount: core.lang.ObservableProperty<number>;
	cmdExport: core.commands.ICommand;
	cmdOpenExport: core.commands.ICommand;
	cmdOpenImport: core.commands.ICommand;
	cmdActivateOp: core.commands.ICommand;
	sysMenuItems: Array<any>;
	private _operationsDefer: Deferred<TransferClientBase[]>;

	constructor(app: core.Application, options?: Transfer.Options) {
		super();

		let that = this;
		that.app = app;
		that.runningOps = [];
		that.runningOpsCount(0);
		that.options = core.lang.appendEx(options || {}, Transfer.defaultOptions, { deep: true });

		that.cmdExport = core.createCommand({
			execute: function (args) {
				that.startExport(args.scenario);
			},
			canExecute: function () {
				return that.runningOps.length === 0;
			}
		});
		that.cmdOpenExport = core.createCommand({
			execute: function (args) {
				that.openExport (args);
			},
			canExecute: function () {
				return that.runningOps.length === 0;
			}
		});
		that.cmdOpenImport = core.createCommand({
			execute: function (args) {
				that.openImport (args);
			},
			canExecute: function () {
				return that.runningOps.length === 0;
			}
		});

		that.cmdActivateOp = core.createCommand({
			execute: function (args) {
				let client = args.client;
				if (client) {
					that._openOpPart(client.type, {client: args.client});
				}
			}
		});
	}

	getRunningOperation (type: string, isInBackground?: boolean): Promise<TransferClientBase> {
		let that = this;

		if (!that._operationsDefer || that._operationsDefer.state() !== "pending") {
			that._operationsDefer = that._loadOperations(isInBackground);
		}

		return that._operationsDefer.then((ops) => {
			that._operationsDefer = undefined;
			if (ops && ops.length) {
				for (let i = 0; i < ops.length; i++) {
					if (ops[i].type === type) {
						return ops[i];
					}
				}
			}
			return null;
		});
	}

	getOperations(isInBackground?: boolean): Promise<TransferClientBase[]> {
		let that = this;

		if (that._operationsDefer && that._operationsDefer.state() === "pending") {
			return that._operationsDefer.promise();
		}
		that._operationsDefer = that._loadOperations(isInBackground);
		return that._operationsDefer.promise();
	}

	startExport (scenario: string): ExportClient {
		let that = this;
		let client = new ExportClient(that.app);
		client.isInBackground(true);
		client.startExport(scenario);

		return client;
	}

	protected _openOpPart(stateName: string, options?): void {
		let that = this;
		let state: core.AreaStateActivateOptions = {
			name: stateName,
			regionState: {
				partOptions: options
			}
		};

		that.app.areaManager.activateState("transfer", state);
	}

	openExport (options?): void {
		this._openOpPart("export", options);
	}

	openImport (options?): void {
		this._openOpPart("import", options);
	}

	protected onOpStarted (client: TransferClientBase): void {
		let that = this,
			count = that.runningOps.push(client); // push returns the new length of the array
		that.runningOpsCount(count);
		if (that.options.updateSysMenu && that.app.sysMenu) {
			let menuItem = that.app.sysMenu.getRootItem("transfer");
			if (menuItem) {
				menuItem.badge(count.toString());
			}
		}
	}

	protected onOpFinished (client: TransferClientBase): void {
		let that = this,
			count: number;
		if (core.lang.arrayRemove(that.runningOps, client)) {
			// operation was removed from running, decrease count
			count = that.runningOps.length;
			that.runningOpsCount(count);
			if (that.options.updateSysMenu && that.app.sysMenu) {
				let menuItem = that.app.sysMenu.getRootItem("transfer");
				if (menuItem) {
					menuItem.badge(count === 0 ? "" : count.toString());
				}
			}
		}
	}

	initialize (): void {
		let that = this,
			app = that.app;

		app.eventPublisher.subscribe("transfer.started", function (ev) {
			let client = ev.args.client;
			that.onOpStarted(client);
		});

		app.eventPublisher.subscribe("transfer.finished", function (ev) {
			let client = ev.args.client;
			that.onOpFinished(client);
		});
		Transfer.Instance = that;

		if (that.options.fetchOpsOnLogin) {
			app.eventPublisher.subscribe("security.login", function (ev) {
				that._operationsDefer = that._loadOperations(true);
			});
		}
		if (that.options.fetchOpsOnInit) {
			that._operationsDefer = that._loadOperations(true);
		}
	}

	protected _loadOperations (isInBackground?: boolean): Deferred<TransferClientBase[]> {
		let that = this,
			defer: JQueryDeferred<TransferClientBase[]> = core.lang.Deferred();

		that.app.dataFacade.ajax({
			url: "api/_transfer/list"
		}, {suppressEventOnError: true}).then(function (result: TransferOperationListResult) {
			if (result.operations && result.operations.length) {
				let tasks = [];
				let operations: Array<TransferClientBase> = [];
				result.operations.forEach((op) => {
					let opId = op.opId,
						type = op.type,
						client;
					if (type === "export") {
						client = new ExportClient(that.app);
					} else if (type === "import") {
						client = new ImportClient(that.app);
					}
					if (client) {
						if (isInBackground !== undefined) {
							client.isInBackground(isInBackground);
						}
						// `connect` will publish an event which will call `onOpStarted`
						let t = client.connect(opId).then(() => {
							operations.push(client);
						});
						tasks.push(t);
					}
				});
				core.lang.whenAll(tasks).then(() => {
					defer.resolve(operations);
				});
			} else {
				defer.resolve();
			}
		}).fail(() => {
			// NOTE: here we're swallow the error
			defer.resolve();
		});
		return defer;
	}

	createSysMenu (options: TransferSysMenuOptions): void {
		var that = this,
			i,
			scenario,
			exportMd = options["export"],
			importMd = options["import"];

		if (!that.app.sysMenu) { return; }
		let items = [];
		if (exportMd) {
			for (i = 0; i < exportMd.length; i++) {
				scenario = exportMd[i];
				items.push({
					name: "export-" + scenario.name,
					title: resources["transfer.export"] + " \"" + scenario.title + "\"",
					icon: "x-icon-upload-2",
					command: that.cmdExport,
					params: { scenario: scenario.name }
				});
			}
		}

		if (importMd) {
			let importScenarios: Array<TransferScenario> = [];
			if (core.lang.isArray(importMd)) {
				importScenarios = <Array<TransferScenario>>importMd;
			} else if (core.lang.isObject(importMd)) {
				importScenarios = [<TransferScenario>importMd];
			}
			if (importScenarios.length) {
				importScenarios.forEach((scenario) => {
					items.push({
						name: "import-" + scenario.name,
						title: resources["transfer.import"] + " \"" + scenario.title + "\"",
						icon: "x-icon-download-2",
						command: that.cmdOpenImport,
						params: { scenario: scenario.name }
					});

				});
			} else {
				items.push({
					name: "Import",
					title: resources["transfer.import"],
					icon: "x-icon-download-2",
					hideIfDisabled: undefined,
					command: that.cmdOpenImport
				});
			}
		}
		that.sysMenuItems = items;

		that.app.sysMenu.addRootItem({
			name: "transfer",
			icon: "x-icon-lightning",
			getMenu: that.getSysMenuItems.bind(that)
		});
	}

	getSysMenuItems () {
		// TODO: add Activate
		let that = this,
			items = this.sysMenuItems || [],
			menu = {items: []};
		Array.prototype.push.apply(menu.items, items);
		that.runningOps.forEach((client) => {
			let item = {
				name: "Activate",
				title: resourcesModule["transfer.cmd.activate." + client.type],
				command: that.cmdActivateOp,
				params: { client: client }
			};
			menu.items.push(item);
		});
		return menu;
	}
}

namespace Transfer {
	export interface Options {
		updateSysMenu?: boolean;
		fetchOpsOnInit?: boolean;
		fetchOpsOnLogin?: boolean;
	}
}

Transfer.prototype.runningOpsCount = core.lang.Observable.accessor("runningOpsCount");

export default Transfer;
