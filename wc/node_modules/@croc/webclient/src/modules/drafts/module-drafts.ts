import core = require("core");
import utils = require("lib/utils");
import DraftManager = require("./DraftManager");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import PopupView = require("lib/ui/PopupView");
import draftsTemplate = require("xhtmpl!./ui/templates/DraftsView.hbs");
import resourcesDrafts = require("i18n!./nls/resources");

import "lib/ui/editor/ObjectEditor";
import "lib/ui/editor/ObjectWizard";
import "lib/ui/editor/ObjectViewer";
import "lib/ui/editor/ObjectFilter";
import {UnloadOptions} from "lib/.core";
import {SaveErrorArgs} from "lib/domain/UnitOfWork";
import lang = core.lang;
import ICommand = core.commands.ICommand;
import {ToJsonOptions} from "lib/domain/.domain";

// extend ObjectEditor.Options
declare module "lib/ui/editor/ObjectEditor" {
	interface Options {
		skipDraftCreation?: boolean;
	}
}

// extend core.UnloadOptions
declare module "lib/.core" {
	interface UnloadOptions {
		skipDraftCreation?: boolean;
	}
}

// extend common resources
const resources = core.nls.merge(resourcesDrafts);

// patch ObjectEditor prototype
const ObjectEditor = core.ui.ObjectEditor;

// Extend ObjectEditor prototype
lang.override(ObjectEditor.prototype, {
	createCommands: function (base) {
		let commands = base.call(this);
		if (this.options.skipDraftCreation) { return commands; }

		commands.DetachDraft = core.createCommand({
			execute: () => {
				this.detachDraft();
			},
			name: "DetachDraft"
		});
		return commands;
	},

	onDisposed: function (base, options: UnloadOptions): void {
		let that = this;

		base.call(that, options);

		if ((!that.editorContext || !that.editorContext.nested) && // it's a root editor
			options.reason !== "close" && // we're being closed from outside (it isn't a call of finish/cancel) - create a draft
			!that.options.skipDraftCreation &&
			(!options.activityContext || !options.activityContext.skipDraftCreation)) {

			let detachOptions = (options.reason === "windowUnload") ? { autoRecovery: true } : {};
			that._detachChanges(detachOptions);
		}
	},

	onQueryUnloadWithChanges: function (base, options: UnloadOptions) {
		if (options.reason === "close" ||
			lang.coalesce(options.skipDraftCreation, this.options.skipDraftCreation) ||
			(this.editorContext.nested && options.reason !== "unload")) {
			if (options.activityContext) {
				options.activityContext.skipDraftCreation = true;
			}

			return base.call(this, options);
		}


		let msg = resources["drafts.editor_query_unload_prompt"];
		let menu = {items: [
			{name: "yes", title: resources["yes"], isDefaultAction: true},
			{name: "no", title: resources["no"] },
			{name: "cancel", title: resources["cancel"]}
		]};
		let dialog = ConfirmDialog.create({ header: resources["editor"], text: msg, menu: menu });
		return dialog.render().then((result) => {
			if (result === "cancel") {
				return resources["closing_canceled"];
			}
			if (result === "no") {
				if (options && options.activityContext) {
					// передадим в корневой редактор, что не надо создавать черновик
					options.activityContext.skipDraftCreation = true;
				}
			}
		});
	},

	createAsyncSaveErrorEvent: function (base, args: SaveErrorArgs): core.SystemEvent {
		let event = base.call(this, args);
		if (this.options.skipDraftCreation) { return event; }

		let menu = {
			items: [
				{
					name: "DetachDraft",
					title: resources["drafts.put_off"],
					icon: "detachDraft",
					command: this.commands.DetachDraft,
					order: -10
				}
			]
		};

		if (core.eth.isUnrecoverableError(event.error)) {
			event.menu.removeItem("SaveLocally");
			event.menu.mergeWith(menu);
		} else if (!event.menu.getItem("SaveLocally")) {
			event.menu.mergeWith(menu);
		}

		return event;
	}
});

lang.extend(ObjectEditor.prototype, /** @lends ObjectEditor.prototype */ {
	/**
	 *
	 * @param {Object} options
	 * @param {String} [options.title] draft's title, if not specified "type:toString()" will be used
	 * @param {String} [options.description] additional description for draft (like "auto-recovery")
	 * @param {Boolean} [options.autoRecovery] flag says "the draft is being created by auto-recovery process"
	 * @param {Object} [options.toJsonOptions] Options for `UnitOfWork.getChanges`
	 * @private
	 */
	_detachChanges: function (options?: DetachDraftOptions) {
		if (!this.viewModel || !this.viewModel.uow) return;
		options = options || {};
		let that = this;

		let title = options.title || (that.viewModel.meta.descr + ": " + that.viewModel.toString()),
			// NOTE: don't call uow.detachChanges() - it will cause rollback and updating bindings
			changes = that.viewModel.uow.getChanges(options.toJsonOptions);

		if (that._hasMeaningfulChanges(changes) && that.app && that.app.eventPublisher) {
			let appState = that._appState || that.app.stateManager.getCurrentState();
			if (appState) {
				appState.isDefaultPart = false;
				appState.regionState = {
					part: that.name,
					partOptions: {
						initialJson: changes,
						type: that.viewModel.meta.name,
						id: that.viewModel.id
					}
				};
				that.app.eventPublisher.publish(DraftManager.Event_CreateDraft, {
					title: title,
					description: options.description,
					autoRecovery: options.autoRecovery,
					appState: appState
				});
			} else {
				that.traceSource.warn("Application.stateManager.getCurrentState returns empty state");
			}
		}
	},

	detachDraft: function (options?: DetachDraftOptions): lang.Promise<void> {
		this._detachChanges(options);
		return this.navigationService.close({success: false});
	}
});

interface DetachDraftOptions {
	title?: string;
	description?: string;
	autoRecovery?: boolean;
	toJsonOptions?: ToJsonOptions;
}
// extend default menus in ObjectEditor-based components
core.ui.ObjectEditor.prototype.defaultMenus.RootEditor.items.push({
	name: "DetachDraft",
	title: resources["drafts.put_off"],
	icon: "detachDraft"
});
core.ui.ObjectWizard.prototype.defaultMenus.Wizard.items.push({
	name: "DetachDraft",
	title: resources["drafts.put_off"],
	icon: "detachDraft"
});

// extend default options in ObjectEditor-based components
core.ui.ObjectEditor.defaultOptions.skipDraftCreation = false;
core.ui.ObjectViewer.defaultOptions.skipDraftCreation = true;
core.ui.ObjectFilter.defaultOptions.skipDraftCreation = true;


class DraftsViewModel extends lang.Observable {
	private _draftManager: DraftManager;
	commands: DraftsViewModel.KnownCommands;
	drafts: any[];

	/**
	 * @constructs DraftsViewModel
	 * @extends Observable
	 * @param {DraftManager} draftManager
	 */
	constructor (draftManager: DraftManager) {
		super();
		if (!draftManager) {
			throw new Error("DraftsViewModel.ctor was called without draftManager param");
		}

		this._draftManager = draftManager;

		this._draftManager.bind("draftsChange", this._initDrafts, this);
		this._initDrafts();

		this.commands = this.createCommands();
	}

	protected _initDrafts (): void {
		let that = this;
		that.drafts = that._draftManager.getDrafts().map((draft) => {
			let item = {
				draft: draft,
				createdFormatted: function () {
					return utils.formatDatetimeAgo(this.draft.created);
				},
				description: undefined
			};
			if (draft.autoRecovery) {
				item.description = "(" + resources["drafts.auto_recovery"] + ")";
			} else if (draft.description) {
				item.description = "(" + draft.description + ")";
			}
			return item;
		});
		that.trigger("change", that);
	}

	/**
	 * Create commands
	 * @protected
	 * @returns {{Restore: (Command), Remove: (Command), RemoveAll: (Command)}}
	 */
	protected createCommands (): DraftsViewModel.KnownCommands {
		var that = this,
			cmdRestore = core.createCommand({
				name: "Restore",
				execute: function (args) {
					that._draftManager.restoreDraft(args.draft);
				}
			}),
			cmdRemove = core.createCommand({
				name: "Remove",
				execute: function (args) {
					that._draftManager.removeDraft(args.draft);
				}
			}),
			cmdRemoveAll = core.createCommand({
				name: "RemoveAll",
				execute: function () {
					that._draftManager.removeAllDrafts();
				}
			});
		return {
			Restore: cmdRestore,
			Remove: cmdRemove,
			RemoveAll: cmdRemoveAll
		};
	}

	dispose (): void {
		this._draftManager.unbind("draftsChange", null, this);
		super.dispose();
	}
}
namespace DraftsViewModel {
	export interface KnownCommands extends lang.Map<ICommand> {
		Restore?: ICommand;
		Remove?: ICommand;
		RemoveAll?: ICommand;
	}
}

//core.drafts.DraftsViewModel = DraftsViewModel;

// augment Application class
declare module "lib/core" {
	export interface Application {
		draftManager?: DraftManager;
	}
}

core.createModule("drafts", function (app: core.Application) {
	return {
		initialize: function (app: core.Application): void {
			this.draftManager = app.draftManager = new DraftManager(app);

			if (app.sysMenu) {
				let menuItem = app.sysMenu.getRootItem("drafts");
				if (!menuItem) {
					let count = app.draftManager.count();
					menuItem = app.sysMenu.addRootItem({
						name: "drafts",
						title: resources["drafts.moduleName"],
						badge: count ? count.toString() : "",
						order: 5,
						getPart: () => {
							let viewModel = new DraftsViewModel(app.draftManager);
							let viewOptions = {
									bodyTemplate: draftsTemplate,
									title: resources["drafts.moduleName"],
									viewModel: viewModel,
									disposeOnClose: true,
									menu: {
										items: [{
											name: "RemoveAll",
											title: resources["delete_all"],
											icon: "remove",
											command: viewModel.commands.RemoveAll
										}]
									}
								};
							return new PopupView(viewOptions);
						}
					});

					// TODO: уведомление об изменении кол-ва черновиков
					this.draftManager.bind("change:count", (sender, count) => {
						if (count > 0) {
							menuItem.badge(count);
						} else {
							menuItem.badge("");
						}
					});
				}
			}

			app.eventPublisher.subscribe("app.start", () => {
				lang.some(app.draftManager.getDrafts(), (draft: DraftManager.Draft) => {
					if (draft.autoRecovery) {
						draft.autoRecovery = false;
						window.setTimeout(() => {
							ConfirmDialog.create({
								header: "Auto recovery",
								text: resources["drafts.restore_autorecovery_prompt"]
							}).render()
								.done((result) => {
									if (result === "yes") {
										app.draftManager.restoreDraft(draft);
									} else {
										draft.autoRecovery = false;
										app.draftManager.updateDraft(draft);
									}
								});
						}, 0);

						return true;	// stop iteration
					}
				});
			});
		}
	};
});

