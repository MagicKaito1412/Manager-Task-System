/** @module "core.lang" */

import $ = require("jquery");
import _ = require("underscore");
import Big = require("big");

// Set defaultFieldProxying depending on whether the browser supports ES5 properties
let supportsES5props: boolean;
if (typeof Object.defineProperty === "function") {
	try {
		let obj: any = {};
		Object.defineProperty(obj, "a", {
			get: function () { return 1; }
		});
		supportsES5props = (obj.a === 1);
	} catch (ex) {
		// supportsES5props = false;
	}
}

function traverseObjectImpl (object: any,
							 visitor: (name: string, value: any, path: string[], object: Object, isObject: boolean) => boolean | void,
							 options: {visitObjects?: boolean, visitValues?: boolean},
							 path?: string[]
): boolean {
	path = path || [];
	return some(object, function (value: any, name: string): boolean {
		let needBreak;
		if (isPlainObject(value)) {
			path.push(name);
			needBreak = traverseObjectImpl(value, visitor, options, path);
			path.pop();
			if (needBreak) {
				return true;
			}
			if (options.visitObjects &&
				visitor(name, value, path, object, /*isObject=*/true)) {
				return true;
			}
		} else if (value === null || value === undefined || isString(value) || isNumber(value) || isBoolean(value)) {
			if (options.visitValues &&
				visitor(name, value, path, object, /*isObject=*/false)) {
				return true;
			}
		}
	});
}

// Common functions
//

export function noop(...args: any[]): void;
export function noop(): void {}

// iterators

export function forEach<T>(obj: T[], iterator: (item: T, index: number) => void, context?);
export function forEach<T>(obj: Map<T>, iterator: (item: T, key: string) => void, context?);
export function forEach(obj: any, iterator: (item: any, key: string) => void, context?);
export function forEach(obj, iterator, context?) {
	if (obj == null) { return; }
	return obj.forEach ? obj.forEach(iterator, context) : _.forEach(obj, iterator, context);
}

export const every = _.every;
export const some = _.some;
export const clone = _.clone;
export const first = _.first;
export const last = _.last;
export const unique = _.unique;

// Firefox has native implementation, but it is experimental
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
export let find = _.find;
// Firefox has native implementation, but it is experimental
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
export function findIndex<T>(obj: T[], predicate: (item: T, index: number) => boolean, context?) {
	let index = -1;
	some(obj, (item, i, list) => {
		if (predicate.call(context, item, i, list)) {
			index = i;
			return true;
		}
	});
	return index;
}

// Objects manipulations

/**
 * Options for extendEx, appendEx and cloneEx methods
 */
type ExtendOptions = {
	/**
	 * Copy recursively.
	 */
	deep?: boolean;
	/**
	 * Copy exactly, i.e. copy props with undefined value.
	 */
	exact?: boolean;
	/**
	 * Props to ignore (do not copy).
	 */
	except?: string[];
};

/**
 * Traverse all object value calling supplied iterator for each value.
 * @param {Object} object A simple object to traverse
 * @param {Function} visitor Iterator with signature: function ({String} name, {*} value, {Array} path)
 * @param {Object} [options]
 * @param {Boolean} [options.visitObjects=false]
 * @param {Boolean} [options.visitValues=true]
 */
export function traverseObject(object: Object,
							   visitor: (name: string, value: any, path: string[], object: Object, isObject: boolean) => boolean | void,
							   options?: {visitObjects?: boolean, visitValues?: boolean}
							   ): boolean {
	options = options || { visitObjects: false, visitValues: true };
	return traverseObjectImpl(object, visitor, options);
}

/**
 * Create a copy of an object or an array
 * @param {Object} obj
 * @param {Object} [options]
 * @param {Boolean} [options.deep] Clone nested values
 * @param {Boolean} [options.exact] Copy undefined values
 * @returns {Object} New object or array
 */
export function cloneEx<T>(obj: T, options: ExtendOptions): T {
	if (!isClonable(obj)) { return obj; }
	return extendEx(isArray(obj) ? [] : {}, obj, options);
}

export function extend<T, U>(obj: T, source: U): T & U;
export function extend<T, U1, U2>(obj: T, source1: U1, source2: U2): T & U1 & U2;
export function extend<T, U1, U2, U3>(obj: T, source1: U1, source2: U2, source3: U3): T & U1 & U2 & U3;
export function extend<T, U>(obj: T, ...sources: U[]): T & U;

/**
 * Extend an object with all values from one or more source
 * @param {Object} obj
 * @param {...Object} sources
 * @returns {Object} obj
 */
export function extend(obj: any, ...sources: any[]): any {
	sources.forEach(source => {
		forEach(source, (v, name) => {
			if (v !== undefined) {
				obj[name] = v;
			}
		});
	});
	return obj;
}

export function extendEx<T, U>(obj: T, source: U, options: ExtendOptions): T & U;
export function extendEx<T, U1, U2>(obj: T, source1: U1, source2: U2, options: ExtendOptions): T & U1 & U2;
export function extendEx<T, U1, U2, U3>(obj: T, source1: U1, source2: U2, source3: U3, options: ExtendOptions): T & U1 & U2 & U3;

/**
 * Extend an object with all values from one or more source
 * @param {Object} obj
 * @param {...Object} sources
 * @param {Object} options
 * @param {Boolean} [options.deep] Process nested values
 * @param {Boolean} [options.exact] Copy undefined values
 * @returns {Object} obj
 */
export function extendEx(obj: any, ...sources: any[]): any {
	let options: ExtendOptions = sources[sources.length - 1] || {}; // last argument is options
	for (let i = 0; i < sources.length - 1; i++) {
		let source = sources[i];
		if (isArray(source) && isArray(obj)) {
			obj.length = 0; // overwrite arrays
		}

		// if the object provides its own clone method then delegate to it
		if (source && source.clone && isFunction(source.clone)) {
			source = source.clone();
			forEach(source, (v, name) => {
				obj[name] = v;
			});
			continue;
		}

		forEach(source, (v, name) => {
			if (v === undefined && !options.exact) { return; }
			if (options.except && options.except.indexOf(name) >= 0) { return; }

			if (!options.deep || !isClonable(v)) {
				obj[name] = v;
			} else {
				// NOTE: merge objects, but overwrite arrays
				let o = isArray(v) ? [] : (obj[name] || {});
				obj[name] = extendEx(o, v, options);
			}
		});
	}
	return obj;
}
/**
 * @deprecated Use extendEx method
 */
export function deepExtend(...args) {
	args.push({ deep: true });
	return extendEx.apply(this, args);
}
/**
 * @deprecated Use extendEx method
 */
export function exactExtend(...args) {
	args.push({ deep: true, exact: true });
	return extendEx.apply(this, args);
}

export function append<T, U>(obj: T, source: U): T & U;
export function append<T, U1, U2>(obj: T, source1: U1, source2: U2): T & U1 & U2;
export function append<T, U1, U2, U3>(obj: T, source1: U1, source2: U2, source3: U3): T & U1 & U2 & U3;
export function append<T, U>(obj: T, ...sources: U[]): T & U;

export function append(obj: any, ...sources: any[]): any {
	sources.forEach(source => {
		forEach(source, (v, name) => {
			if (v !== undefined && obj[name] === undefined) {
				obj[name] = v;
			}
		});
	});
	return obj;
}

export function appendEx<T, U>(obj: T, source: U, options: ExtendOptions): T & U;
export function appendEx<T, U1, U2>(obj: T, source1: U1, source2: U2, options: ExtendOptions): T & U1 & U2;
export function appendEx<T, U1, U2, U3>(obj: T, source1: U1, source2: U2, source3: U3, options: ExtendOptions): T & U1 & U2 & U3;

/**
 * Append values from one or more source to an object
 * @param {Object} obj
 * @param {...Object} sources
 * @param {Object} [options]
 * @param {Boolean} [options.deep] Process nested values
 * @param {Boolean} [options.exact] Append undefined values
 * @returns {Object} obj
 */
export function appendEx(obj: any, ...sources: any[]): any {
	let options: ExtendOptions = sources[sources.length - 1] || {}; // last argument is options
	for (let i = 0; i < sources.length - 1; i++) {
		let source = sources[i];
		if (isArray(source) && isArray(obj)) { continue; } // do not merge arrays

		forEach(source, (v, name) => {
			if (v === undefined && !options.exact) { return; }
			if (options.except && options.except.indexOf(name) >= 0) { return; }

			let o = obj[name];
			if (o === undefined) {
				if (!options.deep || !isClonable(v)) {
					obj[name] = v;
				} else {
					obj[name] = cloneEx(v, options);
				}
			} else if (options.deep && isPlainObject(o)) {
				appendEx(o, v, options);
			}
		});
	}
	return obj;
}
/**
 * @deprecated Use appendEx method
 */
export function deepAppend(...args) {
	args.push({ deep: true });
	return this.appendEx.apply(this, args);
}
/**
 * Assign specified field in obj or a new object.
 * @param {Object} obj
 * @param {String} propName
 * @param {*} propValue
 * @returns {Object} enriched obj or new object with assigned value
 */
export function setValue(obj, propName: string, propValue) {
	obj = obj || {};
	obj[propName] = propValue;
	return obj;
}
/**
 * Overrides some methods of the object.
 * @param {Object} obj
 * @param {Object} overrides
 * @returns {Object} obj
 * @example
 * var obj = {
 *     sayHello: function (name) { console.log("Hello, " + name + "!"); }
 * };
 * lang.override(obj, {
 *     sayHello: function (base, name) {
 *         // first argument is the original method
 *         // others are the arguments passed to the function by a caller
 *         base.call(this, "dear " + name);
 *     }
 * });
 * obj.sayHello("user"); // prints "Hello, dear user!"
 */
export function override(obj, overrides: Map<Function>) {
	forEach(overrides, function (wrapper, name) {
		let base = obj[name];
		obj[name] = function () {
			let args = [ base ];
			args.push.apply(args, arguments);
			return wrapper.apply(this, args);
		};
	});
	return obj;
}

export const difference = _.difference;
export const groupBy = _.groupBy;

export function select<T, U>(obj: T[]|T, iterator: (item: T, index?: number) => U, context?): U[]|T;
export function select<T, U>(obj: T[], iterator: (item: T, index?: number) => U, context?): U[];
export function select<T, U>(obj: T, iterator: (item: T, index?: number) => U, context?): U;
/**
 * Return the results of applying the iterator to the object or each item of array.
 * @param {Array|Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
export function select<T, U>(obj: T[]|T, iterator: (item: T, index?: number) => U, context?): U[]|U {
	return isArray(obj) ? obj.map(iterator, context) : iterator.call(context, obj);
}

// String
/**
 * Checks whether value in 'source' argument starts with value in 'search' argument.
 * @param {String} source Source string to search in
 * @param {String} search Substring to search for
 * @return {Boolean} true if source's value starts with search value.
 */
export function stringStartsWith(source: string, search: string): boolean {
	if (!source || !search) return false;
	return source.slice(0, search.length) === search;
}

export function stringEndsWith(source: string, search: string): boolean {
	if (!source || !search) return false;
	return source.slice(-search.length) === search;
}

export function encodeHtml(str: string, whitespaces?: boolean): string {
	if (str == null) { return ""; }
	// str = _.escape(str);
	str = str.toString()
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#x27;");
	if (whitespaces) {
		str = str.replace(/ /g, "&nbsp;").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
	}
	return str;
}

export function decodeHtml(str: string): string {
	if (str == null) { return ""; }
	// return _.unescape(str);
	return str.toString()
		.replace(/&gt;/g, ">")
		.replace(/&lt;/g, "<")
		.replace(/&amp;/g, "&")
		.replace(/&quot;/g, '"')
		.replace(/&#x27;/g, "'")
		.replace(/&nbsp;/g, " ");
}

/**
 * Extracts text from html
 * @param html
 * @returns {any}
 */
export function htmlText(html: string): string {
	if (!html) { return ""; }
	let text = html.replace(/<(?:.|\n)*?>/gm, "");
	return decodeHtml(text);
}

export function stringFormat(format: string, ...args): string {
	return format.replace(/\{\{|\}\}|\{(\d+)\}/g, function (curlyBrack, index) {
		return ((curlyBrack === "{{") ? "{" : ((curlyBrack === "}}") ? "}" : args[index]));
	});
}

// Arrays and Collections

/**
 * Returns an array of its arguments.
 * Unlike Array#concat this method appends array items whole.
 * Use this method via apply to make an array from arguments object for better performance:
 * @example
 * function foo() {
 *     var args = lang.concat.apply(null, arguments);
 * }
 * @param {...*} args
 * @returns {Array}
 */
export function concat(...args: any[]): any[] {
	return args;
}

export function concatExceptLast(...args: any[]): any[];
/**
 * Returns an array of its arguments except the last one.
 * Unlike Array#concat this method appends array items whole.
 * Use this method via apply to make an array from arguments object for better performance:
 * @example
 * function foo() {
 *     var args = lang.concatExceptLast.apply(null, arguments);
 * }
 * @param {...*} args
 * @returns {Array}
 */
export function concatExceptLast(): any[] {
	let l: number = arguments.length - 1,
		i: number,
		args = [];
	for (i = 0; i < l; i++) {
		args[i] = arguments[i];
	}
	return args;
}

export function array<T>(value: T[]|T): T[] {
	return isArray(value) ? value : [ value ];
}

export function arrayRemove<T>(array: T[], item: T): boolean {
	let idx = array.indexOf(item); // Find the index
	if (idx !== -1) {
		array.splice(idx, 1);
		return true;
	}
	return false;
}
/**
 * @deprecated Use 'find' method instead
 * @param array
 * @param finder
 * @returns {*}
 */
export function arrayFindFirst<T>(array: T[], finder: (item: T, index?: number) => boolean): T {
	let i, length = array.length, item;
	for (i = 0; i < length; i += 1) {
		item = array[i];
		if (finder(item)) {
			return item;
		}
	}
}
/**
 * @deprecated Use 'last' method instead
 * @param stack
 * @returns {*}
 */
export function stackTop<T>(stack: T[]): T {
	return stack && stack.length ? stack[stack.length - 1] : undefined;
}

/**
 * Returns the first non-undefined value among arguments.
 * @param {...*} args
 */
export function coalesce<T>(...args: T[]): T {
	return find(args, function (v) {
		return v !== undefined;
	});
}

// Functions
export const uuid = _.uniqueId;

export function debounce(func: Function|string, wait?: number, field?: string|boolean);
/**
 * Returns a function, that, as long as it continues to be invoked, will not be triggered.
 * The function will be called after it stops being called for N milliseconds.
 * @param {Function|String} func - The original function or the name of original method
 * @param {Number} wait - Timeout in milliseconds
 * @param {String|Boolean} field - If specified the result function will behave like a method of a caller
 * and will be called after it stops being called by the same caller for N milliseconds. In that case
 * a timer will be stored in the field of a caller. If 'field' is a string it specifies* the name of the field
 * to keep a timer; otherwise the name will be generated automatically.
 * If 'field' argument isn't specified the result function will be 'static' and will be called after it stops
 * being called by any caller for N milliseconds.
 * @returns {Function}
 */
export function debounce(func, wait?, field?) {
	var timeout;
	if (!field) {
		return function() {
			let that = this, args = arguments;
			const throttler = function() {
				timeout = null;
				let method = isFunction(func) ? func : that[func];
				method.apply(that, args);
			};
			window.clearTimeout(timeout);
			timeout = window.setTimeout(throttler, wait);
		};
	} else {
		if (!isString(field)) {
			field =  "_timeout_" + (isString(func) ? func : uuid("debounced"));
		}
		return function() {
			let that = this, args = arguments;
			let throttler = function() {
				that[field] = null;
				let method = isFunction(func) ? func : that[func];
				method.apply(that, args);
			};
			window.clearTimeout(that[field]);
			that[field] = window.setTimeout(throttler, wait);
		};
	}
}

// Type checking
export const isArray: (a: any) => a is Array<any> = Array.isArray;
export const isObject: (a: any) => a is Object = <any>_.isObject;
export const isFunction: (a: any) => a is Function = <any>_.isFunction;
export const isString: (a: any) => a is string = <any>_.isString;
export const isNumber: (a: any) => a is number = <any>_.isNumber;
export const isBoolean: (a: any) => a is boolean = <any>_.isBoolean;
export const isDate: (a: any) => a is Date = <any>_.isDate;
export const isRegExp: (a: any) => a is RegExp = <any>_.isRegExp;
export const isEmpty = _.isEmpty;
export const isEmptyObject = $.isEmptyObject;
export function isNullOrEmpty(v): boolean {
	return v == null || v === "";
}
export function isInteger(v): boolean {
	return this.isNumber(v) && (v % 1 == 0);
}
export function isPlainObject(obj): boolean {
	// NOTE: IE8 (and earlier) don't have native Object.getPrototypeOf method,
	// but the 'es5-sham' provides good implementation of it
	return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;
}
export function isClonable(obj): boolean {
	return isPlainObject(obj) || isArray(obj);
}
export function isDisposable(obj: any): obj is IDisposable {
	return obj && isFunction(obj.dispose);
}

export function isError(obj: any): obj is Error {
	if (!isObject(obj)) {
		return false;
	}
	let tag = Object.prototype.toString.call(obj);
	return tag === "[object Error]" || tag === "[object DOMException]" ||
		(typeof obj.message === "string" && typeof obj.name === "string" && !isPlainObject(obj));
}

// Perform a deep comparison to check if two objects are equal.
export const isEqual = _.isEqual;
/**
 * Compare two values for sorting. You can pass this method as an argument of Array.prototype.sort().
 * @param x
 * @param y
 * @returns {number}
 */
export function compare(x, y): number {
	if (x === y) { return 0; }

	// null and undefined are always less than any other value
	if (x === undefined) { return -1; }
	if (y === undefined) { return 1; }
	if (x === null) { return -1; }
	if (y === null) { return 1; }
	if (x instanceof Big || y instanceof Big) {
		x = x instanceof Big ? x : new Big(x);
		y = y instanceof Big ? y : new Big(y);
		return x.cmp(y);
	}

	// compare different types as strings
	if (typeof x !== typeof y) {
		x = x.toString();
		y = y.toString();
	}

	if (x < y) { return -1; }
	if (y < x) { return 1; }
	return 0;
}

/**
 * Sorts an array's element. Unlike Array.prototype.sort(), doesn't modify an original array.
 * Uses stable sorting (unlike Array.prototype.sort()).
 * @param {Array} array an array to sort
 * @param {Function} [comparer] comparison function a-la Array.prototype.sort()
 * @returns {Array} new array
 */
export function sort<T>(array: T[], comparer?: (x: T, y: T) => number): T[] {
	comparer = comparer || compare;
	return array.map((value, index) => {
		return { value: value, index: index };
	}).sort((x, y) => {
		// NOTE: 0 mean x and y are equal, if so order will be determined by their indexes
		return comparer(x.value, y.value) || (x.index - y.index);
	}).map((item) => {
		return item.value;
	});
}
/**
 * Sorts an array's element by a criterion produced by an iterator.
 * Uses stable sorting.
 * @param {Array} array an array to sort
 * @param {Function} iterator function that returns the value to compare
 * @param {*} [context] 'this' argument for calling iterator
 * @returns {Array} new array
 */
export const sortBy = _.sortBy;

// Conversions
// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer
export function toInteger(n): number {
	n = +n;
	if (n !== n) { // isNaN
		n = 0;
	} else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
		n = (n > 0 ? 1 : -1) * Math.floor(Math.abs(n));
	}
	return n;
}

// Deferred
//

export const Deferred = $.Deferred;
export const deferred = $.Deferred;

export interface Promise<T> extends JQueryPromise<T> {}
export interface Deferred<T> extends JQueryDeferred<T> {}

export type Promisable<T> = T | Promise<T>;

/**
 * jQuery Promise
 * @typedef {Deferred|jQuery.Deferred} Promise
 * @global
 */
/**
 * jQuery Promise
 * @typedef {Deferred|jQuery.Deferred} jQuery.Promise
 * @global
 */

export const when = $.when;
export function whenAll(...args: Promise<void>[]): Promise<void>;
export function whenAll(...args: Promise<any>[]): Promise<any>;
export function whenAll(tasks: Promise<void>[]): Promise<void>;
export function whenAll(tasks: Promise<any>[]): Promise<any>;
export function whenAll(): Promise<void>;
export function whenAll(): Promise<any> {
	// NOTE: roll out arrays in arguments
	return $.when.apply($, Array.prototype.concat.apply([], arguments));
}

export function resolved<T>(v: T, ...args: any[]): Promise<T>;
export function resolved(): Promise<void>;
export function resolved(): Promise<any> {
	let d = deferred();
	d.resolve.apply(d, arguments);
	return d.promise();
}

export function rejected(...args: any[]): Promise<any>;
export function rejected<T>(...args: any[]): Promise<T>;
export function rejected(): Promise<any> {
	let d = deferred();
	d.reject.apply(d, arguments);
	return d.promise();
}

export function isPromise(obj: any): obj is Promise<any> {
	return obj && obj.done && obj.then && obj.fail && obj.promise;
}
/**
 * If the Deferred is already resolved, this method returns the value passed as the first argument of
 * Deferred.resolve(). Otherwise it returns undefined.
 * @param deferred
 * @return {*}
 */
export function resolvedValue(deferred: Promise<any>) {
	if (!isPromise(deferred)) { return deferred; }
	let v;
	if (deferred.state() === "resolved") {
		deferred.done((r) => { v = r; });
	}
	return v;
}

export function parseJsonString(str: string) {
	if (!str || typeof str !== "string") { return null;	}

	str = str.trim();
	if (!str) { return null; }

	let normalized = str;
	// replace 'text' => "text" (NOTE: JSON specification supports only double quotes)
	normalized = normalized.replace(/'([^']*)'\s*:/g, "\"$1\":");
	// wrap key names into double quotes
	normalized = normalized.replace(/([^"{\s,:]+)\s*:/g, '"$1":');
	// replace 'text' => "text" (NOTE: JSON specification supports only double quotes)
	normalized = normalized.replace(/:\s*'([^']*)'/g, ": \"$1\"");
	// wrap into {}: "prop": "value" => {"prop": "value"}
	normalized = normalized.replace(/^([^{][^:]*:.*[^}])$/g, "{$1}");
	return normalized ? JSON.parse(normalized) : {};
}

export function observe(obj) {
	if (Observable.isObservable(obj)) {
		return obj;
	}

	if (isArray(obj)) {
		return new ObservableCollection(obj);
	}

	if (isObject(obj)) {
		let observable = new Observable();
		forEach(obj, (value, key) => {
			if (!isFunction(value)) {
				observable.declareProp(key, value);
			} else {
				observable[key] = value;
			}
		});
		return observable;
	}

	return obj;
}

/**
 * Возвращает значение свойства name у объекта obj. Если у объекта obj есть метод с именем name,
 * то вернется результат вызова этого метода; иначе вернется поле с именем name.
 * @param obj
 * @param name
 * @return {*}
 */
export function get(obj, name: string) {
	let v = obj[name];
	return typeof v === "function" ? v.call(obj) : v;
}
export function set(obj, name: string, value): void {
	let v = obj[name];
	if (typeof v === "function") {
		v.call(obj, value);
	} else {
		obj[name] = value;
	}
}

/**
 * Возвращает функцию доступа к свойству с наименованием name. Если у объекта this есть метод с именем name,
 * то будет использоваться этот метод; иначе будет использоваться поле с именем name.
 * @param name
 * @return {Function}
 */
export function property(name: string): Function {
	return function () {
		let v = this[name];
		if (typeof v === "function") {
			return v.apply(this, arguments);
		} else if (arguments.length) {
			this[name] = arguments[0];
		} else {
			return v;
		}
	};
}

/**
 * Получает вложенное значение по пути от корневого объекта/пространства имен.
 * @param root {Object}
 * @param path {String}
 */
export function nested(root, path: string) {
	forEach(path.split("."), function (propName) {
		root = root[propName];
	});
	return root;
}

export type Lazy<T> = T | Factory<T>;

export function unlazy<T>(v: Lazy<T>): T;
export function unlazy<T>(v: Lazy<T>, ...factoryArgs): T;
export function unlazy<T>(v: Lazy<T>): T {
	if (!isFunction(v)) {
		return v;
	} else if (arguments.length === 1) {
		return v();
	} else {
		let factoryArgs = [];
		for (let i = 1; i < arguments.length; i++) {
			factoryArgs[i - 1] = arguments[i];
		}
		return v.apply(undefined, factoryArgs);
	}
}

// NOTE: такая реализация выглядит красиво, но генерит далеко не оптимальный JS
//export function unlazy<T>(v: Lazy<T>, ...factoryArgs): T {
//	return isFunction(v) ? v(...factoryArgs) : v;
//}

/**
 * The mode of overriding conflicting names:
 *  "always" - always override existent members (the mixin has higher priority), used by default
 *  "never" - never override existent members (the current class has higher priority)
 *  "inherited" - override inherited members declared in the ancestor classes only, but keep own members declared directly in the current class
 */
export type OverrideMemberMode = "always" | "never" | "inherited";

function __prototypeOf(obj: Function|Object): Object {
	return obj && isFunction(obj) ? obj.prototype : obj;
}

function __mixin(obj: any, extension: any, override: OverrideMemberMode): void {
	// NOTE: Don't use for-in operator (or lang.extend, _.append etc. based on for-in)
	// because of "DontEnum" bug in IE<9. Object.keys implementation in es5-shim.js has a workaround
	// for this bug, so we should use Object.keys method.
	Object.keys(extension).forEach(prop => {
		let ignore =
			override === "never" ? prop in obj :
			override === "inherited" ? obj.hasOwnProperty(prop) :
			false;
		if (!ignore) {
			obj[prop] = extension[prop];
		}
	});
}

/**
 * Базовый класс для обеспечения обратной совместимости с lang.Class
 */
export class CoreClass {
	// Такая декларация правильней, но не работает для абстрактных миксинов:
	// Cannot assign an abstract constructor type to a non-abstract constructor type.
	// static mixin<T>(extension: T|Constructor<T>) {

	/**
	 * Добавляет члены в текущий класс
	 */
	static mixin(extension: Function|Object, override?: OverrideMemberMode) {
		__mixin(this.prototype, __prototypeOf(extension), override);
		return this;
	}
	/**
	 * Создает наследника от класса
	 */
	static extend(body) {
		return Class(this, body);
	}
	/**
	 * Добавляет статические методы к классу
	 */
	static shared(body) {
		__mixin(this, body, "always");
		return this;
	}

	static create<T extends CoreClass>(this: { new (): T }): T;
	//static create<T extends CoreClass, TArg>(this: { new (_arg: TArg): T }, arg: TArg): T;
	//static create<T extends CoreClass, TArg1, TArg2>(this: { new (_arg1: TArg1, _arg2: TArg2): T }, arg1: TArg1, arg2: TArg2): T;
	//static create<T extends CoreClass, TArg1, TArg2, TArg3>(this: { new (_arg1: TArg1, _arg2: TArg2, _arg3: TArg3): T }, arg1: TArg1, arg2: TArg2, arg3: TArg3): T;
	static create<T extends CoreClass, TArg, TArgEx extends TArg>(this: { new (_arg: TArg): T }, arg: TArgEx): T;
	static create<T extends CoreClass, TArg1, TArg2, TArgEx1 extends TArg1, TArgEx2 extends TArg2>(
		this: { new (_arg1: TArg1, _arg2: TArg2): T }, arg1: TArgEx1, arg2: TArgEx2): T;
	static create<T extends CoreClass, TArg1, TArg2, TArg3, TArgEx1 extends TArg1, TArgEx2 extends TArg2, TArgEx3 extends TArg3>(
		this: { new (_arg1: TArg1, _arg2: TArg2, _arg3: TArg3): T }, arg1: TArgEx1, arg2: TArgEx2, arg3: TArgEx3): T;
	/**
	 * Создает экземпляр класса
	 */
	static create<T extends CoreClass>(this: { new (): T }): T {
		// !ugly hack! for more information see:
		// http://www.bennadel.com/blog/2291-Invoking-A-Native-JavaScript-Constructor-Using-Call-Or-Apply-.htm
		let ctor = this,
			obj = Object.create(ctor.prototype);
		return ctor.apply(obj, arguments) || obj;
	}

	// NOTE: Более изящная реализация, но не работает для ES3
	// Error TS2472: Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.
	// static create<T extends CoreClass>(this: { new (...args: any[]): T }, ...args: any[]): T {
	// 	return new this(...args);
	// }
}

export interface ClassFactory {
	(body): any;
	(parent, body): any;
	(parent, mixin, body): any;
	(parent, mixin1, mixin2, body): any;
	(parent, ...mixins): any;

	create(rootNamespace, fullClassName: string, ...ctorArgs): any;

	rootNamespace : Object;
}

/**
 * @type Function
 */
export const Class: ClassFactory = <any> function() {
	let
		// базовый тип
		parent = arguments.length > 1 ? arguments[0] : null,
		// объект, описывающий свойства класса
		body = arguments[arguments.length - 1] || {},
		ctor = body.constructor;

	if (ctor === Object) {
		ctor = body.constructor = function () { };
	}

	if (!parent) {
		// если базовый класс не задан, то прототипом будет сам объект, описывающий свойства класса
		ctor.prototype = body;
	} else {
		// если задан базовый класс, то создадим наследника прототипа...
		ctor.prototype = Object.create(__prototypeOf(parent));
		// ... и скопируем туда все свойства
		__mixin(ctor.prototype, body, "always");
		// добавляем статическое свойство Super для доступа к базовому классу
		ctor.Super = parent;
		// добавляем статические члены из базового класса
		__mixin(ctor, parent, "never");
	}

	// добавляем члены других классов
	if (arguments.length > 2) {
		for (let i = 1; i < arguments.length - 1; i++) {
			__mixin(ctor.prototype, __prototypeOf(arguments[i]), "never");
		}
	}

	// добавляем статические методы
	__mixin(ctor, CoreClass, "never");

	return ctor;
};

/**
 * Creates an instance of the class by name.
 * @param {Object} [rootNamespace=lang.Class.rootNamespace] A 'namespace' object.
 * If null lang.Class.rootNamespace will be used by default.
 * @param {String} fullClassName
 * @param {...*} args arguments for constructor
 * @returns {*}
 */
Class.create = function (rootNamespace, fullClassName: string, ...args) {
	if (arguments.length < 2) {
		throw new Error("lang.Class.create: expects at least two parameters: root namespace and class name");
	}

	let target = nested(rootNamespace || Class.rootNamespace, fullClassName);
	if (!target) {
		throw new Error("lang.Class.create: cannot find class '" + fullClassName + "'");
	}
	if (!target.create) {
		throw new Error("lang.Class.create: found " + fullClassName + " but it doesn't look like a Class")
	}
	return target.create.apply(target, args);
};


// Common interfaces
//

export interface IDisposable {
	dispose(): void;
}

export interface IEventful {
	bind(eventName: string, callback: Function, context?: any): this;
	unbind(eventName?: string, callback?: Function, context?: any): this;
	subscribe(eventName: string, callback: Function, context?: any): IDisposable;
	trigger(eventName: string, ...args): this;
}

export interface ILoadable<T> {
	isLoaded: boolean;
	load(options?): Promise<T>;
}

export interface LoadArgs<T> {
	loaded: T;
}

export interface ICollection<T> {
	all(): T[];
	count(): number;
	get(i: number): T;
	indexOf(item: T): number;
	add(item: T|T[]): void;
	remove(item: T|T[]): void;
	clear(): void;
	reset(items: T|T[]): void;
	move(indexFrom: number, indexTo: number): void;
	forEach(iterator: (item: T, index: number, array: T[]) => void, context?: any): void;
	find(predicate: (item: T, index: number) => boolean, context?: any): T;
	toggle?(item: T): void; // seems unused
}

export interface IObservableCollection<T> extends ICollection<T>, IEventful {
}

export interface Constructor<T> {
	new (...args): T;
}

export interface Factory<T> {
	(...args): T;
}

export interface Map<T> {
	[key: string]: T;
}

export interface ObservableGetter<T> {
	(): T;
}
export interface ObservableSetter<T> {
	(v: T): void;
}
export interface ObservableProperty<T> extends ObservableSetter<T>, ObservableGetter<T> {
}
// Commented code isn't compiled. See https://github.com/Microsoft/TypeScript/issues/209
//export interface ObservableProperty extends ObservableProperty<any> {
//}

export interface ObservablePropertyArgs {
	prop?: string;
	value?: any;
}

export interface ObservableGetArgs extends ObservablePropertyArgs {
}

export interface ObservableSetArgs extends ObservablePropertyArgs {
	oldValue?: any;
}

export interface ObservableChangeArgs extends ObservableSetArgs {
	reason?: ObservableNotifyReason;
}

export type ObservableNotifyReason = "change" | "load" | "set" | "autoLoad" | "loadError";

export interface ObservableCollectionChangeArgs<T> extends ObservableChangeArgs {
	added?: T[];
	removed?: T[];
	addedIndices?: number[];
	//removedIndices?: number[];
}

export interface ObservableCollectionItemChangeArgs<T> {
	changed?: T[];
}

// Common classes
//

// Concurrency
export class CountdownEvent extends CoreClass {
	private left: number;
	private onComplete: () => void;

	/**
	 * @constructs CountdownEvent
	 * @param left
	 * @param onComplete
	 */
	constructor(left: number, onComplete: () => void) {
		super();
		this.left = left;
		this.onComplete = onComplete;
	}

	signal() {
		var that = this;
		if (that.left === 0) {
			throw new Error("CountdownEvent.signal: countdown object has been already signaled");
		}
		that.left -= 1;
		if (that.left === 0 && that.onComplete) {
			that.onComplete();
		}
	}

	dispose(): void {
		this.left = -1;
		this.onComplete = undefined;
	}
}

/**
 * Don't copy this method to lang.Observable.prototype, or lang.proxy will break.
 * @static
 * @param {Observable} obj
 * @param {String} name
 * @param {*} v
 * @param field
 * @return {Boolean} true if current value was changed (that also means that "change" events were fired)
 */
function __set(obj: Observable, name: string, v: any, field: string): ObservableChangeArgs {
	let old = obj[field],
		args: ObservableChangeArgs = { prop: name, value: v, oldValue: old, reason: "change" },
		changed = !isEqual(v, old);
	if (changed) {
		obj[field] = v;
		obj.trigger("change:" + name, obj, v, old);
		obj.trigger("change", obj, args);
	}
	obj.trigger("set", obj, args);
	return changed ? args : undefined;
}

/**
 * Don't copy this method to lang.Observable.prototype, or lang.proxy will break.
 * @static
 * @param {Observable} obj
 * @param {String} name
 * @param {*} v
 * @returns {*} Value of v
 */
function __get(obj: Observable, name: string, v: any) {
	obj.trigger("get", obj, { prop: name, value: v });
	return v;
}

export class Observable extends CoreClass implements IEventful, IDisposable {
	private _callbacks: Map<{ callback: Function; ctx: any; }[]>;

	/**
	 * Объект, от которого наследуют компоненты для поддержки событий
	 * @constructs Observable
	 */
	constructor() {
		super();
		this._callbacks = {};
		let observables = this["__observableProps"];
		if (observables) {
			forEach(observables, (init, field) => {
				this[field] = init;
			});
		}
	}

	/**
	 * Подписывает обработчик callback на событие eventName. Если задан параметр context, то обработчик
	 * будет вызван в контексте этого объекта (т.е. context будет выступать в качестве this). Если context
	 * не задан, то обрабочик будет вызываться в контексте текущего observable-объекта.
	 * @param {String} eventName
	 * @param {Function} callback
	 * @param {Object} [context]
	 * @return {*}
	 */
	bind(eventName: string, callback: Function, context?: any): this {
		let calls = this._callbacks || (this._callbacks = {}),
			list = calls[eventName] || (calls[eventName] = []);
		list.push({ callback: callback, ctx: context });
		return this;
	}

	/**
	 * Отписывает обработчик callback от события eventName. Обработчик отписывается, только если он был подписан
	 * с тем же значением параметра context.
	 * Если задано только eventName, то от события eventName отписываются все подписанные обработчики.
	 * Если не заданы eventName, callback и context, то все подписанные обработчики отписываются от всех событий.
	 * Если заданы eventName и context, то от события eventName отписываются все обработчики контекста.
	 * Если задан только context, то отписываются все обработчики контекста от всех событий.
	 * @param {String} [eventName]
	 * @param {Function} [callback]
	 * @param {Object} [context]
	 * @return {*}
	 */
	unbind(eventName?: string, callback?: Function, context?: any): this {
		let that = this, calls, list, i, l, item;
		if (!eventName && !callback && !context) {
			this._callbacks = {};
		} else if (calls = this._callbacks) {
			if (!callback && !context) {
				delete calls[eventName];
			} else if (!eventName) {
				// unbind callback/context from all events
				forEach(Object.keys(calls), function (eventName) {
					that.unbind(eventName, callback, context);
				});
			} else if (list = calls[eventName]) {
				for (i = 0, l = list.length; i < l; i++) {
					item = list[i];
					if (item.ctx === context &&
						(callback && item.callback === callback || !callback)) {
						if (--l) {
							list.splice(i, 1);
							i--;
						} else {
							delete calls[eventName];
						}
						if (callback)
							break;
					}
				}
			}
		}
		return this;
	}

	/**
	 * Подписывает обработчик callback на событие eventName и возвращает disposable объект, который
	 * отписывает этот обработчик в методе dispose.
	 * Метод аналогичен методу bind, но возвращает disposable объект, который выполняет unbind.
	 * @param {String} eventName
	 * @param {Function} callback
	 * @param {Object} [context]
	 * @return {Object} Disposable объект, в методе dispose которого выполняется отписка
	 * обработчика (unbind).
	 */
	subscribe(eventName: string, callback: Function, context?): IDisposable {
		let that = this;
		that.bind(eventName, callback, context);
		return {
			dispose: () => {
				that.unbind(eventName, callback, context);
			}
		};
	}

	trigger(eventName: string, ...args): this;
	/**
	 * Возбуждает событие eventName, вызывая все подписанные на него обработчики.
	 * Все аргументы метода, кроме первого (eventName), передаются в обработчики.
	 * @param {String} eventName
	 * @param {...Object} args
	 * @return {*}
	 */
	trigger(eventName: string, ...args): this {
		let calls, list, i, l, item;
		if (calls = this._callbacks) {
			if (list = calls[eventName]) {
				// NOTE: Вызываемые обработчики могут подписать или отписать что-нибудь, при этом список list
				// изменится. Чтобы избежать конфликтов, клонируем список.
				list = list.slice();
				for (i = 0, l = list.length; i < l; i++) {
					item = list[i];
					item.callback.apply(item.ctx || this, args);
				}
			}
		}
		return this;
	}

	/**
	 * Проверяет, что на событие eventName подписан хотя бы один обработчик.
	 * Если имя события не задано, то проверяет, что хотя бы один обработчик подписан на любое событие.
	 * @param {String} eventName
	 * @return {Boolean}
	 */
	bound(eventName?: string): boolean {
		let calls = this._callbacks;
		if (calls) {
			return eventName ? !!calls[eventName] : !isEmptyObject(calls);
		}
		return false;
	}

	get(name: string): any {
		let that = this,
			v = that[name];
		if (typeof v === "function") {
			return v.call(that);
		}
		return __get(that, name, v);
	}

	/**
	 * Getter for implementing ObservableProperty manually.
	 * Should be called `this._get(this, "name_of_prop");`
	 * @param {Observable} that Current object
	 * @param {String} name Name of property
	 * @param {String} [field] Optional field name (if not specifed than "_$name" will be used
	 * @returns {*}
	 * @protected
	 */
	protected static _get(that: Observable, name: string, field?: string) {
		// NOTE: DO NOT USE `this` inside!
		let v = that[field || ("_" + name)];
		return __get(that, name, v);
	}

	set(name: string, v: any): void {
		let that = this,
			old = that[name];
		if (typeof old === "function") {
			return old.call(that, v);
		}
		__set(that, name, v, name);
	}

	/**
	 * Setter for implementing ObservableProperty manually.
	 * Should be called `this._set(this, "name_of_prop", v);`
	 * @param {Observable} that Current object
	 * @param {String} name Name of property
	 * @param v Prop value to be set
	 * @param {String} [field] Optional field name (if not specifed than "_$name" will be used
	 * @protected
	 */
	protected static _set(that: Observable, name: string, v, field?: string): ObservableChangeArgs {
		// NOTE: DO NOT USE `this` inside!
		return __set(that, name, v, field || ("_" + name));
	}

	/**
	 * Trigger 'change' and 'change:prop' events to notify that the property was previously changed
	 * @param {String} name the name of the changed property
	 */
	changed(name: string): void {
		let that = this,
			v = that[name];
		if (typeof v === "function") {
			v = v.call(that);
		}
		that.trigger("change:" + name, that, v, v);
		that.trigger("change", that, { prop: name, value: v, oldValue: v, reason: "change" });
	}
	dispose(): void {
		this.unbind();
	}
	declareProp(name: string, initial): void {
		let field = "_" + name;
		this[field] = initial;
		this[name] = Observable.accessor(name, field);
	}

	static isObservable(obj): obj is Observable {
		return obj && obj.bind && obj.unbind && obj.trigger;
	}

	/**
	 * Get a value of `name` property whatever it is field, function-property or ObserableProperty.
	 * If `name` is field/ObserableProperty when fires "get" Observable's event.
	 * @param {*} obj Any object with `name` field
	 * @param {String} name Name of property to get
	 * @returns {*}
	 */
	static get(obj, name: string) {
		let v = obj[name];
		if (typeof v === "function") {
			return v.call(obj);
		}
		if (Observable.isObservable(obj)) {
			return __get(obj, name, v);
		}
		return v;
	}
	/**
	 *
	 * @param {String} name Name of the property
	 * @param {String} [field] Name of the field created for property (by default _name)
	 * @returns {ObservableProperty}
	 */
	static accessor(name: string, field?: string): ObservableProperty<any>;
	static accessor<T>(name: string, field?: string): ObservableProperty<T>;
	static accessor(name: string, field?: string) {
		field = field || "_" + name;

		return function (v?) {
			let that: Observable = this;
			if (arguments.length) {
				return __set(that, name, v, field);
			} else {
				return __get(that, name, that[field]);
			}
		};
	}

	static getter(name: string, field?: string): ObservableGetter<any>;
	static getter<T>(name: string, field?: string): ObservableGetter<T>;
	static getter(name: string, field?: string) {
		field = field || "_" + name;
		return function (): any {
			let that: Observable = this,
				v = that[field];
			return __get(that, name, v);
		};
	}

	static setter(name: string, field?: string): ObservableSetter<any>;
	static setter<T>(name: string, field?: string): ObservableSetter<T>;
	static setter(name: string, field?: string) {
		field = field || "_" + name;
		return function (v: any): void {
			if (arguments.length) {
				__set(this, name, v, field);
			}
		};
	}

	/**
	 * Create a new instance of {Observable} and
	 * add observable properties for every field in supplied json-object into the new object.
	 * @param {Object} json key-value map for declaring and initializing the new object
	 * @returns {Observable}
	 */
	static construct(json): Observable {
		return observe(json);
	}
}
export namespace Observable { }

// HACK: make Observable's static method non-enumerable to prevent copying for derived class (TS __extend helper does this)
if (supportsES5props) {
	for (let method of ["isObservable", "get", "accessor", "getter", "setter", "construct"]) {
		Object.defineProperty(Observable, method , { enumerable: false});
	}
}

export class ObservableCollection<T> extends Observable implements IObservableCollection<T> {
	private _items: T[];

	/**
	 * @constructs ObservableCollection
	 * @extends Observable
	 * @param {Array} items
	 */
	constructor(items?: T[]) {
		if (items && !isArray(items)) {
			throw new Error("Argument of ObservableCollection constructor should be an array");
		}

		super();

		let that = this;
		if (!items) {
			that._items = [];
		} else {
			that._items = items;
			items.forEach(that._initItem, that);
		}
	}

	dispose(): void {
		let that = this;
		that._items.forEach(that._cleanupItem, that);
		super.dispose();
	}

	all(): T[] {
		let that = this,
			ret = that._items;
		ret.forEach((item, i) => {
			that._triggerGet({ prop: i.toString(), value: item });
		});
		that._triggerGet({ prop: "all", value: ret });
		return ret;
	}

	get(i: number|string): T {
		let ret = this._items[<number>i];
		this._triggerGet({ prop: i.toString(), value: ret });
		return ret;
	}

	count(): number {
		let ret = this._items.length;
		this._triggerGet({ prop: "count", value: ret });
		return ret;
	}

	isEmpty(): boolean {
		return this._items.length === 0;
	}

	indexOf(item: T): number {
		return this._items.indexOf(item);
	}

	add(item: T|T[]): void {
		let that = this,
			items = array(item);

		if (items.length) {
			Array.prototype.push.apply(that._items, items);

			that._triggerChange({ added: items });
		}
	}

	remove(item: T|T[]): void {
		if (!this._items.length) {
			return undefined;
		}
		let that = this,
			removed: T[] = [],
			items: T[] = array(item);

		if (items.length) {
			items.forEach((item) => {
				let i = that._items.indexOf(item);
				if (i >= 0) {
					that._items.splice(i, 1);
					removed.push(item);
				}
			});

			if (removed.length) {
				that._triggerChange({ removed: removed });
			}
		}
	}

	move(indexFrom: number, indexTo: number): void {
		let that = this, item: T;
		if (indexFrom !== indexTo) {
			item = that._items[indexFrom];
			that._items.splice(indexFrom, 1);
			that._items.splice(indexTo, 0, item);

			that._triggerChange({});
		}
	}

	clear(): void {
		let that = this,
			oldItems: T[];

		if (that._items.length) {
			oldItems = that._items.slice();
			that._items.length = 0;

			that._triggerChange({ removed: oldItems });
		}
	}

	/**
	 * Replace current items with new one(s).
	 * @param item New item or array of items
	 */
	reset(item: T|T[]): void {
		let that = this,
			items: T[] = array(item),
			oldItems: T[] = that._items.slice();

		if (items.length === oldItems.length) {
			// check for actual changing (i.e. `obj.items.reset(that.items)` is not a actual change)
			let len = items.length,
				changed = false;
			for (let i = 0; i < len; ++i) {
				if (items[i] !== oldItems[i]) {
					changed = true;
					break;
				}
			}
			if (!changed) {
				return;
			}
		}
		that._items.length = 0;
		Array.prototype.push.apply(that._items, items);

		that._triggerChange({ added: items, removed: oldItems });
	}

	forEach(iterator: (item: T, index: number, array: T[]) => void, context?: any): void {
		this._items.forEach(iterator, context);
	}

	/**
	 * Returns the first element that satisfies the provided testing function.
	 * Analogue of `Array.prototype.find`.
	 * @param predicate
	 * @param context
	 * @returns {any}
	 */
	find(predicate: (item: T, index: number) => boolean, context?: any): T {
		return find(this._items, predicate, context);
	}

	some(iterator: (item: T, index: number) => boolean, context?: any): boolean {
		return this._items.some(iterator, context);
	}

	filter(iterator: (item: T, index: number, array?: T[]) => boolean, context?: any): T[] {
		return this._items.filter(iterator, context);
	}

	toggle(item: T): void {
		let that = this,
			idx = that._items.indexOf(item);
		if (idx > -1) {
			that._items.splice(idx, 1);
			that._triggerChange({ removed: [ item ] });
		} else {
			that._items.push(item);
			that._triggerChange({ added: [ item ] });
		}
	}

	insert(item: T|T[], targetIdx: number): void {
		let that = this,
			items = array(item);

		if (items.length) {
			if (targetIdx >= 0) {
				let temp: T[] = that._items.slice(0, targetIdx);
				Array.prototype.push.apply(temp, items);
				Array.prototype.push.apply(temp, that._items.slice(targetIdx));
				that._items = temp;
				that._triggerChange({ added: items, addedIndices: [targetIdx] });
			} else {
				that.add(items);
			}
		}
	}

	private _triggerGet(args: ObservableGetArgs): void {
		this.trigger("get", this, args);
	}

	private _triggerChange(args: ObservableCollectionChangeArgs<T>): void {
		let that = this;
		if (args.added && args.added.length) {
			args.added.forEach(that._initItem, that);
		}
		if (args.removed && args.removed.length) {
			args.removed.forEach(that._cleanupItem, that);
		}
		that.trigger("change", that, args);
	}

	private _onItemChange(item: T): void {
		this.trigger("itemChange", this, { changed: [ item ] });
	}

	private _initItem(item: T): void {
		if (Observable.isObservable(item)) {
			item.bind("change", this._onItemChange, this);
		}
	}

	private _cleanupItem(item: T): void {
		if (Observable.isObservable(item)) {
			item.unbind("change", this._onItemChange, this);
		}
	}

	static isObservableCollection(obj: any): obj is IObservableCollection<any> {
		return Observable.isObservable(obj) && (obj as any).all && (obj as any).count && (obj as any).indexOf;
	}
}

export class ObservableDictionary extends Observable {
	private _keys: any[] = [];

	/**
	 * @constructs ObservableDictionary
	 * @extends Observable
	 * @param map
	 */
	constructor(map?) {
		super();

		let that = this;
		that.bind("change", that._onItemChange, that);

		if (map) {
			that.addRange(map);
		}
	}
	add(key, value, ignoreRaise?) {
		let that = this;

		if (key === undefined || key === null || key === "")
			throw new Error("Ключ в словаре не может быть пустым");
		if ($.inArray(key, that._keys) !== -1)
			throw new Error("Словарь уже содержит ключ: " + key);

		that._keys.push(key);
		that.declareProp(key, value);
		let added = {};
		added[key] = value;
		if (!ignoreRaise) {
			that._triggerChange({added: added});
		}
		return that;
	}
	remove(key) {
		var that = this,
			removed;
		if ($.inArray(key, that._keys) !== -1) {
			removed = {};
			removed[key] = that[key]();

			var idx = that._keys.indexOf(key);
			if (idx !== -1) that._keys.splice(idx, 1);

			that._removeProp(key);
			that._triggerChange({removed: removed});
		}
		return that;
	}
	addRange(map, ignoreRaise?) {
		var that = this;
		$.each(map, function(n, e){
			that.add(n, e);
		});
		ignoreRaise && that._triggerChange({ added: map });
		return that;
	}
	clear() {
		var that = this,
			old;
		old = that._removeAll();
		that._triggerChange({ removed: old });
		return that;
	}
	reset(map) {
		var that = this,
			old;
		old = that._removeAll();
		that.addRange(map, true);
		that._triggerChange({ removed: old, added: map });
		return this;
	}
	keys(){
		return this._keys.slice();
	}
	values() {
		return $.map(this._keys, (key) => {
			return this[key]();
		})
	}
	all() {
		let dict = {};
		$.each(this._keys, (i, key) => {
			dict[key] = this[key]();
		});
		return dict;
	}
	count(): number {
		return this._keys.length;
	}
	contains(key): boolean {
		return $.inArray(key, this._keys) !== -1;
	}
	private _triggerChange(args) {
		this.trigger("itemsChange", this, args);
	}
	private _triggerItemChange(args) {
		this.trigger("itemChange", this, args);
	}
	private _onItemChange(s, item) {
		this._triggerItemChange({ changed: item });
	}
	private _removeAll(){
		var that = this,
			oldItems = {};
		if (that._keys.length) {
			$.each(that._keys, function(i, key) {
				oldItems[key] = that[key]();
				that._removeProp(key);
			});
			that._keys = [];
		}
		return oldItems;
	}
	private _removeProp(name){
		let field = "_" + name;
		delete this[field];
		delete this[name];
	}
}

export namespace collections {
	export function createComparer<T>(orderBy: OrderBy[]): (x: any, y: any) => number {
		if (!orderBy || !orderBy.length) {
			return undefined;
		}

		return function (obj1: T, obj2: T) {
			for (let orderItem of orderBy) {
				let v1, v2;
				if (orderItem.getter) {
					v1 = orderItem.getter.call(obj1);
					v2 = orderItem.getter.call(obj2);
				} else {
					v1 = get(obj1, orderItem.prop);
					v2 = get(obj2, orderItem.prop);
				}
				let comp = orderItem.comparer ? orderItem.comparer(v1, v2) : compare(v1, v2);
				if (comp !== 0) {
					return orderItem.desc ? -comp : comp;
				}
			}
			return 0;
		};
	}

	export function parseOrderBy(orderBy: OrderByOrString|OrderByOrString[], oldOrderBy?: OrderByData[]): OrderBy[] {

		let items = array(orderBy);
		return items.map((item: OrderByOrString, i) => {
			if (isString(item)) {
				let prop: string = item;
				let desc: boolean;
				if (prop[0] === "+") {
					prop = prop.slice(1);
				} else if (prop[0] === "-") {
					prop = prop.slice(1);
					desc = true;
				} else if (prop[0] === "*") {
					prop = prop.slice(1);
					if (oldOrderBy) {
						let old = oldOrderBy[i];
						if (old && old.prop === prop) {
							desc = !old.desc;
						}
					}
				} else if (prop.slice(-4).toLowerCase() === " asc") {
					prop = prop.slice(0, -4);
				} else if (prop.slice(-5).toLowerCase() === " desc") {
					prop = prop.slice(0, -5);
					desc = true;
				}
				return {
					prop: prop,
					desc: desc
				};
			}
			return item;
		});
	}

	export interface OrderByData {
		prop?: string;
		desc?: boolean;
	}
	export interface OrderBy {
		prop?: string;
		desc?: boolean;
		getter?: () => any;
		comparer?: (x: any, y: any) => number;
	}

	export type OrderByOrString = OrderBy|string;
}

export class EventBinder extends CoreClass {
	private _owner: any;
	private _disposes: (() => void)[] = [];

	/**
	 * @constructs EventBinder
	 * @param owner
	 */
	constructor(owner?: any) {
		super();
		this._owner = owner;
	}

	bind(target: IEventful, event: string, callback: Function): void {
		let that = this,
			handler = that._owner ? callback.bind(that._owner) : callback,
			dispose = function () {
				target.unbind(event, handler);
			};
		target.bind(event, handler);
		that._disposes.push(dispose);
	}

	unbind(): void {
		let that = this;
		that._disposes.forEach((dispose) => {
			dispose();
		});
		that._disposes.length = 0;
	}

	dispose(): void {
		this.unbind();
	}
}

export class Event extends CoreClass {
	private _owner;
	private _eventName: string = "exec";
	private _bound: boolean = false;
	private _innerEvent = new Observable();

	/**
	 * @constructs Event
	 * @param {*} [owner] An object which will be passed in `sender` field of event's handler
	 */
	constructor(owner?) {
		super();
		this._owner = owner;
	}

	/**
	 * Subscribe the callback to the event
	 * @param {Function} callback
	 * @param {*} [context] A context (`this`) in which the callback will be called
	 */
	bind(callback: Function, context?) {
		var that = this;
		that._innerEvent.bind(that._eventName, callback, context);
		if (!that._bound) {
			that._bound = true;
			if (that.onFirstBind) {
				that.onFirstBind();
			}
		}
	}
	/**
	 * Unsubscribe the callback from the event
	 * @param {Function} callback
	 * @param {*} [context]
	 */
	unbind(callback: Function, context?) {
		var that = this;
		that._innerEvent.unbind(that._eventName, callback, context);
		if (!that._innerEvent.bound(that._eventName)) {
			that._bound = false;
			if (that.onLastUnbind) {
				that.onLastUnbind();
			}
		}
	}
	/**
	 * Trigger the event, i.e. execute all its callback.
	 * @param {Object} [data]
	 */
	trigger(data) {
		var that = this,
			args = that._owner ? extend(data || {}, { sender: that._owner }) : data;
		that._innerEvent.trigger(that._eventName, args);
	}

	protected onFirstBind?();
	protected onLastUnbind?();
}
// optional methods (onFirstBind/onLastUnbind) are not allowed without namespace for some reason
export namespace Event { }

/**
 * Создает объект-обертку, инкапсулирующий внутри себя исходный объект.
 * @param source Исходный объект
 * @param {Object} [options]
 * @param {Number} [options.proxyFields] Определяет, каким образовать проксировать исходные свойства, чтобы их изменения отразились в исходном объекте:
 *  1 - для каждого собственного свойства из исходного объекта в прокси-объекте создается одноименное свойство с get/set, которое перенаправляет обращения к свойству в поле исходного объекта;
 *  2 - все методы созданной обертки (включая все унаследованные) перенаправляются в исходные методы, вызываемые в контексте исходного объекта (this === source);
 *  3 - изменения исходных полей через прокси-объект не отражается на исходном объекте;
 *  0 - если браузер поддерживает свойства ES5, то выбирается режим 1; иначе - 2.
 * @return {*}
 * @see {@link http://wiki.rnd.croc.ru/pages/viewpage.action?pageId=37617859}
 */
export function proxy<T>(source: T, options?: proxy.Options): T {
	// NOTE: <any> нужно для совместимости с TS 2.3.
	// Можно также изменить <T> на <T extends object>, но тогда код перестанет компилироваться в TS 2.1
	// Это надо сделать, но позже.
	let ext = Object.create(<any>source),
		proxying: proxy.FieldProxying = options && options.fieldProxying || proxy.defaultFieldProxying;

	if (proxying === proxy.FieldProxying.redirectProps) {
		// NOTE: use Object.keys to enumerate own properties only
		Object.keys(source).forEach(function (name) {
			Object.defineProperty(ext, name, {
				get: function () { return source[name]; },
				set: function (v) { source[name] = v; },
				enumerable: true,
				configurable: true
			});
		});
	} else if (proxying === proxy.FieldProxying.bindMethods) {
		// NOTE: use for..in to enumerate all properties, including prototypes
		for (let name in source) {
			let method: any = source[name];
			if (typeof method === "function") {
				ext[name] = method.bind(source);
			}
		}
	}

	return ext;
}
export declare namespace proxy {
	export const enum FieldProxying {
		default = 0,
		redirectProps = 1,
		bindMethods = 2,
		none = 3
	}

	export interface Options {
		fieldProxying?: FieldProxying;
	}

	export var defaultFieldProxying: FieldProxying;
}

proxy.defaultFieldProxying = supportsES5props ? proxy.FieldProxying.redirectProps : proxy.FieldProxying.bindMethods;

export class ViewModelExtender extends CoreClass {
	eventBinder: EventBinder = new EventBinder(this);
	viewModel;

	/**
	 * @constructs ViewModelExtender
	 * @param originalViewModel
	 * @param options
	 */
	constructor(originalViewModel, options?: proxy.Options) {
		super();
		//this.viewModel = Object.create(originalViewModel);
		this.viewModel = proxy(originalViewModel, options);
	}
	declareProp(name: string, initial, onChange: Function) {
		this.viewModel.declareProp(name, initial);
		if (onChange)
			this.eventBinder.bind(this.viewModel, "change:" + name, onChange.bind(this.viewModel));
	}
	dispose(): void {
		this.eventBinder.unbind();
	}
}

export namespace decorators {
	/**
	 * Property decorator. Initializes the property with a constant in the class prototype.
	 * @see {@link http://www.typescriptlang.org/docs/handbook/decorators.html}
	 * @param {*} value Tthe value of the property.
	 */
	export function constant(value: any): PropertyDecorator {
		return function (proto, propName: string) {
			proto[propName] = value;
		};
	}

	/**
	 * Property decorator. Initializes the property with an 'Observable.accessor'.
	 * @see {@link http://www.typescriptlang.org/docs/handbook/decorators.html}
	 * @param {Object} [spec]
	 */
	export function observableAccessor<T>(spec?: {field?: string, init?: T}): PropertyDecorator {
		let field = spec && spec.field;
		let init;
		if (spec && spec.init !== undefined) {
			init = spec.init;
		}
		return function (proto, propName: string) {
			proto[propName] = Observable.accessor(propName, field);

			let observables = proto["__observableProps"] || (proto["__observableProps"] = {});
			observables[field || ("_" + propName)] = init;
		};
	}

	/**
	 * Property decorator. Initializes the property with an 'Observable.getter'.
	 * @see {@link http://www.typescriptlang.org/docs/handbook/decorators.html}
	 * @param {string} [field]
	 */
	export function observableGetter(field?: string): PropertyDecorator {
		return function (proto, propName: string) {
			proto[propName] = Observable.getter(propName, field);
		};
	}

	/**
	 * Property decorator. Initializes the property with an 'Observable.setter'.
	 * @see {@link http://www.typescriptlang.org/docs/handbook/decorators.html}
	 * @param {string} [field]
	 */
	export function observableSetter(field?: string): PropertyDecorator {
		return function(proto, propName: string) {
			proto[propName] = Observable.setter(propName, field);
		};
	}

	/**
	 * Method decorator. Wraps the method so that it returns a rejected Promise object if an error occurs.
	 * If the original function executes successfully the wrapped method will just return the result.
	 * But if the original method throws as error it will return a rejected Promise.
	 */
	export function asyncSafe(proto, methodName: string, descriptor?: PropertyDescriptor) {
		// see WC-1761
		const safeMethod = async.safe(proto[methodName]);
		if (descriptor) {
			descriptor.value = safeMethod; 	// ES5
		} else {
			proto[methodName] = safeMethod; // ES3
		}
	}
}

export namespace support {

	interface DependentObject {
		obj: any;
		props: { [name: string]: boolean };
		callback?: (sender, args) => void; // used in ObservableExpression
	}

	interface DependencyTrack {
		observed: DependentObject[];
		tracked: any[];
	}

	interface ObservableExpressionDependencies extends DependencyTrack {
		isLoading: boolean;
		loadingError: Error;
	}

	interface IExpressionFactory {
		get: (text: string) => Function;
	}

	export class DependencyTracker {
		private _observed: DependentObject[] = [];
		private _tracked: any[] = [];

		observe(obj: any, prop: string): void {
			let that = this,
				found,
				props;
			prop = prop || "";
			if (Observable.isObservable(obj)) {
				found = that._observed.some((o) => {
					if (o.obj === obj) {
						o.props[prop] = true;
						return true;
					}
				});
				if (!found) {
					props = {};
					props[prop] = true;
					that._observed.push({obj: obj, props: props});
				}
			}
		}

		track(obj: any): void {
			let that = this;
			if (that._tracked.indexOf(obj) < 0) {
				that._tracked.push(obj);
				if (Observable.isObservable(obj)) {
					obj.bind("get", that._onGetSet, that);
					obj.bind("set", that._onGetSet, that);
				}
			}
		}

		stop(): DependencyTrack {
			let that = this;
			that._tracked.forEach((obj) => {
				if (Observable.isObservable(obj)) {
					obj.unbind("get", that._onGetSet, that);
					obj.unbind("set", that._onGetSet, that);
				}
			});
			return {
				observed: that._observed,
				tracked: that._tracked
			};
		}

		private _onGetSet(sender: any, args: ObservablePropertyArgs): void {
			if (args) {
				this.track(args.value);
			}
			if (sender) {
				this.observe(sender, args ? args.prop : undefined);
			}
		}
	}

	export const ExpressionFactory: IExpressionFactory = <IExpressionFactory>{
		_map: {},
		get: function(text: string): Function {
			let expr: Function = this._map[text];
			if (!expr) {
				// частный случай - задано просто имя свойства (поля или метода)
				if (/^[_A-Za-z]\w*$/.test(text)) {
					expr = property(text);
				} else if (text.indexOf("this") >= 0) {
					expr = new Function("return (" + text + ");");
				} else {
					expr = new Function("with (this) { return (" + text + "); }");
				}
				this._map[text] = expr;
			}
			return expr;
		}
	};

	export function isNotLoaded(obj: any): boolean {
		// isLoaded flag must be set (true of false)
		return obj && obj.isLoaded !== undefined && !obj.isLoaded && typeof obj.load === "function";
	}

	/**
	 * Special object that represent a value which is currently loading
	 */
	export let loadingValue = {
		toString: function (): string {
			// NOTE: 'lang' module shouldn't depend on resources, therefore return not-localized string
			return "Loading...";
		}
	};

	export interface IObservableExpression {
		evaluate(thisObj: any, argsArray?: any[]|IArguments): any;
		suppress(): void;
		resume(): void;
		dispose(): void;
	}

	export class ObservableExpressionBase implements IObservableExpression {
		protected _expr: Function;
		protected _options: ObservableExpressionBase.Options;
		protected _dependencies: ObservableExpressionDependencies;
		protected _suppress: boolean;

		/**
		 * @constructs ObservableExpressionBase
		 * Basic observable expression.
		 * @param {String|Function} expr
		 * @param {Object} [options]
		 * @param {Function} [options.onchange] callback to be called on any change of objects observed while `expr` function execution
		 */
		constructor(expr: Function|string, options?: ObservableExpression.Options) {
			if (typeof expr !== "function" && typeof expr !== "string") {
				throw new TypeError("Expression must be function or string");
			}

//				var config = window.xconfig;
//				if (config && config.isDebug) {
//					this._exprDebug = expr.toString();
//				}

			if (typeof expr === "string") {
				expr = support.ExpressionFactory.get(<string>expr);
			}

			let that = this;
			that._expr = <Function>expr;
			that._options = options || {};
		}

		dispose(): void {
			this._reset();
		}

		suppress(): void {
			this._suppress = true;
		}

		resume(): void {
			this._suppress = false;
		}

		evaluate(thisObj: any, argsArray?: any[]|IArguments): any {
			let that = this,
				ret;

			if (!that._dependencies) {
				ret = that._init(thisObj, argsArray);
			} else {
				ret = that._expr.apply(thisObj, argsArray || []);
			}

			return ret;
		}

		protected _notify(reason: ObservableNotifyReason): void {
			let that = this;
			if (that._suppress) { return; }
			if (that._dependencies) {
				that._reset();
				that._callback(reason);
			}
		}

		protected _callback(reason: ObservableNotifyReason): void {
			let onchange = this._options.onchange;
			if (onchange) {
				onchange(reason);
			}
		}

		protected _observe(): void {
			let that = this;
			that._dependencies.observed.forEach((d: DependentObject) => {
				d.callback = (sender: IEventful, ea: ObservableChangeArgs) => {
					let prop = (ea && ea.prop);
					if (!prop || d.props[prop]) {
						that._notify(ea && ea.reason || "change");
					}
				};
				d.obj.bind("change", d.callback);
			});
		}

		protected _reset(): void {
			let that = this;
			if (that._dependencies) {
				that._dependencies.observed.forEach((d: DependentObject) => {
					// NOTE: callback may be not set when something was loaded synchronously
					if (d.callback) {
						d.obj.unbind("change", d.callback);
					}
				});
				that._dependencies = undefined;
			}
		}

		protected _track(source: any, args?: any[]|IArguments): DependencyTracker {
			// WARN: метод может выкинуть исключение, если оно выбрасывается при вычислении выражения
			let tracker, i;
			tracker = new DependencyTracker();
			tracker.track(source);
			if (args) {
				for (i = 0; i < args.length; i++) {
					tracker.track(args[i]);
				}
			}
			return tracker;
		}

		protected _init(source: any, args?: any[]|IArguments): any {
			// WARN: метод может выкинуть исключение, если оно выбрасывается при вычислении выражения
			let that = this, tracker;

			try {
				that._reset();

				// start tracking dependencies before calling the expression
				tracker = that._track(source, args);

				return that._expr.apply(source, args || []);
			} finally {
				// stop tracking dependencies
				that._dependencies = tracker.stop();

				that._observe();
			}
		}
	}

	export namespace ObservableExpressionBase {
		export interface Options {
			onchange?: (reason?: ObservableNotifyReason) => void;
		}
	}

	export class ObservableExpression extends ObservableExpressionBase {
		protected _options: ObservableExpression.Options;

		/**
		 * @constructs ObservableExpression
		 * @param {String|Function} expr
		 * @param {Object} [options]
		 * @param {Function} [options.onchange] callback, который будет вызван при изменении объектов, задействованных при вызове функции
		 * @param {*} [options.loadingValue] значение, возвращаемое функцией, если есть незагруженные объекты
		 * @param {*} [options.errorValue] значение, возвращаемое функцией в случае ошибки
		 * @param {Boolean} [options.suppressAutoLoad] отключить автоматическую загрузку незагруженных объектов
		 */
		constructor(expr: Function|string, options?: ObservableExpression.Options) {
			super(expr, options);
			if (!options || options.autoLoad === undefined) {
				this._options.autoLoad = "always";
			}
		}

		evaluate(thisObj: any, argsArray?: any[]|IArguments): any {
			let that = this,
				ret,
				error: Error;
				//callCtx: ObservableExpression.CallContext;

			try {
				if (!that._dependencies) {
					ret = that._init(thisObj, argsArray);
				} else if (that._dependencies.loadingError) {
					error = that._dependencies.loadingError;
				} else if (!that._dependencies.isLoading) {
					ret = that._expr.apply(thisObj, argsArray || []);
				}
			} catch (ex) {
				error = ex;
			}
			if (that._dependencies && that._dependencies.isLoading) {
				// если есть зависимые незагруженные объекты, то вернем специальное значение
				if (!error && that._options.autoLoad === "onerror" && isPromise(ret)) {
					// выражение вычислилось без ошибок, вернуло Promise и задана опция, отключившая autoLoad,
					// вернем результат as is
					return ret;
				}
				ret = that._options.loadingValue || support.loadingValue;
			} else if (error) {
				if (that._options.errorValue) {
					ret = that._options.errorValue;
				} else {
					throw error;
				}
			}

			return ret;
		}

		protected _init(source: any, args?: any[]|IArguments): any {
			// WARN: метод может выкинуть исключение, если оно выбрасывается при вычислении выражения
			let that = this, runToEnd, tracker, syncLoaded;

			try {
				that._reset();

				// start tracking dependencies before calling the expression
				tracker = that._track(source, args);

				let res = that._expr.apply(source, args || []);
				runToEnd = true;
				return res;
			} finally {
				// stop tracking dependencies
				that._dependencies = tracker.stop();

				if (runToEnd && that._options.autoLoad === "onerror") {
					// expression execution finishes w/o an error and auto-load should happen only on error
				} else {
					// an error occured or autoLoad == "always":
					// загружаем все незагруженные объекты
					that._dependencies.tracked.forEach((obj) => {
						let deferredLoad;
						if (support.isNotLoaded(obj)) {
							that._dependencies.isLoading = true;
							deferredLoad = obj.load();
							if (isPromise(deferredLoad)) {
								if (deferredLoad.state() === "resolved") {
									syncLoaded = true; // object was loaded synchronously
								} else {
									deferredLoad.done((loaded) => {
										//if (loaded !== undefined && !lang.support.isNotLoaded(loaded)) {
										//	that._notify();
										//}
										that._notify("autoLoad");
									}).fail((err) => {
										if (that._dependencies) {
											that._dependencies.isLoading = false;
											that._dependencies.loadingError = err;
											that._callback("loadError");
										}
									});
								}
							}
						}
					});
					if (syncLoaded) {
						// something was loaded synchronously, so we should reinitialize - repeat recursively
						// TODO: max attempts
						return that._init(source, args);
					}
				}


				that._observe();
			}
		}

		public static create(expr: Function|string, options?: ObservableExpression.Options): ObservableExpressionBase {
			let ctor: typeof ObservableExpressionBase = options && (options.suppressAutoLoad || options.autoLoad === "disabled" || options.autoLoad === false) ?
				ObservableExpressionBase :
				ObservableExpression;
			return new ctor(expr, options);
		}
	}

	export namespace ObservableExpression {
		export interface Options extends ObservableExpressionBase.Options {
			loadingValue?;
			errorValue?;
			suppressAutoLoad?: boolean;
			autoLoad?: "always" | "onerror" | "disabled" | false;
		}
	}

	export class AsyncIterator<T> {
		items: T[];
		iterator: (item: T, index: number) => Promise<any>|any;
		context: any;
		private _idx: number = 0;
		private _defer: Deferred<any> = deferred();

		/**
		 * @constructs AsyncIterator
		 * @param {Array} items
		 * @param {Function} iterator
		 * @param {*} [context]
		 */
		constructor(items: T[], iterator: (item: T, index: number) => Promise<any>|any, context?: any) {
			this.items = items;
			this.iterator = iterator;
			this.context = context;
		}

		execute(): Promise<any> {
			this._moveNext();
			return this._defer;
		}

		private _moveNext(): void {
			let that = this;

			if (that._idx >= that.items.length) {
				that._defer.resolve();
				return;
			}

			when(that.iterator.call(that.context, that.items[that._idx], that._idx++, that.items))
				.done(() => {
					that._moveNext();
				})
				.fail((error) => {
					that._defer.reject(error);
				});
		}
	}
}

import ObservableExpression = support.ObservableExpression;
import ObservableExpressionBase = support.ObservableExpressionBase;

export interface IDisposableFunction extends IDisposable {
	(...args): any;
}

export function observableExpression(expr: IDisposableFunction|Function|string, options?: ObservableExpression.Options): IDisposableFunction;
/**
 * Создает функцию, оборачивая expr.
 * При первом вызове созданной функции анализируются все затронутые observable объекты. При изменении
 * любого из них вызывается callback, заданный в options.onchange. После этого изменения в затронутых объектах
 * перестают отслеживаться, для продолжения отслеживания нужно повторно вызвать функцию-результат.
 * @param {String|Function} expr
 * @param {Object} [options]
 * @param {Function} [options.onchange] callback, который будет вызван при изменении объектов, задействованных при вызове функции
 * @param {*} [options.loadingValue] значение, возвращаемое функцией, если есть незагруженные объекты
 * @param {*} [options.errorValue] значение, возвращаемое функцией в случае ошибки
 * @param {Boolean} [options.suppressAutoLoad] отключить автоматическую загрузку незагруженных объектов
 * @returns {function} Javascript функция, которая может вызываться как обычно. Однако, функция содержит метод dispose, который обязательно должен быть вызван, когда созданная функция перестанет быть нужной.
 */
export function observableExpression(expr, options?: ObservableExpression.Options): IDisposableFunction {
	// prevent re-wrapping: expr is already ObservableExpression
	if (typeof expr === "function" && expr.dispose) {
		return expr;
	}
	let obs = ObservableExpression.create(expr, options),
		ret = <IDisposableFunction>function () {
			return obs.evaluate(this, arguments);
		};
	ret.dispose = function () {
		obs.dispose();
	};
	return ret;
}

/**
 * Tries to evaluates the expression and loads all unloaded objects, which are used in the expression.
 * @param {String|Function} expr
 * @param {*} ctx this object for evaluating the expression
 * @param {...*} exprArgs arguments for evaluating the expression
 * @returns {Deferred} Deferred with result of evaluating the expression when all used objects are loaded.
 */
export function loadExpression(expr: Function|string, ctx, ...exprArgs): Promise<any> {
	var defer = deferred(),
		options = {
			loadingValue: support.loadingValue,
			onchange: function () {
				try {
					let r = obs.evaluate(ctx, exprArgs);
					if (r !== options.loadingValue) {
						obs.dispose();
						defer.resolve(r);
					}
				} catch (ex) {
					obs.dispose();
					defer.reject(ex);
				}
			}
		},
		obs = new support.ObservableExpression(expr, options);

	options.onchange();
	return defer;
}

/**
 * Contains some methods for working with Deferred
 */
export namespace async {
	export function attempt<T>(func: () => Promise<T>, context?: any): Promise<T>;
	export function attempt<T>(func: () => T, context?: any): Promise<T>;
	export function attempt<T>(func: () => Promise<T>|T, context?: any) {
		try {
			let r = func.call(context);
			return when(r);
		} catch (ex) {
			return rejected(ex);
		}
	}

	/**
	 * Calls iterator for every item in array.
	 * Iterator may returns Deferred. In this case next item will be processed when Deferred will be resolved.
	 * @param {Array} items
	 * @param {Function} iterator
	 * @param {*} context This object for calling iterator
	 */
	export function forEach<T>(items: T[], iterator: (item: T, index: number) => Promise<any>|any, context?): Promise<any> {
		return new support.AsyncIterator(items, iterator, context).execute();
	}

	export function wrap<T>(func: (...args) => Promise<T>): (...args) => Promise<T>;
	export function wrap<T>(func: (...args) => T): (...args) => Promise<T>;
	export function wrap<T>(func: (...args) => void): (...args) => Promise<void>;
	/**
	 * Wraps the function so that it always returns a Promise object. If the result of the original function
	 * is not a Deferred (or a Promise) the wrapped function will return a resolved Promise object.
	 * If the original function throws as error it will return a rejected Promise.
	 * @param {Function} func
	 * @returns {Function}
	 */
	export function wrap<T>(func: (...args) => T) {
		return func && function () {
			try {
				let r = func.apply(this, arguments);
				return when(r);
			} catch (ex) {
				return rejected(ex);
			}
		};
	}

	/**
	 * Wraps the function so that it returns a rejected Promise object if an error occurs.
	 * If the original function executes successfully the wrapped function will just return the result.
	 * But if the original function throws as error it will return a rejected Promise.
	 * @param {Function} func
	 * @returns {Function}
	 */
	export function safe<T>(func: (...args) => T): (...args) => Promise<T>|T {
		return func && function () {
			try {
				return func.apply(this, arguments);
			} catch (ex) {
				return rejected(ex);
			}
		};
	}

	export function then<T, U>(obj: Promise<T>|T, doneFilter: (v: T) => Promise<U>, failFilter?: (e: Error) => void): Promise<U>;
	export function then<T, U>(obj: Promise<T>, doneFilter: (v: T) => U, failFilter?: (e: Error) => void): Promise<U>;
	export function then<T, U>(obj: Promise<T>, doneFilter: (v: T) => void, failFilter?: (e: Error) => void): Promise<void>;
	export function then<T, U>(obj: T, doneFilter: (v: T) => U|Promise<U>, failFilter?: (e: Error) => void): U|Promise<U>;
	export function then<T, U>(obj: T, doneFilter: (v: T) => void|Promise<void>, failFilter?: (e: Error) => void): void|Promise<void>;
	/**
	 * Executes callback for the object and returns a result.
	 * If the object is a Deferred, adds callbacks to be called when the Deferred is completed via 'then' method
	 * and returns its result (a new Deferred).
	 * Despite 'then' method this method executes the callback in try..catch
	 * @param {Promise|*} obj
	 * @param {Function} [doneFilter]
	 * @param {Function} [failFilter]
	 * @returns {Promise|*}
	 */
	export function then<T, U>(obj: Promise<T>|T, doneFilter: (v: T) => U, failFilter?: (e: Error) => void): Promisable<U> {
		let doneFilterSafe = async.safe(doneFilter);
		if (isPromise(obj)) {
			return (<Promise<T>>obj).then(doneFilterSafe, async.safe(failFilter));
		}
		return doneFilterSafe(obj);
	}

	export function done<T>(obj: Promise<T>, callback: (v: T) => void): Promise<T>;
	export function done<T>(obj: T, callback: (v: T) => void): T;
	/**
	 *
	 * @param {Promise|*} obj
	 * @param {Function} callback
	 * @returns {Promise|*}
	 */
	export function done<T>(obj: Promise<T>|T, callback: (v: T) => void): Promise<T>|T {
		let callbackSafe = async.safe(callback);
		if (isPromise(obj)) {
			return (<Promise<T>>obj).done(callbackSafe);
		}
		callbackSafe(obj);
		return obj;
	}

	export function fail<T>(obj: Promise<T>, callback: (e: Error) => void): Promise<T>;
	export function fail<T>(obj: T, callback: (e: Error) => void): T;
	/**
	 *
	 * @param {Promise|*} obj
	 * @param {Function} callback
	 * @returns {Promise|*}
	 */
	export function fail<T>(obj: Promise<T>|T, callback: (e: Error) => void): Promise<T>|T {
		if (isPromise(obj)) {
			return (<Promise<T>>obj).fail(async.safe(callback));
		}
		return obj;
	}

	export function always<T>(obj: Promise<T>|T, callback: () => void): Promise<T>;
	export function always<T>(obj: T, callback: () => void): T;
	/**
	 *
	 * @param {Promise|*} obj
	 * @param {Function} callback
	 * @returns {Promise|*}
	 */
	export function always<T>(obj: Promise<T>|T, callback: () => void): Promise<T>|T {
		let callbackSafe = async.safe(callback);
		if (isPromise(obj)) {
			return (<Promise<T>>obj).always(callbackSafe);
		}
		callbackSafe(obj);
		return obj;
	}

	export function progress<T>(obj: Promise<T>, callback: (v: any) => void): Promise<T>;
	export function progress<T>(obj: T, callback: (v: any) => void): T;
	/**
	 *
	 * @param {Promise|*} obj
	 * @param {Function} callback
	 * @returns {Promise|*}
	 */
	export function progress<T>(obj: Promise<T>|T, callback: (v: any) => void): Promise<T>|T {
		if (isPromise(obj)) {
			return (<Promise<T>>obj).progress(async.safe(callback));
		}
		return obj;
	}

	export function chain<T>(v: Promise<T>): IDeferredChain<T>;
	export function chain<T>(v: T): IValueChain<T>;
	export function chain(): IValueChain<void>;
	/**
	 * Creates a wrapper around a Promise or any other value, which behaves like a Promise.
	 * It allows to safely add callbacks via 'then', 'done', 'fail', 'always' and 'progress' methods,
	 * redirecting them to the same methods in 'lang.async' namespace.
	 * Call 'value' method to get a result.
	 * @param {Promise|*} v
	 * @returns {DeferredChain}
	 */
	export function chain<T>(v?: Promise<T>|T): IDeferredChain<T>|IValueChain<T> {
		return new DeferredChain(v);
	}

	export interface IDeferredChain<T> {
		value(): Promise<T>;

		then<U>(doneFilter: (v: T) => Promise<U>, failFilter?: (e: Error) => void): IDeferredChain<U>;
		then<U>(doneFilter: (v: T) => U, failFilter?: (e: Error) => void): IDeferredChain<U>;
		then<U>(doneFilter: (v: T) => void, failFilter?: (e: Error) => void): IDeferredChain<void>;

		done(callback: (v: T) => void): IDeferredChain<T>;
		fail(callback: (e: Error) => void): IDeferredChain<T>;
		always(callback: () => void): IDeferredChain<T>;
		progress(callback: (v: any) => void): IDeferredChain<T>;
	}

	export interface IValueChain<T> {
		value(): T;

		then<U>(doneFilter: (v: T) => Promise<U>, failFilter?: (e: Error) => void): IDeferredChain<U>;
		then<U>(doneFilter: (v: T) => U, failFilter?: (e: Error) => void): IValueChain<U>|IDeferredChain<U>;
		then<U>(doneFilter: (v: T) => void, failFilter?: (e: Error) => void): IValueChain<void>|IDeferredChain<void>;

		done(callback: (v: T) => void): IValueChain<T>;
		fail(callback: (e: Error) => void): IValueChain<T>;
		always(callback: () => void): IValueChain<T>;
		progress(callback: (v: any) => void): IValueChain<T>;
	}

	class DeferredChain<T> implements IValueChain<T>, IDeferredChain<T> {
		private _v;

		/**
		 * @constructs DeferredChain
		 * @param {Promise|*} v
		 */
		constructor(v?: Promise<T>|T) {
			this._v = v;
		}

		value(): any {
			return this._v;
		}

		then<U>(doneFilter: (v: T) => Promise<U>|U|void, failFilter?: (e: Error) => void): any {
			this._v = async.then(this._v, doneFilter, failFilter);
			return this;
		}

		done: (callback: (v: T) => void) => DeferredChain<T>;
		fail: (callback: (e: Error) => void) => DeferredChain<T>;
		always: (callback: () => void) => DeferredChain<T>;
		progress: (callback: (v: any) => void) => DeferredChain<T>;
	}

	// extend DeferredChain class
	["done","fail","always","progress"].forEach(function (name) {
		DeferredChain.prototype[name] = function (callback) {
			this._v = async[name].call(null, this._v, callback);
			return this;
		};
	});
}
