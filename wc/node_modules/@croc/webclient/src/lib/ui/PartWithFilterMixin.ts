import core = require("core");
import Part = require("lib/ui/Part");

import lang = core.lang;
import IFilterPart = core.ui.IFilterPart;
import { Violation } from "lib/validation";
import { IUserSettings } from "lib/.core";

interface PartWithFilterMixin extends lang.Observable { }

/**
 * @exports PartWithFilterMixin
 */
abstract class PartWithFilterMixin {
	protected filter: IFilterPart;
	protected _fieldWithFilterMenu: string;
	protected _filterOwned: boolean;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	filterExpanded: lang.ObservableProperty<boolean>;

	protected initFilter(options: PartWithFilterMixin.Options, userSettings: IUserSettings): void {
		let that = this;
		let filterOption = options.filter;
		if (filterOption) {
			if ((<IFilterPart>filterOption).getRestrictions) {
				that.filter = <IFilterPart>filterOption;
			} else {
				if (typeof filterOption === "string") {
					// part name with optional part's options
					that.filter = <IFilterPart>core.createPart(filterOption, options.filterOptions);
				} else if (lang.isFunction(filterOption)) {
					// factory
					that.filter = filterOption(that);
				} else {
					that.filter = new core.ui.ObjectFilter(<Object>filterOption);
				}
				that._filterOwned = true;
				if (!that.filter.getRestrictions) {
					console.error("Supplied filter has no mandatory method getRestrictions");
					that.filter = null;
				}
			}

			if (that.filter) {
				that.filterExpanded(!!options.filterExpanded);

				if (userSettings) {
					userSettings.bindToProp(that, "filterExpanded");
					if (that.filter.userSettings) {
						userSettings.attach("filter", that.filter.userSettings);
					}
				}
			}
		}
	}

	protected notifyFilterApplied(restrictions: any): void {
		let that = this,
			filterApplied;

		if (!that.filter) return;
		if (that.filter.isEmpty) {
			filterApplied = !that.filter.isEmpty();
		} else {
			filterApplied = !lang.isEmptyObject(restrictions);
		}
		let menu = that[that._fieldWithFilterMenu];
		if (menu) {
			let menuItem = menu.getItem("ClearFilter");
			if (menuItem) {
				menuItem.cssClass = filterApplied ? "x-menu-item-badge-warning" : "";
				// notify that property with menu was changed
				that.changed(that._fieldWithFilterMenu);
			}
		}
	}

	/**
	 * Collect restrictions from filter
	 * @returns {Object|null} Result of this.filter.getRestrictions() or null to cancel loading
	 * @protected
	 */
	protected getFilterRestrictions(): any {
		let that = this,
			params,
			errMsg;

		try {
			params = (that.filter && that.filter.getRestrictions()) || {};
			that.notifyFilterApplied(params);
			return params;
		} catch (e) {
			// can filter show violations?
			if (that.filter.canDisplayViolations) {
				that.filterExpanded(true);
			} else {
				errMsg = e.message;
				if (e.violations && e.violations.length) {
					errMsg = "<ul>" +
						e.violations.map((v: Violation) => { return "<li>" + v.error + "</li>"; }).join("") +
						"</ul>";
				}
				// show all errors by a hint
				that.showFilterError(errMsg);
				//that.hintMessage(resources["objectList.getRestrictionsError"] + errMsg);
			}
		}
		return null; // cancel loading
	}

	protected abstract showFilterError(error: string): void;

	protected disposeFilter(): void {
		let filter = this.filter;
		if (this._filterOwned && filter && filter.dispose) {
			filter.dispose();
		}
	}
}

namespace PartWithFilterMixin {
	export interface Options {
		filter?: IFilterPart | string | lang.Map<any> | ((parent: any) => IFilterPart);
		filterOptions?: lang.Map<any>;
		filterExpanded?: boolean;
		filterCollapsable?: boolean;
		expandFilterTitle?: string;
		collapseFilterTitle?: string;
	}
}

export = PartWithFilterMixin;
