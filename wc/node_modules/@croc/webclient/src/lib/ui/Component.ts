import $ = require("jquery");
import lang = require("lib/core.lang");
import Part = require("lib/ui/Part");
import StatefulPart = require("lib/ui/StatefulPart");

import { IPart, HostContextOptions } from "lib/ui/.ui";
import { INavigationService } from ".core";

class Component extends StatefulPart implements IPart {
	static defaultOptions: Component.Options;

	options: Component.Options;
	presenter: IPart;
	name: string;

	/**
	 * Part with a presenter. Presenter is a component which the part delegates rendering to.
	 * The presenter is registered as a child part of the current part.
	 * @constructs Component
	 * @extends StatefulPart
	 * @param {Component#defaultOptions} options
	 */
	constructor(options?: Component.Options) {
		options = Component.mixOptions(options, Component.defaultOptions);
		// pass 'contextName' to the presenter
		if (options.contextName) {
			options.presenterOptions = options.presenterOptions || {};
			options.presenterOptions.contextName = options.contextName;
		}
		super(options);
	}

	/**
	 * Create and initialize presenter
	 * @protected
	 * @param {Object} [options]
	 * @param {*} [options.viewModel=this] viewModel to set to presenter. Specify null to skip setting viewModel.
	 */
	protected initPresenter(options?: { viewModel?: any }): void {
		let that = this,
			opts = that.options,
			presenter: IPart,
			viewModel;

		// create presenter from component options
		if (opts.presenter) {
			presenter = opts.presenter;
		} else {
			let Presenter = opts.Presenter;
			if (lang.isFunction(Presenter)) {
				presenter = new Presenter(opts.presenterOptions);
			} else if (lang.isString(Presenter)) {
				presenter = lang.Class.create(null /*rootNamespace, use default*/, Presenter, opts.presenterOptions);
			}
		}

		if (!presenter) {
			// todo: some identification is needed:
			throw new Error("Can't initialize presenter for component " + (that.name || ""));
		}

		if (presenter.setViewModel) {
			viewModel = (options && options.viewModel !== undefined) ? options.viewModel : that;
			if (viewModel) {
				presenter.setViewModel(viewModel);
			}
		}
		that.presenter = presenter;
	}

	/** @inheritDoc */
	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		super.doRender(domElement);

		let that = this,
			presenter = that.presenter;
		if (presenter) {
			that.registerChild(presenter, {disposeOnUnload: false, keepOnUnload: false, trackStatus: true});
			// NOTE: тут проблема - в doRender мы зовем render презентера,
			// а это значит, что у презентера также вызовется afterRender, в котором может быть установлен renderStatus=ready
			// (если все его дочерние парты read). Но текущий парт мог еще не завершить рендеринг.
			// Например, редактор в своем doRender зовет базовый doRender, потом activatePage.
			return presenter.render(domElement);
		}
	}

	/** @inheritDoc */
	queryUnload(options?: Part.CloseOptions): lang.Promisable<string> {
		let presenter = this.presenter;
		if (presenter && typeof presenter.queryUnload === "function") {
			return presenter.queryUnload(options);
		}
	}

	/** @inheritDoc */
	dispose(options?: Part.CloseOptions): void {
		// NOTE: Part.dispose calls `unload` which is virtual.
		// Part's overridden unload can access dom/viewmodel and so on. So we must call base `dispose` first.
		super.dispose(options);
		this.disposePresenter(options);
	}

	protected disposePresenter(options?: Part.CloseOptions): void {
		let presenter = this.presenter;
		if (presenter && presenter.dispose) {
			presenter.dispose(options);
			this.presenter = undefined;
		}
	}

	applyHostContext(options: HostContextOptions): INavigationService.NavigateOptions {
		// NOTE: super can change options.host
		let navOpts = super.applyHostContext(options);

		let presenter = this.presenter;
		if (presenter && presenter.applyHostContext) {
			presenter.applyHostContext(options);
		}

		return navOpts;
	}
}

/**
 * @typedef {Object} ComponentOptions
 * @property {IPart} presenter
 * @property {Class} Presenter
 * @property {Object} presenterOptions options for passing to presenter's ctor
 */

Component.mixin(/** @lends Component.prototype */ {
	defaultOptions: Component.defaultOptions
});

namespace Component {
	export interface Options extends Part.ContextOptions {
		presenter?: IPart;
		Presenter?: lang.Constructor<IPart>|string;
		presenterOptions?: any;
	}
}

export = Component;

