import jquery = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import defaultTemplate = require("xhtmpl!lib/ui/templates/Popup.hbs");
import "xcss!lib/ui/styles/popupView.css";
import Handlebars = require("handlebars-ext");

import Options = Popup.Options;
import lang = core.lang;
import { IPart, PartCloseOptions } from "lib/ui/.ui";
import HBTemplate = Handlebars.Template;

class Popup extends View {
	/** @type {Object} */
	static defaultOptions: Options = {
		template: defaultTemplate,
		/**
		 * keep body alive; don't dispose body while disposing Popup
		 * @type {Boolean}
		 */
		preserveBody: false,
		/**
		 * 'closing' part (by method or command) will dispose it
		 */
		disposeOnClose: true,
		/**
		 * Events on parent element that close popup.
		 * NOTE: Don't include 'click' here. In fact 'click' is a paired event (mousedown + mouseup).
		 * But the popup can change its size because of 'mousedown' and the next 'mouseup' will be raised
		 * outside of the popup. In this case click in the popup will close it.
		 * (see http://track.rnd.croc.ru/issue/WC-853)
		 */
		closeOn: "mousedown keyup show.bs.dropdown show.bs.modal",
		/**
		 * Options for jQuery.fn.show method
		 * @type {Number|String|Object}
		 */
		animation: 100
	};

	options: Options;
	body: IPart;
	$parent: JQuery;
	private _bodyOwned: boolean;
	private _closeHandler: (eventObject: JQueryEventObject) => any;
	private _keyupHandler: (eventObject: JQueryEventObject) => any;

	/**
	 * @constructs Popup
	 * @extends View
	 * @memberOf core.ui
	 * @description Popup consists of a scaffolding frame (specified by template option)
	 * and an inner part (specified by body or bodyTemplate options).
	 * @param {Popup.defaultOptions} options
	 */
	constructor(options: Options) {
		options = Popup.mixOptions(options, Popup.defaultOptions);
		super(options);

		let body = this.options.body;
		if (typeof body  === "string") {
			body = core.createPart(<string>body);
			this._bodyOwned = true;
		} else if (!body && this.options.bodyTemplate) {
			body = new View({ template: this.options.bodyTemplate });
			this._bodyOwned = true;
		}
		this.body = <IPart>body;

		if (this.options.viewModel) {
			this.setViewModel(this.options.viewModel);
		}
	}

	setViewModel(viewModel: any): void {
		let that = this;
		if (that.body && lang.isFunction(that.body.setViewModel)) {
			that.body.setViewModel(viewModel);
		}
	}

	protected doRender(domElement: JQuery|HTMLElement): void {
		let that = this,
			$container = $(domElement),
			$dropdown = $("<div class='popup'></div>"),
			$parent,
			deferred;

		$container.click(); // force closing other popups & dropdowns

		$dropdown
			.hide()
			.addClass(that.options.rootCssClass)
			.on("domChanged", (e: JQueryEventObject) => {
				e.stopPropagation();
			})
			.on("click", ".x-navigation, a[href]:not([href='#'])", (e: JQueryEventObject) => {
				if (!core.html.isExternalClick(e)) {
					that.close();
				}
			})
			.appendTo($container);

		super.doRender($dropdown);
		// NOTE: we passed dropdown into View.render -> Part.render so now this.domElement === dropdown

		if (that.options.animation) {
			deferred = core.lang.deferred();
			$dropdown.slideDown(that.options.animation, () => {
				deferred.resolve();
			});
		} else {
			$dropdown.show();
		}
		// NOTE: offset should be set when DOM element is visible (after show)
		if (that.options.offset) {
			$dropdown.offset(that.options.offset);
		}

		// try to find parent popup
		$parent = $container.closest(".popup");
		//$parent = $container.closest(core.html.overlay.targets.join(','));
		if (!$parent.length) {
			$parent = core.$document;
		}
		that.$parent = $parent;

		$dropdown.on(that.options.closeOn, function(e: JQueryEventObject): void {
			// prevent bubbling inside the popup
			e.stopPropagation();
			// but re-trigger an event on the parent to close other popups/BS dropdowns
			// and handle keyboard navigation in BS dropdowns also
			let e2: any = $.Event(e.originalEvent, { popupTarget: this });
			core.lang.append(e2, e);
			$parent.trigger(e2);
		});

		that._closeHandler = (e: any) => {
			// close popup (except if it triggered an event itself)
			if (!$dropdown.is(e.popupTarget)) {
				that.close();
			}
		};
		$parent.on(that.options.closeOn, that._closeHandler);

		that._keyupHandler = (e: JQueryKeyEventObject) => {
			if (e.which ===  core.html.keyCode.ESCAPE) {
				that.close();
			}
		};
		$parent.on("keyup", that._keyupHandler);

		return deferred && deferred.promise();
	}

	protected _isFocusOutside(): boolean {
		let focused = core.html.focused();
		return focused && !$(focused).closest(this.$domElement).length;
	}

	close(): void {
		let that = this;
		let $dropdown = that.$domElement;

		if ($dropdown && that.options.animation) {
			$dropdown.slideUp(that.options.animation, () => {
				that.doClose();
			});
		} else {
			that.doClose();
		}
	}

	protected doClose(): void {
		if (this.options.disposeOnClose) {
			this.dispose();
		} else {
			this.unload();
		}
	}

	unload(options?: PartCloseOptions): void {
		let that = this;
		let $dropdown = that.$domElement;

		if (that.$parent) {
			if (that._closeHandler) {
				that.$parent.off(that.options.closeOn, that._closeHandler);
				that._closeHandler = undefined;
			}
			if (that._keyupHandler) {
				that.$parent.off("keyup", that._keyupHandler);
				that._keyupHandler = undefined;
			}
			that.$parent = undefined;
		}

		super.unload(options);

		if ($dropdown) {
			// NOTE: View.unload->Part.unload do domElement.empty() but domElement is our own element which should be removed (see render)
			$dropdown.remove();
		}
	}

	dispose(options?: PartCloseOptions): void {
		let that = this;

		// NOTE: Part.dispose will call our unload method
		super.dispose(options);

		if (!that.options.preserveBody && that.body && that.body.dispose) {
			that.body.dispose(options);
		}
		that.body = undefined;
	}
}

namespace Popup {
	export interface Options extends View.Options {
		/**
		 * inner part or its name
		 * @type {String|Part}
		 */
		body?: string|IPart;
		/**
		 * inner part template (View will created)
		 * @type {Function}
		 */
		bodyTemplate?: HBTemplate;
		/**
		 * keep body alive; don't dispose body while disposing Popup
		 * @type {Boolean}
		 */
		preserveBody?: boolean;
		/**
		 * 'closing' part (by method or command) will dispose it
		 */
		disposeOnClose?: boolean;
		/**
		 * Events on parent element that close popup.
		 * NOTE: Don't include 'click' here. In fact 'click' is a paired event (mousedown + mouseup).
		 * But the popup can change its size because of 'mousedown' and the next 'mouseup' will be raised
		 * outside of the popup. In this case click in the popup will close it.
		 * (see http://track.rnd.croc.ru/issue/WC-853)
		 */
		closeOn?: string;
		/**
		 * CSS class for popup DOM element
		 * @type {String}
		 */
		rootCssClass?: string;
		viewModel?: any;
		/**
		 * Options for jQuery.fn.show method
		 * @type {Number|String|Object}
		 */
		animation?: number | false;
		/**
		 * Options for jQuery.fn.offset method (an object containing the properties 'top' and 'left')
		 * @type {Object}
		 */
		offset?: JQueryCoordinates;
	}
}
Popup.mixin({
	defaultOptions: Popup.defaultOptions
});

// popup element can host other overlayers
//core.html.overlay.targets.push(".popup");

core.ui.Popup = Popup;
export = Popup;
