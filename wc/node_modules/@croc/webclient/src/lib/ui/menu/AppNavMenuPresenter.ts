import $ = require("jquery");
import core = require("core");
import binding = require("lib/binding");
import Part = require("lib/ui/Part");
import Menu = require("lib/ui/menu/Menu");
import MenuPresenterBase = require("lib/ui/menu/MenuPresenterBase");
import "xcss!lib/ui/styles/menuNav.css";

class AppNavMenuPresenter extends MenuPresenterBase {
	static defaultOptions: AppNavMenuPresenter.Options = {
		autoFill: true,
		autoScroll: true,
		tooltips: false,
		radio: true,
		hideSingle: true
	};

	options: AppNavMenuPresenter.Options;

	private _resizeSubscribed: boolean;

	/**
	 * Application navigation toolbar presenter
	 * @class AppNavMenuPresenter
	 * @extends MenuPresenterBase
	 * @param {Object} options
	 */
	constructor (options?: AppNavMenuPresenter.Options) {
		options = AppNavMenuPresenter.mixOptions(options, AppNavMenuPresenter.defaultOptions);
		super(options);
	}

	protected _processItems(items: Menu.Item[], menuRoot: JQuery): void {
		if (this.options.hideSingle) {
			if (items.length <= 1) { return; }

			let visibleItems = items.filter(
				item => !item.hidden && item.command &&
				(!item.hideIfDisabled || core.lang.unlazy(item.command).canExecute())
			);
			if (visibleItems.length <= 1) { return; }
		}
		super._processItems(items, menuRoot);
	}

	protected _processItem(item: Menu.Item): JQuery {
		let that = this,
			itemEl;

		if (item.hidden) { return; }
		if (item.name === "divider") {
			itemEl = that._createDivider(item);
		} else if (item.command) {
			itemEl = that._createActionItem(item);
			itemEl = that._createActionItemContainer(itemEl);
		}
		return itemEl;
	}

	protected _createRootEl(domElement: JQuery): JQuery {
		let autoScroll = this.options.autoScroll;
		domElement.addClass("x-app-navmenu");

		if (autoScroll) {
			$("<a href='#' class='x-icon x-icon-angle-bracket-left x-app-navmenu-btn hidden'></a>").appendTo(domElement);
		}

		let $menuContainer = $("<div class='x-app-navmenu-container'></div>")
			.width(this.options.autoFill ? 0 : "auto") // initially set width = 0, it will be calculated while reflow
			.appendTo(domElement);

		let $root = $("<ul class='x-app-navmenu-menu x-app-navbar-nav'></ul>")
			.appendTo($menuContainer);

		if (autoScroll) {
			$("<a href='#' class='x-icon x-icon-angle-bracket-right x-app-navmenu-btn hidden'></a>").appendTo(domElement);
		}

		return $root;
	}

	protected _createActionItemContainer(anchor: JQuery): JQuery {
		let el = $("<li></li>");
		el.append(anchor);
		return el;
	}

	protected _createItemEl(item: Menu.Item): JQuery {
		let anchor = $("<a class='x-menu-item' href='" +  (item.url || "#") + "'></a>");

		if (item.hidden) {
			anchor.css("display", "none");
		}
		if (item.isDefaultAction) {
			anchor.addClass("x-menu-item-default");
		}
		if (this.options.itemCssClass) {
			anchor.toggleClass(this.options.itemCssClass);
		}
		let noFocus = this.options.noFocus ||
			item.presenterOptions && item.presenterOptions.noFocus ||
			(<any>item).noFocus;
		if (noFocus) {
			anchor.attr("tabIndex", -1);
		}

		return anchor;
	}

	protected _onSelectedItemChanged(sender: Menu, name: string): void {
		let $domElement = this.$domElement;
		name = name.split("#")[0];
		$domElement.find("a.active").removeClass("active");
		$domElement.find("a[name='" + name + "']").addClass("active");
	}

	protected beforeRender(): void {}

	protected afterRender(): void {
		let that = this;

		if (!that.viewModel || that.viewModel.isEmpty()) {
			that.renderStatus("waiting");
		} else {
			if (that.options.autoScroll) {
				that._initScrollButtons();
			}
			if (that.options.autoFill) {
				if (!that._resizeSubscribed) {
					that._resizeSubscribed = true;
					core.html.windowResize.bind(that._doReflow, that);
				}

				that.reflow();
			}
			that.renderStatus("ready");
		}
	}

	protected _initScrollButtons(): void {
		let that = this,
			$me = that.$domElement,
			step = 50,
			$buttons = $me.find(".x-app-navmenu-btn");

		if ($me.length === 0)
			return;

		if (!$me[0].id) {
			$me[0].id = core.lang.uuid("q");
		}
		// expect to find two buttons (left/right)
		if ($buttons.length === 2) {
			$($buttons[0]).click(e => {
				e.preventDefault();
				that.scroll(-step);
			});
			$($buttons[1]).click(e => {
				e.preventDefault();
				that.scroll(step);
			});
		}
	}

	protected _doReflow(): void {
		let that = this;
		if (!that.domElement || !that.options.autoFill) { return; }

		let $me = that.$domElement,
			$parent = $me.parent(),
			autoScroll = that.options.autoScroll,
			vp = core.html.getDisplayViewport(),
			myId = $me[0].id,
			$menu = $me.find(".x-app-navmenu-menu"),
			$container = $me.find(".x-app-navmenu-container");

		// compute widths of all elements (except the menu's one) of the same parent
		let widthOthers = 0;
		$parent.children().each(function (): void {
			if (this.id !== myId) {
				widthOthers += $(this).outerWidth(true) + 1;
			}
		});
		// margin + padding
		let margin = $me.outerWidth(true) - $me.width();

		// compute space we have for the menu
		let width = vp.width - widthOthers - margin - core.platform.measureScrollbar();

		// compute actual width of the menu (what we need)
		let innerWidth = 0;
		$menu.children().each(function (): void {
			innerWidth += $(this).outerWidth(true) + 1;
		});

		if (innerWidth > width) {
			// we have less space than needed
			if (autoScroll) {
				let $buttons = $me.find(".x-app-navmenu-btn");
				// reduce the width of container by the width of scroll buttons
				width -= $buttons.length * $buttons.outerWidth(true);
				$container.width(width);

				$buttons.removeClass("hidden");
			} else {
				$container.width(width);

			}
		} else {
			// we have enough space
			$container.css("width", "auto");
			$menu.css("width", "auto");
			if (autoScroll) {
				let $buttons = $me.find(".x-app-navmenu-btn");
				$buttons.addClass("hidden");
			}
		}

		core.html.notifyDOMChanged();
	}

	/**
	 * Async reflow. Initialized later via mixin.
	 */
	reflow: () => void;

	scroll(step: number): void {
		let $el = this.$domElement.find(".x-app-navmenu-container"),
			left = $el.scrollLeft() + step;
		left = left < 0 ? 0 : left;
		$el.scrollLeft(left);
	}

	unload(options?: Part.CloseOptions): void {
		let that = this;
		core.html.windowResize.unbind(that._doReflow, that);
		that._resizeSubscribed = false;
		super.unload(options);
	}
}

AppNavMenuPresenter.mixin(/** @lends AppNavMenuPresenter.prototype */{
	defaultOptions: AppNavMenuPresenter.defaultOptions,
	reflow: core.lang.debounce("_doReflow", 0, true)
});

namespace AppNavMenuPresenter {
	export interface Options extends MenuPresenterBase.Options {
		autoFill?: boolean;
		autoScroll?: boolean;
		tooltips?: boolean;
		radio?: boolean;
		hideSingle?: boolean;
	}
}

core.ui.AppNavMenuPresenter = AppNavMenuPresenter;

export = AppNavMenuPresenter;
