import core = require("core");
import "lib/ui/handlebars/View";
import _ = require("underscore");

import lang = core.lang;
import Lazy = lang.Lazy;
import IDisposable = lang.IDisposable;
import ICommand = core.commands.ICommand;
import ICommandFactory = core.commands.ICommandFactory;
import ICommandLazyMap = core.commands.ICommandLazyMap;
import Command = core.commands.Command;
import keyCode = core.html.keyCode;
import Item = Menu.Item;
import Options = Menu.Options;
import PresentationItem = Menu.PresentationItem;

class Menu extends lang.Observable {
	/**
	 * Описания меню компонентов по умолчанию
	 * @type {Object}
	 */
	static Defaults: lang.Map<Options> = {};

	/**
	 * Описания меню компонентов для отдельных типов
	 * @type {Object}
	 */
	static Object: lang.Map<lang.Map<Options>> = {};

	options: Options;
	items: Item[];
	radio: boolean;
	title: string;
	hidden: string;

	constructor(...options: Options[]);
	/**
	 * @constructs Menu
	 * @extends Observable
	 * @param {...Object} options One or more options. If two or more arguments then options will be merged.
	 * @param {Array} options.items Array of menu item specifications. When merging target items will be replaced.
	 * @param {String} options.items.name
	 * @param {String} [options.items.title]
	 * @param {String} [options.items.commandName] Name of command
	 * @param {Command} [options.items.command]
	 * @param {String} [options.items.html]
	 * @param {String} [options.items.icon]
	 * @param {Number} [options.items.order]
	 * @param {Boolean} [options.items.isDefaultAction]
	 * @param {Boolean} [options.items.disabled]
	 * @param {Boolean} [options.items.hideIfDisabled]
	 * @param {Boolean} [options.items.hidden]
	 * @param {Boolean} [options.items.disableIfEmpty] For items with sub-items only. Disable the parent item if sub-menu is empty or all its items are disabled.
	 * @param {Array} options.remove Array of menu item names to remove when merge.
	 * @param {Array} options.off Deprecated alias for options.remove
	 * @param {Array} options.update Array of menu item specifications. When merging target items will be merged.
	 * @param {String} [options.title]
	 * @param {Boolean} [options.radio]
	 * @param {Boolean} [options.hidden]
	 * @example
	 * {
	 *     items: [
	 *         { name: "Edit", title: "Edit", command: core.createCommand({execute: function() {}}) }
	 *     ]
	 * }
	 */
	constructor(options?: Options) {
		super();

		let that = this;

		// more than one options should be merged
		if (arguments.length > 1) {
			options = Menu.merge.apply(Menu, arguments);
/*
		} else if (arguments.length === 1 && lang.isArray(arguments[0])) {
			options = Menu.merge.apply(Menu, arguments[0]);
*/
		}

		//that.options = lang.appendEx(that.options || options || {}, Menu.prototype.defaultOptions, {deep: true});
		that.options = options || {};

		// NOTE: различные экземпляры меню могут создаваться с одними и теми же опциями (например,
		// из Menu.Defaults). Однако, каждый экземпляр меню привязывается к различным экземплярам команд.
		// Поэтому необходимо клонировать элементы (items), чтобы привязка команд происходила корректно.
		that.items = lang.cloneEx(that.options.items, {deep: true});
		that.radio = that.options.radio;
		that.title = that.options.title;
		that.hidden = that.options.hidden;

		that._updateItems();
	}

	/**
	 * Name of last executed item if Menu was created with 'radio' option.
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	selectedItem: lang.ObservableProperty<string>;

	mergeWith(other: Menu|Options): void {
		let that = this;

		// TODO: support hierarchical menu (itemSpec.items)

		// WARN: производительность O(that.items.length * other.items.length). Можно that.items сначала загнать
		// в словарь и сделать производительность O(that.items.length + other.items.length).
		if (other.items) {
			for (let otherItem of other.items) {
				let item = that.getItem(otherItem.name);
				if (item) {
					lang.extend(item, otherItem);
				} else {
					that.items.push(lang.clone(otherItem));
				}
			}
		}

		that._updateItems();
	}

	/**
	 * Get a menu item by predicate.
	 * @param predicate A callback accepting a menu item
	 * @return {Object}
	 */
	findItem(predicate: (item: Item) => boolean): Item {
		let resultItem: Item;
		this._traverseItems(this.items, function (item) {
			if (predicate(item)) {
				resultItem = item;
				return true;
			}
		});
		return resultItem;
	}

	/**
	 * Get a menu item by its name.
	 * @param name name of menu item
	 * @return {Object}
	 */
	getItem(name: string): Item {
		return this.findItem(item => item.name === name);
	}

	/**
	 * Get command of menu item with the specified name.
	 * @param {String} name
	 * @return {Command}
	 */
	getCommand(name: string): ICommand {
		let item = this.getItem(name);
		return item ? <ICommand>item.command : undefined;
	}

	/**
	 * Remove item with specified name
	 * @param {String} name
	 */
	removeItem(name: string): boolean {
		let that = this;
		for (let i = that.items.length - 1; i >= 0; i--) {
			let item = that.items[i];
			if (item.name === name) {
				that.items.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	/**
	 * Callback to call before executing item's command. Should be supported by a presenter
	 */
	onItemExecuting: (args: any) => void;

	/**
	 * Execute command of item with specified name.
	 * @param {String} name Name of menu item
	 * @param {Object} args Arguments for item's command
	 */
	execute(name: string, args?: any): any {
		if (!name) {
			throw new Error("Menu.execute: name of a menu item is expected");
		}
		let item = this.getItem(name);
		if (!item) {
			throw new Error("Menu.execute: a menu item with name '" + name + "' was not found");
		}
		return this.executeItem(item, args);
	}

	/**
	 * Execute command of specified item
	 * @param {Object} item Menu item
	 * @param {Object} args Arguments for item's command
	 * @static
	 */
	executeItem(item: Item, args?: any): any {
		// WAS: if (!Menu.canExecuteItem(item)) return; (see WC-1637)
		if (!item.command) {
			return;
		}
		args = lang.extend({}, item.params, args, { name: item.name });
		return (<ICommand>item.command).execute(args);
	}

	/**
	 * Traverses all menu items recursively and call specified callback.
	 * @param {Function} visitor A callback accepting a menu item
	 * @returns {Boolean} true if visitor broke iteration (i.e. returned true)
	 */
	acceptVisitor(visitor: (item: Item) => any): boolean {
		return this._traverseItems(this.items, visitor);
	}

	private _traverseItems(items: Item[], visitor: (item: Item) => any): boolean {
		if (!items) { return false; }

		for (let item of items) {
			if (visitor(item)) {
				return true;
			}
			if (this._traverseItems(item.items, visitor)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Subscribe the specified callback on execution of any menu item.
	 * Once the callback executed it's unsubscribed (i.e. it's executed only once).
	 * @param {Function} callback If callback returns 'false' then it won't be unsubscribed
	 */
	onceExecuted(callback: (args: any) => any): void {
		let that = this,
			disposables: IDisposable[] = [];
		// subscribe on 'executed' event for each item's command
		that.acceptVisitor((item: Item) => {
			let disposable: IDisposable,
				command: Command = <Command>item.command;
			if (command) {
				disposable = command.subscribe("executed", function (args) {
					let res = callback(args);
					if (res !== false) {
						for (let disposable of disposables) {
							disposable.dispose();
						}
					}
				});
				disposables.push(disposable);
			}
		});
	}

	/**
	 * Bind menu items to supplied commands.
	 * @param {Object} commands A map where keys are command names, values are command instances.
	 * @param {*} [ctx] A context used to call command factories (if item's `command` field is a function).
	 * @param {Object} [params] Additional parameters for all menu items, they will be merged with items' own params.
	 */
	bindToCommands(commands?: ICommandLazyMap, ctx?, params?): void {
		let that = this;
		let commandInstances: Command[] = [];
		that.acceptVisitor((item: Item) => {
			// merge params
			if (params) {
				item.params = lang.extend(item.params || {}, params);
			}
			// if menuitem doesn't have a command then try to substitute it from commands by name
			let commandLazy = item.command;
			if (commandLazy === undefined && commands) {
				if (item.commandName) {
					commandLazy = commands[item.commandName];
				}
				if (!commandLazy && item.name) {
					commandLazy = commands[item.name];
				}
			}
			// command may be a factory
			let command = <Command>lang.unlazy(commandLazy, ctx);
			// copy command's name/title into menuitem
			if (command && (!item.name || !item.title)) {
				if (!item.name && command.name) {
					item.name = command.name;
				}
				if (!item.title && command["title"]) {
					item.title = command["title"];
				}
			}
			if (item.getMenu && ctx) {
				// item with dynamic submenu, bind getMenu to the context
				item.getMenu = <any>_.partial(item.getMenu, ctx);
			}

			if (that.radio && command) {
				if (commandInstances.indexOf(command) < 0) {
					// команда ранее не встречалась
					commandInstances.push(command);
				}
			}

			item.command = command;
		});

		if (commandInstances.length) {
			for (let command of commandInstances) {
				command.bind("executed", args => {
					// Если команду выполняют явно, не через меню, то name может и не быть, но тогда мы не знаем к чему она относится
					args = args || {};
					let name = args.name;
					if (name) {
						if (args.result && lang.isPromise(args.result)) {
							args.result.done(() => {
								that._toggleRadio(name);
							});
						} else {
							that._toggleRadio(name);
						}
					}
				});
			}
		}
	}

	removeItemsWithoutCommand(): void {
		let that = this;

		if (!that.items) { return; }

		for (let i = that.items.length; i--; ) {
			let item = that.items[i];

			// call recursively for the item
			Menu.prototype.removeItemsWithoutCommand.call(item);

			// keep the item with command or sub-items
			if (item.command || item.getMenu || item.items && item.items.length) {
				continue;
			}
			// keep the divider only if it is not the first, not the last and not before another divider
			if (item.name === "divider" && i > 0 && i < that.items.length - 1 && that.items[i + 1].name !== "divider") {
				continue;
			}

			// otherwise remove the item
			that.items.splice(i, 1);
		}
	}

	bindToPart(part: { commands: ICommandLazyMap }, params?): void {
		let that = this;
		that.bindToCommands(part.commands, part, params);
		that.removeItemsWithoutCommand();
	}

	/**
	 * Execute menu item with hotkey by given keyboard event
	 * @param {jQuery.Event} event - keyboard event
	 * @return {boolean} true if a menuItem executed
	 */
	executeHotkey(event: JQueryKeyEventObject): boolean {
		if (!event) {
			throw new Error("Menu.executeHotkey: there is no event was specified.");
		}
		let that = this,
			hotkeyItem = that.getHotkeyItem(event);
		if (hotkeyItem) {
			let $target = $(event.target);
			if ($target.is(":focus")) {
				// force losing focus to update binding
				$target.trigger("blur");
				that.executeItem(hotkeyItem, {});
				$target.trigger("focus");
			} else {
				that.executeItem(hotkeyItem, {});
			}
			return true;
		}
		return false;
	}

	/**
	 * Returns the menuitem with hotkey corresponding to the event
	 * @param {jQuery.Event} event
	 * @return {Object} menuItem
	 */
	getHotkeyItem(event: JQueryKeyEventObject): Item {
		let that = this,
			// get special keys if any
			special: string = Menu.specialKeys[event.which],
			// get char if any
			character: string = (special === undefined) && String.fromCharCode(event.which).toLowerCase(),
			eventKeys: string[] = [];

		// process default action
		if (event.which === core.html.keyCode.ENTER && !event.ctrlKey && !event.altKey && !event.shiftKey) {
			return that.getDefaultItem();
		}
		// check control keys
		if (event.ctrlKey)  { eventKeys.push("ctrl"); }
		if (event.metaKey)  { eventKeys.push("meta"); }
		if (event.altKey)   { eventKeys.push("alt"); }
		if (event.shiftKey) { eventKeys.push("shift"); }
		// build keys combination
		if (special)   {  eventKeys.push(special); }
		if (character) { eventKeys.push(character); }

		return that.findItem(function (item) {
			if (!item.hotKey) return false;
			let menuItemKeys = item.hotKey.split("+");
			if (menuItemKeys.length !== eventKeys.length) return false;
			return lang.every(eventKeys, ek => menuItemKeys.indexOf(ek) !== -1) && Menu.canExecuteItem(item);
		});
	}

	/**
	 * Returns the item that should be executed by default
	 * @returns {Item}
	 */
	getDefaultItem(): Item {
		return this.findItem(item => item.isDefaultAction && Menu.canExecuteItem(item));
	}

	isEmpty(): boolean {
		return lang.isEmpty(this.items);
	}

	/**
	 * Returns true if and only if the menu contains items for the specified commands
	 * @param {Array} commands Array of commands
	 * @returns {Boolean}
	 */
	hasOnly(commands: ICommand[]): boolean {
		let found = 0;
		this.acceptVisitor(function (item) {
			if (!item.command) {
				return true;
			}
			let idx = commands.indexOf(<ICommand>item.command);
			if (idx < 0) {
				return true;
			}
			found++;
		});
		return commands.length === found;
	}

	protected _updateItems(): void {
		let that = this;
		// sort items by order
		that.items = lang.sortBy(that.items, item => item.order || 0);
		// copy params of items with submenu to their subitems
		that.acceptVisitor(function (item) {
			if (item.items && item.items.length && item.params) {
				for (let subitem of item.items) {
					subitem.params = lang.extend({}, item.params, subitem.params);
				}
			}
		});
	}

	protected _toggleRadio(itemName: string): void {
		let that = this;
		// NOTE: executed item is already selected, it can mean "unselected"
		if (that.options.radioToggle && that.selectedItem() === itemName) {
			that.selectedItem(undefined);
		} else {
			that.selectedItem(itemName);
		}
	}

	// NOTE: очень мутная реализация, а выигрыш в скорости весьма сомнителен
	//static merge(...sources: Options[]): Options {
	//	// TODO: support hierarchy (item.items)
	//
	//	// filter non-empty sources
	//	sources = sources.filter(source => !!source);
	//	// if only one arg is not empty, than return it
	//	if (sources.length === 1) {
	//		return sources[0];
	//	}
	//
	//	let options: Options = {}, // result options
	//		result: Item[] = [], // result items
	//		resultIndexMap: lang.Map<number[]> = {}; // mapping: name => array of indexes in result items
	//
	//	for (let source of sources) {
	//		// добавляем новые свойства
	//		options = lang.extend(options, source);
	//
	//		// отдельно обрабатываем свойства items, replace, remove/off, update
	//		let items = source.items,
	//			replace = source.replace,
	//			remove = source.remove || source.off,
	//			update = source.update;
	//		if (items) {
	//			result = [];
	//			resultIndexMap = {};
	//			for (let item of items) {
	//				let indices = resultIndexMap[item.name];
	//				if (!indices) {
	//					resultIndexMap[item.name] = [result.length];
	//				} else {
	//					indices.push(result.length);
	//				}
	//				result.push(lang.clone(item));
	//			}
	//		}
	//		if (replace) {
	//			let oldResult = result,
	//				oldResultIndexMap = resultIndexMap;
	//			result = [];
	//			resultIndexMap = {};
	//			for (let itemOrName of replace) {
	//				let item: Item = lang.isString(itemOrName) ? { name: itemOrName } : lang.clone(itemOrName),
	//					indices = resultIndexMap[item.name];
	//				if (!indices) {
	//					resultIndexMap[item.name] = [result.length];
	//				} else {
	//					indices.push(result.length);
	//				}
	//
	//				// find old item with the same name
	//				// NOTE: use only first found item
	//				let oldIndices = oldResultIndexMap[item.name],
	//					oldItem = oldIndices && oldIndices.length && oldResult[oldIndices[0]];
	//				if (oldItem) {
	//					item = lang.append(item, oldItem);
	//				}
	//
	//				result.push(item);
	//			}
	//		}
	//		if (remove) {
	//			for (let name of remove) {
	//				let indices = resultIndexMap[name];
	//				if (indices) {
	//					for (let i of indices) {
	//						delete result[i];
	//					}
	//					delete resultIndexMap[name];
	//				}
	//			}
	//		}
	//		if (update) {
	//			for (let item of update) {
	//				var indices: number[] = resultIndexMap[item.name];
	//				if (indices) {
	//					for (let i of indices) {
	//						lang.extend(result[i], item);
	//					}
	//				} else {
	//					resultIndexMap[item.name] = [result.length];
	//					result.push(lang.clone(item));
	//				}
	//			}
	//		}
	//	}
	//
	//	// delete items modifying props
	//	delete options.replace;
	//	delete options.remove;
	//	delete options.off;
	//	delete options.update;
	//
	//	// set non-empty items in result options
	//	options.items = result.filter(item => !!item);
	//
	//	return options;
	//}

	/**
	 * Merge menu options
	 * @static
	 * @param {...Object} sources One or more options. If two or more arguments then options will be merged.
	 * @param {Array} [sources.items] Array of menu item specifications. When merging target items will be ignored and totally replaced.
	 * @param {Array} [sources.replace] Array of menu item specifications or names. When merging target items will be replaced, but items with the same names will be merged.
	 * @param {Array} [sources.remove] Array of menu item names to remove when merge.
	 * @param {Array} [sources.update] Array of menu item specifications. When merging target items will be merged.
	 */
	static merge(...sources: Options[]): Options {
		// TODO: support hierarchy (item.items)

		// filter non-empty sources
		sources = sources.filter(source => !!source);
		// if only one arg is not empty, than return it
		if (sources.length === 1) {
			return sources[0];
		}

		let options: Options = {}, // result options
			result: Item[] = []; // result items

		for (let source of sources) {
			// добавляем новые свойства
			options = lang.extend(options, source);

			// отдельно обрабатываем свойства items, replace, remove/off, update
			result = mergeItems(result, source);
		}

		// delete items modifying props
		delete options.replace;
		delete options.remove;
		delete options.off;
		delete options.update;

		options.items = result;
		return options;
	}

	/**
	 * Returns default menu options for component with overrides in Menu.Defaults and Menu.Object
	 * @static
	 * @param defaultOptions
	 * @param [componentName]
	 * @param [objectName]
	 * @return {*}
	 */
	static defaultsFor(defaultOptions: Options, componentName?: string, objectName?: string): Options {
		let objectMenus = objectName && Menu.Object[objectName];
		return Menu.merge(
			defaultOptions,
			componentName && Menu.Defaults[componentName],
			objectMenus && objectMenus[componentName]);
	}

	/**
	 * Returns HTML for the icon of menuItem
	 * @static
	 * @param menuItem
	 * @return {String}
	 */
	static getIconHtml(menuItem: PresentationItem): string {
		let iconProvider = core.ui.iconProvider;
		return iconProvider && iconProvider.getIcon(menuItem.icon || menuItem.name) || "";
	}

	/**
	 * Returns the encoded title for menuItem
	 * @static
	 * @param menuItem
	 * @return {String}
	 */
	static getItemTitle(menuItem: PresentationItem): string {
		return lang.encodeHtml(menuItem.title || menuItem.name);
	}

	/**
	 * Returns HTML for menuItem
	 * @static
	 * @param {Object} menuItem
	 * @param {"both"|"icon"|"text"} [presentation]
	 * @return {String}
	 */
	static getItemHtml(menuItem: PresentationItem, presentation?: Menu.ItemPresentation): string {
		let html = menuItem.html,
			iconHtml: string,
			titleHtml: string;

		presentation = presentation || menuItem.presentation;
		if (html) {
			return lang.isFunction(html) ? html.call(menuItem) : html;
		}

		if (!presentation || presentation === "both") {
			iconHtml = Menu.getIconHtml(menuItem);
			let breakpoint = menuItem.labelHiddenBreakpoint;
			breakpoint = (breakpoint === false || breakpoint === "none") ? false : (breakpoint || "xs");
			if (breakpoint === true) { breakpoint = "xs"; }
			if (!iconHtml) { breakpoint = false; }
			let className;
			if (breakpoint) {
				// hidden-md means element is hidden ONLY at [992; 1200), this is useless
				switch (breakpoint) {
					case "xs":
						className = "hidden-xs";
						break;
					case "sm":
						className = "hidden-xs hidden-sm";
						break;
					case "md":
						className = "hidden-xs hidden-sm hidden-md";
						break;
				}
			}
			titleHtml = "<span" + (className ? " class='" + className +"'" : "") + ">" + Menu.getItemTitle(menuItem) + "</span>";
			return iconHtml + titleHtml;
		} else if (presentation === "icon") {
			iconHtml = Menu.getIconHtml(menuItem);
			if (iconHtml) {
				return iconHtml;
			}
		}
		return Menu.getItemTitle(menuItem);
	}

	/**
	 * Return true if menu item can be executed
	 * @static
	 * @param {Object} menuItem
	 * @returns {Boolean} true if menu item can be executed
	 */
	static canExecuteItem(menuItem: Item): boolean {
		if (!menuItem) {
			return false;
		}
		let command = <ICommand>menuItem.command;
		return command && command.execute && (!command.canExecute || command.canExecute());
	}

	static isItemEnabled(item: Item): boolean {
		if (item.name === "divider" && !item.hidden) {
			return true;
		}
		if (item.hidden || item.disabled) {
			return false;
		}
		if (item.command)
			return (<ICommand>item.command).canExecute();

		return item.items && item.items.length > 0;
	}

	static isItemVisible(item: Item): boolean {
		if (item.name === "divider" && !item.hidden) {
			return true;
		}
		if (item.hidden || (item.disabled && item.hideIfDisabled)) {
			return false;
		}
		if (item.hideIfDisabled) {
			if (item.command) {
				return (<ICommand>item.command).canExecute();
			}
			return false;
		}
		return true;
	}

	static create(options?: Options|Menu): Menu {
		let menu = <Menu>options;
		if (menu && menu.bind && menu.trigger && menu.selectedItem) {
			menu._updateItems();
			return menu;
		}
		return new Menu(options);
	}

	/**
	 * Special key codes for executeHotKey method
	 */
	static specialKeys: { [key: number]: string; } = {
		[10]: "enter",
		[keyCode.ENTER]: "enter",
		[keyCode.ESCAPE]: "esc",
		[keyCode.SPACE]: "space",
		[keyCode.INSERT]: "ins",
		[keyCode.DELETE]: "del",
		[keyCode.BACKSPACE]: "backspace",
		[keyCode.TAB]: "tab",
		[keyCode.PAGE_UP]: "pageup",
		[keyCode.PAGE_DOWN]: "pagedown",
		[keyCode.END]: "end",
		[keyCode.HOME]: "home",
		[keyCode.LEFT]: "left",
		[keyCode.UP]: "up",
		[keyCode.RIGHT]: "right",
		[keyCode.DOWN]: "down",
		[keyCode.F1]: "f1",
		[keyCode.F2]: "f2",
		[keyCode.F3]: "f3",
		[keyCode.F4]: "f4",
		[keyCode.F5]: "f5",
		[keyCode.F6]: "f6",
		[keyCode.F7]: "f7",
		[keyCode.F8]: "f8",
		[keyCode.F9]: "f9",
		[keyCode.F10]: "f10",
		[keyCode.F11]: "f11",
		[keyCode.F12]: "f12",
	};
}

namespace Menu {
	export interface Options {
		items?: Item[];
		replace?: (Item|string)[];
		remove?: string[];
		/**
		 * @deprecated Use 'remove' option
		 */
		off?: string[];
		update?: Item[];
		/**
		 * Radio menu: name of last executed item set into selectedItem property
		 */
		radio?: boolean;
		/**
		 * Mode of radio menu: selected item can be unselected (by executing one more time)
		 */
		radioToggle?: boolean;
		// TODO: Это что?
		title?: string;
		// TODO: Это что?
		hidden?: string;

		[key: string]: any;
	}

	export interface PresentationItem {
		name?: string;
		title?: string;
		badge?: string;
		cssClass?: string;
		html?: string | (() => string);
		icon?: string;
		hint?: string;
		/**
		 * alias for hint
		 */
		tooltip?: string;
		presentation?: Menu.ItemPresentation;
		/**
		 * For item with icon and title, label for title will have 'hidden-xs' class by default,
		 * this option allow to override hidden breakpoint or disable it.
		 */
		labelHiddenBreakpoint?: "xs"|"sm"|"md"|"lg"|"none"|boolean;
	}

	export interface Item extends Menu.PresentationItem {
		command?: Lazy<ICommand>;
		commandName?: string;
		params?: lang.Map<any>;
		order?: number;
		disabled?: boolean;
		disableIfEmpty?: boolean;
		hidden?: boolean;
		hideIfDisabled?: boolean;
		isDefaultAction?: boolean;
		hotKey?: string;
		items?: Item[];
		url?: string;
		/**
		 * Options for DropDownMenuPresenter (for item-submenu with items) or
		 * additional presentation options for ordinary item.
		 */
		presenterOptions?: any;
		getMenu?: (ctx?: any) => { items?: Item[] };
		getPart?: () => core.ui.IPart;
		html?: string;
		[key: string]: any;
	}
	export type ItemPresentation = "both" | "icon" | "text";
}

function mergeItems(result: Item[], source: Options): Item[] {
	let items = source.items,
		replace = source.replace,
		remove = source.remove || source.off,
		update = source.update;
	if (items) {
		result = items.map(item => lang.clone(item));
	}
	if (replace) {
		result = replace.map(itemOrName => {
			let item: Item = lang.isString(itemOrName) ? { name: itemOrName } : lang.clone(itemOrName),
				oldItem = lang.find(result, i => i.name === item.name);
			return oldItem ? lang.append(item, oldItem) : item;
		});
	}
	if (remove) {
		result = result.filter(item => remove.indexOf(item.name) < 0);
	}
	if (update) {
		for (let item of update) {
			let found = false;
			for (let oldItem of result) {
				if (oldItem.name === item.name) {
					lang.extend(oldItem, item);
					found = true;
				}
			}
			if (!found) {
				result.push(lang.clone(item));
			}
		}
	}

	return result;
}

/**
 * Register HB helper 'if-menu'.
 * @example
 * {{#if-menu myMenu}}...{{/if-menu}}
 */
core.ui.View.Handlebars.registerHelper("if-menu", function(menu, options) {
	if (menu && !menu.isEmpty()) {
		return options.fn(this);
	} else {
		return options.inverse(this);
	}
});

core.ui.Menu = Menu;
export = Menu;
