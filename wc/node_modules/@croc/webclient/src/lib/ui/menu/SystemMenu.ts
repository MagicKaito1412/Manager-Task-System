import $ = require("jquery");
import core = require("core");
import Menu = require("lib/ui/menu/Menu");
import DropDownMenuPresenter = require("lib/ui/menu/DropDownMenuPresenter");
import View = require("lib/ui/handlebars/View");
import defaultTemplate = require("xhtmpl!lib/ui/templates/SystemMenu.hbs");

import lang = core.lang;

class SystemMenu extends View {
	/** Default options
	 * @type {Object}
	 * @property {Function|String} template Template
	 * @property {String} openItemCssClass CSS-class for currently opened item's element
	 * @property {Array} items Array of menu items descriptions
	 */
	static defaultOptions: SystemMenu.Options = {
		template: defaultTemplate,
		//retargetElementSelector: ".x-app-navbar", //jQ-selector of parent element for retargeting (moving item's popup)
		//retargetScreenWidth: 767, //Screen width in pixel when items' popup will be retargeted
		openItemCssClass: undefined,
		items: undefined
	};

	rootItems: lang.ObservableCollection<SystemMenu.RootItem>;
	options: SystemMenu.Options;

	/**
	 * @class SystemMenu
	 * @extends View
	 */
	constructor(options: SystemMenu.Options) {
		options = SystemMenu.mixOptions(options, SystemMenu.defaultOptions);
		super(options);

		this.rootItems = new lang.ObservableCollection<SystemMenu.RootItem>();

		if (this.options.items && this.options.items.length) {
			lang.forEach(this.options.items, (item) => {
				this.addRootItem(item);
			});
		}
	}

	/**
	 * Add (or update) a new (existing) item.
	 * @param {Object} itemMd
	 * @param {String} itemMd.name
	 * @param {Number} [itemMd.order]
	 * @param {String} [itemMd.title]
	 * @param {String} [itemMd.html]
	 * @param {String} [itemMd.badge]
	 * @param {String} [itemMd.icon]
	 * @param {Command} [itemMd.command]
	 * @param {Function} [itemMd.getMenu]
	 * @param {Array} [itemMd.items]
	 * @param {Function} [itemMd.getPart]
	 * @return {Observable} Observable-object created from json metadata
	 */
	addRootItem(itemMd: Menu.Item): SystemMenu.RootItem {
		let item = this.getRootItem(itemMd.name);
		if (item) {
			lang.forEach(itemMd, (value, name) => {
				lang.set(item, name, value);
			});
		} else {
			item = new SystemMenu.RootItem(itemMd);
			this.rootItems.add(item);
		}
		return item;
	}

	/**
	 * Return item by name
	 * @param {String} name
	 * @returns {Observable} Root item descriptor
	 */
	getRootItem(name: string): SystemMenu.RootItem {
		let items: any[] = this.rootItems.all();
		return lang.find(items, (i) => {
			if (i.name === name) {
				return i;
			}
		});
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;

		that.rootItems.reset(lang.sort(that.rootItems.all(), function (i1, i2) {
			return lang.compare(i1.order() || 0, i2.order() || 0);
		}));

		super.doRender(domElement);
		let $domElement = that.$domElement;

		$domElement.addClass("x-sys-menu");

		$domElement.find("a").each(function () {
			let linkEl = $(this),
				name = linkEl.attr("data-item-name"),
				submenuModel,
				submenuPresenter,
				itemContainer = linkEl.parent(),
				item = that.getRootItem(name);

			// root menu item can be a menu or something else
			submenuModel = item.getMenu ?
			{ getMenu : item.getMenu } :
				item.items ?
					new Menu({items : item.items}) :
					undefined;

			if (submenuModel) {
				submenuPresenter = DropDownMenuPresenter.create({viewModel: submenuModel});
				submenuPresenter.render(itemContainer);
			} else if (item.getPart && typeof item.getPart === "function") {
				linkEl.mousedown(function (e: JQueryEventObject) {
					if (itemContainer.hasClass("open")) {
						// prevent closing popup on mouse down - it will be explicitly closed in _onShow
						e.preventDefault();
						e.stopPropagation();
					}
				}).buttonClick(function (e: JQueryEventObject) {
					e.preventDefault();
					e.stopPropagation();
					that._onShow($(this), item, itemContainer);
				});
			}
		});
	}

	_onShow (link: JQuery, rootItem: SystemMenu.RootItem, itemContainer: JQuery): void {
		let that = this,
			isActive = itemContainer.hasClass("open"),
			part,
			$part;

		if (!rootItem || !rootItem.getPart) { return; }

		that.$domElement.find("li.open").removeClass("open");

		if (rootItem._part) {
			rootItem._part.dispose();
			rootItem._part = undefined;
		}

		if (!isActive) {
			rootItem._part = part = rootItem.getPart();

			part.render(that.$domElement);
			$part = part.$domElement;

			if (part.bind) {
				part.bind("unload", () => {
					itemContainer.removeClass("open");
					rootItem._part = undefined;
				});
			}
			itemContainer.addClass("open");
			if (that.options.openItemCssClass && $part) {
				$part.addClass(that.options.openItemCssClass);
			}

			// ограничиваем высоту popup экраном, чтобы юзер мог проскроллировать его:
			if ($part) {
				$part.css("max-height", core.html.getDisplayViewport().height - $part.offset().top + core.html.$window.scrollTop());
			}
		}
	}
}

namespace SystemMenu {
	export interface Options extends View.Options {
		template?: HandlebarsTemplateDelegate;
		openItemCssClass?: string;
		items?: Menu.Item[];
	}

	// TODO: RootItem должен быть общим для Menu - возможно отдельной реализации BoundMenu
	export class RootItem extends lang.Observable {
		name: string;
		getMenu: Function;
		getPart: Function;
		items: Menu.Item[];
		_part: any;

		/**
		 * @observable-property {String}
		 */
		@lang.decorators.observableAccessor()
		title: lang.ObservableProperty<string>;
		/**
		 * @observable-property {String}
		 */
		@lang.decorators.observableAccessor()
		html: lang.ObservableProperty<string | (() => string)>;
		/**
		 * @observable-property {String}
		 */
		@lang.decorators.observableAccessor()
		badge: lang.ObservableProperty<string>;
		/**
		 * @observable-property {String}
		 */
		@lang.decorators.observableAccessor()
		icon: lang.ObservableProperty<string>;
		/**
		 * @observable-property {Number}
		 */
		@lang.decorators.observableAccessor()
		order: lang.ObservableProperty<number>;
		/**
		 * @observable-property {Boolean}
		 */
		@lang.decorators.observableAccessor({init: false})
		hidden: lang.ObservableProperty<boolean>;
		/**
		 * @observable-property {Command}
		 */
		@lang.decorators.observableAccessor()
		command: lang.ObservableProperty<lang.Lazy<core.commands.ICommand>>;

		/**
		 * @class RootItem
		 * @param itemMd
		 * @param {String} itemMd.name
		 * @param {Number} [itemMd.order]
		 * @param {Boolean} [itemMd.hidden]
		 * @param {String} itemMd.title
		 * @param {String} [itemMd.html]
		 * @param {String} [itemMd.badge]
		 * @param {String} [itemMd.icon]
		 * @param {Command} [itemMd.command]
		 * @param {Function} [itemMd.getMenu]
		 * @param {Array} [itemMd.items]
		 * @param {Function} [itemMd.getPart]
		 */
		constructor(itemMd: Menu.Item) {
			super();
			var that = this;
			that.name = itemMd.name;
			that.title(itemMd.title);
			that.html(itemMd.html);
			that.badge(itemMd.badge);
			that.icon(itemMd.icon);
			that.order(itemMd.order);
			that.hidden(itemMd.hidden);
			that.command(itemMd.command);
			that.getMenu = itemMd.getMenu;
			that.getPart = itemMd.getPart;
			that.items = itemMd.items;
		}

		getHtml () {
			var item = this,
				html = item.html(),
				icon;
			if (!html) {
				// no html explicitly specify, construct icon / title / badge
				icon = item.icon() || item.name;
				if (core.ui.iconProvider) {
					icon = core.ui.iconProvider.getIcon(icon, {alone: true}) || "";
				}
				if (icon) {
					html = icon;
				} else {
					html = lang.encodeHtml(item.title() || item.name);
				}
			}
			return html;
		}
	}
}

core.ui.SystemMenu = SystemMenu;
export = SystemMenu;
