import $ = require("jquery");
import core = require("core");
import Part = require("lib/ui/Part");
import Menu = require("lib/ui/menu/Menu");
import binding = require("lib/binding");
import resources = require("i18n!lib/nls/resources");
import lang = core.lang;

class DropDownMenuPresenter extends Part {
	static defaultOptions: DropDownMenuPresenter.Options = {
		/**
		 * Trigger dropdown menu above element instead of below (by default)
		 * @type {Boolean}
		 */
		dropup: false,
		/**
		 * Bind container element (anchor by default) enable state to availability of any menu items
		 * @type {Boolean}
		 */
		disableIfEmpty: true,
		toggleButtonIcon: "menu",
		tooltips: true
	};

	options: DropDownMenuPresenter.Options;
	viewModel: any;	// TODO: надо бы задать тип (DropDownMenuPresenter.Model | Menu), но очень удобно получается с getMenu
	link: JQuery;
	menuEl: JQuery;

	/**
	 * @class DropDownMenuPresenter
	 * @extends Part
	 */
	constructor (options?: DropDownMenuPresenter.Options) {
		if (!core.lang.isPlainObject(options)) {
			options = {viewModel: options};
		}
		options = DropDownMenuPresenter.mixOptions(options, DropDownMenuPresenter.defaultOptions);
		super(options);

		if (options && options.viewModel) {
			this.setViewModel(options.viewModel);
		}
	}

	setViewModel (model: DropDownMenuPresenter.Model): void {
		let that = this;
		if (lang.Observable.isObservable(that.viewModel)) {
			that.viewModel.unbind("change", null, that);
		}
		super.setViewModel(model);
		if (lang.Observable.isObservable(that.viewModel)) {
			that.viewModel.bind("change", that._onMenuChanged, that);
		}
		if (that.domElement) {
			that.rerender();
		}
	}

	dispose (options?: core.ui.Part.CloseOptions): void {
		let that = this;
		if (lang.Observable.isObservable(that.viewModel)) {
			that.viewModel.unbind("change", null, that);
		}
		super.dispose(options);
	}

	protected doRender (domElement: JQuery|HTMLElement): core.lang.Promisable<void> {
		let that = this,
			container = $(domElement);

		super.doRender(domElement);

		if (!container.hasClass("dropdown-toggle")) {
			let anchorInContainer = container.find(".dropdown-toggle");
			that.link = anchorInContainer.length ? anchorInContainer :
				$("<a class='btn btn-default dropdown-toggle' href='#'>"
					+ (core.ui.iconProvider && that.options.toggleButtonIcon ? core.ui.iconProvider.getIcon(that.options.toggleButtonIcon) : "")
					+ "</a>")
					.appendTo(container);
		} else {
			// the supplied element is a link itself, so container will its parent
			that.link = container;
			container = container.parent();
		}
		container.addClass("dropdown");
		if (that.options.dropup) {
			container.addClass("dropup");
		}
		// user root css-class
		if (that.options.cssClassContainer) {
			container.addClass(that.options.cssClassContainer);
		}

		that.link
			.attr("data-toggle", "dropdown") // support Bootstrap Dropdown
			.dropdown() // init Bootstrap Dropdown
			// support space to open dropdown
			.buttonClick(function (): void {
				if ($(this.parentElement).hasClass("open")) {
					that.onShow();	// reinitialize menu on opening
				}
			});

		that.menuEl = $("<ul class='dropdown-menu' role='menu'>").appendTo(container);
		if (that.options.cssClass) {
			container.addClass(that.options.cssClass);
		}
		that.menuEl.on("click", "a", function (e: JQueryEventObject): void|boolean {
			let $this = $(this);
			let $item = $this.parent(),
				name = $item.data("item-name"),
				args = $item.data("command-params") || {};
			if (name && that.viewModel) {
				args.$event = e;
				e.preventDefault();
				if (that.viewModel.onItemExecuting) {
					that.viewModel.onItemExecuting.call(that, args);
				}
				if (!args.cancel) {
					that.viewModel.execute(name, args);
				}
			} else if (!name && $this.attr("href") === "#") {
				return false;
			}
		});

		container.keydown(function (e: JQueryEventObject): void {
			let isActive = container.hasClass("open");
			switch (e.which) {
				case core.html.keyCode.TAB:
					// close on Tab
					if (isActive) {
						that.link.dropdown("toggle");
					}
					break;
			}
		});
		// radio?
		// reverse?

		that._bindToggleLinkToItems();
	}

	protected _bindToggleLinkToItems (): void {
		let that = this;
		//if not items list is dynamic
		if (that.link && that.options.disableIfEmpty && that.viewModel && !that.viewModel.getMenu) {
			// NOTE: binding should be auto-disposed when DOM element is removed
			binding.databind(
				binding.html(that.link, "enabled"),
				binding.expr(that.viewModel, function () {
					let menu = this;
					return menu.items.some((item, i) => {
						let cmd = item.command;
						if (!cmd) { return false; }
						// simulate getting command as an observable property
						menu.trigger("get", menu, { prop: "command" + i, value: cmd });
						return cmd.canExecute();
					});
				})
			);
		}
	}

	/**
	 * On opening dropdown menu (toggle button/link was clicked)
	 */
	protected onShow(): void {
		let that = this;

		if (that.viewModel.getMenu) {
			let menuOrTask = that.viewModel.getMenu();
			if (core.lang.isPromise(menuOrTask) && menuOrTask.state() === "pending") {
				that._renderWaitStub(that.menuEl);
			}
			core.lang.when(menuOrTask).then((newModel) => {
				let getMenuFn;
				if (newModel) {
					getMenuFn = newModel.getMenu || that.viewModel.getMenu;
					if (lang.Observable.isObservable(that.viewModel)) {
						that.viewModel.unbind("change", null, that);
					}
					that.viewModel = Menu.create(newModel);
					that.viewModel.getMenu = getMenuFn;
					if (lang.Observable.isObservable(that.viewModel)) {
						that.viewModel.bind("change", that._onMenuChanged, that);
					}
				}
				if (!newModel || !that.viewModel.items) {
					that.viewModel.items = [];
				}
				that._renderItems(that.viewModel.items, that.menuEl);
			});
		} else {
			that._renderItems(that.viewModel.items, that.menuEl);
		}
	}

	unload (options?: Part.CloseOptions): void {
		this.clear();
		super.unload(options);
	}

	clear (): void {
		let that = this,
			container = that.menuEl.parent();
		if (container && container.hasClass("open")) {
			that.link.dropdown("toggle");
		}
		this.menuEl.empty();
	}

	toggle (): void {
		this.link && this.link.click();
	}

	protected _onMenuChanged (): void {
		this.clear();
	}

	protected _renderItems (items: Menu.Item[], $menu: JQuery): void {
		let that = this,
			count = 0,
			countIcon = 0;

		$menu.empty();

		if (!items) { return; }

		items.forEach((item) => {
			let $item = that._renderItem(item);
			if ($item) {
				$item.appendTo($menu);
				count += 1;
				if ($item.data("icon") === "1") {
					countIcon += 1;
				}
			}
		});
		// hide empty menu
		if (count === 0) {
			$menu.addClass("-empty");
		} else {
			$menu.removeClass("-empty");

			// если всех элементы presentation: "icon", то надо удалить min-width: 160px
			if (countIcon === count) {
				that.menuEl.css("min-width", "initial");
			}
		}
	}

	protected _renderItem(item: Menu.Item): JQuery {
		let that = this;
		let $item;
		if (item.name === "divider" && !item.hidden) {
			$item = that._createDivider(item);
		} else if (item.name === "header" && !item.hidden) {
			$item = that._createHeader(item);
		} else if (Menu.isItemVisible(item)) {
			$item = that._createItemEl(item);

			$item.data("icon", (item.presentation || this.options.itemPresentation) === "icon" ? "1" : "0");

			// NOTE: хак, чтобы не вызывать canExecute 2-ой раз:
			// если заданы hideIfDisabled и command, при этом isItemVisible==true (выше),
			// то это означает, что canExecute команды точно вернул true (см. isItemVisible)
			let enabled = item.hideIfDisabled && item.command || Menu.isItemEnabled(item);
			if (!enabled) {
				$item.addClass("disabled");
			} else {
				if (item.params) {
					$item.data("command-params", item.params);
				}

				if (item.hint && that.options.tooltips) {
					$item.prop({ title: item.hint });
					$item.tooltip({ delay: { show: 500 } });
				}

				if (item.items) {
					this._renderSubItems(item.items, $item);
				}
			}
		}

		if ($item) {
			if (item.cssClass) {
				$item.addClass(item.cssClass);
			}
		}
		return $item;
	}

	protected _createDivider (item: Menu.Item): JQuery {
		return $("<li role='presentation' class='divider'></li>");
	}

	protected _createHeader (item: Menu.Item): JQuery {
		return $("<li role='presentation' class='dropdown-header'>" + item.title + "</li>");
	}

	protected _createItemEl (item: Menu.Item): JQuery {
		let itemHtml = this._getItemHtml(item);
		let $item = $("<li><a href='" + (item.url || "#") + "'>" + itemHtml + "</a></li>")
			.data("item-name", item.name)
			.prop({ name: item.name, title: item.title })
			.attr("name", item.name);
		if (this.options.itemCssClass) {
			$item.addClass(this.options.itemCssClass);
		}
		return $item;
	}

	protected _getItemHtml (item: Menu.Item): string {
		if (item.html) {
			return item.html;
		}
		return Menu.getItemHtml(item, item.presentation || this.options.itemPresentation);
	}

	protected _renderSubItems (subitems: Menu.Item[], $item: JQuery): void {
		if (!subitems || !subitems.length) { return; }

		let $submenu = $("<ul></ul>");
		subitems.forEach((item) => {
			item.presentation = item.presentation || "icon";
		});
		this._renderItems(subitems, $submenu);

		if ($submenu.children().length) {
			$item.addClass("dropdown-submenu").append($submenu);
		}
	}

	protected _renderWaitStub (domElement: JQuery): void {
		let waitContainer = $("<div />")
			.css({
				"marginLeft": 10,
				"marginRight": 10,
				"display": "inline-block",
				"verticalAlign": "text-top"
			})
			.addClass("x-waiting-container")
			.addClass(core.ui.getWaitingIconClass(16));
		domElement.empty();
		$("<li></li>").text(resources["wait"]).prepend(waitContainer).appendTo(domElement);
	}
}

DropDownMenuPresenter.mixin({
	defaultOptions: DropDownMenuPresenter.defaultOptions
});

namespace DropDownMenuPresenter {
	export interface Options extends Part.Options {
		/**
		 * Bind container element (anchor by default) enable state to availability of any menu items
		 * @type {Boolean}
		 */
		disableIfEmpty?: boolean;
		/**
		 * Icon name for button
		 */
		toggleButtonIcon?: string;
		/**
		 * Additional user CSS class for root menu (ul) element.
		 * @type {String}
		 */
		cssClass?: string;
		/**
		 * Additional user CSS class for root element.
		 * @type {String}
		 */
		cssClassContainer?: string;
		/**
		 * Additional user CSS class for item element.
		 * @type {String}
		 */
		itemCssClass?: string;
		/**
		 * @type {"both"|"icon"|"text"}
		 */
		itemPresentation?: Menu.ItemPresentation;
		/**
		 * Add tooltip for items with hint attribute
		 * @type {Boolean}
		 */
		tooltips?: boolean;
		/**
		 * Trigger dropdown menu above element instead of below (by default)
		 * @type {Boolean}
		 */
		dropup?: boolean;

		viewModel?: any;
	}

	export type Model = Menu | {
		// {getMenu: (ctx?: any) => { items?: Menu.Item[] } } | Menu
		getMenu?: (ctx?: any) => { items?: Menu.Item[] } | DropDownMenuPresenter.Model;
	};
}


core.ui.DropDownMenuPresenter = DropDownMenuPresenter;
export = DropDownMenuPresenter;
