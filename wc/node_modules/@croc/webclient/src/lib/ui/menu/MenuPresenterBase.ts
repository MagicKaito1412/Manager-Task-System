import $ = require("jquery");
import core = require("core");
import binding = require("lib/binding");
import Part = require("lib/ui/Part");
import Menu = require("lib/ui/menu/Menu");
import DropDownMenuPresenter = require("lib/ui/menu/DropDownMenuPresenter");
import IPart = core.ui.IPart;
import ICommand = core.commands.ICommand;

abstract class MenuPresenterBase extends Part {
	static defaultOptions: MenuPresenterBase.Options = {
		orientation: "horizontal",
		/**
		 * @type {"both"|"icon"|"text"}
		 */
		itemPresentation: "both",
		/**
		 * Add tooltip for items with hint attribute
		 * @type {Boolean}
		 */
		tooltips: true,
		classes: {
			itemAction: "x-menu-item-action",
			submenuItem: "dropdown-toggle"
		}
	};

	options: MenuPresenterBase.Options;
	viewModel: Menu;
	radio: boolean;

	/**
	 * @constructs MenuPresenterBase
	 * @extends Part
	 * @param options
	 */
	constructor(options: MenuPresenterBase.Options) {
		options = MenuPresenterBase.mixOptions(options, MenuPresenterBase.defaultOptions);
		super(options);
		if (this.options.viewModel) {
			this.setViewModel(this.options.viewModel);
		}
	}

	protected _bindItemCommand(item: Menu.Item, itemEl: JQuery): void {
		if (item.command) {

			if (item.hideIfDisabled) {
				// TODO: хорошо бы также менять поле hidden для item
				binding.databind(
					binding.html(itemEl, "visibility"),
					binding.expr(item.command, (<ICommand>item.command).canExecute)
				);
			} else {
				binding.databind(
					binding.html(itemEl, "enabled"),
					binding.expr(item.command, (<ICommand>item.command).canExecute)
				);
			}
		}
	}

	doRender(domElement: JQuery|HTMLElement): core.lang.Promisable<void>  {
		if (!this.viewModel) { throw new Error("MenuPresenter.render: viewModel wasn't set"); }

		let that = this,
			options = that.options,
			items = that.viewModel.items,
			menuRoot;

		that.radio = options.radio || that.viewModel.radio;
		// NOTE: для radio menu должны были не забыть вызвать bindToCommands, иначе работать не будет
		// Может тут позвать явно: if (that.radio) that.viewModel.bindToCommands() ?
		super.doRender(domElement);

		menuRoot = that._createRootEl(domElement);
		// user root css-class
		if (options.cssClass) {
			menuRoot.addClass(options.cssClass);
		}
		if (options.orientation === "vertical") {
			menuRoot.addClass("x-menu--vertical");
		}
		that._processItems(items, menuRoot);

		if (that.radio) {
			let selectedItem = that.viewModel.selectedItem();
			if (selectedItem) {
				that._onSelectedItemChanged(that.viewModel, selectedItem);
			}
		}
		that.viewModel.bind("change", that._onViewModelChanged, that);

		that._setupClickHandle(menuRoot);
	}

	protected _onViewModelChanged(sender: Menu, args: core.lang.ObservableChangeArgs): void {
		if (args && args.prop === "selectedItem") {
			this._onSelectedItemChanged(sender, args.value);
		} else {
			this._onMenuChanged();
		}
	}

	protected _onMenuChanged(): void {
		this.rerender();
	}

	protected abstract _createRootEl(domElement: JQuery|HTMLElement): JQuery;

	protected _processItems(items: Menu.Item[], menuRoot: JQuery): void {
		let that = this;
		if (items && items.length > 0) {
			if (that.options.reverse) {
				items = items.slice().reverse();
			}
			items.forEach((item: Menu.Item) => {
				let itemEl = that._processItem(item);
				if (itemEl) {
					itemEl.appendTo(menuRoot);
				}
			});
		}
	}

	protected _processItem(item: Menu.Item): JQuery {
		let that = this,
			itemEl: JQuery;

		if (item.hidden) { return; }
		if (item.name === "divider") {
			itemEl = that._createDivider(item);
		} else if ((item.items && item.items.length) || item.getMenu) {
			// submenu (note: it can contain own command)
			itemEl = that._createSubmenuItem(item);
		} else if (item.command || item.url) {
			// action item
			itemEl = that._createActionItem(item);
			itemEl = that._createActionItemContainer(itemEl);
		}
		// else: TODO: an item without command or submenu - what is it? info? checkbox?
		if (itemEl) {
			if (item.cssClass) {
				itemEl.addClass(item.cssClass);
			}
		}

		return itemEl;
	}

	protected _createDivider (item: Menu.Item): JQuery {
		return null;
	}

	/**
	 * Create an element for action item (item with command), set up bindings
	 * @param item
	 * @returns {JQuery}
	 * @protected
	 */
	protected _createActionItem(item: Menu.Item): JQuery {
		let that = this,
			itemHtml = Menu.getItemHtml(item, item.presentation || that.options.itemPresentation),
			itemEl = that._createItemEl(item);

		if (item.command) {
			itemEl.addClass(that.options.classes.itemAction);
		}
		if (that.options.itemWidth) {
			itemEl.css({width: that.options.itemWidth});
		}

		itemEl
			.prop({ name: item.name, title: item.title })
			.html(itemHtml);
		if (item.hint && that.options.tooltips) {
			itemEl.prop({ title: item.hint });
			$(itemEl).tooltip({ delay: { show: 500} });
		}
		that._bindItemCommand(item, itemEl);

		if (item.disabled) {
			if (item.hideIfDisabled) { return null; }
			itemEl.prop("disabled", "disabled");
			itemEl.addClass("disabled");
		}
		return itemEl;
	}

	/**
	 * Wrap element for action item (created by _createActionItem) with an element
	 * @param {JQuery} itemEl item element
	 * @returns {JQuery} new item element
	 * @protected
	 */
	protected _createActionItemContainer(itemEl: JQuery): JQuery {
		return itemEl;
	}

	/**
	 * Create element for submenu - an item with sub items
	 * @param {Menu.Item} item
	 * @returns {JQuery}
	 * @protected
	 */
	protected _createSubmenuItem(item: Menu.Item): JQuery {
		let that = this,
			btnDropdown = that._createSubmenuContainer(item);

		let itemEl = that._createActionItem(item);
		itemEl.appendTo(btnDropdown);
		if (item.command) {
			// - the item has command AND submenu, it'll consist of two elements: action "button" and dropdown "button"
			// 1. action "button" - already created itemEl (in _createActionItem)

			// 2. dropdown "button"
			itemEl = that._createItemEl(item);
			if (item.hideIfDisabled) {
				binding.databind(
					binding.html(itemEl, "visibility"),
					binding.expr(item.command, (<ICommand>item.command).canExecute)
				);
			}
			itemEl.appendTo(btnDropdown);
		}

		itemEl
			.addClass(that.options.classes.submenuItem)
			.append($("<span class='caret' />"));

		let subMenu = item.getMenu ?
			{ getMenu : item.getMenu } :
			new Menu( {items : item.items} );

		let presenterOptions = {
			viewModel: subMenu,
			dropup: that.options.dropup,
			disableIfEmpty: item.disableIfEmpty
		};
		let dropMenuPresenter = that._createDropDownPresenter(item, presenterOptions);
		dropMenuPresenter.render(itemEl);
		that.registerChild(dropMenuPresenter, {disposeOnUnload: true});

		return btnDropdown;
	}

	protected _createSubmenuContainer(item: Menu.Item): JQuery {
		return null;
	}

	protected abstract _createItemEl(item: Menu.Item): JQuery;

	protected _addItemCommonAttrs(item: Menu.Item, itemEl: JQuery): void {
		if (item.hidden) {
			itemEl.css("display", "none");
		}
		if (item.isDefaultAction && this.options.classes.itemDefault) {
			itemEl.addClass(this.options.classes.itemDefault);
		}
		if (this.options.itemCssClass) {
			itemEl.addClass(this.options.itemCssClass);
		}
		if (this.options.noFocus || (item.presenterOptions && item.presenterOptions.noFocus)) {
			itemEl.attr("tabIndex", -1);
		}
	}

	protected _createDropDownPresenter(item: Menu.Item, presenterOptions: any): IPart {
		if (item.presenterOptions) {
			core.lang.extend(presenterOptions, item.presenterOptions);
		}
		return DropDownMenuPresenter.create(presenterOptions);
	}

	protected _onSelectedItemChanged(sender: Menu, name: string): void {}

	/*
	 _onSelectedItemChanged: function (sender, name) {
	 var that = this;
	 $(that.domElement).find("li.active").removeClass('active');
	 $(that.domElement).find("li a[name='" + name + "']").parent().addClass("active");
	 },
	 */

	protected _setupClickHandle(menuRoot: JQuery): void {
		let that = this;
		if (that.viewModel) {
			menuRoot.find(".x-menu-item-action").buttonClick(function (e: JQueryEventObject): void {
				if (core.html.isExternalClick(e)) {
					// if user clicks a link with ctrl/shift/alt/wheel then let the browser to process the click
					return;
				}

				let name = this.getAttribute("name");
				if (name) {
					let item = that.viewModel.getItem(name);
					if (item && item.command) {
						e.preventDefault();
						that.viewModel.executeItem(item, { $event: e });
					}
				}
			});
		}
	}

	unload(options?: Part.CloseOptions): void {
		let that = this;
		if (that.viewModel) {
			that.viewModel.unbind("change", null, that);
		}
		super.unload(options);
	}
}

MenuPresenterBase.mixin({
	defaultOptions: MenuPresenterBase.defaultOptions
});

namespace MenuPresenterBase {
	export interface Options extends Part.Options {
		orientation?: "horizontal" | "vertical";
		/**
		 * Additional user CSS class for root element.
		 * @type {String}
		 */
		cssClass?: string;
		/**
		 * Additional user CSS class for item element.
		 * @type {String}
		 */
		itemCssClass?: string;
		/**
		 * Item element width (as value for css attribute 'width').
		 * @type {Number}
		 */
		itemWidth?: number | string;
		/**
		 * Use reverse order of items
		 * @type {Boolean}
		 */
		reverse?: boolean;
		/**
		 * @type {"both"|"icon"|"text"}
		 */
		itemPresentation?: Menu.ItemPresentation;
		/**
		 * Add tooltip for items with hint attribute
		 * @type {Boolean}
		 */
		tooltips?: boolean;
		/**
		 * Radio buttons
		 * @type {Boolean}
		 */
		radio?: boolean;
		/**
		 * @type {Boolean}
		 */
		noFocus?: boolean;
		/**
		 * Trigger dropdown menu above element instead of below (by default)
		 * @type {Boolean}
		 */
		dropup?: boolean;

		viewModel?: Menu;

		classes?: ClassesOptions;
	}
	export interface ClassesOptions {
		root?: string;
		item?: string;
		itemDefault?: string;
		itemAction?: string;
		submenuItem?: string;
		submenuContainer?: string;
	}
}

core.ui.MenuPresenterBase = MenuPresenterBase;

export = MenuPresenterBase;
