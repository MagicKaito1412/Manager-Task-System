import $ = require("jquery");
import lang = require("lib/core.lang");
import View = require("lib/ui/handlebars/View");
import resources = require("i18n!lib/nls/resources");
import defaultTemplate = require("xhtmpl!lib/ui/templates/WaitingModal.hbs");
import "bootstrap";
import { CloseOptions } from "lib/ui/Part";

let g_rootDialog;
let g_waitingInstance;
let g_tasksCount = 0;

class WaitingModal extends View {
	static defaultOptions: WaitingModal.Options = {
		text: resources["wait"],
		template: defaultTemplate,
		unbound: true,
		inplace: false  // don't create modal dialog and show "waiting" inside the specified DOM element
	};

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	text: lang.ObservableProperty<string>;

	private _isRoot: boolean;
	options: WaitingModal.Options;
	modalRoot: JQuery;

	/**
	 * @class WaitingModal
	 * @extends View
	 * @param {Object} options
	 */
	constructor(options: WaitingModal.Options) {
		options = WaitingModal.mixOptions(options, WaitingModal.defaultOptions);
		super(options);

		if (this.options.text) {
			this.text(this.options.text);
		}
	}

	render(domElement?: JQuery|HTMLElement): lang.Promisable<void> {
		super.render(domElement);
	}

	protected doRender(domElement?: JQuery | HTMLElement): lang.Promisable<void> {
		let that = this;

		if (that.options.inplace) {
			super.doRender(domElement);
			return;
		}

		if (!domElement) {
			// preventing several root dialogs (it makes Chrome to crash!)
			if (g_rootDialog) {
				return g_rootDialog;
			}
			this._isRoot = true;
		}

		let modalRoot = $("<div class='modal' tabIndex='-1' />");
		let modalContent = $("<div class='modal-content' />");
		modalRoot.appendTo(domElement || document.body);
		if (!domElement) {
			g_rootDialog = modalRoot;
		}
		$("<div class='modal-dialog'></div>").appendTo(modalRoot).append(modalContent);

		super.doRender(modalContent);

		that.modalRoot = modalRoot;

		modalRoot.on("hidden.bs.modal", () => {
			that.modalRoot.remove();
			if (that._isRoot) {
				g_rootDialog = null;
			}
		});

		modalRoot.modal({
			backdrop: "static",
			keyboard: false
		});
	}

	unload(options?: CloseOptions): void {
		if (this.modalRoot) {
			this.modalRoot.modal("hide");
		}

		super.unload(options);
	}
	
	static executeTask(task: lang.Promise<any>, domElement, options: WaitingModal.Options): lang.Promise<void> {
		if (!task) {
			throw "task cannot be null";
		}

		options = options || {};

		let waiting;
		let blockUI = () => {
			if (task.state() !== "pending") { return; }

			waiting = (!options.inplace && g_waitingInstance) || new WaitingModal(options);
			if (!waiting.domElement) {
				waiting.render(domElement);
			}
		};

		if (!options.inplace) { g_tasksCount++; }

		if (options.blockTimeout) {
			window.setTimeout(() => {
				blockUI();
			}, options.blockTimeout);
		} else {
			blockUI();
		}

		task.always(() => {
			if (!options.inplace) {
				--g_tasksCount;
				if (!g_tasksCount && waiting && waiting.domElement) {
					waiting.dispose();
					g_waitingInstance = null;
				}
			} else if (waiting) {
				waiting.dispose();
			}
		});

		return task;
	}                           
}

// backward compatibility: access to static fields via prototype
WaitingModal.mixin({
	defaultOptions: WaitingModal.defaultOptions
});

namespace WaitingModal {
	export interface Options extends View.Options {
		text?: string;
		blockTimeout?: number;
		inplace?: boolean;
	}
}

export = WaitingModal;
