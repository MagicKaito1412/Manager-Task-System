import $ = require("jquery");
import core = require("core");
import formatters = require("lib/formatters");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import htmplMain = require("xhtmpl!lib/ui/templates/peViewOnly.hbs");
import htmplData = require("xhtmpl!lib/ui/templates/peViewOnly.data.hbs");
import htmplEmpty = require("xhtmpl!lib/ui/templates/peViewOnly.empty.hbs");
import resources = require("i18n!lib/nls/resources");
import "xcss!lib/ui/styles/peViewOnly.css";

import { Part } from "core.ui";
import { DomainObject } from "lib/domain/.domain";
import { EditorContext } from "lib/ui/editor/ObjectEditor";
import lang = core.lang;
import Promise = lang.Promise;
import ICommand = core.commands.ICommand;
import IPart = core.ui.IPart;
import IStatefulPart = core.ui.IStatefulPart;
import IPartFactory = PartCommandMixin.IPartFactory;
import PartCommandOptions = PartCommandMixin.PartCommandOptions;
import PartCommandResult = PartCommandMixin.PartCommandResult;
import ViewOptions = peViewOnly.ViewOptions;
import Options = peViewOnly.Options;

class peViewOnly extends PropertyEditor {
	static defaultOptions: Options = {
		Presenter: core.ui.View,
		template: htmplMain,
		partialTemplates: {
			data: htmplData,
			empty: htmplEmpty
		},
		/**
		 * formatter for items of navigation set property:
		 * name of formatter in value type or formatter function accepting value DomainObject
		 * It's used if formatter option (for the whole property) is not specified.
		 * @type {String|Function}
		 */
		itemFormatter: undefined,
		nullable: true,
		hideEmpty: false,
		emptyValue: undefined,
		navigable: false,
		commandsOptions: {},
		showCopy: undefined,
		html: true,
		focusable: true,
		focusableLink: false
	};

	static contextDefaultOptions: lang.Map<Options> = {
		viewer: {
			navigable: true
		}
	};

	options: Options;
	commands: lang.Map<ICommand>;

	protected urlFormatter: (v: DomainObject) => string;
	private _clipboardBtn: core.ui.clipboard.CopyButton;

	/**
	 * @constructs peViewOnly
	 * @extends PropertyEditor
	 * @param {Object} options
	 */
	constructor(options?: Options) {
		options = peViewOnly.mixContextOptions(options,
			peViewOnly.defaultOptions,
			peViewOnly.contextDefaultOptions
		);
		super(options);

		if (!core.ui.clipboard || !core.ui.clipboard.isSupported) {
			this.options.showCopy = false;
		}
		this.commands = lang.extend(this.createCommands(), this.options.commands);
		this.urlFormatter = this.options.urlFormatter || this.getViewUrl.bind(this);

		this.initPresenter();

		this.subscribeOnNavigation();
	}

	tweakOptions(options: Options): void {
		lang.appendEx(options, {
			presenterOptions: {
				template: options.template
			},
			showCopy: core.ui.clipboard && core.ui.clipboard.isSupported
		}, { deep: true });
		super.tweakOptions(options);
	}

	/**
	 * Return formatted (as text) prop value presentation.
	 * Used in template with additional html-encoding.
	 * @returns {string}
	 */
	formattedValue(): string {
		return formatters.formatPropValue(this.options, this.value()).toString();
	}

	/**
	 * Return html-formatted prop value presentation.
	 * Used in template without additional html-encoding.
	 * @returns {string} html/text
	 */
	formattedHtml(): string {
		return formatters.formatPropHtml(this.options, this.value());
	}

	isEmpty(): boolean {
		let that = this,
			v = that.value();
		// NOTE: тут раньше (до 0.21) была проверка на isLoaded(v), но она мешает использованию PE для незагруженных свойств
		// теоретически, если св-во не загружено, то isEmpty должны быть true, чтобы шаблон не пытался раскатывать незагруженное значение
		// Но в реальности, если функция шаблона натыкается на незагруженное значение, то возвращается объект loading, и результат шаблона игнорируется
		if (v == null || v === "") { return true; }
		return that.options.many && (v.isGhost || (lang.isFunction(v.count) && v.count() === 0));
	}

	protected onReady(): void {
		let that = this,
			$container = that.$domElement;
		that.element = $container.find(".x-pe-viewonly");

		super.onReady();

		if (that.options.showCopy) {
			let $btnCopy = $container.find(".btn-copy");
			if ($btnCopy.length) {
				if (that._clipboardBtn) {
					that._clipboardBtn.dispose();
				}
				that._clipboardBtn = new core.ui.clipboard.CopyButton($btnCopy[0], {
					text: () => that.title() + ": " + that.formattedValue(),
					tooltip: { placement: "top" }
				});
			}
		}
	}

	unload(options?: Part.CloseOptions): void {
		if (this._clipboardBtn) {
			this._clipboardBtn.dispose();
		}
		super.unload(options);
	}

	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			commands: lang.Map<ICommand> = {};
		if (that.options.vt === "object" && that.options.navigable) {
			commands["View"] = new core.commands.BoundCommand(that.doView, that.canView, that);
		}
		return commands;
	}

	getViewUrl(obj: DomainObject): string {
		if (!obj) { return "#"; }

		let partName = "ObjectViewer:" + obj.meta.name,
			cmdOptions = this._createCommandOptions<ViewOptions>({
				part: partName,
				partOptions: {
					type: obj.meta.name,
					id: obj.id
				}
			}, { object: obj }, "View"),
			stateManager: core.IAppStateManager = core.Application.current.stateManager,
			appState: core.AppState = stateManager.getCurrentState();

		if (!cmdOptions.activateOptions.freezeUrl) {
			let part: IPart|IPartFactory|string = cmdOptions.part,
				// NOTE: cmdOptions.partOptions is full options for the part, but it can contain redundant info,
				// which should not be included in URL. So we must use only known options
				partOptions = {
					type: cmdOptions.partOptions.type,
					id: cmdOptions.partOptions.id
				},
				regionState: core.RegionState;

			if (lang.isString(part)) {
				regionState = {
					part: part,
					partOptions: partOptions
				};
			} else if (lang.isFunction(part)) {
				// part is IPartFactory
				// TOTHINK: Создавать парт - слишком накладно, используем имя парта. Однако, это не совсем корректно,
				// так как фабрика может вернуть парт с другим именем.
				regionState = {
					part: partName,
					partOptions: partOptions
				};
			} else {
				// part is IPart
				regionState = {
					part: part,
					partOptions: (part as IStatefulPart).getState ?
						(part as IStatefulPart).getState(cmdOptions.partOptions) :
						partOptions
				};
			}
			appState.regionState = regionState;
		}
		return stateManager.getStateUrl(appState);
	}

	/**
	 * Open a viewer for the object
	 * @param {Object} args Command arguments
	 * @param {Object} args.object Object ot view
	 * @returns {*|jQuery.Deferred|$.Promise}
	 */
	protected doView(args: ViewOptions): Promise<PartCommandMixin.EditorCommandResult> {
		let that = this,
			obj = args.object;
		
		if (!obj) {	throw new Error("args.object must be specified"); }

		return that.executePartCommand({
			part: "ObjectViewer:" + obj.meta.name,
			partOptions: {
				viewModel: obj,
				editorContext: that._createNestedEditorContext()
			}
		}, args, "View").closed;
	}
	protected canView(): boolean {
		return !this.disabled();
	}

	protected _createNestedEditorContext(): EditorContext {
		return {
			parentObject: this.viewModel,
			parentProp: this.viewModel.meta.props[this.viewModelProp],
			nested: true
		};
	}
}

interface peViewOnly extends PartCommandMixin { }

// mix methods from PartCommandMixin
PartCommandMixin.mixinTo(peViewOnly);

// Override to take into account the 'hideEmpty' option
peViewOnly.prototype.hidden = function (): boolean {
	let that = this, v = PropertyEditor.prototype.hidden.apply(that, arguments);
	if (arguments.length) {
		return v;
	}
	return !!v || !!(that.options.hideEmpty && that.isEmpty());
};

// backward compatibility: access to static fields via prototype
peViewOnly.mixin(/** @lends peViewOnly.prototype */ {
	defaultOptions: peViewOnly.defaultOptions,
	contextDefaultOptions: peViewOnly.contextDefaultOptions
});

namespace peViewOnly {
	export interface Options extends PropertyEditor.Options, PartCommandMixin.Options {
		template?: HandlebarsTemplateDelegate;
		itemFormatter?: string|((v: DomainObject) => string);
		urlFormatter?: (v: DomainObject) => string;
		hideEmpty?: boolean;
		emptyValue?: any;
		navigable?: boolean;
		showCopy?: boolean;
		partialTemplates?: PartialTemplates;
		html?: boolean;
		/**
		 * root element with x-pe-viewonly class focusable
		 */
		focusable?: boolean;
		/**
		 * links (a) for values of navigation prop focusable
		 */
		focusableLink?: boolean;
	}

	export interface PartialTemplates {
		data?: HandlebarsTemplateDelegate;
		empty?: HandlebarsTemplateDelegate;
		[name: string]: HandlebarsTemplateDelegate;
	}

	export interface ViewOptions extends PartCommandMixin.EditorCommandOptions {
		object?: DomainObject;
	}
}

core.ui.peViewOnly = peViewOnly;

core.ui.PropertyEditor.DefaultMapping.register(function (propMd) {
	return propMd.readOnly ? core.ui.peViewOnly : null;
}, { priority: 10 });
core.ui.PropertyEditor.DefaultMapping.register(function (propMd) {
	return propMd.contextName === "viewer" ? core.ui.peViewOnly : null;
}, { priority: 20 });

export = peViewOnly;