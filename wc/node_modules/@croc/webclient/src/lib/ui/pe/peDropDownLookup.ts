import core = require("core");
import $ = require("lib/core.jquery");
import Rx = require("rx");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import DataSource = require("lib/data/DataSource");
import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import utils = require("lib/utils");
import binding = require("lib/binding");
import formatters = require("lib/formatters");
import resources = require("i18n!lib/nls/resources");
import peLoadableMixin = require("lib/ui/pe/peLoadableMixin");
import "lib/ui/menu/MenuButtonsPresenter";
import "xcss!lib/ui/styles/peObjectDropDownLookup.css";

import { LoadQuerySpec, LoadOptions, LoadQueryParams, LoadResponse, InteropError } from "lib/interop/.interop";
import lang = core.lang;
import Part = core.ui.Part;
import Menu = core.ui.Menu;
import ICommand = core.commands.ICommand;
import IBindable = binding.IBindable;
import IDataProvider = peDropDownLookup.IDataProvider;
import IJsonSerializable = peDropDownLookup.IJsonSerializable;
import DataLoadEventArgs = peLoadableMixin.DataLoadEventArgs;
import State = peLoadableMixin.State;

class peDropDownLookup extends PropertyEditor {
	/**
	 * @enum {String}
	 */
	static Modes = {
		/**
		 * "live" - load is initiated every time a value changed in lookup field.
		 * The mode is only supported when an external DataSource is used
		 */
		"live": "live",
		/**
		 * "preload" - load is initiated on initialization
		 */
		"preload": "preload",
		/**
		 * "demand" - load is initiated by demand. It's default mode.
		 */
		"demand": "demand"
	};

	/**
	 * @enum {String}
	 */
	static MatchModes = {
		"equals": "equals",
		"startsWith": "startsWith",
		"contains": "contains"
	};

	/**
	 * @enum {String}
	 */
	static Events = {
		/* data loading */
		DATA_LOADING: "dataLoading",
		/* data loaded */
		DATA_LOADED: "dataLoaded",
		/* data loaded and set */
		LOADED: "Loaded",
		/* restrictions changed */
		RESTRICTIONS_CHANGED: "restrictionsChanged"
	};

	static defaultOptions: peDropDownLookup.Options = {
		filter: undefined,
		/**
		 * @type Array|String
		 */
		orderBy: undefined,
		/**
		 * demand, preload, demand (default)
		 * @type peDropDownLookup.prototype.modes
		 */
		mode: "demand",
		matchMode: "contains",
		canReload: true,
		canClear: true,
		isLookup: true,
		lookupMinChars: 2,
		lookupDelay: 250,
		dropDownEmptyItemText: "<i class='text-muted'>&lt; " + resources["value_not_set"] + " &gt;</i>",
		emptyValueTextFromDropDown: false,
		emptyValueText: "<i class='text-muted'>"+ resources["value_not_specified"] + "</i>",
		loadingText: "<i class='text-muted'>" + resources["loading"] + "</i>",
		/**
		 * filter restrictions changed event handler
		 * @type {Function}
		 */
		onRestrictionsChanged: undefined,
		/**
		 * data loading event handler
		 * @type {Function}
		 */
		onDataLoading: undefined,
		/**
		 * data loaded event handler
		 * @type {Function}
		 */
		onDataLoaded: undefined,
		selectOnTab: true
	};

	static defaultMenu: Menu.Options = { items: [
		{ name: "Toggle", title: resources.select, icon: "search" },
		{ name: "Reload", title: resources.reload, icon: "refresh" }
		//{ name: "Unlink", title: resources["navigationPE.unlink.scalar"], icon: "clear" }
	]};

	// prototype members: begin

	/**
	 * @enum {String}
	 */
	modes: typeof peDropDownLookup.Modes;

	/**
	 * @enum {String}
	 */
	matchModes: typeof peDropDownLookup.MatchModes;

	/**
	 * @enum {String}
	 */
	events: typeof peDropDownLookup.Events;

	// prototype members: end

	/**
	 * @observable-property {peDropDownLookup#states}
	 */
/*
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<peDropDownLookup.State>;
*/

	/**
	 * @observable-property {Function|Object}
	 */
	@lang.decorators.observableAccessor()
	filter: lang.ObservableProperty<lang.Lazy<Object|IJsonSerializable>>;

	options: peDropDownLookup.Options;
	app: core.Application;
	menu: Menu;
	commands: lang.Map<ICommand>;
	dataProvider: IDataProvider<any, any>;
	items: lang.ObservableCollection<any>;

	protected viewItems: ObservableCollectionView<any>;
	protected menuPresenter: core.ui.MenuButtonsPresenter;

	private _isOpen: boolean;
	private _isLookupStarted: boolean;
	private _inputId: string;
	private _dropId: string;
	private _inputInitialVal: string;
	private _onDomChange: () => void;

	private _input: JQuery;
	private _btnContainer: JQuery;
	private _presentation: JQuery;
	private _loading: JQuery;
	private _dropContainer: JQuery;
	private _dropScroll: JQuery;
	private _dropdown: JQuery;

	/**
	 * @constructs peDropDownLookup
	 * @extends PropertyEditor
	 * @param options
	 */
	constructor(options?: peDropDownLookup.Options) {
		options = peDropDownLookup.mixOptions(options, peDropDownLookup.defaultOptions);
		if (options.mode === peDropDownLookup.Modes.live && !options.lookupParam) {
			throw new Error("peDropDownLookup.ctor: options.lookupParam was not specified for live search mode.");
		}
		if (options.mode === peDropDownLookup.Modes.live) {
			options.isLookup = true;
		}
		if (options.showEmptyItem === undefined) {
			options.showEmptyItem = options.nullable;
		}

		if (options.emptyValueTextFromDropDown) {
			options.emptyValueText = options.dropDownEmptyItemText;
		}
		super(options);

		let that = this;
		that.app = core.Application.current;
		that.dataProvider = that.createDataProvider();

		that.items = new lang.ObservableCollection<any>();
		that.viewItems = new ObservableCollectionView<any>();
		if (that.options.orderBy) {
			that.viewItems.orderBy(that.options.orderBy);
		}
		that.viewItems.bind("change", () => { that._renderViewItems(); });

		that._isOpen = false;
		that.isDataLoaded = false;
		that._isLookupStarted = false;

		that.state(peLoadableMixin.State.initial);

		// идентификатор контрола. используется при определении id контент контролов при работе с фокусом.
		let cid = utils.generateGuid();
		that._inputId = "inputLookup" + cid;
		that._dropId = "drop" + cid;

		//that.commands = that.createCommands();
		that.commands = lang.extend(that.createCommands(), that.options.commands);
		that.menu = that._createMenu();
		if (that.menu) {
			that.menu.bindToPart(that);
		}

		that.bind("change", function(sender, e: lang.ObservableChangeArgs) {
			if (e.prop === "filter") {
				that._filterChanged(e);
			}
		});

		if (that.options.filter) {
			that.filter(that.options.filter);
		}

		utils.subscribeOnEvents(that, that.options, that.events);
	}

	protected createDataProvider(): IDataProvider<any, any> {
		let options = this.options,
			dataProvider = options.dataProvider;
		if (dataProvider) {
			return lang.unlazy(dataProvider, this);
		}
		let DataProvider = options.DataProvider;
		if (DataProvider) {
			return new DataProvider(this);
		}
		return undefined;
	}

	/**
	 * Create commands
	 * @protected
	 * @returns {{Toggle: BoundCommand, Reload: (BoundCommand|undefined), Unlink: BoundCommand}}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			options = that.options,
			cmdToggleDrop = new core.commands.BoundCommand(that.doToggleDrop, that.canToggleDrop, that),
			cmdReload,
			cmdClear;

		if (options.canReload) {
			cmdReload = new core.commands.BoundCommand(that._doReload, that.canReload, that);
		}
		if (options.canClear) {
			cmdClear = new core.commands.BoundCommand(that._doClear, that.canClear, that);
		}

		return {
			Toggle: cmdToggleDrop,
			Reload: cmdReload,
			Unlink: cmdClear
		};
	}

	protected _createMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(peDropDownLookup.defaultMenu, "peObject");
	}

	protected _createMenu(): Menu {
		return new Menu(this._createMenuDefaults(), this.options.menu);
	}

	private _onRestrictionsChanged(restrictions: lang.Lazy<Object|IJsonSerializable>): void {
		this.isDataLoaded = false;
		this.onRestrictionsChanged(restrictions);
	}

	protected onRestrictionsChanged(restrictions: lang.Lazy<Object|IJsonSerializable>): void {
		this.trigger(this.events.RESTRICTIONS_CHANGED, this, restrictions);
	}

	protected _filterChanged(e: lang.ObservableChangeArgs): void {
		let that = this,
			oldValue = e.oldValue,
			newValue = e.value;

		if (lang.Observable.isObservable(oldValue)) {
			oldValue.unbind("change", null, that);
		}

		that._onRestrictionsChanged(newValue);

		if (lang.Observable.isObservable(newValue)) {
			newValue.bind("change", that._onRestrictionsChanged, that);
		}
	}

	render(domElement: JQuery|HTMLElement): lang.Promise<any>|any {
		let that = this,
			options = that.options,
			$rootElement,
			$valueContainer,
			$presentationContainer,
			$clearBtn;

		// pe container:
		$rootElement = $("<div class='x-pe-object-dropdown input-group'></div>").appendTo(domElement);

		// value container:
		$valueContainer = $("<div class='value-container'></div>").appendTo($rootElement);
		// buttons:
		if (!that.menu.isEmpty()) {
			that._btnContainer = $("<div class='input-group-btn'></div>").appendTo($rootElement);
			that.menuPresenter = core.ui.MenuButtonsPresenter.create({
				inline: true,
				ungrouped: true,
				reverse: true,
				itemPresentation: "icon"});
			that.menuPresenter.setViewModel(that.menu);
			that.menuPresenter.render(that._btnContainer);
		}

		$presentationContainer = $("<div class='presentation-container'></div>").appendTo($valueContainer);
		that._presentation = $("<span/>").appendTo($presentationContainer);

		that._loading = $("<div class='x-waiting-container' title='" + resources["loading"] + "'></div>")
			.hide() // initially invisible
			.appendTo($valueContainer);
		$("<span></span>").addClass(core.ui.getWaitingIconClass(16)).appendTo(that._loading);

		if (options.isLookup) {
			that._setupLookup($valueContainer);
		}

		if (that.commands["Unlink"]) {
			$valueContainer.addClass("has-clear-btn");
			$clearBtn = $("<span class='clear-btn'>&times;</span>").appendTo($valueContainer);
			binding.commandBind($clearBtn, that.commands["Unlink"]);
		}
		//that._dropContainer = $("<div id='" + that._dropId + "' class='drop-container' ></div>").appendTo("body");
		that._dropContainer = $("<div id='" + that._dropId + "' class='drop-container' ></div>")
			// prevent bubbling of mouse and keyboard events outside of the element
			.stopBubbling()
			// in Chrome 'mousedown' on scroll-bar can cause 'focusout' (see WC-839)
			.mousedown(() => { return false; });

		that._dropScroll = $("<div class='drop-scroll'></div>").appendTo(that._dropContainer);
		that._dropdown = $("<ul class='dropdown-menu' tabindex='-1'></ul>").appendTo(that._dropScroll);
		that._dropdown
			.on("click", (e) => {
				//console.log("peLookup click");
				e.stopPropagation();
				e.preventDefault();
				that._selectCurrentDropDownValue();
			})
			.on("mouseenter", "li", that._mouseEnter.bind(that));

		//core.html.overlay(that._dropContainer, that.domElement);

		that.element = $rootElement;
		that.element
			.on("keypress keydown", that._keypress.bind(that))
			.on("keyup", that._keyup.bind(that));

		// if pe (any inner elements) lost focus - check activeElement. if it is outside a pe - close drop
		that.element.focusout(() => {
			window.setTimeout(() => {
				if (!that._isFocusInside()) {
					that._close();
				}
			});
		});

		super.render(domElement);

		that.databind(that.createBindableElement());

		if (options.mode === that.modes.preload) {
			that.reload();
		}
	}

	unload(options?: Part.CloseOptions): void {
		let that = this;
		that._close();
		$("#"+that._dropId).remove();
		that.viewItems.clear();
		if (that.menuPresenter){
			that.menuPresenter.unload();
		}
		super.unload(options);
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		let that = this;
		that.unbind();
		that.items.dispose();
		that.viewItems.dispose();

		let filter = that.filter();
		if (lang.Observable.isObservable(filter)) {
			filter.unbind("change", null, that);
		}

		let dataProvider = that.dataProvider;
		if (lang.isDisposable(dataProvider)) {
			dataProvider.dispose();
		}

		super.dispose(options);
		that.state(peLoadableMixin.State.disposed);
	}

	protected _onDisabledChange(disabled: boolean): void {
		this._disableInput(disabled);
	}

	protected createBindableProp(): IBindable {
		let that = this;

		return binding.expr(that.viewModel, function() {
			// NOTE: this === that.viewModel here. Don't use lambda instead of function, otherwise this === that)
			let value = this[that.viewModelProp]();
			return that.dataProvider.getValuePresentation(value);
		});
	}

	protected createBindableElement(): IBindable {
		let that = this;
		return {
			set(value: any): void {
				if (value === lang.support.loadingValue) {
					that._disableInput(true);
					that._presentation.html(that.options.loadingText);
				} else {
					that._disableInput(false);
					if (value === null || value === "") {
						that._presentation.html(that.options.emptyValueText);
					} else {
						that._presentation.text(value);
						if (that._presentation.hasClass("lookup-active")) {
							// NOTE: lookup input currently is active (and _presentation is hidden)
							// So the current prop value has been changed during lookup input active (it can be done due to prop value loading)
							// If the user didn't change initial lookup value then update it basing on the new prop value.
							if (that._inputInitialVal === that._input.val()) {
								that._inputInitialVal = that._getInputValuePresentation();
								that._input.val(that._inputInitialVal);
							}
						}
					}
				}
			},
			setError(error: InteropError): void {
				that._disableInput(false);

				let message: string = null;
				if (error) {
					that._presentation.empty();
					if (core.eth.isObjectNotFound(error)) {
						// the value object was deleted, reset value to null
						that.value(null);
					} else if (error.httpStatus) {
						message = resources["peDropDownLookup.loadingError"] + error.message;
					}
				}

				that.renderError(message);
			}
		};
	}

	protected _getLoadParams(params: LoadQueryParams): LoadQueryParams {
		let that = this,
			options = that.options,
			filter: (Object|IJsonSerializable) = lang.unlazy(that.filter(), that.viewModel),
			filterParams: LoadQueryParams;

		if (filter) {
			filterParams = (filter as IJsonSerializable).toJson ? (filter as IJsonSerializable).toJson() : filter;
		}
		params = lang.extend(filterParams || {}, params);

		if (options.mode === that.modes.live && !params[options.lookupParam]) {
			params[options.lookupParam] = "";
		}

		return params;
	}

	reload(params?: LoadQueryParams): lang.Promise<void> {
		let that = this,
			args = {} as DataLoadEventArgs;
		return lang.async.chain().then(() => {
			args.query = { params: that._getLoadParams(params) };
			args.options = {};

			that._onDataLoading(args);
			return that.dataProvider.loadItems(args.query, args.options);
		}).then((items: any[]) => {
			if (that.state() === State.disposed) { return; }
			args.items = items;
			that._onDataLoaded(args);
			that.onLoaded();
			//return items;
		}).then<void>(null, error => {
			if (core.eth.isCanceled(error)) {
				// load was cancel - it's ok and not an error
				return lang.resolved();
			}
			that._onFailed(error);
			return error;
		}).value();
	}

	/**
	 * Select item with specified index
	 * @param {Number} index index to select
	 */
	selectIndex(index: number): void {
		let item = this.viewItems.get(index),
			value = this.dataProvider.getValue(item);
		this.value(value);
	}

	/**
	 * Select first item
	 */
	selectFirst(): void {
		if (this.viewItems.count() > 0) {
			this.selectIndex(0);
		}
	}

	/**
	 * Select item if single
	 */
	selectSingle(): void {
		if (this.viewItems.count() === 1) {
			this.selectIndex(0);
		}
	}

	/**
	 * Disable property editor if only one item exists
	 */
	disableIfSingle(): void {
		if (this.viewItems.count() === 1){
			this.disabled(true);
		}
	}

	protected _disableInput(disabled: boolean): void {
		let that = this;
		if (that._input && disabled !== undefined) {
			that._input.prop("disabled", (disabled !== false) || !!that.disabled());
		}
	}

	protected _readonlyInput(readonly: boolean): void {
		let that = this;
		if (that._input) {
			that._input.prop("readonly", (readonly !== false));
			//ie10 bug. ie10 does not change readonly if cursor already inside field
			if (that._input.is(":focus")) {
				let input = that._input[0] as HTMLInputElement;
				// NOTE: IE8 does not support setSelectionRange
				if (input.setSelectionRange) {
					input.setSelectionRange(input.selectionStart, input.selectionEnd);
				}
			}
		}
	}

	/**
	 * @override
	 * @protected
	 */
	protected onDataLoading(args: DataLoadEventArgs): void {
		this.trigger(this.events.DATA_LOADING, this, args);
	}

	/**
	 * @override
	 * @protected
	 */
	protected onDataLoaded(args: DataLoadEventArgs): void {
		this.trigger(this.events.DATA_LOADED, this, args);
	}

	/**
	 * @override
	 * @protected
	 */
	protected onLoaded(): void {
		this.trigger(this.events.LOADED, this);
	}

	/**
	 * @override
	 * @protected
	 */
	protected _renderBeginLoading(): void {
		// block input in lookup field (if exist)
		let that = this;
		that._readonlyInput(true);
		that.element.addClass("loading");
		that._loading.show();
	}

	/**
	 * @override
	 * @protected
	 */
	protected _renderEndLoading(): void {
		let that = this;
		that._readonlyInput(false);
		that.element.removeClass("loading");
		that._loading.hide();
	}

	/**
	 * @override
	 * @protected
	 */
	protected _setItems(items: any[]): void {
		this.items.reset(items);
		this.viewItems.reset(items);
	}

	protected _setupLookup(valueContainer: JQuery): void {
		let that = this,
			keyCode = core.html.keyCode;

		that._input = $("<input id='" + that._inputId + "' type='text' class='form-control' />")
			.appendTo(valueContainer)
			.focus(() => {
				let inputValBefore = that._input.val();
				lang.loadExpression(that._getInputValuePresentation, that)
					.done((v) => {
						that._presentation.addClass("lookup-active");
						if (!inputValBefore || inputValBefore === v) {
							// input's val wasn't change by the user while we were loading lookup list
							that._inputInitialVal = v;
							that._input.val(that._inputInitialVal);
							that._input.select();
						}
					});
			})
			.blur(() => {
				that._inputInitialVal = undefined;
				if (!that._isLookupStarted) {
					that._presentation.removeClass("lookup-active");
					that._input.val("");
				}
			})
			.on("mousedown", () => {
				// fix for chrome\safari. They set cursor at mouseup event
				// and if we want to select all text on focus event we need to supress mouseup once
				if (!that._input.is(":focus")){
					that._input.one("mouseup", function(e: JQueryEventObject): void {
						e.preventDefault();
					});
				}
			});

		// sequence of input values from 'keyup' event
		let keyupVals: Rx.Observable<string> = Rx.Observable
			.fromEvent<JQueryEventObject>(that._input, "keyup")
			.where(ev =>
				!that._isLookupStarted && (
					ev.which > keyCode.DOWN || // всякие буквы
					ev.which === keyCode.SPACE ||
					ev.which === keyCode.BACKSPACE ||
					ev.which === keyCode.DELETE
				)
			)
			.select(ev => $(ev.target).val())
			.where(text =>
				text.length >= that.options.lookupMinChars // либо что-то введено
				|| text.length === 0 // либо вообще пусто после ввода (значит стирали) и нужно показывать всё
				|| that._isOpen      // или дропдаун уже открыт
			)
			.debounce(that.options.lookupDelay);

		// sequence of input values from 'paste' event
		let pasteVals: Rx.Observable<string> = Rx.Observable
			.fromEvent<JQueryEventObject>(that._input, "paste")
			.delay(0) // asynchronously to have time to update input value
			.select(ev => $(ev.target).val())
			// ввели минимум символов или дропдаун уже открыт
			.where(text => text.length >= that.options.lookupMinChars || that._isOpen);

		// merge 'keyup' and 'paste' sequences and process values from them
		let subscription = Rx.Observable.merge(keyupVals, pasteVals)
			.flatMapLatest(text => {
				that._isLookupStarted = true;
				return that._searchForSuggestions(text)
					.then(null, err => {
						// NOTE: Ошибка уже отобразилась внутри _searchForSuggestions.
						// Здесь просто возвращаем пустой Deferred, чтобы не было ошибки в Rx
						return lang.resolved();
					});
			})
			.subscribe((results: any[]) => {
				if (results) {
					that.viewItems.reset(results);
					if (!that._isOpen) {
						that._open();
					}
					that._isLookupStarted = false;
					if (results.length === 1) {
						if (that._filterItems(that.viewItems, $(that._input).val(), that.matchModes.equals).length === 1) {
							// the text in lookup field strictly equals to the single option value (in lookup dropdown)
							// so automatically choose it as selected value
							let item = that.viewItems.get(0);
							that._selectValue(item);
						}
					}
				} else {
					// NOTE: отсутствие results свидетельствует об ошибке
					that._close();
					that._isLookupStarted = false;
				}
			});

		that.addDisposable(subscription);
	}

	protected _getInputValuePresentation(): string {
		let value = this.value();
		if (value == null) { return ""; }
		return this.dataProvider.getValuePresentation(value);
	}

	protected _getDropdownValuePresentation(item: any): string | formatters.SafeHtml{
		return this.dataProvider.getItemPresentation(item);
	}

	protected _searchForSuggestions(term: string): lang.Promise<any[]> {
		let that = this,
			options = that.options;

		if (options.mode === that.modes.live) {
			let params = {
				[options.lookupParam]: term || ""
			};
			return that.reload(params).then(() => that.items.all());
		}

		if (that.isDataLoaded) {
			return lang.resolved(that._filterItems(that.items, term));
		}

		return that.reload().then(() => that._filterItems(that.items, term));
	}

	protected _lookupMatcherDefault(item: any, term: string, matchMode: peDropDownLookup.MatchMode): boolean {
		let that = this,
			text = that._getDropdownValuePresentation(item).toString().toLowerCase();
		if (matchMode === that.matchModes.equals) {
			return text === term.toLowerCase();
		}
		if (matchMode === that.matchModes.startsWith) {
			return text.indexOf(term.toLowerCase()) === 0;
		}
		// if (matchMode === that.matchModes.contains):
		return text.indexOf(term.toLowerCase()) !== -1;
	}

	protected _filterItems<T>(items: lang.IObservableCollection<T>, term: string, matchMode?: peDropDownLookup.MatchMode): T[] {
		let that = this,
			matcher = that.options.lookupMatcher || that._lookupMatcherDefault.bind(that);
		term = term || "";
		matchMode = matchMode || that.options.matchMode;
		return items.all().filter((item) => {
			return matcher(item, term, matchMode);
		});
	}

	protected _isAllowInteraction(): boolean {
		let that = this;
		return that.state() !== State.loading && !that.disabled();
	}

	protected doToggleDrop(): void {
		let that = this;
		if (!that._selectInsteadExecute()) {
			that.toggle();
		}
	}
	protected canToggleDrop(): boolean {
		return this._isAllowInteraction();
	}

	protected _doReload(): void {
		let that = this;
		if (!that._selectInsteadExecute()) {
			// NOTE: do not pass command' args into reload
			if (that._input) {
				that._input.focus();
			}
			that.reload();

			if (that.menuPresenter) {
				that.menuPresenter.focusItem("Reload");
			}
		}
	}
	protected canReload(): boolean {
		return this._isAllowInteraction();
	}

	protected _doClear(): void {
		let that = this;
		that.value(null);
		if (that.menuPresenter) {
			that.menuPresenter.focusItem("Toggle");
		}
	}
	protected canClear(): boolean {
		return this._isAllowInteraction() && !!this.value();
	}

	protected _selectInsteadExecute(): boolean {
		if (this._isOpen) {
			return this._selectCurrentDropDownValue();
		}
		return false;
	}

	protected _selectCurrentDropDownValue(): boolean {
		let active: JQuery = this._dropdown.find(".active");
		if (!active.length) { return false; }

		let item = active.data("object");
		this._selectValue(item);
		return true;
	}

	protected _selectValue(item: any): void {
		let that = this,
			value = that.dataProvider.getValue(item);

		that.value(value === undefined ? null : value); // undefined -> null

		if (that._input) {
			that._resetInput();
		}
		that._close();
	}

	protected _hasActive(): boolean {
		return this._dropdown.find(".active").length > 0;
	}

	protected _resetInput(): void {
		let that = this;
		that._presentation.removeClass("lookup-active");
		/*	ранее мы уводимо фокус на кнопку. но ее может не быть и тогда все ломалось
		if (that.menuPresenter) {
			that.menuPresenter.focusItem("Toggle");
		}
		*/
		that._input.blur().focus();
	}

	protected _keyup(e: JQueryEventObject): boolean {
		let that = this,
			keyCode = core.html.keyCode;
		switch (e.keyCode) {
			case keyCode.TAB:
			case keyCode.ENTER:
				if (e.keyCode === keyCode.TAB && !that.options.selectOnTab) { break; }

				if (that._isOpen && that._selectCurrentDropDownValue()) {
					return false;
				}
				break;
			case keyCode.ESCAPE: // escape
				if (that._isOpen) {
					that._resetInput();
					that._close();
					return false;
				}
				break;
		}
	}

	protected _keypress(e: JQueryEventObject): boolean {
		let that = this,
			keyCode = core.html.keyCode;
		switch (e.keyCode) {
			case keyCode.BACKSPACE:
				//if input element is readonly (while loading) backspase shouldn't go back
				if (that._input && that._input.prop("readonly")) {
					return false;
				}
				break;
			case keyCode.TAB:
				break;
			case keyCode.ENTER:
			case keyCode.ESCAPE:
				return false;
			case keyCode.UP:
				if (e.type === "keydown") {
					that._prev();
				}
				return false;
			case keyCode.DOWN:
				if (!that._isOpen){
					if (e.target.id) {
						that._isLookupStarted = false;
					}
					that._open();
				}
				if (e.type === "keydown") {
					that._next();
				}
				return false;
		}
	}

	protected _next(): void {
		let active = this._dropdown.find(".active").removeClass("active"),
			next = active.next();

		if (!next.length) {
			next = $(this._dropdown.find("li")[0]);
		}
		next.addClass("active");
		this._ensureItemInView(this._dropScroll, next);
	}

	protected _prev(): void {
		let active = this._dropdown.find(".active").removeClass("active"),
			prev = active.prev();

		if (!prev.length) {
			prev = this._dropdown.find("li").last();
		}
		prev.addClass("active");
		this._ensureItemInView(this._dropScroll, prev);
	}

	protected _ensureItemInView(view: JQuery, item: JQuery): void {
		if (!view.length || !item.length) { return; }

		let viewTop = view.scrollTop(),
			viewBottom = viewTop + view.height(),
			elemTop = item.position().top,
			elemBottom = elemTop + item.height();

		if (elemBottom > viewBottom || elemTop < viewTop){
			view.scrollTo(item, 100, {easing: "swing"});
		}
	}

	protected _mouseEnter(e: JQueryEventObject): void {
		this._dropdown.find(".active").removeClass("active");
		$(e.currentTarget).addClass("active");
	}

	protected _renderViewItems(): void {
		let that = this;

		that._dropdown.empty();

		if (that.options.showEmptyItem) {
			$("<li><a href='#' tabindex='-1'>" + that.options.dropDownEmptyItemText + "</a></li>").appendTo(that._dropdown);
		}
		try {
			that.viewItems.forEach((item) => {
				let $li = $("<li></li>").data("object", item).appendTo(that._dropdown);
				let text = that._getDropdownValuePresentation(item);
				// NOTE: _getDropdownValuePresentation возвращает строку, которая может быть Html,
				// если задана опция formatterHtml или formatter вернул SafeHtml.
				// Во всех остальных случах строка должна быть html-encoded, поэтому тут вставим ее как HTML.
				let $item = $("<a href='#' tabindex='-1'></a>");
				if (formatters.isHtml(text)) {
					$item.html(text.toHTML());
				} else {
					$item.text(text.toString());
				}
				$item.appendTo($li);
			});
		} catch (ex) {
			console.error(ex);
			throw ex;
		}

		// make the single option active by default (so pressing Enter will select it as prop value)
		if (that.viewItems.count() === 1) {
			that._dropdown.children(":last-child").addClass("active");
		}
	}

	toggle(): void {
		let that = this;
		that._isLookupStarted = false;
		if (that._input) {
			that._input.focus();
		}
		that._toggle();
	}

	protected _toggle(): void {
		let that = this;
		if (that._isOpen) {
			that._close();
		} else {
			that._open();
		}
	}

	protected _open(): void {
		let that = this;

		if (!that.isDataLoaded) {
			that.reload().
				done(() => {
					//if focus leaved from pe, while loading, do nothing
					if (!that._isFocusInside()) {
						return;
					}

					that._open2();
				});
		} else {
			if (!that._isLookupStarted) {
				that.viewItems.reset(that.items.all());
			}
			that._open2();
		}
	}

	/**
	 * Corrects the position of dropContainer
	 * @param {JQuery} $overlayContainer Parent "overlay" element for dropContainer (if any).
	 * @private
	 */
	protected _layoutDropContainer($overlayContainer: JQuery): void {
		let that = this;
		// get coordinates of the parent relative to the document.
		let pos = that.element.offset();

		// NOTE: если контролл внутри какого-то overlay элемента (например, в диалоге), то позиция относительно
		// документа (которую возвращает offset) может не соответствовать абсолютной позиции контрола дропдауна,
		// т.к. в документе мог быть скроллинг, который отключается при показе диалога
		let offPos = $overlayContainer && $overlayContainer.offset() || { top: 0, left: 0 };

		// растянуть дроп на всю ширину контрола и опустить его так что бы был чуть ниже
		// нижнего края презентейшена
		that._dropContainer.css({
			width: that.element.outerWidth(),
			top: pos.top + that.element.outerHeight() - offPos.top,
			left: pos.left - offPos.left
		});
	}

	protected _open2(): void {
		let that = this;

		that._isOpen = true;

		// NOTE: если domElement внутри overlay-элемента (например, диалога), то помещаем dropContainer туда же
		let $overlayContainer = core.html.overlay(that._dropContainer, that.$domElement);
		that._layoutDropContainer($overlayContainer);
		that._onDomChange = lang.debounce(() => {
			if (that._isOpen) {
				that._layoutDropContainer($overlayContainer);
			}
		});
		core.$document.on("domChanged", that._onDomChange);

		that._dropContainer.show();
		that.element.addClass("open");
		that._dropScroll.scrollTop(0);

		that.onOpened();
	}

	protected onOpened(): void {
		this.trigger("opened", this, { dropContainer: this._dropContainer });
	}

	protected _close(): void {
		let that = this;
		that._isOpen = false;
		if (that._onDomChange) {
			core.$document.off("domChanged", that._onDomChange);
			that._onDomChange = undefined;
		}
		that.element.removeClass("open");
		if (that._dropContainer) {
			that._dropContainer.hide();
		}
	}

	protected onClosed(): void {
		this.trigger("closed", this, {});
	}

	focus(): void {
		let that = this;
		if (that._input) {
			that._input.focus();
		} else if (that._btnContainer) {
			that._btnContainer.find(".btn:last").focus();
		}
	}

	protected _isFocusInside(): boolean {
		return $(document.activeElement).parents("#" + this.id + ", #" + this._dropId).length > 0;
	}
}
interface peDropDownLookup extends peLoadableMixin { }

peDropDownLookup.mixin(peLoadableMixin);

// backward compatibility: access to static fields via prototype\
peDropDownLookup.mixin({
	defaultOptions: peDropDownLookup.defaultOptions,
	defaultMenu: peDropDownLookup.defaultMenu,
	states: peLoadableMixin.State,
	modes: peDropDownLookup.Modes,
	matchModes: peDropDownLookup.MatchModes,
	events: peDropDownLookup.Events,
});

namespace peDropDownLookup {
	export type State = string; // initial | loading | loaded | failed | disposed

	export type Mode = string; // live | preload | demand

	export type MatchMode = string; // equals | startsWith | contains

	export interface IJsonSerializable {
		toJson(): Object;
	}

	export interface Options extends PropertyEditor.Options {
		dataProvider?: IDataProvider<any, any> | ((pe?: peDropDownLookup) => IDataProvider<any, any>);
		DataProvider?: new (pe?: peDropDownLookup) => IDataProvider<any, any>;
		dataSource?: DataSource;
		menu?: Menu.Options;
		commands?: lang.Map<core.commands.ICommand|core.commands.ICommandFactory>;
		filter?: lang.Lazy<Object|IJsonSerializable>;
		/**
		 * @type Array|String
		 */
		orderBy?: string|string[];
		/**
		 * demand, preload, demand (default)
		 * @type peDropDownLookup.prototype.modes
		 */
		mode?: Mode;
		matchMode?: MatchMode;
		canReload?: boolean;
		canClear?: boolean;
		isLookup?: boolean;
		lookupMinChars?: number;
		lookupDelay?: number;
		lookupParam?: string;
		lookupMatcher?: (item: any, term: string, matchMode: MatchMode) => boolean;
		showEmptyItem?: boolean;
		dropDownEmptyItemText?: string;
		emptyValueTextFromDropDown?: boolean;
		emptyValueText?: string;
		loadingText?: string;
		/**
		 * filter restrictions changed event handler
		 * @type {Function}
		 */
		onRestrictionsChanged?: (sender: peDropDownLookup, restrictions: lang.Lazy<Object|IJsonSerializable>) => void;
		/**
		 * data loading event handler
		 * @type {Function}
		 */
		onDataLoading?: (sender: peDropDownLookup, args: DataLoadEventArgs) => void;
		/**
		 * data loaded event handler
		 * @type {Function}
		 */
		onDataLoaded?: (sender: peDropDownLookup, args: DataLoadEventArgs) => void;
		/**
		 * loaded event handler
		 * @type {Function}
		 */
		onLoaded?: (sender: peDropDownLookup) => void;
		selectOnTab?: boolean;
	}

	/**
	 * Provides data for peDropDownLookup.
	 * TValue - type of value of peDropDownLookup, TItem - type of raw data item returned by this provider.
	 */
	export interface IDataProvider<TValue, TItem> {
		loadItems(query?: LoadQuerySpec, options?: LoadOptions): lang.Promise<TItem[]>;
		getValue(item: TItem): TValue;
		getValuePresentation(value: TValue): string;
		getItemPresentation(item: TItem): string | formatters.SafeHtml;
		dispose?(): void;
	}

	export abstract class DataProviderBase<TValue, TItem> implements IDataProvider<TValue, TItem> {
		dataSource: DataSource;
		protected pe: peDropDownLookup;
		private _reloadOpId: string;

		constructor(pe: peDropDownLookup) {
			this.pe = pe;
			this.dataSource = pe.options.dataSource;
		}

		loadItems(query?: LoadQuerySpec, options?: LoadOptions): lang.Promise<TItem[]> {
			let that = this;
			return lang.async.chain().then(() => {
				let dataSource = that.dataSource;
				if (!dataSource) {
					throw new Error("peDropDownLookup.DataProviderBase: dataSource must be specified");
				}
				// cancel previous operation
				if (that._reloadOpId && dataSource.cancel) {
					try {
						dataSource.cancel(that._reloadOpId);
					} catch (ex) {
					}
				}

				that._reloadOpId = utils.generateGuid();
				options = options || {};
				options.opId = that._reloadOpId;
				return dataSource.load(query, options);
			}).always(() => {
				that._reloadOpId = null;
			}).then((response: LoadResponse) => {
				return that.getItems(response);
			}).value();
		}

		protected abstract getItems(response: LoadResponse): TItem[];

		abstract getValue(item: TItem): TValue;
		abstract getValuePresentation(value: TValue): string;
		abstract getItemPresentation(item: TItem): string | formatters.SafeHtml;
	}

	export class PlainDataProvider<TItem> extends DataProviderBase<TItem, TItem> {
		constructor(pe: peDropDownLookup) {
			super(pe);
		}

		protected getItems(response: LoadResponse): TItem[] {
			return response.result as TItem[];
		}

		getValue(item: TItem): TItem {
			return item;
		}

		getValuePresentation(value: TItem): string {
			return this.getItemPresentation(value);
		}

		getItemPresentation(item: TItem): string {
			return item != null ? item.toString() : "";
		}
	}
}

core.ui.peDropDownLookup = peDropDownLookup;

core.ui.PropertyEditor.DefaultMapping.register((propMd: PropertyEditor.Options) => {
	return propMd.presentation === "dropdown" ? core.ui.peDropDownLookup : null;
});

export = peDropDownLookup;
