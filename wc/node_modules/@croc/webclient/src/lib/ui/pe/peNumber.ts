import $ = require("jquery");
import core = require("core");
import validation = require("lib/validation");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import InputSpinner = require("lib/ui/pe/InputSpinner");
import binding = require("lib/binding");
import Big = require("big");

import "xcss!lib/ui/styles/peNumber.css";
import "vendor/jquery.numeric";

//import ui = require("lib/ui/.ui");
//import domain = require("lib/domain/.domain");
import lang = core.lang;
import { SpinnerOptions } from "lib/ui/pe/peNumber";

class peNumber  extends PropertyEditor {
	static defaultOptions: peNumber.Options = {
		step: 1,
		useNative: "mobileOnly",
		spinner: {buttons: "horizontal", icons: "plusminus"},
		autoCorrect: false
	};
	private _spinner: InputSpinner;
	options: peNumber.Options;
	isInteger: boolean;
	commands: lang.Map<core.commands.ICommand>;

	/**
	 * @constructs peNumber
	 * @extends PropertyEditor
	 * @param options
	 */
	constructor(options: peNumber.Options) {
		options = peNumber.mixOptions(options, peNumber.defaultOptions);
		super(options);
		let that = this;
		let vt = that.options.vt;
		that.isInteger = vt === "ui1" || vt === "i2" || vt === "i4" || vt === "i8";
		that.commands = that.createCommands();

		// create validation rules for facets minValue/maxValue/range if they don't exist
		this._initValidationRules();
	}

	protected _initValidationRules(): void {
		let options = this.options;
		let rules: validation.RuleMap = {};
		if (options.rules && options.rules.length) {
			for (let i = 0; i < options.rules.length; i++) {
				let rule = options.rules[i];
				if (rule.name) {
					rules[rule.name] = rule;
				}
			}
		}
		let newRules = [];
		if (options.minValue != null && !rules["minValue"]) {
			newRules.push(validation.facets["minValue"]);
		}
		if (options.maxValue != null && !rules["maxValue"]) {
			newRules.push(validation.facets["maxValue"]);
		}
		if (options.range && options.range.length === 2 && !rules["range"]) {
			newRules.push(validation.facets["range"]);
		}
		if (newRules.length) {
			options.rules = options.rules ? options.rules.concat(newRules) : newRules;
		}
	}

	useNative(): boolean {
		let isNativeSupported = core.platform.modernizr.inputtypes["number"];
		switch (this.options.useNative) {
			case "always":
				return isNativeSupported;
			case "never":
				return false;
			case "mobileOnly":
				return isNativeSupported && core.platform.isMobileDevice;
		}
	}

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isEmpty: lang.ObservableProperty<boolean>;

	/**
	 * @protected
	 * @returns {Object.<string, Command>}
	 */
	createCommands(): lang.Map<core.commands.ICommand>  {
		let that = this,
			commands: any = {};
		if (!that.options.hideClearButton) {
			commands.Clear = new core.commands.BoundCommand(that.doClear, that.canClear, that);
		}
		return core.lang.extend(commands, that.options.commands);
	}

	canClear(): boolean {
		return !this.disabled() && !this.isEmpty();
	}

	doClear(): void {
		if (!this.element) { return; }

		$(this.element).val("")
			.trigger("input")
			.trigger("change")
			.focus();
	}

	format(v: any): string {
		let that = this,
			formatter = that.options.formatter,
			text, separator;
		if (formatter) { return formatter.call(that, v); }
		if (v == null || isNaN(v)) { return ""; }// null|undefined|NaN

		text = v.toString();
		separator = that.options.decimalSeparator;
		if (separator) {
			text = text.replace(".", separator);
		}
		return text;
	}

	parse(text: string): number {
		let that = this,
			parser = that.options.parser,
			separator;
		if (parser) { return parser.call(that, text); }
		if (text === "") { return null; }

		separator = that.options.decimalSeparator;
		if (separator) {
			text = text.replace(separator, ".");
		}
		let res = validation.getParser(that.options.vt).tryParse(that.options, text);
		if (res.errorMsg) {
			throw res.errorMsg;
		}
		return res.parsedValue;
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this,
			options = that.options,
			useNativeInput = that.useNative(),
			$container = $("<div class='x-pe-number input-group'/>").appendTo(domElement),
			$input = $("<input class='form-control' type='" + (useNativeInput ? "number" : "text") + "' autocomplete='off' />").appendTo($container),
			$clearBtn,
			bindable,
			minValue,
			maxValue;

		$input.attr("name", options.name);

		$input.bind("input keyup", function (): void {
			let val = $(this).val();
			that.isEmpty(!val);
		});

		// init min/max
		if (options.minValue !== undefined) {
			minValue = options.minValue;
		}
		if (options.maxValue !== undefined) {
			maxValue = options.maxValue;
		}
		if (options.range && options.range.length === 2) {
			minValue = options.range[0];
			maxValue = options.range[1];
		}
		// если min/max не заданы в фасетах свойства, надо подставлять min/max от типа (vt),
		// чтобы юзер не мой выйти за допустимый диапазон
		if (minValue === undefined) {
			// NOTE: тут не важно, minValue это Number или Big, т.к. InputSpinner поддерживает оба
			let parser = <validation.NumberParser>validation.getParser(options.vt);
			minValue = parser.minValue;
		}
		if (maxValue === undefined) {
			// NOTE: тут не важно, minValue это Number или Big, т.к. InputSpinner поддерживает оба
			let parser = <validation.NumberParser>validation.getParser(options.vt);
			maxValue = parser.maxValue ;
		}

		// set INPUT'a attrs
		if (minValue !== undefined) {
			// NOTE: minValue can be Big
			$input.attr("min", minValue.toString());
		}
		if (maxValue !== undefined) {
			// NOTE: maxValue can be Big
			$input.attr("max", maxValue.toString());
		}

		// for integers limit total length of input with the length of max value (as string)
		// e.g.: if maxValue is 999 and user entered 100 then it makes no sense to enter more digits
		if (options.maxLength != undefined) {
			$input.attr("maxlength", options.maxLength);
		} else if (options.formatter && that.isInteger && maxValue != undefined && !options.noMaxLength) {
			let maxLength = maxValue.toString().length;
			if (new Big(maxValue).lt(0)) {
				maxLength++;
			}
			$input.attr("maxlength", maxValue.toString().length)

			/*
			 TODO: для i2/i4/ui1: при вводе количества цифр, равном количеству цифр в maxValue, переходить на следующий PE (возможно опцией)
			 if (that.options.autoBlur) {}
			 */
		}
		if (options.nullable) {
			$input.attr("required");
		}

		if (options.placeholder) {
			$input.attr("placeholder", options.placeholder);
		}
		if (options.step) {
			$input.attr("step", options.step);
		}

		if (!useNativeInput) {
			// NOTE: для нативного контрола никаких дополнительных контролов не добавляем

			$input.numeric({
				decimal: that.isInteger ? false : (that.options.decimalSeparator || ".")
			});

			if (that.commands["Clear"]) {
				$input.addClass("has-clear-btn");
				$clearBtn = $("<span class='clear-btn'>&times;</span>").appendTo($container);
				binding.commandBind($clearBtn, that.commands["Clear"]);
			}

			if (options.spinner) {

				that._spinner = new InputSpinner({
					min: minValue,
					max: maxValue,
					step: options.step,
					autoCorrect: options.autoCorrect,
					formatter: that.format.bind(that),
					parser: that.parse.bind(that)
				});
				that._spinner.attach($input);

				if (options.spinner !== "hidden") {
					// true or SpinnerOptions (not false and not "hidden")
					let spinnerOpts: peNumber.SpinnerOptions =
						options.spinner === true ? {buttons:"horizontal", icons:"plusminus"} : options.spinner;
					that._renderSpinButtons($container, spinnerOpts);
				}
			}
		}

		binding.databind(
			binding.html($input, "disabled"),
			binding.domain(that, "disabled")
		);
		that.element = $input;

		bindable = binding.html($input, {
			name: that.options.changeTrigger === "keyPressed" ? "valueLive" : "value",
			// NOTE: override standard accessor $.fn.val for usage of format/parse
			accessor: function (v) {
				let $this = this;
				if (arguments.length > 0) {
					$this.val(that.format(v));
				} else {
					return that.parse($this.val());
				}
			},
			// disable builtin domain->html parsing (toString calling)
			parse: null
		});
		that.databind(bindable);

		// trigger event for refresh
		$input.trigger("input");

		super.doRender(domElement);
	}

	protected _renderSpinButtons($container: JQuery, spinnerOptions: peNumber.SpinnerOptions): void {
		let that = this;
		if (spinnerOptions.buttons === "hidden" ) { return; }
		let $spinner = $("<span class='input-group-addon x-pe-number-spinner'></span>").appendTo($container);
		let $btnUp: JQuery, $btnDown: JQuery;

		if (spinnerOptions.buttons === "vertical") {
			$spinner.addClass("x-pe-number-spinner-vertical");
		} else {
			$spinner.addClass("x-pe-number-spinner-horizontal");
		}
		// for vertical: first button - UP, next - DOWN, for horizontal: first - DOWN, next - UP
		if (spinnerOptions.icons === "arrows") {
			if (spinnerOptions.buttons === "vertical") {
				$btnUp = $("<button class='btn' tabindex='-1'><span class='caret caret-up'></span></button>").appendTo($spinner);
				$btnDown = $("<button class='btn' tabindex='-1'><span class='caret'></span></button>").appendTo($spinner);
			} else {
				$btnDown = $("<button class='btn' tabindex='-1'><span class='caret'></span></button>").appendTo($spinner);
				$btnUp = $("<button class='btn' tabindex='-1'><span class='caret caret-up'></span></button>").appendTo($spinner);
			}
		} else {
			if (spinnerOptions.buttons === "vertical") {
				$btnUp = $("<button class='btn' tabindex='-1'><span class='x-icon x-icon-plus'></span></button>").appendTo($spinner);
				$btnDown = $("<button class='btn' tabindex='-1'><span class='x-icon x-icon-minus'></span></button>").appendTo($spinner);
			} else {
				$btnDown = $("<button class='btn' tabindex='-1'><span class='x-icon x-icon-minus'></span></button>").appendTo($spinner);
				$btnUp = $("<button class='btn' tabindex='-1'><span class='x-icon x-icon-plus'></span></button>").appendTo($spinner);
			}
		}

		let bindableDisabled = binding.expr(that, "disabled");

		that._spinner.attach(undefined /* don't change input */, $btnUp, $btnDown);

		binding.databind(binding.html($btnUp, "disabled"), bindableDisabled);
		binding.databind(binding.html($btnDown, "disabled"), bindableDisabled);
	}

	protected _onPropChanged(sender, value) {
		super._onPropChanged(sender, value);
		this.isEmpty(!value);
	}
}
namespace peNumber {
	export interface SpinnerOptions {
		/**
		 * Style of spinner buttins (increment/decrement):
		 * 	hidden - no buttons, vertical - vertical arrows up and down, horizontal - plus/minus buttons besides
		 */
		buttons?: "hidden" | "vertical" | "horizontal";
		icons?: "arrows" | "plusminus"
	}
	export interface Options extends PropertyEditor.Options {
		hideClearButton?: boolean;
		changeTrigger?: "keyPressed" | "lostFocus";
		decimalSeparator?: string;
		minValue?: number | string | Big;
		maxValue?: number | string | Big;
		range?: number[] | string[] | Big[];
		step?: number;
		useNative?: "mobileOnly" | "always" | "never";
		/**
		 * Style of spinner buttons: false - disable competely, "hidden" - support mouse/keyboard but hide buttons, "vertical"
		 */
		spinner?: boolean | "hidden" | SpinnerOptions;
		autoCorrect?: boolean;
		// NOTE: formatter option is inherited from formatters.FormatOptions
		/**
		 * @type {peNumberParserCallback}
		 */
		parser?: (v: any) => number;
		commands?: lang.Map<core.commands.ICommand | core.commands.ICommandFactory>;
		/**
		 * disable adding maxlength for integers with number of digits in maxValue
		 */
		noMaxLength?: boolean;
		/**
		 * Value for INPUT's maxlength attribute.
		 */
		maxLength?: number;
		/**
		 * Text for placeholder in input.
		 */
		placeholder?: string;
	}
}
/**
 * Returns text presentation of the value
 * @callback peNumberFormatterCallback
 * @this peNumber
 * @param {Number|String|*} v
 * @returns {String}
 */

/**
 * Returns typed value of the string presentation
 * @callback peNumberParserCallback
 * @this peNumber
 * @param {String} text
 * @returns {Number|null|NaN}
 */

// backward compatibility: access to static fields via prototype
peNumber.mixin(/** @lends peNumber.prototype */{
	defaultOptions: peNumber.defaultOptions
});

core.ui.peNumber = peNumber;

PropertyEditor.DefaultMapping["i8"] = peNumber;
PropertyEditor.DefaultMapping["i4"] = peNumber;
PropertyEditor.DefaultMapping["i2"] = peNumber;
PropertyEditor.DefaultMapping["ui1"] = peNumber;
PropertyEditor.DefaultMapping["single"] = peNumber;
PropertyEditor.DefaultMapping["float"] = peNumber;
PropertyEditor.DefaultMapping["double"] = peNumber;
PropertyEditor.DefaultMapping["decimal"] = peNumber;

export = peNumber;
