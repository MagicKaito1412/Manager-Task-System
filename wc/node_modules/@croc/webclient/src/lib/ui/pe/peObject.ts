import core = require("core");
import $ = require("lib/core.jquery");
import NavigationPropertyEditor = require("lib/ui/pe/NavigationPropertyEditor");
import Menu = require("lib/ui/menu/Menu");
import binding = require("lib/binding");
import formatters = require("lib/formatters");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import MenuButtonsPresenter = require("lib/ui/menu/MenuButtonsPresenter");
import DropDownMenuPresenter = require("lib/ui/menu/DropDownMenuPresenter");
import resources = require("i18n!lib/nls/resources");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import "xcss!lib/ui/styles/peObject.css";

import ui = require("lib/ui/.ui");
import domain = require("lib/domain/.domain");
import PartCommandMixin = require("../PartCommandMixin");
import IPart = ui.IPart;
import DomainObject = domain.DomainObject;
import lang = core.lang;
import Promise = lang.Promise;
import EditorCommandOptions = PartCommandMixin.EditorCommandOptions;
import EditorCommandResult = PartCommandMixin.EditorCommandResult;
import SelectorCommandOptions = PartCommandMixin.SelectorCommandOptions;
import SelectorCommandResult = PartCommandMixin.SelectorCommandResult;
import { IBindable } from "lib/binding";

type OrphanCheckResult = {orphan: boolean; value: DomainObject};

class peObject extends NavigationPropertyEditor {
	static defaultOptions: peObject.Options = {
		/**
		 * @type {"auto"|"buttons"|"dropdown"}
		 */
		menuPresentation: "auto",
		menuItemPresentation: "icon",
		emptyValue: "<i class='text-muted'>" + resources["value_not_specified"] + "</i>",
	};

	static defaultMenu: Menu.Options = { items: [
		{ name: "Select", title: resources["select"], icon: "search" },
		{ name: "Create", title: resources["create"] },
		{ name: "divider" },
		{ name: "Edit", title: resources["edit"] },
		{ name: "divider" },
		{ name: "Unlink", title: resources["navigationPE.unlink.scalar"], icon: "clear" },
		{ name: "Delete", title: resources["delete"] }
	]};

	options: peObject.Options;
	menu: Menu;
	commands: lang.Map<core.commands.ICommand>;

	private menuPresenter: IPart;
	private _button: JQuery;
	private _tabIndex: number;

	/**
	 * @constructs peObject
	 * @extends NavigationPropertyEditor
	 * @param options
	 */
	constructor(options?: peObject.Options) {
		options = peObject.mixOptions(options, peObject.defaultOptions);
		super(options);

		this.commands = lang.extend(this.createCommands(), this.options.commands);
		this.menu = this.createMenu();
		if (this.menu) {
			this.menu.bindToPart(this);
			this.menu.onItemExecuting = (args) => {
				args.object = this.value();
				args.pe = this;
			};
		}
	}

	protected createMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(peObject.defaultMenu, "peObject");
	}

	protected createMenu(): Menu {
		return new Menu(this.createMenuDefaults(), this.options.menu);
	}

	doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		var that = this,
			$element: JQuery,
			$btnGroup: JQuery,
			bindable,
			presentationContainer,
			presentation;

		// pe container:
		$element = $("<div class='x-pe-object'/>").appendTo(domElement);
		that.element = $element;

		// menu container:
		$btnGroup = $("<div class='btn-group pull-right' style='margin:0' />").appendTo($element);

		that.menuPresenter = that._createMenuPresenter();
		that.menuPresenter.setViewModel(that.menu);
		that.menuPresenter.render($btnGroup);
		that._button = $btnGroup.find("a.dropdown-toggle");

		// value presentation container:
		presentationContainer = $("<div class='x-pe-object-presentation-container' >").appendTo($element);
		presentation = $("<div></div>").textOverflow().appendTo(presentationContainer);

		bindable = {
			set: function (value) {
				if (!value) {
					let html;
					if (lang.isFunction(that.options.emptyValue)) {
						html = that.options.emptyValue.apply(that);
					} else {
						html = that.options.emptyValue;
					}
					presentation.html(html);
				} else {
					// NOTE: мы вставляем содержие как html осознанно (см. createBindableProp),
					// если в опциях нет formatterHtml или html=false, то текстовое значение (от formatter), будет закодировано
					presentation.html(value);
				}
			}
		};
		that.databind(bindable);

		super.doRender(domElement);
	}

	protected _createMenuPresenter(): IPart {
		let that = this,
			presenter;

		if (that.options.menuPresentation === "buttons" ||
			(that.options.menuPresentation === "auto" &&
				that.menu.hasOnly([that.commands["Unlink"], that.commands["Select"]]))
			) {
			presenter = MenuButtonsPresenter.create({
				inline: true,
				reverse: true,
				itemPresentation: that.options.menuItemPresentation || "icon",
				cssClass: "x-menu-btn-addon-right"
			});
		} else {
			// "dropdown" or "auto" and
			presenter = DropDownMenuPresenter.create();
		}
		return presenter;
	}

	protected _onDisabledChange(disabled: boolean): void {
		if (!this._button) { return; }
		let that = this,
			btnEl = that._button[0];
		if (!btnEl) { return; }
		// кнопка дропдауна от bootstrap не очень реагирует на установку аттрибута disabled
		// однако работает при установке соотв-го класса
		// так же отключается возможность установить фокус клавой
		disabled ?
			that._button.addClass("disabled")
			: that._button.removeClass("disabled");
		// отключается/включается переход по табу
		// запоминается текущий tabIndex для того, что бы его вернуть, когда pe раздизейблится
		// выполняется только когда _tabIndex еще не задан
		disabled && (that._tabIndex === undefined) && (that._tabIndex = btnEl.tabIndex);
		btnEl.tabIndex = disabled ? -1 : that._tabIndex || 0;
	}

	protected _bindToEsc(): void {
		let that = this,
			menuClosing: boolean,
			$element = that.element || that.$domElement,
			keyCode = core.html.keyCode;

		$element.keydown(function (e: JQueryKeyEventObject): void {
			if (e.which === keyCode.ESCAPE && $element.find(".btn-group.dropdown.open").length) {
				menuClosing = true;
			}
		});
		$element.keyup(function (e: JQueryKeyEventObject): void {
			if (e.which !== keyCode.ESCAPE || e.ctrlKey || e.shiftKey || e.metaKey || menuClosing) {
				menuClosing = false; return;
			}
			$(e.target).blur();
		});
	}

	protected createBindableProp(): IBindable {
		let that = this;
		return binding.expr(this.viewModel, () => {
			return formatters.formatPropHtml(this.options, this.value());
		});
	}

	currentValue(): DomainObject {
		return this.value();
	}

	unload(): void {
		let menuPresenter = this.menuPresenter;
		if (menuPresenter) {
			menuPresenter.unload();
		}
		super.unload();
	}

	protected _addObject(obj: DomainObject): void {
		this.value(obj);
	}

	protected _valueIds(): string[] {
		let value = this.value();
		return value ? [ value.id ] : [];
	}

	protected doUnlink(): lang.Promisable<void> {
		// execute base command
		let obj = this.currentValue();
		if (obj) {
			// orphan check: currently object-value which has changes and will become unreachable
			return lang.async.then(this.checkForOrphan(), (orphanCheck: OrphanCheckResult) => {
				this.value(null);
				if (orphanCheck.orphan) {
					this.viewModel.uow.detach(orphanCheck.value);
				}
			});
		}
	}

	protected doDelete(): void | lang.Promisable<void> {
		let obj = this.currentValue();
		if (obj) {
			let dialog = ConfirmDialog.create({
				header: this.options.descr || resources["navigationPE.deleteHeader"],
				text: resources["navigationPE.deletePrompt.one"]
			});

			return dialog.render().then((result) => {
				if (result !== "yes") { return; }

				// unlink object first
				this.value(null);

				if (this.viewModel && this.viewModel.uow) {
					this.viewModel.uow.remove(obj);
				}
			});
		}
	}

	protected doSelect(args: SelectorCommandOptions): Promise<SelectorCommandResult> {
		// overridden for possible orphan check: currently object-value which has changes and will become unreachable
		return lang.async.then(this.checkForOrphan(), (orphanCheck: OrphanCheckResult) => {
			// execute base command
			let cmdRes: Promise<SelectorCommandResult> = super.doSelect(args);

			if (orphanCheck.orphan) {
				// if command was executed (new value-object selected), detach previous orphan object on cmd completion
				cmdRes.then((result: SelectorCommandResult) => {
					if (result && result.selection) {
						this.viewModel.uow.detach(orphanCheck.value);
					}
				});
			}
			return cmdRes;
		});
	}

	protected doCreate(args: EditorCommandOptions): Promise<EditorCommandResult> {
		// overridden for possible orphan check: currently object-value which has changes and will become unreachable
		return lang.async.then(this.checkForOrphan(), (orphanCheck: OrphanCheckResult) => {
			// execute base command
			let cmdRes: Promise<EditorCommandResult> = super.doCreate(args);

			if (orphanCheck.orphan) {
				// if command was executed (new value-object created), detach previous orphan object on cmd completion
				cmdRes.then((result: EditorCommandResult) => {
					if (result && result.success) {
						this.viewModel.uow.detach(orphanCheck.value);
					}
				});
			}
			return cmdRes;
		});
	}

	protected checkForOrphan(): lang.Promisable<OrphanCheckResult> {
		let that = this,
			obj = that.value();
		if (!obj) {
			return {orphan: false, value: obj};
		}

		if (!that._isOrphan(obj)) {
			return {orphan: false, value: obj};
		}

		let dialog: ConfirmDialog = ConfirmDialog.create({
			header: that.title(),
			text: resources["peObject.orphan"]
		});
		// warn user about losing data
		return dialog.open().then((result) => {
			if (result !== "yes") {
				// cancel command
				return lang.rejected();
			}

			return {orphan: true, value: obj};
		});
	}
}

interface peObject {
	// override type of value
	value(v: DomainObject): void;
	value(): DomainObject;
}

// backward compatibility: access to static fields via prototype
peObject.mixin({
	defaultOptions: peObject.defaultOptions,
	defaultMenu: peObject.defaultMenu
});

namespace peObject {
	export interface Options extends NavigationPropertyEditor.Options {
		menu?: Menu.Options;
		/**
		 * @type {"auto"|"buttons"|"dropdown"}
		 */
		menuPresentation?: "auto"|"buttons"|"dropdown";
		menuItemPresentation?: Menu.ItemPresentation;
		/**
		 * Html or callback returning html for empty value presentation
		 */
		emptyValue?: string | (() => string);
	}
}

core.ui.peObject = peObject;

PropertyEditor.DefaultMapping.register(function (propMd) {
	return !propMd.presentation ? core.ui.peObject : null;
}, { vt: "object" });

export = peObject;
