import $ = require("jquery");
import core = require("core");
import binding = require("lib/binding");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import formatters = require("lib/formatters");
import resources = require("i18n!lib/nls/resources");
import "xcss!lib/ui/styles/peBooleanSwitch.css";

import lang = core.lang;

class peBooleanSwitch  extends PropertyEditor {
	static defaultOptions: peBooleanSwitch.Options = {
		trueTitle: resources["peBooleanSwitch.true"],
		falseTitle: resources["peBooleanSwitch.false"],
		nullTitle: resources["peBooleanSwitch.null"],
		threeStates: undefined
	};

	private _animatingTo: JQuery;

	options: peBooleanSwitch.Options;

	/**
	 * @constructs peBooleanSwitch
	 * @extends PropertyEditor
	 * @param {Object} options
	 */
	constructor(options: peBooleanSwitch.Options) {
		options = peBooleanSwitch.mixOptions(options, peBooleanSwitch.defaultOptions);
		super(options);
		if ((this.options.threeStates === undefined) && this.options.nullable) {
			this.options.threeStates = true;
		}
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		var that = this,
			element = $("<div></div>").appendTo(domElement).addClass("x-pe-bool-switch").attr("tabindex", 0),
			options = that.options,
			inputs = [],
			selection,
			groupName = that.id,
			trueTitle = options.trueTitle || formatters.formatPropValue(options, true),
			falseTitle = options.falseTitle || formatters.formatPropValue(options, false);
		//that.groupName = groupName;

		if (!options.threeStates && options.nullable) {
			// 2-states nullable: true & null
			inputs.push(that._addInput(element, groupName, true, trueTitle));
			inputs.push(that._addInput(element, groupName, null, falseTitle));
		} else {
			// not-nullable or 3-states: true & false
			if (options.threeStates) {
				inputs.push(that._addInput(element, groupName, null, options.nullTitle));
			}
			inputs.push(that._addInput(element, groupName, true, trueTitle));
			inputs.push(that._addInput(element, groupName, false, falseTitle));
		}

		// find selection marker
		selection = $("<a></a>").appendTo(element).css({ display: "none" });

		that.element = element;

		that._addInputHandlers(inputs, selection);
		that._bindToHtml(groupName);
		that._bindToDisabled();

		if (!that.disabled()) {
			that._addKeyboardHandlers();
		}

		super.doRender.call(this, domElement);
	}

	focus(): void {
		if (this.disabled()) { return; }
		if (!this.element) { return; }

		this.element.focus();
	}

	_addInput(parent: JQuery, name: string, value: boolean|null, title: string|formatters.SafeHtml): JQuery {
		let id = this._getInputId(name, value);
		let input = $("<input />", { type: "radio", name: this.viewModelProp, id: id, tabindex: -1 }).appendTo(parent);

		if (value != null) {
			input.attr("value", value ? "true" : "false");
		}

		let $label = $("<label></label>").appendTo(parent);
		if (formatters.isHtml(title)) {
			$label.html(title.toHTML());
		} else {
			$label.text(title);
		}
		$label.addClass("x-pe-bool-switch-label").attr("for", id);
		return input;
	}

	_getInputId(group: string, val: boolean|null) {
		return group + "_" + (val != null ? val.toString() : "null");
	}

	_addInputHandlers(inputs: JQuery[], selection: JQuery): void {
		let that = this;
		for (let i = 0; i < inputs.length; i++) {
			let input = $(inputs[i]);
			input.change(function (e) {
				let label = $("label[for='" + e.target.id + "']");
				that._setSelection(label, selection);
			});
		}
	}

	_setSelection(item: JQuery, sel: JQuery): void {
		var that = this,
			lastSelected = that._animatingTo
				? that._animatingTo
				: that.element.find("label.selected");

		if (that._animatingTo) {
			// NOTE: because of jquery.animate-enhanced plugin, animation can be unstoppable
			// If jquery.animate-enhanced choose to use CSS3 transitions animation's callback will called anyway
			that._animatingTo.data("animation-canceled", true);
			sel.stop(true);
			that._animatingTo = null;
			//sel.hide();
			//lastSelected = that.element.find('label.selected');
		}
		if (!lastSelected.length) {
			// initial selection - on the page load
			item.addClass("selected");
			return;
		}

		// remove css-border under selected item
		lastSelected.removeClass("selected");

		// if was not animating put selection element under previously selected item
		if (!that._animatingTo) {
			sel.css({ left: lastSelected.position().left, width: lastSelected.outerWidth() });
		}
		sel.show();
		// set new end point
		that._animatingTo = item;

		// run animation to the end point
		sel.animate({ left: item.position().left, width: item.outerWidth() }, 100, "swing", function (): void {
			// set css-border under new selected item
			if (item.data("animation-canceled")) {
				item.removeData("animation-canceled");
				return;
			}
			item.addClass("selected");
			that._animatingTo = null;
			sel.hide();
		});
	}

	_addKeyboardHandlers(): void {
		var that = this,
			element = that.element,
			keyCode = core.html.keyCode;

		// set keyup handler on outer div
		element.keyup(function (e) {
			if (e.keyCode === keyCode.SPACE || e.keyCode === keyCode.RIGHT) {
				that._switchNext();
			}

			if (e.keyCode === keyCode.LEFT) {
				that._switchPrev();
			}
		});

		// block default behaviour of radio buttons
		element.find("input[type='radio']").keyup(function (e: JQueryKeyEventObject): void {
			e.preventDefault();
		});

		// block space handling on document
		element.keydown(function (e: JQueryKeyEventObject): void {
			if (e.keyCode === keyCode.SPACE || e.keyCode === keyCode.RIGHT || e.keyCode === keyCode.LEFT) {
				e.stopPropagation();
				e.preventDefault();
			}
		});
	}

	_switchNext(): void {
		let element = this.element;
		let current = element.find("input:checked");
		let next = element.find("input:checked ~ input");

		if (!current.length || !next.length) {
			next = element.find("input").eq(0);
		} else {
			next = next.eq(0);
		}

		this._doSwitch(next);
	}

	_switchPrev(): void {
		let inputs = this.element.find("input[type='radio']");
		let previous;

		for (let i = 0; i < inputs.length; i++) {
			if (inputs.eq(i).is(":checked")) {
				break;
			}
			previous = inputs.eq(i);
		}

		previous = previous || inputs.last();

		this._doSwitch(previous);
	}

	_doSwitch(input: JQuery): void {
		if (!input.is(":checked")) {
			input.prop("checked", true).trigger("change");
			// no need to call _setSelection here. it will be called from the input's change handler
		}
	}

	_parseBoolean(str: string): boolean|null {
		if (str === "true" || str === "1")
			return true;
		if (str === "false" || str === "0")
			return false;

		return null;
	}

	_bindToHtml(groupName) {
		var that = this,
			element = that.element,
			bindable = {
				get: function () {
					let v = element.find("input:checked").attr("value");
					return v !== undefined ? that._parseBoolean(v) : null;
				},
				set: function (v) {
					let id = that._getInputId(groupName, v),
						input = element.find("#" + id);
					if (v === false && !input.length && !that.options.threeStates) {
						// NOTE: special-case: для значения false в 2-х позиционном PE, будет считать false как null,
						// иначе оно не отобразится
						id = that._getInputId(groupName, null);
						input = element.find("#" + id)
					}
					if (!input.length) {

						// there's no input for current value (e.g. nullable=false but property is null) - remove selection
						element.find("input:checked").prop("checked", false);
						element.find("label.selected").removeClass("selected");
						that._animatingTo = null;
					} else {
						that._doSwitch(input);
					}
				},
				onchange: function (handler) {
					element.find("input").bind("change", handler);
					return {
						dispose: () => {
							element.find("input").unbind("change", handler);
						}
					};
				}
			};
		that.databind(bindable);
	}

	_bindElementToDisabled(): void {
		let that = this,
			inputs = that.element.find("input");

		for (let i = 0; i < inputs.length; i++) {
			binding.databind(
				binding.html(inputs[i], "disabled"),
				binding.domain(that, "disabled"),
				{ oneway: true }
			);
		}

		let bindable = {
			set: function (disabled) {
				disabled
					? that.element.attr("tabindex", -1)
					: that.element.remove("tabindex");
			}
		};

		binding.databind(
			bindable,
			binding.domain(that, "disabled")
		);
	}
}

namespace peBooleanSwitch {
	export interface Options extends PropertyEditor.Options {
		/**
		 * Checkbox with tree state (checked=>true, unchecked=>false, indeterminate=>null)
		 * @type {Boolean}
		 */
		threeStates?: boolean;
		trueTitle?: string | formatters.SafeHtml;
		falseTitle?: string | formatters.SafeHtml;
		nullTitle?: string | formatters.SafeHtml;
	}
}

// backward compatibility: access to static fields via prototype
peBooleanSwitch.mixin(/** @lends peBooleanSwitch.prototype */{
	defaultOptions: peBooleanSwitch.defaultOptions
});

core.ui.peBooleanSwitch = peBooleanSwitch;

PropertyEditor.DefaultMapping["boolean"] = peBooleanSwitch;
PropertyEditor.DefaultMapping.register(function (propMd) {
	return (!propMd.presentation || propMd.presentation === "switch") ? core.ui.peBooleanSwitch : null;
}, { vt: "boolean" });

export = peBooleanSwitch;

