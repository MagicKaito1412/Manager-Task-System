import $ = require("jquery");
import core = require("core");
import Component = require("lib/ui/Component");
import binding = require("lib/binding");
import formatters = require("lib/formatters");
import validation = require("lib/validation");
import utils = require("lib/utils");
import resources = require("i18n!lib/nls/resources");
import "bootstrap";
import "jquery-ui/core"; // used for :focusable selector in focus() method

import { metadata } from "lib/domain/.domain";

import lang = core.lang;
import IDisposable = lang.IDisposable;
import IBindable = binding.IBindable;
import ValueType = metadata.ValueType;
import PropertyMeta = metadata.PropertyMeta;
import Violation = validation.Violation;
import SafeHtml = formatters.SafeHtml;
import PropertyEditorConstructor = PropertyEditor.DefaultMapping.PropertyEditorConstructor;
import PropertyEditorFactory = PropertyEditor.DefaultMapping.PropertyEditorFactory;
import PropertyEditorResolver = PropertyEditor.DefaultMapping.PropertyEditorResolver;
import PropertyEditorRegisterOptions = PropertyEditor.DefaultMapping.PropertyEditorRegisterOptions;
import PropertyEditorMap = PropertyEditor.DefaultMapping.PropertyEditorMap;
import ValidationOptions = PropertyEditor.ValidationOptions;
import { FormatOptions } from "../../formatters";
import { Part } from "core.ui";

type PropertyEditorMapItem = {
	resolver: PropertyEditorResolver;
	priority: number;
};
type PropertyEditorFactoryItem = {
	factory: PropertyEditorConstructor | PropertyEditorFactory;
	priority: number;
};

const TIMEOUT_VALIDATION_FIELD = "_timeout_validation";

const DefaultMapping: PropertyEditorMap = {
	peNotAuthorized: undefined,
	peNotImplemented: undefined,
	_resolvers: {},
	_findFactory: function (vt: ValueType, propMeta: PropertyEditor.Options): PropertyEditorFactoryItem {
		let resolvers: PropertyEditorMapItem[] = this._resolvers[vt || ""],
			result = null;
		lang.some(resolvers, (item: PropertyEditorMapItem) => {
			let factory = item.resolver(propMeta);
			if (factory) {
				result = {
					factory: factory,
					priority: item.priority
				};
				return true;
			}
			return false;
		});
		return result;
	},
	/**
	 * Maps metadata of PE to implementation class
	 * @param {Function} resolver A function which gets a metadata of PE and returns implementation class or null
	 * @param {Object} [options]
	 * @param {String} [options.vt]
	 * @param {Number} [options.priority=0]
	 * @returns {PropertyEditor.DefaultMapping}
	 */
	register: function (resolver: PropertyEditorResolver, options?: PropertyEditorRegisterOptions) {
		if (!resolver) { throw new Error("PropertyEditor.DefaultMapping.register: resolver is null"); }
		options = options || {};

		let vt = options.vt || "",
			resolvers: PropertyEditorMapItem[] = this._resolvers[vt] || [];
		resolvers.push({
			resolver: resolver,
			priority: options.priority || 0
		});
		// sort by priority (desc)
		this._resolvers[vt] = lang.sortBy(resolvers, item => -item.priority);
		return this;
	},
	getImpl: function (propMd: PropertyEditor.Options): PropertyEditorConstructor | PropertyEditorFactory {
		let that = this,
			itemVt: PropertyEditorFactoryItem = propMd.vt && that._findFactory(propMd.vt, propMd),
			itemAll: PropertyEditorFactoryItem = that._findFactory("", propMd),
			item: PropertyEditorFactoryItem = (itemAll && (!itemVt || itemAll.priority > itemVt.priority)) ? itemAll : itemVt;

		if (item && item.factory) { return item.factory; }

		// otherwise search for PE in static fields of DefaultMapping
		return <lang.Constructor<PropertyEditor>>lang.find(that, (v, key: string) => key === propMd.vt);
	},

	/**
	 * Create the property editor and optionally set viewModel
	 * @param {Object} propMd
	 * @param {*} [viewModel]
	 * @returns {PropertyEditor} Created property editor
	 */
	create: function (propMd: PropertyEditor.Options, viewModel?: any): PropertyEditor {
		let peImpl;
		if (propMd.PropertyEditor) {
			peImpl = propMd.PropertyEditor;
		} else {
			peImpl = PropertyEditor.DefaultMapping.getImpl(propMd) || PropertyEditor.DefaultMapping.peNotImplemented;
		}

		let pe = peImpl.create(propMd);

		if (viewModel) {
			if (!pe.setViewModel) {
				throw new Error("Property editor implementation for prop '" + propMd.name + "' doesn't have required method setViewModel");
			}
			pe.setViewModel(viewModel);
		}

		return pe;
	}
};

class PropertyEditor extends Component {
	static DefaultMapping: PropertyEditorMap = DefaultMapping;

	static defaultOptions: PropertyEditor.Options = {
		/**
		 * Property Name
		 * @type {String}
		 */
		name: undefined,
		/**
		 * Description
		 * @type {String}
		 */
		descr: undefined,
		/**
		 * Var Type
		 * @type {String}
		 */
		vt: undefined,
		/**
		 * Hint
		 * @type {String}
		 */
		hint: undefined,
		/**
		 * Whether property is nullable or not
		 * @type {Boolean}
		 */
		nullable: undefined,
		readOnly: false,
		formatter: undefined,
		formatterName: undefined,
		rules: undefined,
		layout: {position: "cell"},
		hidden: undefined,
		disabled: undefined,
		width: undefined,
		onSetViewModel: undefined,
		/**
		 * clear focus from PE when ESC pressed
		 */
		blurOnEsc: true,
		/**
		 * Run a validation when changing the property of viewModel
		 * @type {Boolean}
		 */
		autoValidate: true,
		/**
		 * Context in which the PE is created
		 * @type {String}
		 */
		contextName: undefined
	};

	/**
	 * Default options by context
	 */
	static contextDefaultOptions: lang.Map<PropertyEditor.Options> = {};

	options: PropertyEditor.Options;
	id: string;
	/**
	 * name of viewModel, passed via Options.name
	 */
	viewModelProp: string;
	/**
	 * original name, usually the same as viewModelProp/options.name but differs for prop-chains (viewModelProp/options.name change fullName does not)
	 */
	fullName: string;
	element: JQuery;
	protected _chainPropName: string;

	protected layout: PropertyEditor.LayoutOptions;

	private _nullable: boolean;
	// disposable to dispose on unload
	private _disposes: IDisposable[];
	// disposable to dispose on dispose
	private _disposesPersisted: IDisposable[];
	private _notAuthorized: any;
	private _domElement: HTMLElement|JQuery;

	/**
	 * @constructs PropertyEditor
	 * @extends Component
	 * @param {Object} options
	 * @param {String} options.name
	 * @param {String} options.descr
	 * @param {String} options.vt
	 * @param {String} [options.hint]
	 * @param {boolean} [options.nullable]
	 * @param {boolean} [options.readOnly=false]
	 * @param {Object} [options.formatter]
	 * @param {String} [options.formatterName]
	 * @param {Array} [options.rules]
	 * @param {Object} [options.layout]
	 * @param {boolean} [options.hidden=false]
	 * @param {boolean} [options.disabled=false]
	 */
	constructor(options?: PropertyEditor.Options) {
		options = PropertyEditor.mixContextOptions(options,
			PropertyEditor.defaultOptions,
			PropertyEditor.contextDefaultOptions
		);

		super(options);

		this._validateRequiredOptions(this.options);
		this.viewModelProp = this.options.name;
		this.fullName = this.options.name;
		this.viewModel = null;  // NOTE: viewModel is assigned later, in setViewModel
		this.title(this.options.descr || this.options.name);
		this.layout = this.options.layout;
		if (this.options.hidden) {
			this.hidden(true);
		}
		if (this.options.disabled) {
			this.disabled(true);
		}

		this.autoValidate(this.options.autoValidate);
		this.bind("change:autoValidate", (sender, v) => {
			if (!v) {
				// abandon pending async validation (if any)
				window.clearTimeout(this[TIMEOUT_VALIDATION_FIELD]);
				this[TIMEOUT_VALIDATION_FIELD] = null;
			}
		});

		this.notnull(!this.options.nullable && !this.options.many);
	}

	/**
	 * Title. By default it's description of the property
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	title: lang.ObservableProperty<string>;

	notnull(): boolean;
	notnull(v: boolean): void;
	/**
	 * Whether property if mandatory.
	 * @observable-property {Boolean}
	 */
	notnull(v?: boolean): boolean {
		if (!arguments.length) {
			return PropertyEditor._get(this, "notnull");
		}
		if (PropertyEditor._set(this, "notnull", v)) {
			this.onNotnullChange(v);
		}
	}

	protected onNotnullChange(v: boolean): void {
		this.options.nullable = !v;
	}

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	hidden: lang.ObservableProperty<boolean>;

	// NOTE: do not add init value (in accessor spec) as we specificall handle undefined value in _bindElementToDisabled
	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor()
	disabled: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor()
	autoValidate: lang.ObservableProperty<boolean>;

	bindingError(): any;
	bindingError(v: any): void;
	/**
	 * Binding error
	 * @observable-property {Object}
	 */
	bindingError(v?: any) {
		if (!arguments.length) {
			return PropertyEditor._get(this, "bindingError");
		}
		if (PropertyEditor._set(this, "bindingError", v)) {
			this._onBindingErrorChanged(v);
		}
	}
	violation(): any;
	violation(v: any): void;
	/**
	 * Violation
	 * @observable-property {Object}
	 */
	violation(v?: Violation) {
		if (!arguments.length) {
			return PropertyEditor._get(this, "violation");
		}
		if (PropertyEditor._set(this, "violation", v)) {
			this._onViolationChanged(v);
		}
	}

	createId(viewModel: any, prop: string): string {
		let id = prop + "_" + (viewModel.id || utils.generateGuid());
		// replace symbols which may be used in css selectors
		return id.replace(/[.,#>+~]/g, "_");
	}

	setViewModel(viewModel: any): void {
		let that = this,
			oldModel = that.viewModel;

		if (lang.support.isNotLoaded(viewModel)) {
			if (oldModel) {
				that._unsubscribeViewModel();
			}
			viewModel.load().done(viewModel => {
				viewModel = that.onSetViewModel(viewModel) || viewModel;
				super.setViewModel(viewModel);
				if (that.domElement) {
					that.rerender();
				}
			});
			// prevent sync rerender (below)
			oldModel = null;
		} else {
			viewModel = that.onSetViewModel(viewModel) || viewModel;
			if (oldModel && oldModel !== viewModel) {
				that._unsubscribeViewModel();
			}
		}

		if (viewModel) {
			that.id = that.createId(viewModel, that.viewModelProp);
		}

		super.setViewModel(viewModel);
		// NOTE: нам надо подписаться на события VM, но мы это сделаем в onReady,
		// т.к. реакция нужна для отрендеренного РЕ

		if (oldModel !== viewModel) {
			if (that.domElement && viewModel) {
				that.rerender();
			} else if (that.domElement && !viewModel) {
				// not-null -> null
				that._domElement = that.domElement;
				that.unload();
			} else if (that._domElement && !that.domElement && viewModel) {
				// PE was rendered before VM was set to null, render it back again
				that.render(that._domElement);
			}
		}
	}

	protected _unsubscribeViewModel(): void {
		let that = this;
		// unsubscribe on the current viewModel
		if (that.viewModel && that.viewModel.unbind && that.viewModelProp) {
			that.viewModel.unbind("change:" + that.viewModelProp, null, that);
			that.viewModel.unbind("error:" + that.viewModelProp, null, that);
		}
	}

	protected onSetViewModel(viewModel: any): any {
		// NOTE: propMd/options могут указывать на цепочку свойств от VM,
		// таким образом viewModel это не наша ViewModel, а как бы родительская, относительно которой мы должны пройти цепочку
		// В обычном случае можно считать, что цепочка состоит из одного свойства.
		let that = this;
		let propMd = that.options;
		let propChain = propMd.chain;
		if (viewModel && propChain) {
			let viewModelRoot = viewModel;
			// current name contains full chain, change it to local prop relatively to PE's VM
			that._chainPropName = propMd.name;
			propMd.name = propChain.props[propChain.props.length - 1].name;
			that.viewModelProp = propMd.name;
			// NOTE: в качестве цепочки поддерживает 2-уровня: prop1.prop2, везьмем prop1 и переполучим VM для PE
			viewModel = core.lang.get(viewModel, propChain.props[0].name);
			// NOTE: сбросим chain, чтобы при повторных вызовах setViewModel (например, при загрузке объекта), мы сюда не попали
			propMd.chain = null;
			that._observePropChain(viewModelRoot, propChain);
		}

		let onSetViewModel = this.options.onSetViewModel;
		if (viewModel && onSetViewModel) {
			viewModel = onSetViewModel.call(this, viewModel);
		}
		let value = that._getRawValue(viewModel);
		if (value && value.isNotAuthorized) {
			// NOTE: ранее NotAuthorized значение анализировалось перед созданием PE в PropertyEditorMap.create (WC-1189)
			that.onNotAuthorized();
		}

		return viewModel;
	}

	protected _observePropChain (vmRoot: any, chain: { props: any[] }): void {
		let that = this;
		// NOTE: в качестве цепочки поддерживает 2-уровня: prop1.prop2,
		// где prop1 это навигируемое св-во, prop2 это просто свойство (но оно может быть свойство комплексного типа, т.е. содержать "." в имени)
		let propName = chain.props[0].name;
		let expr = lang.observableExpression(lang.property(propName), {
			onchange: (reason) => {
				if (reason === "loadError") {
					console.warn("PropertyEditor: ObservableExpression failed on loading '" + chain.props.map(p => p.name).join(".") + "'");
					// NOTE: нам нужна ошибка, возникшая при загрузке
					try {
						expr.apply(vmRoot);
					} catch (ex) {
						this.violation(ex);
					}
					expr.dispose();
				} else {
				expr.dispose();
				that._observePropChain(vmRoot, chain);
			}
			}
		});
		let val = expr.apply(vmRoot);
		if (val === null || val === undefined) {
			// Объект владелец текущего свойтсва-цепочки пропал. Надо очистить/скрыть PE.
			// Т.к. если его оставить, то байндинг продолжит работать.
			// При установке viewModel=null PE будет выгружен (unload), это разрушит байндинги.
			// Одного hidden может быть недостаточно, если он не задействован в шаблоне.
			// Альтернативный вариант - disabled(true), то тогда может остаться текущее значение в поле.
			that.hidden(true);
			that.setViewModel(null);
		} else if (lang.support.loadingValue !== val) {
			// У свойства цепочки есть значение, если ранее оно было скрыто, его надо показать
			// Но свойство могло быть скрыто прикладной логикой
			if (that.options.hidden !== true) {
				that.hidden(false);
			}
			that.setViewModel(val);
		}
		// else: значение свойства корневой VM - loadingValue, т.е. объект/свойство не загружен(ы),
		//		они загрузятся автоматичеки (в observableExpression) и после загрузки вызовется onchange,
		//		и мы опять попадем сюда же.
		that.addDisposable(expr, null, true);
	}


	/**
	 * @deprecated Use Part.mixOptions instead
	 * @param staticOptions
	 * @param options
	 * @returns {*}
	 */
	protected mergeOptions(staticOptions: PropertyEditor.Options, options: PropertyEditor.Options): PropertyEditor.Options {
		return utils.mergeOptions(staticOptions, options);
	}

	protected _validateRequiredOptions(options: PropertyEditor.Options): void {
		if (!options.name) { throw new Error("PropertyEditor.constructor: required attribute options.name wasn't specified");}
		if (!options.vt) { throw new Error("PropertyEditor.constructor: required attribute options.vt wasn't specified"); }
	}

	protected createBindableProp(): IBindable {
		// NOTE: так не верно!
		//return binding.expr(this.viewModel, this.viewModelProp);

		// viewModelProp может быть именем комплексного свойства, содержащим точки (например,
		// address.locality.type). Если передать такое выражение в текстовом виде, то будет попытка получать
		// последовательно свойства "address"."locality"."type". А нам нужно одно свойство с точками:
		// "address.locality.type". Поэтому передадим в байндинг функцию-accessor (к тому же так
		// не нужно парсить текст - должно быть чуть быстрее).
		return binding.expr(this.viewModel, lang.property(this.viewModelProp));

		// NOTE: можно было бы сразу получить accessor у viewModel, как в закомментированном коде:
		//return binding.expr(this.viewModel, this.viewModel[this.viewModelProp]);
		// Но если viewModel в данный момент не прогружена (isLoaded == false), то нужной функции
		// еще не будет и все упадет.
	}

	protected databind(element: HTMLElement|JQuery|IBindable): void;
	/**
	 * Bind DOMElement to viewModel's property
	 * @param {HTMLElement|jQuery|bindable} element DOM-элемент, jQuery-множество или любое bindable значение
	 */
	protected databind(element: any): void {
		let that = this,
			bindableProp: IBindable = that.createBindableProp();

		let bindableElement: IBindable = (element.nodeType || element instanceof $) ?
			binding.html(element) : element;
		$(bindableElement).on("bindingErrorChanged", (event, error) => {
			that.bindingError(error);
		});

		let disposable = binding.databind(bindableElement, bindableProp);
		that.addDisposable(disposable);
	}

	protected _onDisabledChange?(v: boolean): void;

	protected _bindToDisabled(): void {
		this._bindElementToDisabled();
		this._bindNullableToDisabled();
	}

	/**
	 * Creates binding between disabled prop and html:
	 * if the current part contains _onDisabledChange method then binding will call it,
	 * otherwise simple html "disabled" binding will be created.
	 * @protected
	 */
	protected _bindElementToDisabled(): void {
		let that = this,
			disposable: IDisposable;

		if (that._onDisabledChange) {
			disposable = binding.databind(
				{
					set(v: any): void {
						// NOTE: изменение disabled может быть true <-> false,
						// если оно undefined - это начальное значение, его можно игнорировать
						if (v !== undefined) {
							that._onDisabledChange(v);
						}
					}
				},
				binding.expr(that, "disabled")
			);
		} else {
			disposable = that.element ?
				binding.databind(
					binding.html(that.element, "disabled"),
					binding.expr(that, "disabled")
				) :
				undefined;
		}
		that.addDisposable(disposable, "disabled-html");
	}

	/**
	 * Creates binding between disabled prop and nullable options:
	 * for disabled PE set nullable=true, for enabled PE restores previous value.
	 * @private
	 */
	protected _bindNullableToDisabled(): void {
		let that = this,
		disposable = binding.databind(
				{
					set(v: any): void {
						if (v) {
							that._nullable = !!that.options.nullable;
							that.options.nullable = true;
						} else if (that._nullable !== undefined) {
							that.options.nullable = that._nullable;
									that._nullable = undefined;
						}
					}
				},
				binding.expr(that, "disabled")
		);
		that.addDisposable(disposable, "disabled-nullable");
	}

	protected validate?(): string|Violation;

	protected createViolation(error: string|SafeHtml|Violation): Violation {
		return validation.createViolation(error, this.viewModel, this.options as PropertyMeta);
	}

	/**
	 * Run validation for the current property editor - validate viewModel's property with PE's metadata
	 * @return {Object} violation object or undefined if there was no errors
	 */
	runValidation(options?: ValidationOptions): Violation {
		let that = this;
		if (!that.shouldValidate(options)) { return null; }

		if (that.bindingError()) {
			return that.createViolation(that.bindingError());
		}

		let violation: Violation = that.validateProp();
		if (!violation && that.validate) {
			violation = that.createViolation(that.validate());
		}
		that.violation(violation);

		return violation;
	}

	/**
	 * Validate property current value using rules in options.
	 * @returns {Violation}
	 */
	protected validateProp(): Violation {
		return validation.validateProp(this.viewModel, this.options as PropertyMeta);
	}

	/**
	 * Run validation for the current property editor - validate viewModel's property with PE's metadata
	 * @method
	 * @async-debounce throttle=100
	 * @return {Object} violation object or undefined if there was no errors
	 */
	@lang.decorators.constant(lang.debounce("runValidation", 100, TIMEOUT_VALIDATION_FIELD))
	runValidationAsync: (options?: ValidationOptions) => void;

	protected shouldValidate(options?: ValidationOptions): boolean {
		return !this.hidden() && this.viewModel;
	}

	protected _onPropChanged(sender: any, value: any): void {
		if (value && value.isNotAuthorized) {
			// NOTE: ранее NotAuthorized значение анализировалось перед созданием PE в PropertyEditorMap.create (WC-1189)
			// TODO: обрабатывать обратную установку (NotAuthorized -> не-NotAuthorized)?
			this.onNotAuthorized();
		} else {
			if (this._notAuthorized) {
				// NotAuthorized -> не-NotAuthorized
				this.onNotAuthorized(/*rollback:*/true);
			}
			if (this.autoValidate()) {
				this.runValidationAsync({ reason: "auto" });
			}
		}
	}

	protected onNotAuthorized(rollback?: boolean): void {
		let that = this;
		if (rollback) {
			if (that._notAuthorized) {
				that.disabled(that._notAuthorized.disabled);
				that.hidden(that._notAuthorized.hidden);
			}
			that._notAuthorized = undefined;
		} else {
			that._notAuthorized = {
				disabled: that.disabled(),
				hidden: that.hidden()
			};
			// Это вызовет rerender
			that.disabled(true);
			that.hidden(true);
		}
	}

	protected _onPropErrorChanged(error: Violation): void {
		this.violation(error);
	}

	/**
	 * Handler for changing "bindingError"
	 * @param {*} newVal
	 * @private
	 */
	protected _onBindingErrorChanged(newVal: string): void {
		// NOTE: this will clear violation error if it exists
		this.renderError(newVal);
	}

	/**
	 * Handler for changin "violation".
	 * It's also called directly if violation already exists during render.
	 * @param {*} [newVal]
	 * @private
	 */
	protected _onViolationChanged(newVal?: Violation): void {
		let violation = newVal;
		if (!arguments.length) {
			violation = this.violation();
		}
		this.renderError(violation || this.bindingError());
	}

	/**
	 * Add a "disposable" - an object holding some subscription to destroy on unload.
	 * Usually disposables are created with binding.databind or Observable.subscribe.
	 * @param disposable
	 * @param [name] optional name of subscription to guarantee its uniqueness (dispose existing).
	 * @param [persisted] true to dispose the disposable on dispose instead of unload
	 */
	addDisposable(disposable: IDisposable, name?: string, persisted?: boolean): void {
		let that = this;
		let disposables: IDisposable[];
		if (persisted) {
			that._disposesPersisted  = disposables = that._disposesPersisted || [];
		} else {
			that._disposes = disposables = that._disposes || [];
		}
		if (name) {
			// Если задано имя, то байндинг именованный и его disposable может быть найден
			// Это используется для гарантирования исключения повторного байндинга

			// Например, метод _bindElementToDisabled вызывается из onReady,
			// и может вызывать более одного раза.
			// В этом случае предыдущий байндинг не уничтожен, т.к. unload не было.
			// Найдем его и уничтожим.
			for (let i = 0; i < disposables.length; i++) {
				let item = disposables[i];
				if ((<any>item).name === name) {
					item.dispose();
					disposables.splice(i, 1);
					break;
				}
		}
	}
		if (disposable && disposable.dispose) {
			if (name) {
				(<any>disposable).name = name;
			}
			disposables.push(disposable);
		}
	}

	protected _getRawValue(viewModel?: any): any {
		let that = this;
		let value;
		viewModel = viewModel || that.viewModel;
		if (viewModel) {
			// NOTE: получим значение св-ва, без генерации событий
			if (viewModel.get) {
				value = viewModel.get(that.viewModelProp, {suppressEvents: true});
			} else {
				value = viewModel[that.viewModelProp];
				if (value && typeof value === "function") {
					value = value.call(that);
				}
			}
		}
		return value;
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		this._domElement = undefined; // see setViewModel(null)
		if (this._notAuthorized) {
			// NOTE: ранее NotAuthorized значение анализировалось перед созданием PE в PropertyEditorMap.create (WC-1189)
			this.renderNotAuthorize(domElement);
			return;
		}

		let result = super.doRender(domElement);
		// add cssClass
		// NOTE: не переносить в onReady, т.к. PE может отрисоваться в состоянии waiting, а cssClass нужен в любом случае
		let cssClass = this.options.cssClass;
		if (cssClass) {
			$(domElement).addClass(cssClass);
		}
		return result;
	}

	protected afterRender(): void {
		super.afterRender();

		// NOTE: не переносить в onReady, т.к. onReady может вызываться несколько раз, а отписки от jq-событий нет
		this._bindHotkeys();
	}

	protected onReady(): void {
		super.onReady();

		let that = this;
		if (that.viewModel && that.viewModel.bind) {
			// NOTE: симметричная отписка в onUnready
			that.viewModel.bind("change:" + that.viewModelProp, that._onPropChanged, that);
			that.viewModel.bind("error:" + that.viewModelProp, that._onPropErrorChanged, that);
		}

		if (that.violation()) {
			that._onViolationChanged();
		}

		that._bindToDisabled();

		if (that.element && that.id) {
			that.element.attr("id", that.id);
		}

		that._setWidth();
	}

	protected onUnready(): void {
		this._unsubscribeViewModel();
	}

	unload(options?: Part.CloseOptions): void {
		super.unload(options);

		let that = this;
		if (that._disposes) {
			for (let d of that._disposes) {
				d.dispose();
			}
			that._disposes = undefined;
		}
		if (that._nullable !== undefined) {
			// Reset nullable options back to its original value
			// (which could be spoiled in _bindNullableToDisabled if PE was disabled).
			that.options.nullable = that._nullable;
		}
		that._unsubscribeViewModel();

		that.bindingError("");
		that.violation(null);
	}

	dispose (options?: Part.CloseOptions): void {
		let that = this;
		if (that._disposesPersisted) {
			for (let d of that._disposesPersisted) {
				d.dispose();
			}
			that._disposesPersisted = undefined;
		}

		super.dispose(options);
	}

	protected _setWidth(): void {
		let that = this;
		if (that.element && that.options.width) {
			$(that.element).css({width: that.options.width});
		}
	}

	protected _bindHotkeys(): void {
		if (this.options.blurOnEsc) {
			this._bindToEsc();
		}
	}

	protected _bindToEsc(): void {
		let that = this,
			$element = that.element || that.$domElement;
		$element.keyup(e => {
			if (e.which !== core.html.keyCode.ESCAPE || e.ctrlKey || e.shiftKey || e.metaKey) { return; }
			$(e.target).blur();
		});
	}

	protected renderError(error: Violation|Error|string): void {
		let that = this,
			$element = that.element || that.$domElement;
		if ($element) {
			that._renderError(error, $element);
		}
	}

	protected _renderError(error: Violation|Error|string, $element: JQuery): void {
		$element
			.toggleClass("-invalid", !!error)
			.trigger("pe.invalid", error);

		// HACK: workaround for BS Tooltip race conditions:
		// Tooltip can't be reinitialize (title will be old), so we have to destroy it first.
		// But BS Tooltip has race conditions (see https://github.com/twbs/bootstrap/issues/16376) as destroy method is async.
		// So we manually remove "fade" class from internal tooltip element to make 'hide' method (called inside destroy) synchronous.
		let tooltip = $element.data("bs.tooltip");
		if (tooltip) {
			if (tooltip.$tip)
				tooltip.$tip.removeClass("fade");
			tooltip.destroy();
		}

		if (error) {
			let html: string = this._errorToHtml(error);
			if (html) {
				$element.tooltip({
					html: true,
					title: html,
					delay: { show: 500 },
					trigger: "hover"
				});
			}
		}
	}

	protected _errorToHtml(error: Violation|Error|string): string {
		let message: string|SafeHtml = (error as Violation).error || (error as Error).message || (error as string);
		return formatters.isHtml(message) ?
			message.toHTML() :
			lang.encodeHtml(message.toString());
	}

	protected renderNotAuthorize(domElement: JQuery|HTMLElement): void {
		$("<input type='text' class='x-pe-string uneditable-input' disabled readonly />")
			.val(resources["not_authorized"])
			.appendTo(domElement);
		super.doRender(domElement);
	}

	/**
	 * Returns true if the editor should fill entire row.
	 * The method is used in templates.
	 * @return {boolean}
	 */
	isFullWidth(): boolean {
		return this.layout && this.layout.position === "row";
	}

	focus(): void {
		let that = this,
			$element = that.element || that.$domElement;
		if (!$element) { return; }
		if (that.disabled()) { return; }

		let $focusable = $element.filter(":focusable:first");
		if (!$focusable.length) {
			$focusable = $element.find(":focusable:first");
		}
		$focusable.focus();
	}

	scrollToSelf(): void {
		core.html.scrollToElement({element: this.domElement, align: "center"});
	}

	activate(): void {
		// NOTE: focus can force scrolling, but it ignores affixed elements. So we must manually scroll first.
		this.scrollToSelf();
		this.focus();
	}

	value(v: any): void;
	value(): any;
	/**
	 * Gets or sets current property value
	 * @param {*} [v] a new property value
	 * @return {*} Current property value (if no arguments were specified)
	 */
	value(v?: any): any {
		let that = this,
		// NOTE: use this.get("viewModel") instead of this.viewModel for triggering 'get' event
			viewModel = that.get("viewModel");
		if (!that.options.many && arguments.length > 0) {
			viewModel[that.viewModelProp](v);
		} else {
			return viewModel[that.viewModelProp]();
		}
	}
}

PropertyEditor.mixin(/** @lends PropertyEditor.prototype */{
	defaultOptions: PropertyEditor.defaultOptions,
	/**
	 * Default options by context
	 */
	contextDefaultOptions: PropertyEditor.contextDefaultOptions
});

namespace PropertyEditor {
	export interface Options extends Component.Options, FormatOptions {
		name?: string;
		descr?: string;
		vt?: ValueType;
		many?: boolean;
		/**
		 * Popup tooltip (hint) for context help
		 */
		hint?: string;
		/**
		 * Switch off of showing tooltip for hint (i.e. even if hint specified there will be no help icon with tooltip)
		 */
		hideHelp?: boolean;
		nullable?: boolean;
		readOnly?: boolean;
		rules?: validation.Rule[];
		layout?: LayoutOptions;
		hidden?: boolean;
		disabled?: boolean;
		width?: string|number;
		cssClass?: string;
		onSetViewModel?: (viewModel: any) => any;
		blurOnEsc?: boolean;
		autoValidate?: boolean;
		contextName?: string;
		// Following options are not used by PE itself, but DefaultMapping uses them to choose the implementation of PE
		PropertyEditor?: PropertyEditorConstructor | PropertyEditorFactory;
		presentation?: string;
		// property chain description (for internal usage)
		chain?: { props: any[] };
	}

	export interface LayoutOptions {
		position?: string;
		noLabel?: boolean;
	}

	export interface ValidationOptions {
		reason?: string;
	}

	export namespace DefaultMapping {
		export interface PropertyEditorConstructor {
			new (options: Options): PropertyEditor;
		}

		export interface PropertyEditorFactory {
			create(options: Options): PropertyEditor;
		}

		export interface PropertyEditorResolver {
			(propMeta: any): PropertyEditorConstructor | PropertyEditorFactory;
		}

		export interface PropertyEditorRegisterOptions {
			vt?: string;
			priority?: number;
		}

		export interface PropertyEditorMap {
			register(resolver: PropertyEditorResolver, options?: PropertyEditorRegisterOptions): void;
			getImpl(propMeta: PropertyEditor.Options): PropertyEditorConstructor | PropertyEditorFactory;
			create(propMeta: PropertyEditor.Options, viewModel?: any): PropertyEditor;

			peNotAuthorized: PropertyEditorConstructor;
			peNotImplemented: PropertyEditorConstructor;
			[key: string]: PropertyEditorConstructor|any; // any - to support other methods (register/getImpl/create)
		}
	}

	export interface Summary {
		title: string;
		value: any;
	}
}


class peNotImplemented extends PropertyEditor {
	/**
	 * @constructs peNotImplemented
	 * @extends PropertyEditor
	 */
	constructor(options?: PropertyEditor.Options) {
		super(options);
	}
	render(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		$("<span style='color:red'>PropertyEditor for vartype '" + this.options.vt + "' has not been implemented yet</span>")
			.appendTo(domElement);
		return super.render(domElement);
	}
}
class peNotAuthorized extends PropertyEditor {
	/**
	 * @constructs peNotAuthorized
	 * @extends PropertyEditor
	 */
	constructor(options?: PropertyEditor.Options) {
		super(options);
		this.hidden(true);
		this.disabled(true);
	}
	render(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		$("<input type='text' class='x-pe-string uneditable-input' disabled readonly />")
			.val(resources["not_authorized"])
			.appendTo(domElement);
		return super.render(domElement);
	}
}

/**
 * Global map where all PE implementations register their mappings: prop type to PE-class
 */

core.ui.PropertyEditor = PropertyEditor;
core.ui.peNotImplemented = peNotImplemented;
core.ui.peNotAuthorized = peNotAuthorized;

DefaultMapping.peNotImplemented = peNotImplemented;
DefaultMapping.peNotAuthorized = peNotAuthorized;

export = PropertyEditor;

