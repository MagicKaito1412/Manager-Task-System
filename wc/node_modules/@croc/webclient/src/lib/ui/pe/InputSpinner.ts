import $ = require("jquery");
import core = require("core");
import Big = require("big");

import "vendor/jquery.mousewheel";

class InputSpinner extends core.lang.CoreClass {
	static defaultOptions: InputSpinner.Options = {
		step: 1,
		formatter: function (v): string {
			return "" + v;
		},
		parser: function (text: string): number {
			return parseFloat(text);
		},
		autoCorrect: true
	};

	options: InputSpinner.Options;
	$input: JQuery;
	$btnUp: JQuery;
	$btnDown: JQuery;
	private _mouseTimeout: number;
	private _mouseInterval: number;
	private min: Big;
	private max: Big;

	constructor(options: InputSpinner.Options) {
		super();
		this.options = core.lang.append(options || {}, InputSpinner.defaultOptions);

		if (this.options.max !== undefined) {
			this.max = new Big(this.options.max);
		}
		if (this.options.min !== undefined) {
			this.min = new Big(this.options.min);
		}
	}

	attach(input: Element|JQuery, btnUp?: Element|JQuery, btnDown?: Element|JQuery): void {
		let that = this,
			$input = input && $(input),
			$btnUp = btnUp && $(btnUp),
			$btnDown = btnDown && $(btnDown);
		if ($input) {
			if (that.$input && that.$input[0] !== $input[0]) {
				that.$input.off(".inputspinner");
			}
			that.$input = $input;
			that.$input.on("keydown.inputspinner", that._onInputKeydown.bind(that));
			that.$input.on("mousewheel.inputspinner", that._onInputMousewheel.bind(that));
			that.$input.on("blur.inputspinner", that._onInputBlur.bind(that));
		}
		if ($btnUp) {
			if (that.$btnUp && that.$btnUp[0] !== $btnUp[0]) {
				that.$btnUp.off(".inputspinner");
			}
			that.$btnUp = $btnUp;
			that.$btnUp.on("mousedown.inputspinner", that._onBtnUpMouseDown.bind(that));
			that.$btnUp.on("mouseup.inputspinner mouseleave.inputspinner", that._onButtonsMouseUp.bind(that));
		}
		if ($btnDown) {
			if (that.$btnDown && that.$btnDown[0] !== $btnDown[0]) {
				that.$btnDown.off(".inputspinner");
			}
			that.$btnDown = $btnDown;
			that.$btnDown.on("mousedown.inputspinner", that._onBtnDownMouseDown.bind(that));
			that.$btnDown.on("mouseup.inputspinner mouseleave.inputspinner", that._onButtonsMouseUp.bind(that));
		}
	}

	detach(): void {
		let that = this;
		if (that.$input) {
			that.$input.off(".inputspinner");
			that.$input = null;
		}
		if (that.$btnUp) {
			that.$btnUp.off(".inputspinner");
			that.$btnUp = null;
		}
		if (that.$btnDown) {
			that.$btnDown.off(".inputspinner");
			that.$btnDown = null;
		}
	}

	increase(): void {
		this._incValue(this.options.step);
	}

	decrease(): void {
		this._incValue(-this.options.step);
	}

	/**
	 * Normalize value (val) to allowed range (min/max).
	 * @param val
	 * @param autoCorrect
	 * @returns {any}
	 * @private
	 */
	protected _normalizeValue(val: any, autoCorrect: boolean): number|Big {
		if (val instanceof Big) {
			if (autoCorrect) {
				if (this.min != null && val.lt(this.min)) {
					return this.min;
				}
				if (this.max != null && val.gt(this.max)) {
					return this.max;
				}
			}
		} else {
			if (typeof val !== "number" || isNaN(val)) {
				return 0;
			}
			if (autoCorrect) {
				if (this.min != null && this.min.gte(val)) {
					return this.min;
				}
				if (this.max != null && this.max.lte(val)) {
					return this.max;
				}
			}
		}
		return val;
	}

	protected _parseValue(s: string): number {
		return this.options.parser.call(this, s);
	}

	protected _formatValue(v: any): string {
		return this.options.formatter.call(this, v);
	}

	protected _incValue(increment: number): void {
		let that = this,
			$input = that.$input;
		let autoCorrect = that.options.autoCorrect;
		if (!$input) { return; }

		try {
			// parse & normalize current value
			let valueOld = that._normalizeValue(that._parseValue($input.val()), autoCorrect);
			// increment/decrement
			let valueNew;
			if (valueOld instanceof Big) {
				valueNew = that._normalizeValue(valueOld.plus(increment), autoCorrect);
			} else {
				valueNew = that._normalizeValue(valueOld + increment, autoCorrect);
			}
			let text = that._formatValue(valueNew);
			$input.val(text).trigger("change");
		} catch (ex) {
			// при парсинге значения может быть исключение (обычно оно обрабатывается байндингом - см. binding::bindOneWay,
			// ну тут мы напрямую зовем parse, просто игнорируем, ошибка байндинга должна
		}
	}

	protected _onInputKeydown(e: JQueryEventObject): void {
		let that = this,
			keyCode = core.html.keyCode;
		if (e.which === keyCode.UP || e.which === keyCode.DOWN) {
			if (e.which === keyCode.UP) {
				that.increase();
			} else {
				that.decrease();
			}
		}
	}

	protected _onInputMousewheel(e/*: JQueryMouseEventObject*/): void {
		// handle mousewheel on focused <input> only
		if (e.target !== core.html.focused()) { return; }

		// NOTE: deltaY is normalized by jquery.mousewheel plugin
		let delta = e.deltaY;

		e.stopPropagation();
		e.preventDefault();

		if (delta < 0) {
			this.decrease();
		} else {
			this.increase();
		}
	}

	protected _onInputBlur(): void {
		let that = this;
		if (that.$input && that.$input.val() !== "") {
			that._incValue(0);
		}
	}

	protected _onBtnUpMouseDown(): void {
		this._onButtonsMouseDown(true);
	}

	protected _onBtnDownMouseDown(): void {
		this._onButtonsMouseDown(false);
	}

	protected _onButtonsMouseDown(isUp: boolean): void {
		let that = this;
		if (isUp) {
			that.increase();
		} else {
			that.decrease();
		}

		if (that._mouseTimeout) {
			window.clearTimeout(that._mouseTimeout);
		}
		// NOTE: first delay is longer than others (250 vs 50)
		that._mouseTimeout = window.setTimeout(() => {
			if (that._mouseInterval) {
				window.clearInterval(that._mouseInterval);
			}
			that._mouseInterval = window.setInterval(() => {
				if (isUp) {
					that.increase();
				} else {
					that.decrease();
				}
			}, 50);
		}, 250);
	}

	protected _onButtonsMouseUp(): void {
		let that = this;
		window.clearTimeout(that._mouseTimeout);
		window.clearInterval(that._mouseInterval);
		that._mouseTimeout = null;
		that._mouseInterval = null;
	}
}

namespace InputSpinner {
	export interface Options {
		min?: number | Big | string;
		max?: number | Big | string;
		step?: number;
		formatter?: (v: number) => string;
		parser?: (text: string) => number;
		/**
		 * Auto correct value on blur and increase/decrease to nearest boundary
		 */
		autoCorrect?: boolean;
	}
}

InputSpinner.mixin(/** @lends InputSpinner.prototype */{
	defaultOptions: InputSpinner.defaultOptions
});

export = InputSpinner;