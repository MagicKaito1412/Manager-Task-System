import $ = require("jquery");
import core = require("core");
import formatters = require("lib/formatters");
import binding = require("lib/binding");
import support = require("lib/domain/support");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import moment = require("moment");

import "vendor/bootstrap-datetimepicker/bootstrap-datetimepicker";
import "xcss!lib/ui/styles/peDateTime.css";

import lang = core.lang;
import { IBindable } from "lib/binding";

const isoFormats = {
	date: "YYYY-MM-DD",
	time: "HH:mm",
	timeTz: "HH:mm",
	dateTime: "YYYY-MM-DDTHH:mm",
	dateTimeTz: "YYYY-MM-DDTHH:mmZ"
};

// override default options of datetimepicker
core.lang.extend($.fn.datetimepicker.defaults, {
	locale: moment.locale(),
	useCurrent: false,
	showTodayButton: true,
	toolbarPlacement: "bottom",
	icons: {
		time: 	"x-icon x-icon-clock",
		date: 	"x-icon x-icon-calendar",
		up: 	"x-icon x-icon-angle-bracket-top",
		down: 	"x-icon x-icon-angle-bracket-bottom",
		previous: "x-icon x-icon-angle-bracket-left",
		next: 	"x-icon x-icon-angle-bracket-right",
		today: 	"x-icon x-icon-today"
	}
});

class peDateTime  extends PropertyEditor {
	static defaultOptions: peDateTime.Options = {
		format: "",
		useNative: "mobileOnly",	// "always", "never", "mobileOnly"
		openPickerOn: "button",      // "focus", "button", "both"
		hideClearButton: false
	};
	static contextDefaultOptions: lang.Map<peDateTime.Options> = {
		filter: {
			openPickerOn: "button"
		},
		inline: {
			openPickerOn: "focus"
		}
	};

	s: JQueryAjaxSettings;
	/**
	 * isEmpty.
	 * @observable-property {boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isEmpty: lang.ObservableProperty<boolean>;

	options: peDateTime.Options;
	format: string;
	min: Date;
	max: Date;
	commands: peDateTime.KnownCommands;
	picker: BootstrapV3DatetimePicker.Datetimepicker;

	/**
	 * @class peString
	 * @extends PropertyEditor
	 * @param options
	 */
	constructor(options: peDateTime.Options) {
		options = peDateTime.mixContextOptions(options, peDateTime.defaultOptions, peDateTime.contextDefaultOptions);
		super(options);

		// check correct vt
		if (!formatters.defaultFormats[this.options.vt]) {
			throw new Error("peDateTime: unsupported var type: " + this.options.vt);
		}

		this.options.format = this.options.format || formatters.defaultFormats[this.options.vt];
		// calculate actual format (copy/paste from bootstrap-datetimepicker)
		this.format = this.options.format.replace(/(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, (input: moment.LongDateFormatKey) => {
			return moment.localeData().longDateFormat(input) || input;
		});

		let convertType: moment.unitOfTime.DurationConstructor = this.options.vt === "date" ? "days" : "seconds";
		this.min =
			(this.options.minInclusive && moment(this.options.minInclusive).toDate()) ||
			(this.options.minExclusive && moment(this.options.minExclusive).add(1, convertType).toDate());
		this.max =
			(this.options.maxInclusive && moment(this.options.maxInclusive).toDate()) ||
			(this.options.maxExclusive && moment(this.options.maxExclusive).subtract(1, convertType).toDate());

		this.commands = this.createCommands();
	}

	useNative(): boolean {
		let nativeType;
		switch (this.options.vt) {
			case "timeTz":
			case "time":
				nativeType = "time";
				break;
			case "date":
				nativeType = "date";
				break;
			case "dateTimeTz":
				nativeType = "datetime";
				break;
			case "dateTime":
				nativeType = "datetime-local";
				break;
		}
		if (!nativeType) { return false; }
		let isNativeSupported = core.platform.modernizr.inputtypes[nativeType];
		switch (this.options.useNative) {
			case "always":
				return isNativeSupported ? nativeType : undefined;
			case "never":
				return undefined;
			case "mobileOnly":
				return isNativeSupported && core.platform.isMobileDevice ? nativeType : undefined;
		}
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this,
			bindableElement,
			useNativeInput = that.useNative(),
			nativeType = useNativeInput || "text";

		that.element = $("<div class='x-pe-datetime input-group'></div>").appendTo(domElement);
		that.element = $("<input type='" + nativeType + "' />").appendTo(that.element);
		that.element.attr("placeholder", that.options.placeholder || that.format);
		that.element.addClass("x-pe-datetime-input form-control");
		if (!that.options.nullable) {
			that.element.attr("required");
		}

		// datetimepicker присвоет элементу id, если он не задан. Однако базовый метод принудительно
		// устанавливает id элемента, поэтому мы должны позвать базовый метод до создания datetimepicker-а.
		super.doRender.call(this, domElement);

		bindableElement = useNativeInput ? that._renderNative() : that._renderWidget();

		if (bindableElement) {
			bindableElement.onchange = bindableElement.onchange || function(handler) {
					that.element.bind("change", handler);
					return {
						dispose: () => {
							that.element.unbind("change", handler);
						}
					};
				};

			that.databind(bindableElement);
		}

		that.element.bind("input keyup", function (): void {
			let val = $(this).val();
			that.isEmpty(!val);
		});

		// trigger event for refresh
		that.element.trigger("input");
	}

	/**
	 * @protected
	 * @returns {Object.<string, Command>}
	 */
	createCommands(): peDateTime.KnownCommands {
		let that = this;
		let commands: peDateTime.KnownCommands = {};
		if (!that.options.hideClearButton) {
			commands.Clear = new core.commands.BoundCommand(that.doClear, that.canClear, that);
		}
		return core.lang.extend(commands, that.options.commands);
	}

	doClear(): void {
		let that = this;

		if (that.picker) {
			that.picker.date(null);
		} else if (that.element) {
			that.element.val("")
				.trigger("input")
				.trigger("change");
		}

		that.focus();
	}

	canClear(): boolean {
		return !this.disabled() && !this.isEmpty();
	}

	protected _bindToEsc(): void {
		let that = this;
		that.element.keydown(function (e: JQueryKeyEventObject) {
			let $parent;
			if (e.which !== core.html.keyCode.ESCAPE || e.ctrlKey || e.shiftKey || e.metaKey) { return; }

			if (that.picker) {
				// do nothing if the picker is open: the picker is closed by itself on ESC and the focus remains on INPUT
				$parent = that.picker.options().widgetParent || $(e.target).parent();
				if ($parent.find("> .bootstrap-datetimepicker-widget").length) {
					return;
				}
			}
			$(e.target).blur();
		});
	}

	protected _setWidth(): void {
		let that = this,
			width = that.options.width;
		if (width && that.$domElement) {
			that.$domElement.find("> .x-pe-datetime").css({ width: width });
		}
	}

	protected _renderNative(): IBindable {
		let that = this,
			bindableElement: IBindable ,
			format = isoFormats[that.options.vt];

		// wow! cool! но сейчас, как минимум в андровском (4.2.1) хроме (18.0)
		// на эти аттрибуты пикер не реагирует
		that.min && (that.element.prop("min", moment(that.min).format(format)));
		that.max && (that.element.prop("max", moment(that.max).format(format)));

		bindableElement = {
			set: function (v: any): void {
				let prev = that.element.val(),
					momentVal;
				prev = prev && moment(prev);
				if (!v !== !prev || v && prev && v.valueOf() !== prev.valueOf()) {
					that.element.val((momentVal = moment(v)) ? momentVal.format(format) : "");
				}
			},
			get: function (): any {
				let v = that.element.val();
				switch (that.options.vt) {
					case "dateTime":
					case "dateTimeTz":
						v = moment(v, format).toDate();
						break;
					case "date":
						v = moment(v, format).toDate();
						break;
					case "time":
					case "timeTz":
						v = moment("1900-01-01T" + v).toDate();
						break;
				}
				return v;
			}
		};
		return bindableElement;
	}

	protected _renderWidget(): IBindable {
		let that = this,
			bindableElement: IBindable,
			pickerOptions: BootstrapV3DatetimePicker.DatetimepickerOptions = {
				format: that.format || false,
				extraFormats: that._getExtraFormats(),
				defaultDate: that._getDefaultMoment(),
				minDate: that.min || false,
				maxDate: that.max || false,
				widgetParent: that.options.contextName === "inline" ? that.$domElement : undefined
			},
			$picker: JQuery;

		pickerOptions = core.lang.extend(pickerOptions, that.options.pickerOptions);

		if (that.options.openPickerOn !== "focus") {
			let buttonCssClass = that.options.vt === "time" || that.options.vt === "timeTz" ?
				$.fn.datetimepicker.defaults.icons.time :
				$.fn.datetimepicker.defaults.icons.date;
			that.element.after("<span class='input-group-addon x-pe-datetime-buttons'><span class='" + buttonCssClass + "'></span></span>");
			$picker = that.element.parent();
		} else {
			$picker = that.element;
		}

		$picker.datetimepicker(pickerOptions);
		that.picker = $picker.data("DateTimePicker");

		// add clear button
		if (that.commands.Clear) {
			that.element.addClass("has-clear-btn");
			let $clearBtn = $("<span class='clear-btn'>&times;</span>").insertAfter(that.element);
			binding.commandBind($clearBtn, that.commands.Clear);
		}

		that.element.on("keyup", function (e) {
			if (e.keyCode === core.html.keyCode.DOWN && that.picker) {
				that.picker.show();
			}
		});

		// NOTE: focus is handled by widget without button out of box
		if (that.options.openPickerOn === "both") {
			that.element.focus(() => {
				if (that.picker) {
					that.picker.show();
				}
			});
		}

		bindableElement = {
			set: function (v: any): void {
				if (that.picker) {
					v = v ? moment(v) : null;
					that.picker.date(v);
				}
			},
			get: function (): any {
				let v = that.picker && that.picker.date();
				if (!v) { return null; }
				return that._castMoment(v).toDate();
			},
			onchange: function (handler) {
				$picker.on("change.dp", handler);
				return {
					dispose: function () {
						$picker.off("change.dp", handler);
					}
				};
			}
		};

		return bindableElement;
	}

	protected _onPropChanged(sender: any, value: any): void {
		super._onPropChanged.apply(this, arguments);
		this.isEmpty(!value);
	}

	/**
	 * Change a value according to value type of PE
	 * @param {moment} v
	 * @returns {moment}
	 * @private
	 */
	protected _castMoment(v: moment.Moment): moment.Moment {
		switch (this.options.vt) {
			case "date":
				v = v.startOf("day");
				break;
			case "time":
			case "timeTz":
				v = v.year(1900).month(0).date(1);
				break;
		}
		return v;
	}

	protected _getDefaultMoment(): moment.Moment {
		let that = this;
		let v = that._castMoment(moment().startOf("day")); // to set time part to '0:00:00' (otherwise current time)
		if (that.min) { v = moment.max(v, moment(that.min)); }
		if (that.max) { v = moment.min(v, moment(that.max)); }
		return v;
	}

	protected _getExtraFormats() {
		let that = this;
		if (!that.format) { return false; }

		// NOTE: collect all formats "shorher" than that.format, each in 2-digit year and 4-digit year form
		// "DD.MM.YYYY HH:mm" -> [ "DD", "DD.MM", "DD.MM.YY", "DD.MM.YYYY", "DD.MM.YY HH", "DD.MM.YYYY HH", "DD.MM.YY HH:mm", "DD.MM.YYYY HH:mm" ]

		let extraFormats = [],
			formatTokens = that.format.match(/(.)\1*/g), // groups of the same symbols
			indexYYYY = formatTokens.indexOf("YYYY");
		formatTokens.forEach(function (token: string, i: number): void {
			if (!/\w/.test(token)) { return; }

			let tokens = formatTokens.slice(0, i + 1),
				format = tokens.join("");
			// 2-digit year instead of 4-digit
			if (indexYYYY >= 0 && i >= indexYYYY) {
				tokens[indexYYYY] = "YY";
				extraFormats.push(tokens.join(""));
			}
			extraFormats.push(format);
		});

		return extraFormats;
	}

	unload(): void {
		let that = this;
		if (that.picker) {
			that.picker.hide();
			that.picker.destroy();
			that.picker = undefined;
		}
		PropertyEditor.prototype.unload.apply(that, arguments);
	}
}
namespace peDateTime {
	export interface Options extends PropertyEditor.Options {
		format?: string;
		useNative?: "always" | "never" | "mobileOnly";
		maxInclusive?: Date;
		minInclusive?: Date;
		maxExclusive?: Date;
		minExclusive?: Date;
		pickerOptions?: BootstrapV3DatetimePicker.DatetimepickerOptions;
		openPickerOn?: "focus" | "button" | "both";
		hideClearButton?: boolean;
		commands?: lang.Map<core.commands.ICommand|core.commands.ICommandFactory>;
		/**
		 * Text for placeholder in input.
		 */
		placeholder?: string;
	}
	export interface KnownCommands extends lang.Map<core.commands.Command> {
		Clear?: core.commands.Command;
	}
}

// backward compatibility: access to static fields via prototype
peDateTime.mixin(/** @lends peDateTime.prototype */{
	defaultOptions: peDateTime.defaultOptions,
	contextDefaultOption: peDateTime.contextDefaultOptions
});

core.ui.peDateTime = peDateTime;
core.ui.PropertyEditor.DefaultMapping["dateTime"] = peDateTime;
core.ui.PropertyEditor.DefaultMapping["date"] = peDateTime;
core.ui.PropertyEditor.DefaultMapping["time"] = peDateTime;
core.ui.PropertyEditor.DefaultMapping["timeTz"] = peDateTime;
core.ui.PropertyEditor.DefaultMapping["dateTimeTz"] = peDateTime;

export = peDateTime;
