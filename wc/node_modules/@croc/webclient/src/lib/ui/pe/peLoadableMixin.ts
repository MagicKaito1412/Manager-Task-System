import lang = require("lib/core.lang");

import DataLoadEventArgs = peLoadableMixin.DataLoadEventArgs;
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import { LoadQuerySpec, LoadOptions } from "lib/interop/.interop";

interface peLoadableMixin  extends PropertyEditor { }

const State = {
	initial: "initial" as "initial",
	loading: "loading" as "loading",
	loaded: "loaded" as "loaded",
	failed: "failed" as "failed",
	disposed: "disposed" as "disposed"
};

abstract class peLoadableMixin {
	static State = State;
	/**
	 * isEmpty.
	 * @observable-property {peObjectRadio#state}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<peLoadableMixin.State>;

	isDataLoaded: boolean;
	lastError: any;

	protected _onDataLoading(args: DataLoadEventArgs): void {
		let that = this;
		// block input in lookup field (if exist)
		that.state(State.loading);
		that.onDataLoading(args);
		that._renderBeginLoading();
	}
	protected _renderBeginLoading(): void {}

	protected abstract onDataLoading(args: DataLoadEventArgs): void;

	protected _onDataLoaded(args: DataLoadEventArgs): void {
		let that = this;
		that.onDataLoaded(args);
		that.lastError = null;
		that.isDataLoaded = true;
		that.state(State.loaded);
		that._renderEndLoading();
		that._setItems(args.items);
	}
	protected _renderEndLoading(): void {}
	protected abstract _setItems(items: any[]): void;

	protected abstract onDataLoaded(args: DataLoadEventArgs): void;

	protected abstract onLoaded(): void;

	protected _onFailed(error: Error): void {
		let that = this;
		that.lastError = error;
		that.isDataLoaded = false;
		that.state(State.failed);
		that._renderEndLoading();
		that.renderError(error);
	}
}

namespace peLoadableMixin {
	export type State = (typeof State)[keyof typeof State];

	export interface DataLoadEventArgs {
		query: LoadQuerySpec;
		options: LoadOptions;
		items?: any[];
	}
}

export = peLoadableMixin;
