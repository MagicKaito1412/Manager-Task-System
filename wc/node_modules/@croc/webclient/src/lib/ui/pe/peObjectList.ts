import core = require("core");
import utils = require("lib/utils");
import NavigationPropertyEditor = require("lib/ui/pe/NavigationPropertyEditor");
import ListCommonMixin = require("lib/ui/list/ListCommonMixin");
import ObjectListMixin = require("lib/ui/list/ObjectListMixin");
import Menu = require("lib/ui/menu/Menu");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import resources = require("i18n!lib/nls/resources");
import "xcss!lib/ui/styles/peObjectList.css";

import list = require("lib/ui/list/.list");
import domain = require("lib/domain/.domain");
import { Violation } from "lib/validation";
import {
	PartCommandOptions,
	EditorCommandOptions,
	EditorCommandResult,
	SelectorCommandResult
} from "lib/ui/PartCommandMixin";

import lang = core.lang;
import Promise = lang.Promise;
import Promisable = lang.Promisable;
import ICommand = core.commands.ICommand;
import ObjectListColumn = list.ObjectListColumn;
import DomainObject = domain.DomainObject;
import PropertyMeta = domain.metadata.PropertyMeta;
import EntityMeta = domain.metadata.EntityMeta;
import INavigationPropSet = domain.INavigationPropSet;
import ValidationOptions = PropertyEditor.ValidationOptions;
import AggregatedViolation = peObjectList.AggregatedViolation;
import OrderByData = lang.collections.OrderByData;

class peObjectList extends NavigationPropertyEditor implements list.IDomainObjectList, ObjectListMixin {
	static defaultOptions: peObjectList.Options = {
		indexed: false,
		commands: {},
		layout: {position: "row"},
	};

	static defaultMenus: lang.Map<Menu.Options> = {
		peObjectListRow: { items: [
			{ name: "Select", title: resources.select },
			{ name: "Create", title: resources.create, hotKey: "ins" },
			{ name: "Edit", title: resources.edit, isDefaultAction: true },
			{ name: "View", title: resources.view, isDefaultAction: true },
			{ name: "Unlink", title: resources["navigationPE.unlink.many"] },
			{ name: "Delete", title: resources["delete"], hotKey: "del" },
			{
				name: "Customize",
				icon: "settings",
				title: resources.customize,
				presentation: "icon",
				order: 100
			}, {
				name: "RowHeight",
				icon: "x-icon-menu4-outer",
				presentation: "icon",
				order: 101,
				items: [{
					name: "IncreaseRowHeight",
					title: resources["increase_row_height"],
					icon: "x-icon-menu4-outer",
					presentation: "icon",
					order: 1
				}, {
					name: "DecreaseRowHeight",
					title: resources["decrease_row_height"],
					icon: "x-icon-menu4-inner",
					presentation: "icon",
					order: 2
				}]
			}
		]},
		peObjectListSelection: { items: [
			{
				name: "Selection",
				title: resources.selection,
				html: "<span class='x-icon x-icon-select-all visible-xs'></span><span class='hidden-xs'>" + resources.selected + "</span>" +
				" <span class='x-list-menu-selection-counter'></span>/<span class='x-list-menu-total-counter'></span>",
				items: [
					{ name: "SelectAll", title: resources.selectAll },
					{ name: "SelectNone", title: resources.selectNone }
				]
			}
		]}
	};

	// prototype members: begin
	defaultMenus: {
		peObjectListRow?: Menu.Options;
		peObjectListSelection?: Menu.Options;
	};

	/**
	 * @enum {String}
	 */
	events: {
		/* data loaded event */
		DATA_LOADED: string
	};
	// prototype members: end

	options: peObjectList.Options;

	commands: lang.Map<core.commands.ICommand>;
	menuList: Menu;
	menuRow: Menu;
	menuSelection: Menu;

	/**
	 * @constructs peObjectList
	 * @extends NavigationPropertyEditor
	 * @mixes ListCommonMixin
	 * @param {Object} options
	 */
	constructor(options?: peObjectList.Options) {
		options = peObjectList.mixOptions(options, peObjectList.defaultOptions);
		super(options);
		this._initializeProps();

		this.layout = this.options.layout;
		this.userSettings = core.UserSettings.create(this.options.userSettings);

		this.commands = lang.extend(this.createCommands(), this.options.commands);

		this.menuRow = this.createRowMenu();
		if (this.menuRow) { this.menuRow.bindToPart(this); }

		this.menuSelection = this.createSelectionMenu();
		if (this.menuSelection) { this.menuSelection.bindToPart(this); }

		// NOTE: specify viewModel as null to skip setting viewModel to presenter
		this.initPresenter({ viewModel: null });

		this.state(this.states.initial);
		utils.subscribeOnEvents(this, this.options, this.events);
		this._bindToDisabled();

		this.violations.bind("change", this._onViolationsChange, this);
	}

	protected tweakOptions<T extends peObjectList.Options>(options: T): void {
		lang.appendEx(options, {
			validateItems: options.readOnly ? "never" : "explicit", // inlineEdit?
			presenterOptions: {
				canMoveRows: !!options.indexed && !options.readOnly,
				canSort: !options.orderBy,
				hasCheckboxes: lang.coalesce(options.hasCheckboxes, !options.readOnly),
				hasRowNum: options.hasRowNum
			},
		}, { deep: true });
		super.tweakOptions(options);
	}

	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			commands = super.createCommands.call(that);
		commands.SelectAll = new core.commands.BoundCommand(that.doSelectAll, that.canSelectAll, that);
		commands.SelectNone = new core.commands.BoundCommand(that.doSelectNone, that.canSelectNone, that);
		commands.Customize = new core.commands.BoundCommand(that.doCustomize, that.canCustomize, that);

		commands.IncreaseRowHeight = new core.commands.BoundCommand(that.doIncreaseRowHeight, that.canChangeRowHeight, that);
		commands.DecreaseRowHeight = new core.commands.BoundCommand(that.doDecreaseRowHeight, that.canChangeRowHeight, that);

		return commands;
	}

	protected doDeleteSelection(): void {
		let objects = this.selection.all().slice();
		this._deleteObjects(objects);
	}
	protected canDeleteSelection(): boolean {
		return !this.disabled() && this.get("selection").count();
	}

	protected doUnlinkSelection(): Promisable<void> {
		let objects = this.selection.all().slice();
		return lang.async.then(this.doUnlinkObjects(objects), () => {
			this.activate();
		});
	}
	protected canUnlinkSelection(): boolean {
		return !this.disabled() && this.get("selection").count();
	}

	protected createRowMenuDefaults(): Menu.Options {
		// TODO: how to get objectName?
		const key = "peObjectListRow";
		return Menu.defaultsFor(this.defaultMenus[key], key);
	}
	protected createSelectionMenuDefaults(): Menu.Options {
		// TODO: how to get objectName?
		const key = "peObjectListSelection";
		return Menu.defaultsFor(this.defaultMenus[key], key);
	}
	protected createRowMenu(): Menu {
		return new Menu(this.createRowMenuDefaults(), this.options.menuRow);
	}
	protected createSelectionMenu(): Menu {
		return new Menu(this.createSelectionMenuDefaults(), this.options.menuSelection);
	}

	setViewModel(viewModel: DomainObject): void {
		super.setViewModel(viewModel);

		let that = this;

		// NOTE: viewModel can be null, viewModel can be a not-loaded object
		if (that.viewModel && that.viewModel[that.viewModelProp]) {
			// init columns
			that._initializeColumns();

			let value = that.value();
			if (value && !lang.support.isNotLoaded(value)) {
				that.items.source(value);
				that.state(that.states.loaded);
			}
			// NOTE: if the property isn't loaded here, it will be loaded in render method
			// TODO: what if value is null?
			if (that.presenter && that.presenter.setViewModel) {
				that.presenter.setViewModel(that);
			}
		}
	}

	protected _initializeColumns(): void {
		let that = this,
			columns: ObjectListColumn[] = [];

		if (lang.isArray(that.options.columns)) {
			for (let col of that.options.columns) {
				let column: ObjectListColumn = lang.isString(col) ? { prop: col } : col;

				if (!column.role || column.role === "data") {
					column.name = column.name || column.prop;
					if (!column.getter) {
						// NOTE: если у колонки нет prop и есть getter, то предполагать prop на основе name небезопасно (WC-1399)
						column.prop = column.prop || column.name;
					}

					let prop: PropertyMeta = that.findDomainProp(column);
					column.title = column.title || (prop && prop.descr) || column.name;
					//column.vt = column.vt || (prop && prop.vt);
					if (!column.vt && prop) {
						column.vt = prop.vt;
					}
				}

				columns.push(column);
			}
		} else {
			// auto-generating columns from type's metadata
			let propMeta = that.viewModel.meta.props[that.viewModelProp]; // may be undefined for calculated properties
			lang.forEach(that.valueObjectEntityType.props, (prop: PropertyMeta, propName: string) => {
				if ((propMeta && prop.opposite === propMeta) || // ignore reverse props
					(prop.ref && prop.many) ||                  // ignore navigation set props
					prop.vt === "binary") {                     // ignore binary props
					return;
				}
				columns.push({
					name: propName,
					prop: propName,
					title: prop.descr,
					vt: prop.vt
				});
			});
		}
		that.setupColumns(columns);
	}

	protected _ensurePropLoaded(): Promisable<void> {
		let that = this;
		if (that.viewModel[that.viewModelProp]) {
			let value = that.value(),
				propLoadOptions = {
					preloads: that.options.preloads
				};
			if (lang.support.isNotLoaded(value)) {
				that.state(that.states.reloading);
				return value.load(propLoadOptions).then(() => {
					that._onDataLoaded();
				}, () => {
					that.state(that.states.failed);
					that.stateMessage(resources["objectList.state.load_failed"]);
				});
			} else if (value !== that.items.source()) {
				that._onDataLoaded(value);
			}
		}
	}
	protected _onPropChanged(sender, value): void {
		super._onPropChanged(sender, value);

		this._ensurePropLoaded();
	}
	private _onDataLoaded(data?: INavigationPropSet): void {
		let that = this;
		if (that.isDisposed) { return; }
		that.items.source(data || that.value());
		that.state(that.states.loaded);
		that.onDataLoaded();
	}
	protected onDataLoaded(): void {
		let that = this;
		that.trigger(that.events.DATA_LOADED, that);
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		super.dispose(options);
		this.items.dispose();
		this.selection.dispose();
		this.violations.dispose();
	}

	protected beforeRender(domElement?: JQuery|HTMLElement): void {
		super.beforeRender(domElement);
		this._ensurePropLoaded();
	}

	protected _onViolationsChange(): void {
		let violation = this.violation() as AggregatedViolation;
		if (violation && !violation.aggregated) { return; }

		if (this.violations.find((item: Violation) => {
			return (!item.severity || item.severity === "error" || item.severity === "critical");
		})) {
			// convert several items violations to single aggregated violation
			violation = this.createViolation(this.options.descr + ": " + resources["peObjectList.validation.itemsViolations"]);
			violation.aggregated = true;
		} else {
			violation = undefined;
		}
		this.violation(violation);
	}

	runValidation(options?: ValidationOptions): Violation {
		super.runValidation();

		if (this.shouldValidateItems(options)) {
			this.runItemsValidation();
		}

		// NOTE: runValidation and runItemsValidation set violation themselves
		return this.violation();
	}

	protected _errorToHtml(error: AggregatedViolation|Error|string): string {
		// don't show violation for the whole PE, separated violations are shown for items
		if ((error as AggregatedViolation).aggregated) { return; }
		return super._errorToHtml(error);
	}

	/* -- api for ObjectListPresenter (me as model) */

	// achtung: copy-paste from ObjectList
	//findObject(type, id) {
	//	let that = this;
	//	return that.value().first(type, id);
	//}

	currentValue(): DomainObject {
		return this.activeItem();
	}

	findDomainProp(column: ObjectListColumn): PropertyMeta {
		let entity: EntityMeta = this.valueObjectEntityType;
		if (!entity) { return; }

		return entity.props[column.prop || column.name];
	}

	focus(): void {
		let presenter: any = this.presenter;
		if (!presenter || !presenter.focus) {
			super.focus();
			return;
		}
		presenter.focus();
	}

	scrollToSelf(): void {
		let presenter: any = this.presenter;
		if (!presenter || !presenter.scrollToSelf) {
			super.scrollToSelf();
			return;
		}
		presenter.scrollToSelf();
	}

	protected onBeforeEdit(editOptions: EditorCommandOptions): void {
		let that = this,
			partOptions;
		if (editOptions.navigateSiblings) {
			partOptions = editOptions.partOptions = editOptions.partOptions || {};
			partOptions.navigateSiblings = that.items.all()
				.map(item => lang.append({ viewModel: item }, partOptions));
		}
	}

	protected onAfterEdit(result: EditorCommandResult, editOptions: PartCommandOptions): void {
		this.onSiblingsNavigated(result, editOptions);
		super.onAfterEdit(result, editOptions);

		// validate edited object
		if (result && result.success) {
			// NOTE: `result.object` is ObjectEditor's viewModel, which can be overridden by the editor
			// and diffirred from the original item. But `partOptions.viewModel` points to original item.
			let obj: DomainObject = editOptions.partOptions.viewModel || result.object;
			// validate edited item
			lang.async.then(result.success, () => {
				this.runItemsValidation(obj as DomainObject);
			});
		}
	}

	protected onSiblingsNavigated(result: EditorCommandResult, options: EditorCommandOptions): void {
		let obj: DomainObject;
		if (options && options.navigateSiblings &&
			result && result.selectedId && (obj = this.items.find(item => item.id === result.selectedId))) {
			this.activeItem(obj);
		}
	}

	protected _onSelectedValues(result: SelectorCommandResult): void {
		super._onSelectedValues(result);

		// NOTE: all objects in result.selection must be in UoW after executing base method
		let objects = result && result.selection;
		if (!objects || !objects.length) { return; }

		// activate first object
		this.activeItem(objects[0]);
		// reset current selection if there are several selected objects
		if (objects.length > 1) {
			this.selection.reset(objects);
		}
	}

	protected _addObject(obj: DomainObject): void {
		let propValue = this.value();
		if (propValue.indexOf(obj) < 0) {
			propValue.add(obj);
		}
	}

	protected _valueIds(): string[] {
		let value = this.value();
		// NOTE: `ids()` is optional method
		return value.ids ? value.ids() : value.all().map(o => o.id);
	}

	protected onColumnsChanged(): void {
		let that = this,
			menuItem = that.menuRow.getItem("Customize");

		// update menu
		if (menuItem) {
			let hasHidden = that.columns.some(col => col.hidden);
			menuItem.cssClass = hasHidden ? "x-menu-item-badge-warning" : "";
			// notify that property 'menuRow' was changed
			that.changed("menuRow");
		}
	}

	protected shouldValidateItem(item: DomainObject): boolean {
		return item.isNew() || item.isModified();
	}

	protected canUnlink(): boolean {
		return !this.disabled() && (!!this.currentValue() || this.get("selection").count() > 0);
	}

	protected doUnlink(): void|Promise<void> {
		return this._unlinkObjects();
	}

	protected _unlinkObjects(objects?: DomainObject[]): void|Promise<void> {
		let that = this,
			activeObj = that.activeItem(),
			selection = that.selection.all();

		// #1: detect what should we unlink
		if (!objects) {
			let selectionCount = selection.length;
			if (selectionCount  === 0 && activeObj) {
				objects = [activeObj];
			} else if (selectionCount > 0 && activeObj) {
				// there are selected objects AND active - it's the most subtle case for UX
				if (selection.indexOf(activeObj) > -1) {
					// selection includes the active
					objects = selection;
				} else {
					// we couldn't determine what to delete
					objects = null;
				}
			} else if (selectionCount > 0 && !activeObj) {
				// there are only selected objects
				objects = selection;
			} else {
				// nothing to unlink
				return;
			}
		}

		// now we have a set of objects to unlink - `objects` (or may be not if it's unclear what to unlink),
		// #2: construct a confirmation for user
		let confirmation = that.getOperationConfirmation("unlink", objects, selection, activeObj);

		if (!confirmation) {
			return;
		}

		// #3: ask user
		lang.async.then(confirmation, (confirmation) => {
			if (confirmation.text) {
				ConfirmDialog.create({
					header: resources["objectList.name"],
					text: confirmation.text,
					menu: confirmation.menu
				}).render().done(result => {
					if (result === "Selected") {
						objects = selection;
						result = "yes";
					} else if (result === "Active") {
						objects = [activeObj];
						result = "yes";
					}
					if (result === "yes") {
						that.doUnlinkObjects(objects);
					}
				});
			} else if (confirmation.objects) {
				// no text, delete silently
				that.doUnlinkObjects(objects);
			}
		});
	}

	doUnlinkObjects(objects: DomainObject[]): Promisable<void> {
		let that = this,
			orphanObjects: DomainObject[] = objects.filter(obj => that._isOrphan(obj));

		// NOTE: склонируем массив, т.к. это может быть selection.all() (а это ссылка, и при исключении объектов они будут удаляться из selection)
		objects = [].concat(...objects);

		// if objects being unlinked are changes and has no other references (except the current property),
		// we'll detach these objects (as they would become "orphan")
		if (orphanObjects.length > 0) {
			// among objects being unlinked there're some orphans: changed objects which become unreachable,
			// there could be the following cases:
			//		- one unlinked object
			//		- several unlinked objects and all of them are orphans
			//		- several unlinked objects but only some of they are orphans
			let msgText;
			if (objects.length === 1) {
				msgText = resources["peObjectList.orphan.unlink.one"];
			} else if (objects.length === orphanObjects.length) {
				msgText = resources["peObjectList.orphan.unlink.many_all"];
			} else {
				msgText = resources["peObjectList.orphan.unlink.many_some"];
			}

			let dialog: ConfirmDialog = ConfirmDialog.create({
				header: that.title(),
				text: msgText
			});

			return dialog.open().then((result: string) => {
				if (result !== "yes") {
					return lang.rejected();
				}

				// remove references from property
				that.executeUnlink(objects);

				// detach orphan objects
				return orphanObjects.forEach(obj => {
					that.viewModel.uow.detach(obj);
				});
			});
		}

		that.executeUnlink(objects);
	}

	protected executeUnlink(objects: DomainObject[]): void {
		let activeObj = this.activeItem();
		objects.forEach((obj: DomainObject) => {
			if (obj === activeObj) {
				this.activeItem(null);
			}
		});
		// NOTE: при исключении объектов для _каждого_ из них:
		// 	меняется items списка -> это вызывает обновление грида, валидацию, байндинги команд
		//	объект удаляется из selection (если он в него входит) -> это вызывает обновление селекшена грида, байндинги команд
		this.value().remove(objects);
	}

	protected shouldValidateItems(options?: ValidationOptions): boolean {
		if (!this.shouldValidate(options)) { return false; }

		switch (this.options.validateItems) {
			case "explicit":
				return !options || options.reason !== "auto";
			case "always":
				return true;
			case "never":
			default:
				return false;
		}
	}

	protected doDelete(): void {
		return this._deleteObjects();
	}

	protected executeDelete(objects?: DomainObject[]): void {
		let uow = this.viewModel.uow;
		let activeObj = this.activeItem();
		objects.forEach((obj: DomainObject) => {
			uow.remove(obj);
			if (obj === activeObj) {
				this.activeItem(null);
			}
		});

		// unlink objects first
		this.value().remove(objects);

		objects.forEach((obj) => {
			uow.remove(obj);
		});

		this.activate();
	}

	protected getMessage(resources: lang.Map<string>, op: string, mod: string): string {
		let res = resources[`peObjectList.${op}.${mod}`];
		if (res) { return res; }
		res = resources[`objectList_editable.${op}.${mod}`];
		if (res) { return res; }
		return resources[`objectList.${op}.${mod}`];
	}
}

interface peObjectList extends ListCommonMixin<DomainObject>, ObjectListMixin {
	// override type of value
	value(v: INavigationPropSet): void;
	value(): INavigationPropSet;
}

// NOTE: use `override: "inherited"` to keep existent `shouldValidateItem` and `shouldValidateItems` methods
peObjectList.mixin(ListCommonMixin, /*override*/ "inherited");
peObjectList.mixin(ObjectListMixin);
peObjectList.mixin(/** @lends peObjectList.prototype */{
	defaultOptions: peObjectList.defaultOptions,
	defaultMenus: peObjectList.defaultMenus,
	/**
	 * @enum {String}
	 */
	events: {
		/* data loaded event */
		DATA_LOADED: "dataLoaded"
	}
});

namespace peObjectList {
	export interface Options extends NavigationPropertyEditor.Options, ListCommonMixin.Options, ObjectListMixin.Options {
		preloads?: string|string[];
		menuRow?: Menu.Options;
		menuSelection?: Menu.Options;
		indexed?: boolean;
		/**
		 * Data loaded event handler
		 * @type {Function}
		 */
		onDataLoaded?: (sender: peObjectList) => void;
	}

	export interface AggregatedViolation extends Violation {
		aggregated?: boolean;
	}
}

core.ui.peObjectList = peObjectList;

PropertyEditor.DefaultMapping.register(function (propMd) {
	return propMd.many ? core.ui.peObjectList : null;
}, { vt: "object", priority: 10 });
PropertyEditor.DefaultMapping.register(function (propMd) {
	return propMd.many && propMd.presentation === "list" ? core.ui.peObjectList : null;
}, { vt: "object", priority: 20 });

export = peObjectList;
