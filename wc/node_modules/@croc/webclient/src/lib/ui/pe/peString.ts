import $ = require("jquery");
import core = require("core");
import binding = require("lib/binding");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import resources = require("i18n!lib/nls/resources");
import Menu = require("lib/ui/menu/Menu");
import MenuButtonsPresenter = require("lib/ui/menu/MenuButtonsPresenter");

import "xcss!lib/ui/styles/peString.css";

import lang = core.lang;

class peString  extends PropertyEditor {
	static defaultOptions: peString.Options = {
		/**
		 * Specifies the number of rows for a multiline text. Ignored if 'isMultiline' == false.
		 * @type Number
		 */
		rows: 3,
		/**
		 * type for html input control ("text" by default)
		 */
		inputType: "text",
		hideLetterCounter: false,
		hideClearButton: false,
	};
	/**
	 * Default options by context
	 */
	static contextDefaultOptions: lang.Map<peString.Options> = {
		filter: {
			hideLetterCounter: true
		},
		inline: {
			hideLetterCounter: true
		}
	};

	static defaultMenu: lang.Map<Menu.Options> = {
		items: [
			//{ name: "Clear", title: resources["clear"], icon: "clear", noFocus: true }
		]
	};

	/**
	 * isEmpty.
	 * @observable-property {boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isEmpty: lang.ObservableProperty<boolean>;

	options: peString.Options;
	menu: Menu;
	commands: peString.KnownCommands;
	isMultiline: boolean;
	menuPresenter: MenuButtonsPresenter;

	/**
	 * @class peString
	 * @extends PropertyEditor
	 * @param options
	 */
	constructor(options: peString.Options) {
		options = peString.mixContextOptions(options, peString.defaultOptions, peString.contextDefaultOptions);
		super(options);

		this.isMultiline = !!core.lang.coalesce(this.options.isMultiline, this.options.vt === "text");
		this.options.rows = this.isMultiline ? this.options.rows : 1;

		this.commands = this.createCommands();
		this.menu = this.createMenu();
		if (this.menu) {
			this.menu.bindToPart(this);
		}
	}

	createMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(peString.defaultMenu, "peString");
	}

	createMenu(): Menu {
		return new Menu(this.createMenuDefaults(), this.options.menu);
	}

	/**
	 * @protected
	 * @returns {Object.<string, Command>}
	 */
	createCommands(): peString.KnownCommands {
		let that = this;
		let commands: peString.KnownCommands = {};
		if (!that.options.hideClearButton) {
			commands.Clear = new core.commands.BoundCommand(that.doClear, that.canClear, that);
		}
		return core.lang.extend(commands, that.options.commands);
	}

	doClear(): void {
		if (!this.element) { return; }

		$(this.element).val("")
			.trigger("input")
			.trigger("change")
			.focus();
	}

	canClear(): boolean {
		return !this.disabled() && !this.isEmpty();
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		var that = this,
			options = that.options,
			$textBox,
			bindable;

		if (that.isMultiline) {
			$textBox = that._renderTextArea(domElement);
		} else {
			$textBox = that._renderInputText(domElement);
		}
		that.element = $textBox;

		$textBox.addClass("form-control").attr("name", options.name);

		if (!options.nullable) {
			$textBox.attr("required");
		}
		if (options.placeholder) {
			$textBox.attr("placeholder", options.placeholder);
		}

		binding.databind(
			binding.html($textBox, "disabled"),
			binding.domain(that, "disabled")
		);

		bindable = binding.html($textBox, that.options.changeTrigger === "keyPressed" ? "valueLive" : undefined);
		that.databind(bindable);

		// trigger event for refresh
		$textBox.trigger("input");

		super.doRender.call(this, domElement);
	}

	protected _renderTextArea(domElement: JQuery|HTMLElement): JQuery {
		return $("<textarea />")
			.appendTo(domElement)
			.addClass("x-pe-text")
			.attr("rows", this.options.rows || 1);
	}

	protected _renderInputText(domElement: JQuery|HTMLElement): JQuery {
		var that = this,
			$container = $("<div class='x-pe-string input-group'/>").appendTo(domElement),
			iconHtml = that.options.addonIcon && core.ui.iconProvider ? core.ui.iconProvider.getIcon(that.options.addonIcon) : "",
			$addon = iconHtml ? $("<span class='input-group-addon'>" + iconHtml + "</span>").appendTo($container) : null,
			$textBox = $("<span class='x-pe-string-textbox'></span>").appendTo($container),
			$input = $("<input class='x-pe-string-input' type='" + that.options.inputType + "'/>").appendTo($textBox),
			$clearBtn;

		if (that.options.maxLen) {
			$input.attr("maxlength", that.options.maxLen);
		}
		$input.bind("input keyup", function () {
			let val = $(this).val();
			that.isEmpty(!val);
		});

		if (that.commands.Clear) {
			$input.addClass("has-clear-btn");
			$clearBtn = $("<span class='clear-btn'>&times;</span>").appendTo($textBox);
			binding.commandBind($clearBtn, that.commands.Clear);
		}
		if (that.menu.items && that.menu.items.length) {
			that._renderCustomMenu($container);
		}
		if (!that.options.hideLetterCounter) {
			that._renderLetterCounter($container, $input);
		}

		return $input;
	}

	protected _onPropChanged(sender: any, value: any): void {
		super._onPropChanged.apply(this, arguments);
		this.isEmpty(!value);
	}

	protected _renderCustomMenu($container: JQuery): void {
		let that = this;
		let $btnContainer = $("<span class='input-group-btn' />").appendTo($container);

		that.menuPresenter = MenuButtonsPresenter.create({
			ungrouped: true,
			inline: true,
			itemPresentation: "icon"
		});
		that.menuPresenter.setViewModel(that.menu);
		that.menuPresenter.render($btnContainer);
	}

	protected _renderLetterCounter($container: JQuery, $textBox: JQuery): void {
		let that = this;
		let maxLen = that.options.maxLen;
		let $counterEl = $("<span class='input-group-addon x-pe-string-counter' />")
				.attr("title", resources["peString.letterCounter.tip"])
				.appendTo($container);

		$textBox.bind("input keyup", function () {
			let val = $(this).val();
			val = (val ? val.length : "0");
			if (maxLen) {
				val = val + "/" + maxLen;
			}
			$counterEl.text(val);
		});
	}

	/*
	 TODO: See http://track.rnd.croc.ru/issue/WC-959
	 renderError: function (error) {
	 this._renderError(error, this.domElement.find(".x-pe-string"));
	 }
	 */
}
namespace peString {
	export interface Options extends PropertyEditor.Options {
		isMultiline?: boolean;
		/**
		 * Specifies the number of rows for a multiline text. Ignored if 'isMultiline' == false.
		 * @type Number
		 */
		rows?: number;
		changeTrigger?: "keyPressed" | "lostFocus";
		/**
		 * type for html input control ("text" by default)
		 */
		inputType?: string;
		hideLetterCounter?: boolean;
		hideClearButton?: boolean;
		addonIcon?: string;
		maxLen?: number;
		menu?: Menu.Options;
		commands?: lang.Map<core.commands.ICommand|core.commands.ICommandFactory>;
		/**
		 * Text for placeholder in input.
		 */
		placeholder?: string;
	}
	export interface KnownCommands extends lang.Map<core.commands.Command> {
		Clear?: core.commands.Command;
	}
}

peString.mixin(/** @lends peString.prototype */{
	defaultOptions: peString.defaultOptions,
	contextDefaultOption: peString.contextDefaultOptions
});

core.ui.peString = peString;
core.ui.PropertyEditor.DefaultMapping["string"] = peString;
core.ui.PropertyEditor.DefaultMapping["text"] = peString;
core.ui.PropertyEditor.DefaultMapping["uuid"] = peString;

export = peString;

