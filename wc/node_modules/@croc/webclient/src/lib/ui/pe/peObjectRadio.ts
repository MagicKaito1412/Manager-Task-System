import $ = require("jquery");
import core = require("core");
import peObjectBase = require("lib/ui/pe/peObjectBase");
import DataSource = require("lib/data/DataSource");
import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import utils = require("lib/utils");
import formatters = require("lib/formatters");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import resources = require("i18n!lib/nls/resources");
import peLoadableMixin = require("lib/ui/pe/peLoadableMixin");

import "xcss!lib/ui/styles/peObjectRadio.css";

import { LoadResponse } from "lib/interop/.interop";
import { UnitOfWork, metadata } from "lib/domain/.domain";
import domain = require("lib/domain/.domain");
import lang = core.lang;

import DataLoadEventArgs = peLoadableMixin.DataLoadEventArgs;
import State = peLoadableMixin.State;

class peObjectRadio extends peObjectBase {
	static defaultOptions: peObjectRadio.Options = {
		orientation: "vertical",
		changeTrigger: "keyPressed",
		nullValueText: resources["not_specified"],
		showNullValue: true,
	};

	/**
	 * @enum {String}
	 */
	static Events = {
		DATA_LOADING: "dataLoading",
		DATA_LOADED: "dataLoaded",
		LOADED: "loaded"
	};

	options: peObjectRadio.Options;
	items: ObservableCollectionView<any>;
	entityType: string;
	dataSource: DataSource;
	showNullValue: boolean;
	jsonAdapter: peObjectRadio.JsonAdapter;
	private _uow: UnitOfWork;
	private _ownUow: boolean;
	private _domainDataSource: boolean;
	private _rerenderScheduled: boolean;

	/**
	 * @class peObjectRadio
	 * @extends peObjectBase
	 * @param options
	 */
	constructor(options: peObjectRadio.Options) {
		options = peObjectRadio.mixOptions(options, peObjectRadio.defaultOptions);
		super(options);

		let app = core.Application.current;

		this.state(State.initial);
		this._uow = options.uow;
		if (!this._uow) {
			this._uow = app.createUnitOfWork({ connected: true });
			this._ownUow = true;
		}
		this.items = new ObservableCollectionView();
		if (this.options.orderBy) {
			this.items.orderBy(this.options.orderBy);
		}

		utils.subscribeOnEvents(this, options, peObjectRadio.Events);

		if (this.options.valueOptions) {
			this.isDataLoaded = true;
			this.items.reset(this.options.valueOptions);
			this._ensureJsonAdapter();
		} else {
			this.isDataLoaded = false;
			this.entityType = options.entityType || options.urlSuffix || this.options.ref.name;
			if (!this.entityType) {
				throw new Error("peObjectRadio.ctor: nor options.entityType, options.urlSuffix or options.ref were specified.");
			}
			this.dataSource = options.dataSource || DataSource.create(app, { entityType: this.entityType });
			this._domainDataSource = this.dataSource.isDomain;
			if (!this._domainDataSource) {
				this._ensureJsonAdapter();
			}
			// TODO: loading in ctor, really?
			this.reload();
		}
	}

	reload(): lang.Promise<void> {
		let that = this,
			args = {} as DataLoadEventArgs;
		this.state(State.loading);
		return lang.async.chain().then(() => {
			that._onDataLoading(args);
			return this.dataSource.load();
		})
		.then((dsResult: LoadResponse) => {
			if (this.state() === State.disposed) { return; }
			args.items = this._domainDataSource ?
				this._uow.fromServerResponse(dsResult) :
				dsResult.result;
			this._onDataLoaded(args);
			if (that._rerenderScheduled) {
				that._rerenderScheduled = false;
				that.rerender();
			}
			this.onLoaded();
		}).then<void>(null, error => {
			if (core.eth.isCanceled(error)) {
				// load was cancel - it's ok and not an error
				return lang.resolved();
			}
			that._onFailed(error);
			return error;
		}).value();
	}

	protected _ensureJsonAdapter(): void {
		let that = this;
		that.jsonAdapter = that.options.jsonAdapter;
		if (!that.options.jsonAdapter && (!that.options.displayField || !that.options.idField)) {
			throw new Error("peObjectRadio.ctor: plain(json) DataSource was specified but none of required options: jsonAdapter or displayField/idField");
		}
		if (!that.jsonAdapter) {
			that.jsonAdapter = {
				getPresentation: (value) => {
					return value ? value[that.options.displayField] : "";
				},
				getId: (value) => {
					return value ? value[that.options.idField] : null;
				}
			};
		} else {
			if (!core.lang.isFunction(that.jsonAdapter.getPresentation))
				throw new Error("peObjectRadio.ctor: jsonAdapter should have getPresentation method");
			if (!core.lang.isFunction(that.jsonAdapter.getId))
				throw new Error("peObjectRadio.ctor: jsonAdapter should have getId method");
		}
	}

	protected _setItems(items: any[]): void {
		this.items.reset(items);
	}

	protected onDataLoading(args: DataLoadEventArgs): void {
		this.trigger(peObjectRadio.Events.DATA_LOADING, this, args);
	}

	protected onDataLoaded(args: DataLoadEventArgs): void {
		this.trigger(peObjectRadio.Events.DATA_LOADED, this, args);
	}

	protected onLoaded(): void {
		this.trigger(peObjectRadio.Events.LOADED, this);
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;

		super.doRender.call(that, domElement);
		if (that.isDataLoaded) {
			that._renderLoaded(domElement);
		} else {
			that._renderLoading(domElement);
			that._rerenderScheduled = true;
		}
	}

	protected afterRender(domElement?: JQuery|HTMLElement): void {
		let that = this;
		if (!that.isDataLoaded) {
			that.renderStatus("waiting");
		} else {
			super.afterRender.call(that, domElement);
		}
	}

	protected _renderLoaded(domElement: JQuery|HTMLElement): void {
		let that = this;
		let element = $("<div class='x-pe-object-radio'/>").appendTo(domElement);
		let groupName = that.options.name + "_" + (that.viewModel.id || utils.generateGuid());
		let isHorizontal = that.options.orientation === "horizontal";
		that.showNullValue = that.options.nullable && that.options.showNullValue;
		if (that.showNullValue) {
			$("<div></div>")
				.addClass(isHorizontal ? "radio-inline" : "radio")
				.append(
					$("<label />")
						.append($("<input />", { type: "radio", value: "", name: groupName }))
						.append(that.options.nullValueText)
				)
				.appendTo(element);
		}

		that.items.forEach(function(opt: any): void {
			$("<div></div>")
				.addClass(isHorizontal ? "radio-inline" : "radio")
				.append(
					$("<label />")
						.append($("<input />", { type: "radio", value: that._getOptionId(opt), name: groupName }))
						.append(that._getOptionTitle(opt).toString())
				)
				.appendTo(element);
		});

		// принудительное фокусирование батона при клике мышкой
		element.bind("click", function (e: JQueryEventObject): void {
			if (e.target.tagName === "INPUT") {
				$(e.target).focus();
			}
		});

		let bindable = {
			get: function(): any {
				let v = element.find("input:checked").val();
				return v !== undefined ? v : null;
			},
			set: function(v: any): void {
				if (v != null) {
					element.find("input[value='" + v.id + "']").prop("checked", true);
				} else if (that.showNullValue) {
					element.find("input[value='']").prop("checked", true);
				} else {
					element.find("input:checked").prop("checked", false);
				}
			},
			onchange: function(handler) {
				// когда обновляется значение
				if (that.options.changeTrigger === "keyPressed") {
					// перемещение по группе (ползаем стрелками и перемещаем фокус)
					element.find("input").bind("change", handler);
				} else {
					// уходим из группы радиобатонов
					that.element.focusout(function(): void {
						window.setTimeout(() => {
							$("[id*='" + that.id + "']").is($(document.activeElement)) || handler();
						}, 200);
					});
				}
				return {
					dispose: () => {
						element.find("input").unbind("change", handler);
					}
				};
			}
		};

		that.element = element;
		that.databind(bindable);
	}

	protected _renderLoading(domElement: JQuery|HTMLElement): void {
		$("<div class='x-pe-object-radio'><div class='" + core.ui.getWaitingIconClass(32) + "'></div></div>").appendTo(domElement);
	}

	protected _getOptionTitle(obj: any): string | formatters.SafeHtml {
		let that = this;
		return that._domainDataSource ?
			formatters.formatPropValue(that.options, obj) :
			that.jsonAdapter.getPresentation(obj);
	}

	protected _getOptionId(obj: any): string {
		return this._domainDataSource ? obj.id : this.jsonAdapter.getId(obj);
	}

	focus(): void {
		if (this.element) {
			let input = this.element.find("input");
			let checked = input.filter(":checked");
			let target = checked[0] || input[0];
			if (target) {
				$(target).focus();
			}
		}
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		let that = this;
		that.items.dispose();
		if (that._ownUow && that._uow) {
			that._uow.dispose();
		}
		super.dispose(options);
		that.state(State.disposed);
	}
}

interface peObjectRadio extends peLoadableMixin { }

namespace peObjectRadio {
	export interface Options extends peObjectBase.Options {
		ref?: metadata.EntityMeta;
		/**
		 * @type {DataSource}
		 */
		dataSource?: DataSource;
		/**
		 * @type {Array}
		 */
		valueOptions?: any[];
		/**
		 * @type Array|String
		 */
		orderBy?: string|string[];
		orientation?: "vertical" | "horizontal";
		changeTrigger?: "keyPressed" | "lostFocus";
		nullValueText?: string;
		showNullValue?: boolean;
		entityType?: string;
		urlSuffix?: string;
		uow?: UnitOfWork;
		onDataLoading?: (sender: peObjectRadio, args: DataLoadEventArgs) => void;
		/**
		 * data loaded event handler
		 * @type {Function}
		 */
		onDataLoaded?: (sender: peObjectRadio, args: DataLoadEventArgs) => void;
		onLoaded?: (sender: peObjectRadio) => void;
		/**
		 * Json Adapter - an object with two methods: getId and getPresentation, which accept an json object from DataSource result
		 * It's only used with plain DataSource (DataSource returns json, not domain objects)
		 * @type {Object}
		 */
		jsonAdapter?: JsonAdapter;
		displayField?: string;
		idField?: string;
	}

	export interface JsonAdapter {
		getPresentation(jsonItem: any): string | formatters.SafeHtml;
		getId(jsonItem: any): string;
	}
}

peObjectRadio.mixin(peLoadableMixin);

// backward compatibility: access to static fields via prototype
peObjectRadio.mixin(/** @lends peObjectRadio.prototype */{
	defaultOptions: peObjectRadio.defaultOptions,
	states: State,
	events: peObjectRadio.Events
});

core.ui.peObjectRadio = peObjectRadio;

core.ui.PropertyEditor.DefaultMapping.register(function (propMd) {
	return propMd.presentation === "radio" ? core.ui.peObjectRadio: null;
}, { vt: "object" });

export = peObjectRadio;

