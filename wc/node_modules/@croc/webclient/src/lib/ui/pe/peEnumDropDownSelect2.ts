import $ = require("jquery");
import core = require("core");
import _ = require("underscore");
import peEnumDropDownBase = require("lib/ui/pe/peEnumDropDownBase");
import validation = require("lib/validation");
import Select2 = require("vendor/select2/select2");
import resources = require("i18n!lib/nls/resources");

import "xcss!vendor/select2/content/select2.css";
import "xcss!lib/ui/styles/peEnum.css";
import "xcss!lib/ui/styles/peEnumDropDownSelect2.css";

import { metadata } from "lib/domain/.domain";
import EnumMeta = metadata.EnumMeta;
import EnumMember = metadata.EnumMember;
import lang = core.lang;

// TODO var AttachContainer = $.fn.select2.amd.require("select2/dropdown/attachContainer");
function AttachContainer (decorated, $element, options) {
	decorated.call(this, $element, options);
}
AttachContainer.prototype.position = function (decorated, $dropdown, $container) {
	let $dropdownContainer = $container.find(".dropdown-wrapper");
	$dropdownContainer.append($dropdown);

	$dropdown.addClass("select2-dropdown--below").addClass("select2-dropdown-inplace");
	$container.addClass("select2-container--below");
};

class peEnumDropDownSelect2 extends peEnumDropDownBase {
	static defaultOptions: peEnumDropDownSelect2.Options = {
		dropdownAutoWidth: false,
		hideSearch: false,
		minimumResultsForSearch: 4,
		//dropdownPosition: "inplace",
		closeOnSelect: undefined        // by default: false for flags, true - otherwise
	};

	static contextDefaultOptions: lang.Map<peEnumDropDownSelect2.Options> = {
		filter: {
			dropdownPosition: "absolute"
		},
		editor: {
			dropdownPosition: "inplace"
		},
		inline: {
			dropdownPosition: "inplace"
		}
	};

	options: peEnumDropDownSelect2.Options;
	select2: Select2;

	/**
	 * @constructs peEnumDropDownSelect2
	 * @extends peEnumDropDownBase
	 * @param options
	 */
	constructor (options: peEnumDropDownSelect2.Options ) {
		options = peEnumDropDownSelect2.mixContextOptions(options, peEnumDropDownSelect2.defaultOptions, peEnumDropDownSelect2.contextDefaultOptions);
		// TODO: options = peEnumDropDownSelect2.mixOptions2(options);
		super(options);
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this,
			flags = that.flags,
			bindable,
			select;

		super.doRender(domElement);
		that.element.addClass("x-pe-enum-dropdown-select2");

		select = that.select;
		select.removeClass("form-control");
		select.attr("data-disabled", 0);

		let modalParent = that.select.parents(".modal");

		let selectOptions = that.getSelectOptions(modalParent);
		if (that.options.dropdownPosition === "inplace") {
			selectOptions  = that.addDropdownAdapter(selectOptions);
		}
		that.select2 = new Select2(select, selectOptions);

		if (that.options.dropdownPosition === "inplace") {
			// notify Affix about changes in dom
			select.bind("select2:opening", () => {
				that.notifyDOMChanged();
			});
			select.bind("select2:close", () => {
				that.notifyDOMChanged();
			});
		}

		// workaround: for multi-select selecting a value should clear search field (by default it doesn't)
		if (that.select2.options.options.multiple && that.select2.selection) {
			that.select2.on("select", () => {
				that.select2.selection.$search.val("");
				that.select2.selection.handleSearch();
			});
		}

		// workaround: по умолчанию Select2 не гасит keyup, в диалоге оно доходят до меню,
		// и, например, Enter/ESC закрывают диалог.
		// Попытка починить Select2 пока не удалась, см. https://github.com/select2/select2/issues/4495
		// Поэтому просто блокируем все события (элемент $dropdown находится не под $container)
		// Ес-но, это ломает нормальное поведение PE, когда по ESC мы делаем blur
		that.select2.$container.stopKeyboardBubbling();
		that.select2.$dropdown.stopKeyboardBubbling();

		if (!flags){
			bindable = {
				get: function (): any {
					let v = select.val();
					if (!that.isDomain) {
						return that.parseValue(v);
					}
					return v;
				},
				set: function (v: any): void {
					select.val(v != null ? v.toString() : v).trigger("change.select2");
				}
			};
		} else {
			bindable = {
				get: function (): number {
					let v = 0;
					$.each(select.val(), (i, optionVal) => {
						v = v | optionVal;
					});
					return v;
				},
				set: function (v: number): void {
					let options = _.filter(_.pluck(that.members(), "value"), function(memberValue: number): boolean {
						return (v & memberValue) === memberValue;
					});
					select.val(options).trigger("change.select2");
				}
			};
		}

		bindable.onchange = function (handler) {
			select.bind("change", handler);
			return {
				dispose: function() {
					select.unbind("change", handler);
				}
			};
		};

		that.databind(bindable);

		// workaround: multi-select отображаемый в диалоге будет иметь placeholder обрезанный width:100px (https://github.com/select2/select2/issues/4513)
		if (flags && !select.is(":visible")) {
			if (modalParent.length && !modalParent.is(":visible")) {
				// dialog is hidden, postpone resize when it's shown
				modalParent.on("shown.bs.modal.select2", () => {
					that.select2.selection.resizeSearch();
					modalParent.off("shown.bs.modal.select2");
				});
			} else {
				// dialog is visible, but control is invisible, make resize with timer
				// NOTE: Стандартный ObjectEditorPresenter показывает страницу синхронно сразу после рендеринга
				window.setTimeout( () => {
					that.select2.selection.resizeSearch();
				});
			}
		}

		if (that._tabIndex) {
			that._setTabIndex(that._tabIndex);
		}
	}

	getSelectOptions(modalParent: JQuery): Select2.Options {
		let that = this;
		let options = that.options;
		let flags = that.flags;

		// NOTE: Можно загрузкить языковой файл (добавить в начало: import "vendor/select2/i18n/ru"),
		// но он падает, т.к. ожидает jQuery.fn.select2, поэтому определим объект Translation:
		let Language = {
			noResults: () => { return that.options.noResultsText; },
			searching: () => { return resources["searching"]; },
			maximumSelected: () => { return ""; }
		};

		return lang.extendEx({
			allowClear : options.nullable && !flags,
			width: options.width,
			dropdownAutoWidth: options.dropdownAutoWidth,
			minimumResultsForSearch: options.hideSearch ? Infinity : options.minimumResultsForSearch,
			// by default dropdown will be under body, but in dialog we move it under modal root
			dropdownParent: modalParent.length ? modalParent : undefined,
			closeOnSelect: options.closeOnSelect !== undefined ? options.closeOnSelect : (flags ? false : true),
			language: Language,
			/* default options:
			 amdBase: './',
			 amdLanguageBase: './i18n/',
			 closeOnSelect: true,
			 debug: false,
			 dropdownAutoWidth: false,
			 escapeMarkup: Utils.escapeMarkup,
			 language: EnglishTranslation,
			 matcher: matcher,
			 minimumInputLength: 0,
			 maximumInputLength: 0,
			 maximumSelectionLength: 0,
			 minimumResultsForSearch: 0,
			 selectOnClose: false,
			 sorter: function (data) { return data; },
			 templateResult: function (result) { return result.text; },
			 templateSelection: function (selection) { return selection.text; },
			 theme: 'default',
			 width: 'resolve'
			 * */
		}, options.select2, {deep: true});
	}

	protected addDropdownAdapter(options: Select2.Options): Select2.Options {
		// NOTE: Код взять из Select2 (Defaults.prototype.apply),
		//  по умолчаню Select2 использует AttachBody в качестве dropdownAdapter,
		//  dropdownAdapter можно переопределить через опцию,
		//  но вместе с этим приходится повторять настройку всей цепочики декораторов
		// NOTE: важно: в отличии от кода в select2 здесь в опции еще не подставлены defaults
		let Utils = $.fn.select2.amd.require("select2/utils");
		let Dropdown = $.fn.select2.amd.require("select2/dropdown");
		let DropdownSearch = $.fn.select2.amd.require("select2/dropdown/search");
		let CloseOnSelect = $.fn.select2.amd.require("select2/dropdown/closeOnSelect");
		let MinimumResultsForSearch = $.fn.select2.amd.require("select2/dropdown/minimumResultsForSearch");

		if (options.dropdownAdapter == null) {
			if (this.flags) {
				options.dropdownAdapter = Dropdown;
			} else {
				let SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

				options.dropdownAdapter = SearchableDropdown;
			}

			if (options.minimumResultsForSearch !== 0) {
				options.dropdownAdapter = Utils.Decorate(
					options.dropdownAdapter,
					MinimumResultsForSearch
				);
			}

			if (options.closeOnSelect) {
				options.dropdownAdapter = Utils.Decorate(
					options.dropdownAdapter,
					CloseOnSelect
				);
			}

			options.dropdownAdapter = Utils.Decorate(
				options.dropdownAdapter,
				AttachContainer
			);
		}

		return options;
	}

	focus (): void {
		this.select2.focus();
		//this.select.select2("focus");
	}

	_setWidth(): void {
		// ничего не делаем - ширина установлена в render
	}

	_onDisabledChange (disabled: boolean): void {
		this.select.prop("disabled", disabled);

		// IE8-IE10 hack: несмотря на поддержку mutation events (и onpropertychanged в IE8) для disabled-элементов они не работают!
		if (core.platform.browser.ie && core.platform.browser.ie.version < 11) {
			// simulate setting disabled - see select2._syncAttributes
			let select2: any = this.select2;
			select2.options.set("disabled", disabled);
			disabled ? select2.trigger("disable", {}) : select2.trigger("enable", {});
		}
	}

	_renderError (error, element): void {
		let that = this;
		super._renderError(error, element);
		// TODO:
		if (that.select && that.select) {
			that.select.toggleClass("-invalid", !!error);
			//that.select.select2("dropdown").toggleClass("-invalid", !!error);
		}
	}

	unload (options?): void {
		let that = this;
		if (that.select2) {
			that.select2.destroy();
			that.select2 = undefined; // prevent repeated dispose
		}
		super.unload(options);
	}

	/*
	 _setTabIndex: function (index) {
	 var that = this,
	 el,
	 select2;

	 // просто установка таба в оригинальном select ничего не даёт.
	 // select2 принудительно устанавливает ему tabindex=-1, т.к. прячет

	 // поэтому выставляем tabindex в доме селекта2
	 el = that.options.ref.flags ?
	 that.element.find("input.select2-input") :
	 that.element.find("input.select2-focusser");
	 el.prop("tabIndex", index);

	 // но этого мало. т.к.:
	 // 1) tabindex в частях плагина сильно юзается для его работы (устанавливается в -1/возвращается в оригинальный и тд)
	 // 2) оригинальный tabindex (полученный из оборачиваемого селекта) сохраняется в свойстве экземпляра плагина
	 // итого - меняем руками свойство
	 // внимание, дальше хак. в документации разумеется ничего не написано, так что основываясь на исходниках
	 // получаем экземпляр плагина
	 if(!!that.select) {
	 select2 = that.select.select2("container").data("select2");
	 }
	 // меняем свойство
	 if(!!select2){
	 select2.elementTabIndex = index;
	 }
	 },
	 */

}

peEnumDropDownSelect2.mixin({
	defaultOptions: peEnumDropDownSelect2.defaultOptions
});

namespace peEnumDropDownSelect2 {
	export interface Options extends peEnumDropDownBase.Options {
		dropdownAutoWidth?: boolean;
		hideSearch?: boolean;
		minimumResultsForSearch?: number;
		dropdownPosition?: "inplace" | "absolute";
		closeOnSelect?: boolean;
		select2?: Select2.Options;
	}
}

core.ui.peEnumDropDownSelect2 = peEnumDropDownSelect2;

core.ui.PropertyEditor.DefaultMapping.register(function (propMd) {
	// NOTE: it's default PE for enums and for flags with presentation=="dropdown"
	// NOTE: before 1.26 it was only used if presentation=="select2"
	if (propMd.ref && !core.platform.isMobileDevice) {
		if (propMd.presentation === "select2" ||
			propMd.presentation === "dropdown" ||
			!propMd.presentation && !propMd.flags && !propMd.ref.flags) {
			return core.ui.peEnumDropDownSelect2;
		}
	}

	/*if (propMd.ref && !core.platform.isMobileDevice && propMd.presentation === "select2") {
		return core.ui.peEnumDropDownSelect2;
	}*/
}, { vt: "enum" });

export = peEnumDropDownSelect2;


