import $ = require("jquery");
import core = require("core");
import utils = require("lib/utils");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import Menu = require("lib/ui/menu/Menu");
import binding = require("lib/binding");
import support = require("lib/domain/support");
import BackendInterop = require("lib/interop/BackendInterop");
import template = require("xhtmpl!lib/ui/templates/peBinary.hbs");
import resources = require("i18n!lib/nls/resources");

import "bootstrap";
import "vendor/jquery.fileupload";
import "vendor/jquery.iframe-transport";
import "vendor/colorbox/jquery.colorbox";
import "xcss!vendor/colorbox/colorbox.css";
import "xcss!lib/ui/styles/peBinary.css";

import lang = core.lang;
import Command = core.commands.Command;

import { TraceSource } from "lib/core.diagnostics";
import { IDataFacade } from "lib/interop/.interop";
import { LobPropValue } from "lib/domain/support";
import {Part} from "core.ui";

class peBinary  extends PropertyEditor {
	/**
	 * @constant {Object}
	 */
	static defaultOptions: peBinary.Options = {
		Presenter: core.ui.View,
		template: template,
		contentType: undefined, // "image"
		uploadChunkSize: undefined,
		uploadUrl: undefined,
		thumbnailWidth: 256,
		thumbnailHeight: undefined,
		menu: undefined,
		commands: undefined,
		imgPreviewSettings: {
			imgError: resources["peBinary.previewLoadingError"]
		},
		/**
		 * file extensions list (e.g. ".jpg,.png,.doc"), A valid MIME type with no extensions, "audio/*", "video/*", "image/*"
		 * */
		acceptFileTypes: undefined,
		showPlaceholder: "empty"	// true - show always / false - show never / "empty" - show for empty
	};

	/**
	 * @constant {Object}
	 */
	static defaultMenu: Menu.Options = {
		items: [
			{
				name: "Remove",
				title: resources["peBinary.clear"],
				icon: "clear",
				hideIfDisabled: true
			}, {
				name: "Export",
				title: resources["peBinary.save"],
				icon: "download",
				hideIfDisabled: true
			}, {
				name: "Open",
				title: resources["peBinary.open"],
				icon: "export",
				hideIfDisabled: true
			}
		]
	};

	/**
	 * @observable-property {peBinary.State}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<peBinary.State>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	lastError: lang.ObservableProperty<string>;

	options: peBinary.Options;
	isImage: boolean;
	traceSource: TraceSource;
	files: core.files.Module;
	dataFacade: IDataFacade;
	uploadUrl: string;
	uploadChunkSize: number;
	placeholder: string;
	commands: peBinary.KnownCommands;
	menu: Menu;
	private _uploadToken;
	private _dragCounter: number;
	private inputElement: JQuery;
	private inputButton:  JQuery;
	private imgThumbnail: JQuery;

	/**
	 * @class peBinary
	 * @extends PropertyEditor
	 * @param options
	 */
	constructor(options: peBinary.Options) {
		options = peBinary.mixOptions(options, peBinary.defaultOptions);
		super(options);
		let that = this;
		that.traceSource = new core.diagnostics.TraceSource("ui.peBinary");
		that.isImage = that.options.contentType === "image";
		that.files = core.files || options.files;
		//that.files = core.Application.current.files;	// TODO: to think
		that.dataFacade = core.Application.current.dataFacade;
		that.uploadUrl = core.lang.coalesce(that.options.uploadUrl, that.files.uploadUrl);
		if (!that.uploadUrl) {
			that.options.readOnly = true;
		}
		that.uploadChunkSize = core.lang.coalesce(that.options.uploadChunkSize, that.files.uploadChunkSize);
		if (that.uploadChunkSize <= 0) {
			that.uploadChunkSize = undefined;
		}
		that.placeholder = that.options.placeholder || resources["peBinary.placeholder"];

		that.commands = core.lang.extend(that.createCommands(), that.options.commands || {});
		that.menu = that._createMenu();
		if (that.menu) {
			that.menu.bindToPart(that);
		}
		that.bind("change:state", that._onStateChanged);
		that.state(peBinary.State.Unknown);

		that.initPresenter();
	}

	showPlaceholder(): boolean {
		return this.options.showPlaceholder === "empty" && this.isEmpty() || this.options.showPlaceholder === true;
	}

	isEmpty(): boolean {
		return this.state() === peBinary.State.Empty;
	}

	isUploading(): boolean {
		return this.state() === peBinary.State.Uploading;
	}

	isServer(): boolean {
		return this.state() === peBinary.State.Server;
	}

	isFail(): boolean {
		return this.state() === peBinary.State.Fail;
	}

	isPropLoading(): boolean {
		return this.state() === peBinary.State.PropLoading;
	}

	isReadOnly(): boolean {
		return this.disabled() || this.options.readOnly;
	}

	tweakOptions(options: peBinary.Options): void {
		core.lang.appendEx(options, {
			presenterOptions: {
				template: options.template
			}
		}, { deep: true });
		super.tweakOptions(options);
	}

	setViewModel(viewModel: any): void {
		let that = this;
		super.setViewModel(viewModel);

		if (viewModel) {
			if (that.hidden()) {
				let disposable = that.subscribe("change:hidden", function (sender, val) {
					disposable.dispose();
					if (that.viewModel && !val) {
						that._ensurePropLoaded();
					}
				});
				that.addDisposable(disposable, null, true);
			} else {
				that._ensurePropLoaded();
			}
		}
	}

	protected _onPropChanged(sender: any, value: any): void {
		let that = this;

		that._setStateByValue(value);
		super._onPropChanged(sender, value);
	}

	protected _ensurePropLoaded(): void {
		let that = this;
		if (!that.viewModel) { return; }
		let curValue = lang.get(that.viewModel, that.viewModelProp);

		if (curValue !== undefined) {
			// already loaded
			that._setStateByValue(curValue);
			return;
		}
		// the prop isn't loaded yet
		that.state(peBinary.State.PropLoading);
		that.viewModel.uow.loadProp(
			that.viewModel.meta.name, that.viewModel.id, that.viewModelProp
		).fail(() => {
			that.state(peBinary.State.Fail);
			that.lastError(resources["data_load_error"]);
		});
	}

	protected _setStateByValue(propVal: LobPropValue): void {
		let that = this;
		if (!propVal) {
			that.state(peBinary.State.Empty);
		} else if (propVal.pendingUpload) {
			that.state(peBinary.State.Uploading);
		} else {
			that.state(peBinary.State.Server);
		}

		//that.state(propVal ? State.server : State.empty);
	}

	protected _onStateChanged(sender: any, state): void {
		let that = this;
		if (state !== peBinary.State.Fail) {
			that.lastError(null);
		}
		that._invalidateCommands();
		that._disableUploadInput(that.isPropLoading());
	}

	protected _invalidateCommands(): void {
		let that = this;
		if (!that.commands) { return; }

		let value = that.viewModel ? lang.get(that.viewModel, that.viewModelProp) : null;

		let canRead = that.isServer() && !!value,
			disabled = that.disabled();
		if (that.commands.Remove) {
			that.commands.Remove.canExecute(canRead && !disabled && !that.isReadOnly());
		}
		if (that.commands.Export) {
			that.commands.Export.canExecute(canRead && !disabled && !value.resourceId);
		}
		if (that.commands.Open) {
			that.commands.Open.canExecute(canRead && !disabled && !value.resourceId);
		}
		if (that.commands.UploadCancel) {
			that.commands.UploadCancel.canExecute(that.isUploading());
		}
	}

	onReady(): void {
		let that = this;

		let $element = that.$domElement.find(".x-pe-binary");
		$element.attr("name", that.options.name);
		let bindable = binding.html($element.find(".x-pe-binary-fileinfo"));
		that.databind(bindable);

		let $inputElement = $element.find("input[name=file]");
		if (that.options.acceptFileTypes) {
			$inputElement.attr("accept", that.options.acceptFileTypes);
		} else if (that.isImage) {
			$inputElement.attr("accept", "image/*");
		} else if (that.options.contentType === "video") {
			$inputElement.attr("accept", "video/*");
		} else if (that.options.contentType === "audio") {
			$inputElement.attr("accept", "audio/*");
		}

		let chainId;
		if (!that.isReadOnly()) {
			$element.addClass("x-pe-binary-editable");
			$inputElement.fileupload({
				url: that.uploadUrl,
				replaceFileInput: false,
				maxChunkSize: that.uploadChunkSize,
				dropZone: $element,
				// NOTE: pasteZone doesn't work with any elements except document, so we'll filter our events in `paste` handler
				pasteZone: core.html.$document,
				dataType: "json",
				formData: [
					{
						name: "X-EntityType",
						value: that.viewModel.meta.name
					}, {
						name: "X-ObjectId",
						value: that.viewModel.id
					}, {
						name: "X-PropName",
						value: that.viewModelProp
					}, {
						name: "X-StorageType",
						value: "domain"
					}
				],
				add: function(e: JQueryEventObject, data: JQueryFileInputOptions): boolean {
					return that._onAdd(data);
				},
				done: function(e: JQueryEventObject, data: JQueryFileUploadDone): void {
					that._onUploadSuccess(data);
				},
				fail: function(e: JQueryEventObject, data: JQueryFileUploadDone): void {
					that._onUploadFail(data);
				},
				progress: function(e: JQueryEventObject, data: JQueryFileUploadProgressAllObject): void {
					that._onUploadProgress(data);
				},
				chunksend: function (e: JQueryEventObject, data: JQueryFileUploadChunkObject): void {
					if (chainId) {
						data.headers["X-ChunkChain"] = chainId;
					}
				},
				chunkdone: function(e: JQueryEventObject, data: JQueryFileUploadChunkObject): void {
					if (data.result) {
						chainId = data.result.resourceId;
					}
				},
				paste: function(e: JQueryEventObject, data: JQueryFileUploadFilesObject): void {
					let focusedEl = core.html.focused();
					if (!$.contains($element[0], focusedEl)) {
						// it's not our element
						e.preventDefault();
					}
				},
				drop: function(e: JQueryEventObject, data: JQueryFileUploadFilesObject) {
					if (data && data.files) {
						if (data.files.length > 1) {
							// multiple files are not supported
							core.Application.current.eventPublisher.publish("ui.peBinary.error", core.SystemEvent.create({
								kind: core.SystemEvent.Kind.notification,
								priority: "low",
								severity: "info",
								message: resources["peBinary.multiple_files_not_supported"]
							}));
							return false;
						}
						let file = data.files[0];
						let res = that._validateFile(file);
						if (!res) {
							that.traceSource.warn("peBinary: ignored dropped file due to filters: " + file.name);
							that._reportFileTypeNotSupported(file.name);
						}
						return res;
					}
				}
			});
			that._dragCounter = 0;
			$element.on("dragenter", function () {
				if (that._dragCounter === 0) {
					$element.addClass("dragover");
				}
				that._dragCounter++;
			});
			$element.on("dragleave", function () {
				that._dragCounter--;
				if (that._dragCounter === 0) {
					$element.removeClass("dragover");
				}
			});
			$element.on("drop", function () {
				that._dragCounter = 0;
				$element.removeClass("dragover");
			});
		} else {
			// for readonly PE set tabIndex to allow focus (as it won't have input, only div/img which are not focusable by default)
			$element.attr("tabindex", "0");
		}

		that.inputElement = $inputElement;
		that.inputButton = $element.find(".x-pe-binary-uploadbutton");
		that.element = $element;

		if (that.isImage) {
			that._updateThumbnailImage();
		}

		super.onReady();
	}

	protected _reportFileTypeNotSupported(fileName: string) {
		core.Application.current.eventPublisher.publish("ui.peBinary.error", core.SystemEvent.create({
			kind: core.SystemEvent.Kind.notification,
			priority: "low",
			severity: "info",
			message: resources["peBinary.filetype_not_supported"]
		}));
	}

	protected _validateFile(file): boolean {
		let that = this, fileTypes, contentType;
		if (fileTypes = that.options.acceptFileTypes) {
			if (!file.name) {
				return true;
			}
			// split by ","
			let exts = fileTypes.toLowerCase().split(",");
			return exts.some((ext: string) => {
				return core.lang.stringEndsWith(file.name.toLowerCase(), ext);
			});
		} else if (that.isImage) {
			return !!(file.type && file.type.indexOf("image/") === 0);
		} else if (contentType = that.options.contentType) {
			return !!(file.type && file.type.indexOf(contentType + "/") === 0);
		}
		return true;
	}

	protected _getUrl(params?: {width?: number, height?: number}): string {
		return this.files.getBinaryPropLoadUrl(this.viewModel, this.viewModelProp, params);
	}

	protected _openPreview(): void {
		let url = this._getUrl();
		if (url) {
			$.colorbox({
				title: this.options.descr || "",
				href: url,
				photo: true,
				scrolling: false,
				maxWidth: "90%",
				maxHeight: "90%",
				initialWidth: 300,
				initialHeight: 183,
				imgError: this.options.imgPreviewSettings.imgError,
				onComplete: () => {
					// fix for colorBox+jquery.animate-enhanced+webview issue
					// https://github.com/jackmoore/colorbox/issues/378
					$("#cboxLoadingOverlay").hide();
				}
			});
		}
	}

	protected _createMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(peBinary.defaultMenu, "peBinary");
	}

	protected _createMenu(): Menu {
		return new Menu(this._createMenuDefaults(), this.options.menu);
	}

	/**
	 * Create commands
	 * @protected
	 */
	protected createCommands(): peBinary.KnownCommands {
		let that = this,
			cmdRemove = core.createCommand({
				name: "Remove",
				execute: that._doRemove.bind(that)
			}),
			cmdExport = core.createCommand({
				name: "Export",
				execute: that._doExport.bind(that)
			}),
			cmdOpen = core.createCommand({
				name: "Open",
				execute: that._doOpen.bind(that)
			}),
			cmdUploadCancel = core.createCommand({
				name: "UploadCancel",
				execute: that._uploadCancel.bind(that)
			});
		return {
			Remove: cmdRemove,
			Export: cmdExport,
			Open: cmdOpen,
			UploadCancel: cmdUploadCancel
		};
	}

	protected _uploadCancel(): void {
		let that = this;
		if (that._uploadToken) {
			that._uploadToken.abort();
		}
		that.state(peBinary.State.Empty);
	}

	protected _doRemove(): void {
		let that = this,
			value: LobPropValue = that.viewModel[that.viewModelProp]();
		if (value && value.resourceId) {
			that._purgeUploadedFile(value.resourceId);
		}
		that.viewModel[that.viewModelProp](null);
	}

	protected _doExport(): void {
		let that = this,
			url = that._getUrl();

		core.Application.current.dataFacade.ajax(url, {
				fileDownload: true,
				suppressEventOnError: true,
				processEvent: { message: resources["interop.downloading_file"] }
		}).fail((error) => {
			core.Application.current.eventPublisher.publish("interop.error", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.notification,
				priority: "normal",
				severity: "error",
				message: resources["interop.download_error"] + (error.message ? ": " + error.message : ""),
				error: error
			}));
		});
	}

	protected _doOpen(): void {
		window.open(this._getUrl());
	}

	protected _onAdd(data: JQueryFileInputOptions): boolean {
		let that = this;
		if (data.files && data.files.length) {
			// disable auto-validate to prevent validation of intermediate value (pendingUpload)
			that.autoValidate(false);
			// clear uploaded but unused anymore file on server
			let value = that.viewModel[that.viewModelProp]();
			if (value && value.resourceId) {
				that._purgeUploadedFile(value.resourceId);
			}
			let file = data.files[0];
			let res = that._validateFile(file);
			if (!res) {
				that.traceSource.warn("peBinary: ignored chosen file due to filters: " + file.name);
				that._reportFileTypeNotSupported(file.name);
				return false;
			}
			value = that.createPropValue(file);

			that.viewModel[that.viewModelProp](value);
			that._uploadToken = data.submit();
		}
		return true;
	}

	protected createPropValue(file): LobPropValue {
		let fileName = file.name;
		if (!file.name && file.type) {
			// generate a name if it's absent (it can be when file was pasted from clipboard)
			let separator = file.type.indexOf("/");
			if (separator > 0 && separator < file.type.length - 1) {
				fileName = this.viewModelProp + "." + file.type.substring(separator + 1);
			}
		}
		return new LobPropValue({
			size: file.size,
			fileName: fileName,
			pendingUpload: true,
			mimeType: file.type
		});
	}

	protected _updateThumbnailImage(): void {
		let that = this,
			options = that.options;

		that.imgThumbnail = that.element.find(".x-pe-binary-thumbnail");
		if (that.imgThumbnail.length === 0) { return; }

		let url = that._getUrl({ width: options.thumbnailWidth, height: options.thumbnailHeight });

		if (options.thumbnailWidth || options.thumbnailHeight) {
			let styleMap: any = {};
			options.thumbnailWidth && (styleMap.maxWidth = options.thumbnailWidth + "px");
			options.thumbnailHeight && (styleMap.maxHeight = options.thumbnailHeight + "px");
			that.imgThumbnail.css(styleMap);
		}
		// TODO waiting-анимация
		that.imgThumbnail.attr("src", url);

		that.imgThumbnail.on("load", function (e: JQueryEventObject): void {
			// thumbnail loaded, setup a click handler to open preview dialog
			that.traceSource.debug("peBinary: thumbnail loaded");
			that.imgThumbnail.off();
			that.imgThumbnail.click(function (e: JQueryEventObject): void {
				e.preventDefault();
				that._openPreview();
			});
			that.notifyDOMChanged();
		});
		that.imgThumbnail.on("error", function (e: JQueryEventObject): void {
			that.traceSource.warn("peBinary: thumbnail load error");
			that.imgThumbnail.off();
			// replace thumbnail IMG onto "warning" icon
			if (core.ui.iconProvider) {
				let ico = core.ui.iconProvider.getIcon("warning", { title: resources["peBinary.previewNotAvailable"] });
				that.imgThumbnail.replaceWith(ico);
				that.imgThumbnail = that.element.find(".x-pe-binary-thumbnail-container .x-icon");
				$(that.imgThumbnail).addClass("x-icon-48 x-pe-binary-thumbnail");
			}
			that.notifyDOMChanged();
		});
	}

	protected _purgeUploadedFile(resourceId: string): void {
		let url = this.files.getResourceDeleteUrl(resourceId);
		core.Application.current.dataFacade.ajax({ url: url, type: "POST" }, { suppressProcessEvent: true });
	}

	protected _onUploadSuccess(data: JQueryFileUploadDone): void {
		let that = this;
		let result = data.result;

		if (that._uploadToken) {
			that._uploadToken = undefined;
		}
		// NOTE: state will be changed to 'State.Server' as reaction on changing viewModel's prop (see _onPropChanged)
		if (result && result.resourceId) {
			let value = that.viewModel[that.viewModelProp]();
			value.resourceId = result.resourceId;
			delete value.pendingUpload;
			that.viewModel[that.viewModelProp](value);
		}
		that.autoValidate(that.options.autoValidate);

		// NOTE: as we've changed VM's prop, it'll change the PE's state which in turn will cause rerender,
		// in onReady we'll update thumbnail's url (_updateThumbnailImageUrl), it makes no sense to do it here
	}

	protected _onUploadFail(data: JQueryFileUploadDone): void {
		let that = this,
			error = that.files.handleUploadError(data.jqXHR, data.textStatus, data.errorThrown);

		if (that._uploadToken) {
			that._uploadToken = undefined;
		}
		that.autoValidate(that.options.autoValidate);
		that.state(peBinary.State.Fail);
		that.lastError(error.message);
		that.viewModel[that.viewModelProp](null);
	}

	protected _onUploadProgress(data: JQueryFileUploadProgressAllObject): void {
		let that = this,
			progress = Math.round(data.loaded / data.total * 100),
			$bar = that.element.find(".progress-bar");

		$bar.css("width", progress + "%");
		if (progress >= 100) {
			$bar.text(resources["peBinary.processing"]);
		} else {
			$bar.text(resources["peBinary.uploading"] + " - " + progress + "%");
		}
	}

	protected _onDisabledChange(disabled: boolean): void {
		this._invalidateCommands();
	}

	protected _disableUploadInput(disabled: boolean): void {
		let that = this;
		// чтобы было видно
		if (that.inputButton) { that.inputButton.toggleClass("disabled", disabled); }
		// чтобы не реагировало
		if (that.inputElement) { that.inputElement.prop("disabled", disabled); }
	}

	queryUnload(options?: Part.CloseOptions): string {
		if (this.isUploading()) {
			return "Uploading is in progress";
		}
	}

	unload(): void {
		if (this.isUploading()) {
			this._uploadCancel();
		}
		super.unload();
	}
}
namespace peBinary {
	export interface Options extends PropertyEditor.Options {
		template?: HandlebarsTemplateDelegate;
		contentType?: string;
		uploadChunkSize?: number;
		uploadUrl?: string;
		thumbnailWidth?: number;
		thumbnailHeight?: number;
		menu?: Menu.Options;
		commands?: lang.Map<core.commands.ICommand|core.commands.ICommandFactory>;
		imgPreviewSettings?: {
			imgError?: string
		};
		/**
		 * file extensions list (e.g. ".jpg,.png,.doc"), A valid MIME type with no extensions, "audio/*", "video/*", "image/*"
		 * */
		acceptFileTypes?: string;
		/**
		 * Text for placeholder, by default resource "peBinary.placeholder" is used
		 */
		placeholder?: string;
		/**
		 * true - show always / false - show never / "empty" - show for empty
		 */
		showPlaceholder?: boolean | "empty";
		/**
		 * Module options, usually they are taken from `core.files`.
		 */
		files?: core.files.Module;
	}

	export interface KnownCommands extends lang.Map<Command> {
		Remove?: Command;
		Export?: Command;
		Open?: Command;
		UploadCancel?: Command;
	}

	export const State = {
		Unknown: "unknown" as "unknown",
		Empty: "empty" as "empty",
		PropLoading: "propLoading" as "propLoading",
		Uploading: "uploading" as "uploading",
		Server: "server" as "server",
		Fail: "fail" as "fail"
	};
	export type State = (typeof State)[keyof typeof State];
}

// backward compatibility: access to static fields via prototype
peBinary.mixin(/** @lends peNumber.prototype */{
	defaultOptions: peBinary.defaultOptions
});

core.ui.peBinary = peBinary;

core.ui.PropertyEditor.DefaultMapping.register(() => {
	return core.ui.peBinary;
}, { vt: "binary", priority: 20 });

export = peBinary;
