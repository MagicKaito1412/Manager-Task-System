import $ = require("jquery");
import core = require("core");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import InputSpinner = require("lib/ui/pe/InputSpinner");
import Menu = require("lib/ui/menu/Menu");
import binding = require("lib/binding");
import resources = require("i18n!lib/nls/resources");
import moment = require("moment");
import utils = require("lib/utils");
import "vendor/jquery.numeric";
import "xcss!lib/ui/styles/peTimeSpan.css";

import lang = core.lang;

interface InputValue {
	part: string;
	val: string;
}

class peTimeSpan extends PropertyEditor {
	static defaultOptions: peTimeSpan.Options = {
		format: "dhm",
		max: 1000,
		zeroIsEmpty: undefined
	};

	static contextDefaultOptions: lang.Map<peTimeSpan.Options> = {
		filter: {
			zeroIsEmpty: true
		}
	};

	static defaultMenu: lang.Map<Menu.Options> = {
		items: [
			{ name: "Clear", title: resources["clear"], icon: "clear" }
		]
	};

	/**
	 * Object stores date part letter as key and the jQ-input as value
	 */
	private _inputs: lang.Map<JQuery>;

	private static _fullFormat: string = "yMdhms";

	options: peTimeSpan.Options;
	format: string[];
	commands: lang.Map<core.commands.ICommand>;
	menu: Menu;
	menuPresenter: core.ui.IPart;

	/**
	 * isEmpty. By default it's description of the property
	 * @observable-property {boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isEmpty: lang.ObservableProperty<boolean>;

	/**
	 * @constructs peTimeSpan
	 * @extends PropertyEditor
	 * @param {Object} options
	 */
	constructor(options: peTimeSpan.Options){
		options = peTimeSpan.mixContextOptions(options,
			peTimeSpan.defaultOptions,
			peTimeSpan.contextDefaultOptions
		);
		super(options);
		this.format = this._simplifyFormat(this.options.format);
		this.commands = this.createCommands();
		this.menu = this.createMenu();
		if (this.menu) {
			this.menu.bindToPart(this);
		}
	}

	createMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(peTimeSpan.defaultMenu, "peTimeSpan");
	}

	createMenu(): Menu {
		return new Menu(this.createMenuDefaults(), this.options.menu);
	}

	/**
	 * @protected
	 * @returns {Object.<string, Command>}
	 */
	createCommands(): lang.Map<core.commands.ICommand> {
		let that = this,
			commands: any = {};
		if (that.options.nullable) {
			commands.Clear = new core.commands.BoundCommand(that._doClear, that._canClear, that);
		}
		return lang.extend(commands, that.options.commands);
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;

		that.element = $("<div></div>").appendTo(domElement).addClass("x-pe-timespan");

		that._renderValueContainer();
		that._makeInputsNumeric();
		that._setInputHandlers();
		that._bindValue();
		that._bindToDisabled();

		super.doRender(domElement);
	}

	protected _renderValueContainer(): void {
		let that = this,
			$element = that.element,
			$container = $("<div></div>").appendTo($element).addClass("value-container input-group");

		that._inputs = {};
		for (let formatPart of that.format) {
			that._inputs[formatPart] =
				that._addInput(
					$container,
					formatPart,
					resources["timeSpan." + formatPart]
				);
		}

		if (!that.menu.isEmpty()){
			that._renderCustomMenu($container);
		}
	}

	protected _renderCustomMenu(container: JQuery): void {
		let that = this,
			btnContainer = $("<div class='input-group-btn' />").appendTo(container);

		that.menuPresenter = core.ui.MenuButtonsPresenter.create({
			ungrouped: true,
			inline: true,
			itemPresentation: "icon"
		});
		that.menuPresenter.setViewModel(that.menu);
		that.menuPresenter.render(btnContainer);
	}

	protected _makeInputsNumeric(): void {
		this.element.find("input.number-box").numeric({ decimal: false, negative: false });
	}

	protected _setInputHandlers(): void {
		let that = this,
			$element = that.element,
			$valueContainer = $element.find(".value-container"),
			inputSpinner = new InputSpinner({
				min: 0,
				max: that.options.max,
				autoCorrect: true
			});

		// recalculate isEmpty state on any input change
		$valueContainer.find(".number-box").bind("change", () => {
			that._updateIsEmpty();
		});

		$valueContainer.find("input.number-box").focus((e: JQueryEventObject) => {
			inputSpinner.attach(e.target);
		}).blur(() => {
			inputSpinner.detach();
		});

		if (!that.disabled()){
			$valueContainer.find(".time-part-box").click((e: JQueryEventObject) => {
				let id = $(e.target).attr("for"),
					$input = that.element.find("#" + id);

				$input.focus();
			});
		}
	}

	protected _bindValue(): void {
		let that = this,
			$element = that.element,
			bindable: binding.IBindable = {
				get(): number {
					return that._getMilliseconds();
				},
				set(v: number): void {
					that._setMilliseconds(v);
				},
				onchange(handler: (e) => void): lang.IDisposable {
					$element.find(".value-container .number-box").bind("change", handler);
					return {
						dispose(): void {
							$element.find(".value-container .number-box").unbind("change", handler);
						}
					};
				}
			};

		that.databind(bindable);
	}

	protected _onDisabledChange(v: boolean): void {
		let that = this,
			$valueContainer = that.element.find(".value-container");

		lang.forEach(that._inputs, $input => {
			$input.prop("disabled", v);
		});
		if (v) {
			$valueContainer.addClass("disabled");
		} else {
			$valueContainer.removeClass("disabled");
		}
	}

	// protected _switchNext(editedId): void {
	// 	let that = this,
	// 		prop,
	// 		inputs = [],
	// 		current,
	// 		idx = -1;
	//
	// 	if (!editedId) return;
	//
	// 	for (prop in that._inputs) {
	// 		if (that._inputs.hasOwnProperty(prop)) {
	// 			current = that._inputs[prop];
	// 			inputs.push(current);
	//
	// 			if (current.attr("id") === editedId) {
	// 				idx = inputs.length - 1;
	// 			}
	// 		}
	// 	}
	// 	if (idx < 0) {
	// 		return; // something goes wrong
	// 	}
	//
	// 	idx++;
	//
	// 	if (idx < inputs.length){
	// 		inputs[idx].focus();
	// 	}
	// 	// focus should go further
	// }

	protected _getInputValues(): InputValue[] {
		let that = this,
			prop,
			inputs = that._inputs,
			values: InputValue[] = [];

		for (prop in inputs) {
			if (inputs.hasOwnProperty(prop)){
				values.push({
					part: prop,
					val: inputs[prop].val()
				});
			}
		}

		return values;
	}


	protected _updateIsEmpty(): void {
		let inputValues = this._getInputValues();
		let zeroIsEmpty = this.options.zeroIsEmpty;
		let isEmpty = lang.every(inputValues,
			(item: InputValue) => item.val === null || item.val === "" || (zeroIsEmpty && item.val === "0"));
		this.isEmpty(isEmpty);
	}

	protected _setMilliseconds(milliseconds: number): void {
		let that = this,
			parsed = utils.splitDuration(milliseconds, that.format);
		if (!parsed){
			that._doClear();
			return;
		}

		let $inputs = that._inputs;
		for (let unit in parsed) {
			if (parsed.hasOwnProperty(unit)){
				$inputs[unit].val(parsed[unit]);
			}
		}

		that._updateIsEmpty();
	}

	protected _getMilliseconds(): number {
		let that = this,
			i,
			values = that._getInputValues();

		if (that.isEmpty()) { return null; }

		let dt = moment("1900-01-01");
		for (i = 0; i < values.length; i++) {
			let val = values[i].val;
			let nVal = val === "" ? 0 : Math.abs(parseInt(val, 10));
			if (isNaN(nVal)) {
				return null;
			}
			if (nVal  > 0) {
				dt.add(nVal, <moment.unitOfTime.DurationConstructor>values[i].part);
			}
		}
		// return is difference between 1900-01-01 and a new date created as 1900-01-01 + Interval
		return dt.diff(moment("1900-01-01"));
	}

	protected _canClear(): boolean {
		return !this.disabled() && !this.isEmpty();
	}

	protected _doClear(): void {
		let prop,
			inputs = this._inputs,
			first;

		for (prop in inputs) {
			if (inputs.hasOwnProperty(prop)){
				inputs[prop].val(null);

				if (!first) {
					first = inputs[prop];
				}
			}
		}
		first.trigger("change");
	}

	protected _addInput($container: JQuery, id: string, label: string): JQuery {
		let fullId = this.viewModel.id + "_" + this.viewModelProp + "_" + id,
			$input = $("<input>", {
				id: fullId,
				type: "text"
			}).appendTo($container).addClass("number-box form-control");
		$("<label for='" + fullId +  "'>" + label + "</label>").appendTo($container).addClass("time-part-box input-group-addon");

		return $input;
	}

	protected _simplifyFormat(format: string): string[] {
		format = format || peTimeSpan.defaultOptions.format;
		return peTimeSpan._fullFormat.split("").filter((part) => {
			return format.indexOf(part) !== -1;
		});
	}
}

namespace peTimeSpan {
	export interface Options extends PropertyEditor.Options {
		menu?: Menu.Options;
		commands?: lang.Map<core.commands.ICommand|core.commands.ICommandFactory>;
		/**
		 * String with shorthand for duration parts, see http://momentjs.com/docs/#/manipulating/add/
		 * By default: dhm (days, hours, minutes)
		 */
		format?: string;
		max?: number;
		zeroIsEmpty?: boolean;
	}
}

// backward compatibility: access to static fields via prototype
peTimeSpan.mixin(/** @lends peTimeSpan.prototype */{
	defaultOptions: peTimeSpan.defaultOptions,
	defaultMenu: peTimeSpan.defaultMenu,
	contextDefaultOptions: peTimeSpan.contextDefaultOptions
});

core.ui.peTimeSpan = peTimeSpan;
PropertyEditor.DefaultMapping["timeSpan"] = peTimeSpan;

export = peTimeSpan;
