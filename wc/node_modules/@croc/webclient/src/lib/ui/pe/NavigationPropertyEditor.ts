import core = require("core");
import peObjectBase = require("lib/ui/pe/peObjectBase");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;
import ui = require("lib/ui/.ui");
import domain = require("lib/domain/.domain");
import ObjectSelector = require("../list/ObjectSelector");
import IPart = ui.IPart;
import DomainObject = domain.DomainObject;
import PartCommandOptions = PartCommandMixin.PartCommandOptions;
import PartCommandResult = PartCommandMixin.PartCommandResult;
import ICommand = core.commands.ICommand;
import PropertyMeta = domain.metadata.PropertyMeta;
import EntityMeta = domain.metadata.EntityMeta;
import Promise = core.lang.Promise;
import EditorCommandOptions = PartCommandMixin.EditorCommandOptions;
import EditorCommandResult = PartCommandMixin.EditorCommandResult;
import SelectorCommandOptions = PartCommandMixin.SelectorCommandOptions;
import SelectorCommandResult = PartCommandMixin.SelectorCommandResult;

abstract class NavigationPropertyEditor extends peObjectBase /*implements PartCommandMixin*/ {
	static defaultOptions: NavigationPropertyEditor.Options = {
		commandsOptions: {
			/**
			 * Options for 'Select' command - select object(s) into current property
			 * @type {Object|Function}
			 */
			Select: {
				/**
				 * Part name of selector (by default "ObjectSelector:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of selector (see `ObjectSelector.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {
					entityType: undefined,
					hasCheckboxes: undefined,
					filter: undefined,
					loadParams: undefined,
					presenterOptions: {}
				},
				/**
				 * true - opening ObjectSelector in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 */
				openInDialog: undefined
			},
			/**
			 * Options for 'Create' command
			 * @type {Object|Function}
			 */
			Create: {
				/**
				 * Part name of editor (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				name: undefined,
				/**
				 * Part options of editor (see `ObjectEditor.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening editor in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 */
				openInDialog: undefined
			},
			/**
			 * Options for 'Edit' command
			 * @type {Object|Function}
			 */
			Edit: {
				/**
				 * Part name of editor (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of editor (see `ObjectSEditor.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening editor in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 */
				openInDialog: undefined,
				navigateSiblings: true
			},
			/**
			 * Options for 'View' command
			 * @type {Object|Function}
			 */
			View: {
				/**
				 * Part name of viewer (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of viewer (see `ObjectViewer.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening viewer in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 * */
				openInDialog: undefined
			}
		}
	};

	/**
	 * Default options by context
	 */
	static contextDefaultOptions: lang.Map<NavigationPropertyEditor.Options> = {
		filter: {
			commandsOptions: {
				Select: {
					openInDialog: true
				}
			}
		},
		inline: {
			commandsOptions: {
				Select: {
					openInDialog: true
				},
				Edit: {
					openInDialog: true
				},
				View: {
					openInDialog: true
				},
				Create: {
					openInDialog: true
				}
			}
		}
	};

	options: NavigationPropertyEditor.Options;
	viewModel: DomainObject;
	valueObjectEntityType: EntityMeta;

	private _oppositeCanUnlink: boolean;

	/**
	 * @description Base class for navigation property editors.
	 * @constructs NavigationPropertyEditor
	 * @extends peObjectBase
	 */
	constructor(options?: NavigationPropertyEditor.Options) {
		options = NavigationPropertyEditor.mixContextOptions(options,
			NavigationPropertyEditor.defaultOptions,
			NavigationPropertyEditor.contextDefaultOptions
		);

		super(options);

		// операции unlink не может быть у свойства, для которых обратное свойство - скалярное ненулабельное
		let opposite = this.options.opposite;
		this._oppositeCanUnlink = !(opposite && !opposite.many && !opposite.nullable);

		this.subscribeOnNavigation();
	}

	setViewModel(viewModel: DomainObject): void {
		super.setViewModel(viewModel);
		let that = this;
		if (that.viewModel) {
			let ref = that.options.ref;
			if (!ref && that.viewModel.meta) {
				let propMeta = that.viewModel.meta.props[that.viewModelProp];
				ref = propMeta && <EntityMeta>propMeta.ref;
			}
			if (core.lang.isString(ref)) {
				if (!that.viewModel.meta) {
					throw new Error(`NavigationPropertyEditor.setViewModel: ref ('${ref}') is string but viewModel has no meta`);
				}
				that.valueObjectEntityType = that.viewModel.meta.model.entities[ref];
			} else {
				that.valueObjectEntityType = ref;
			}
		}
	}

	/**
	 * Create commands
	 * @protected
	 * @returns {Object.<string, BoundCommand>}
	 */
	protected createCommands(): lang.Map<ICommand> {
		var that = this,
			commands: any = {};

		// readOnly PE has View operation only
		if (that.options.readOnly) {
			commands.View = new core.commands.BoundCommand(that.doView, that.canView, that);
			return commands;
		}

		if (that.options.flavor !== "reference") { // "aggregation" or undefined
			commands.Create = new core.commands.BoundCommand(that.doCreate, that.canCreate, that);
			commands.Edit = new core.commands.BoundCommand(that.doEdit, that.canEdit, that);
			commands.Delete = new core.commands.BoundCommand(that.doDelete, that.canDelete, that);
		}
		if (that.options.flavor !== "aggregation") { // "reference" or undefined
			commands.Select = new core.commands.BoundCommand(that.doSelect, that.canSelect, that);
			commands.Unlink = new core.commands.BoundCommand(that.doUnlink, that.canUnlink, that);
		}
		return commands;
	}

	private _createNestedEditorContext() {
		return {
			parentObject: this.viewModel,
			// NOTE: for non-domain properties we use `options` as metadata
			parentProp: this.viewModel.meta.props[this.viewModelProp] || this.options,
			nested: true
		};
	}

	protected doEdit(args: EditorCommandOptions): Promise<EditorCommandResult> {
		var that = this,
			obj = that.currentValue();

		return that.executePartCommand({
			part: "ObjectEditor:" + obj.meta.name,
			partOptions: {
				viewModel: obj,
				editorContext: that._createNestedEditorContext()
			}
		}, args, "Edit").closed;
	}
	protected canEdit(): boolean {
		return !this.disabled() && !!this.currentValue();
	}
	protected onBeforeEdit(editOptions: EditorCommandOptions): void {
	}
	protected onAfterEdit(result: EditorCommandResult, editOptions: EditorCommandOptions): void {
		if (result && result.success) {
			this.runValidationAsync({ reason: "auto" });
		}
	}

	protected doView(args: EditorCommandOptions): Promise<EditorCommandResult> {
		var that = this,
			obj = that.currentValue();

		return that.executePartCommand({
			part: "ObjectViewer:" + obj.meta.name,
			partOptions: {
				viewModel: obj,
				editorContext: that._createNestedEditorContext()
			}
		}, args, "View").closed;
	}
	protected canView(): boolean {
		return !this.disabled() && !!this.currentValue();
	}
	protected onBeforeView(viewOptions: EditorCommandOptions): void {
	}
	protected onAfterView(result: EditorCommandResult, viewOptions: EditorCommandOptions): void {
	}

	protected doCreate(args: EditorCommandOptions): Promise<EditorCommandResult> {
		let that = this;
		return that.executePartCommand({
			part: "ObjectEditor:" + that.valueObjectEntityType.name,
			partOptions: {
				uow: that.viewModel.uow,
				type: that.valueObjectEntityType.name,
				editorContext: that._createNestedEditorContext(),
				onInitializing: (editor) => {
					// add created object to the property
					that._addObject(editor.viewModel);
				}
			}
		}, args, "Create").closed;
	}
	protected canCreate(): boolean {
		return !this.disabled();
	}
	protected onBeforeCreate(createOptions: EditorCommandOptions): void {
	}
	protected onAfterCreate(result: EditorCommandResult, createOptions: EditorCommandOptions): void {
		if (result && result.success) {
			this.runValidationAsync({ reason: "auto" });
		}
	}

	/**
	 * @abstract
	 */
	protected abstract _addObject(obj: DomainObject): void;

	/**
	 * Handles Select command's result.
	 * @param {Object} result
	 * @param {Array} result.selection
	 * @protected
	 */
	protected _onSelectedValues(result: SelectorCommandResult): void {
		var that = this,
			uow = that.viewModel.uow;
		if (result && result.selection && result.selection.length) {
			result.selection = result.selection.map(function (obj) {
				if (obj.uow !== uow) {
					// если возвращенный объект из другой uow, то добавим его в текущую UoW только в том
					// случае, если там нет такого объекта. Иначе могут возникнуть конфликты.
					// TODO: эту проверку можно будет убрать, когда будет реализовано полноценное разрешение
					// подобных конфликтов.
					let localObj = uow.find(obj.meta.name, obj.id);
					if (!localObj) {
						uow.attach(obj, { norollback: true });
					} else {
						obj = localObj;
					}
				}
				that._addObject(obj);
				return obj;
			});

			// NOTE: result.selection contains objects in local UoW now
		}
	}
	/**
	 * @abstract
	 */
	protected abstract _valueIds(): string[];
	/**
	 * Returns array of ids of objects which should not be visible to user.
	 * @returns {Array|*}
	 * @private
	 */
	private _getExcludeIds(): string[] {
		var that = this,
			ids = that._valueIds(),
			deletedIds;

		// filter out deleted unsaved objects
		deletedIds = that.viewModel.uow.all()
			.filter(function (obj) {
				return !obj.isGhost && obj.isRemoved() &&
					((obj.meta.derived ? !!obj.meta.derived[that.valueObjectEntityType.name] : true) ||
					obj.meta.name === that.valueObjectEntityType.name);
			})
			.map(obj => obj.id);

		return deletedIds.concat(ids);
	}

	/**
	 * Open ObjectSelector
	 * @param {Object} [args]
	 * @param {String} [args.partName] objectSelector part name
	 * @param {Object} [args.partOptions] Options for objectSelector (will override options.selectorOptions.partOptions)
	 * @returns {Promise}
	 */
	protected doSelect(args: SelectorCommandOptions): Promise<SelectorCommandResult> {
		let that = this;
		return that.executePartCommand({
			part: "ObjectSelector:" + that.valueObjectEntityType.name,
			partOptions: {
				hasCheckboxes: !!that.options.many,
				entityType: that.valueObjectEntityType.name,
				excludeIds: that._getExcludeIds()
			}
		}, args, "Select").closed;
	}
	protected canSelect(): boolean {
		return !this.disabled();
	}
	protected onBeforeSelect(selectOptions: SelectorCommandOptions): void {
	}
	protected onAfterSelect(result: SelectorCommandResult, selectOptions: SelectorCommandOptions): void {
		this._onSelectedValues(result);
		if (result && result.selection && result.selection.length) {
			this.runValidationAsync({ reason: "auto" });
		}
	}

	/**
	 * Unlink command implementation method - unlink currently selected object.
	 */
	protected abstract doUnlink(): void|Promise<void>;
	protected canUnlink(): boolean {
		return !this.disabled() && !!this.currentValue();
	}

	protected _isOrphan(obj: DomainObject): boolean {
		let oppositeMeta = this.options.opposite,
			hasChanges = oppositeMeta ? obj.hasChangesExcept(oppositeMeta.name) : obj.hasChanges();
		if (hasChanges) {
			let objectRefs = this.viewModel.uow.findRefsTo(obj);
			if (objectRefs.length === 1 && objectRefs[0].object.id === this.viewModel.id) {
				// there're no other references except one from the current object
				return true;
			}
		}
		return false;
	}

	protected abstract doDelete(): void;
	protected canDelete(): boolean {
		return !this.disabled() && !!this.currentValue();
	}

	/**
	 * Returns currently active object.
	 * Must be an observable expression.
	 * @abstract
	 * @returns {DomainObject}
	 */
	abstract currentValue(): DomainObject;
}

interface NavigationPropertyEditor extends PartCommandMixin { }

// mix methods from PartCommandMixin
PartCommandMixin.mixinTo(NavigationPropertyEditor as any);
// override some methods from PartCommandMixin
NavigationPropertyEditor.mixin({
	_createCommandPart(cmdOptions: PartCommandOptions, cmdName: string): IPart {
		let that: NavigationPropertyEditor = this;
		// nested part can change the value of current PE, prevent auto-validating
		// NOTE: we must do this before part creation
		that.autoValidate(false);

		return PartCommandMixin.prototype["_createCommandPart"].apply(that, arguments);
	},
	onNavigated(args: PartCommandMixin.NavigatedArgs): void {
		let that: NavigationPropertyEditor = this;
		// restore auto-validation
		that.autoValidate(that.options.autoValidate);
		that.activate();

		PartCommandMixin.prototype["onNavigated"].apply(that, arguments);
	}
});

NavigationPropertyEditor.mixin({
	defaultOptions: NavigationPropertyEditor.defaultOptions,
	contextDefaultOptions: NavigationPropertyEditor.contextDefaultOptions
});

namespace NavigationPropertyEditor {
	export interface Options extends peObjectBase.Options, PartCommandMixin.Options {
		opposite?: PropertyMeta;
	}
}

core.ui.NavigationPropertyEditor = NavigationPropertyEditor;

export = NavigationPropertyEditor;
