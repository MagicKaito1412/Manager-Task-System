import $ = require("lib/core.jquery");
import core = require("core");
import SlickObjectListDataPresenter = require("lib/ui/slick/SlickObjectListDataPresenter");
import resources = require("i18n!lib/nls/resources");
import "lib/ui/Popup";

import domain = require("lib/domain/.domain");
import list = require("lib/ui/list/.list");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import peEnumBase = require("lib/ui/pe/peEnumBase");
import lang = core.lang;
import ValueType = domain.metadata.ValueType;
import PropertyMeta = domain.metadata.PropertyMeta;
import EnumMeta = domain.metadata.EnumMeta;
import IPart = core.ui.IPart;
import ICommand = core.commands.ICommand;
import IList = list.IList;
import IDomainObjectList = list.IDomainObjectList;
import ObjectListColumn = list.ObjectListColumn;
import SlickGrid = SlickObjectListDataPresenter.SlickGrid;
import GridColumn = SlickObjectListDataPresenter.GridColumn;

abstract class SlickColumnFilterBase extends core.ui.Part {
	/**
	 * @constructs SlickColumnFilterBase
	 * @extends Part
	 * @param options
	 * @param {ObjectListColumn} options.column
	 */
	constructor(options?: SlickColumnFilterBase.Options) {
		options = SlickColumnFilterBase.mixOptions(options, SlickColumnFilterBase.defaultOptions);
		super(options);

		this.column = this.options.column;
	}

	protected tweakOptions(options: SlickColumnFilterBase.Options): void {
		let pe = options.pe;

		// ensure vt is initialized
		if (!pe.vt || pe.vt === "object") {
			pe.vt = "string";
		}

		// column filters are always nullable
		pe.nullable = true;

		// facets (e.g. minLen) should not be applied to column filters, turn validation rules off
		pe.rules = [];

		super.tweakOptions(options);
	}

	options: SlickColumnFilterBase.Options;
	column: ObjectListColumn;

	static defaultOptions: SlickColumnFilterBase.Options = {
		/**
		 * @prototype {Object} pe metadata of inner PE
		 */
		pe: <any>{
			contextName: "inline", // maybe "filter"?
			changeTrigger: "keyPressed"
		}
	};

	// Filter API:
	abstract match(value: any): boolean;
	abstract isEmpty(): boolean;
	abstract clear(): void;
	abstract focus(): void;

	static events = {
		FILTER_CHANGED: "filterChanged"
	};

	@lang.decorators.constant(SlickColumnFilterBase.events)
	events: typeof SlickColumnFilterBase.events;

	protected _triggerFilterChanged(): void {
		this.trigger(this.events.FILTER_CHANGED, this);
	}
	protected _createPE(options: PropertyEditor.Options, viewModel?: any): PropertyEditor {
		options = lang.append(options || {}, this.options.pe);
		return core.ui.PropertyEditor.DefaultMapping.create(options, viewModel || this);
	}
}
namespace SlickColumnFilterBase {
	export interface Options extends core.ui.Part.Options {
		vt?: ValueType;
		pe?: PropertyEditor.Options;
		column?: ObjectListColumn;
	}
}

class SlickColumnFilterValue extends SlickColumnFilterBase{
	/**
	 * @constrcuts SlickColumnFilterValue
	 * @extends SlickColumnFilterBase
	 * @param options
	 */
	constructor(options?: SlickColumnFilterValue.Options) {
		super(options);

		let that = this;
		that.matcher = that.options.matcher || that.defaultMatcher;
		that.bind("change:value", that._triggerFilterChanged, that);
	}

	options: SlickColumnFilterValue.Options;

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	value: lang.ObservableProperty<any>;

	protected pe: PropertyEditor;
	protected matcher: SlickColumnFilterValue.MatchCallback;

	protected defaultMatcher(value: any, filterValue: any): boolean {
		// NOTE: value and filterValue are not empty here
		return value.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) >= 0;
	}

	// Filter API
	match(value: any): boolean {
		let filterValue = this.value();
		if (lang.isNullOrEmpty(filterValue)) { return true; }
		if (lang.isNullOrEmpty(value)) { return false; }

		return this.matcher(value, filterValue);
	}
	isEmpty(): boolean {
		return lang.isNullOrEmpty(this.value());
	}
	clear(): void {
		this.value(null);
	}
	focus(): void {
		let pe = this.pe;
		if (pe) {
			pe.focus();
		}
	}

	// Part API
	protected doRender(domElement: JQuery|HTMLElement): void {
		let that = this;
		super.doRender(domElement);

		let $div = $("<div class='x-pe'></div>").appendTo(domElement);
		that.pe = that._createPE({ name: "value" });
		that.pe.render($div);

		that.registerChild(that.pe, true);
	}
}
namespace SlickColumnFilterValue {
	export interface Options extends SlickColumnFilterBase.Options {
		matcher?: MatchCallback;
	}

	export type MatchCallback = (value: any, filterValue: any) => boolean;
}

class SlickColumnFilterEnum extends SlickColumnFilterValue {
	constructor(options?: SlickColumnFilterValue.Options) {
		super(options);
		let peMd = (this.options.pe as peEnumBase.Options);
		let ref = peMd.ref;
		this.isFlags = lang.coalesce(peMd.flags, ref && ref.flags);
	}

	isFlags: boolean;

	protected defaultMatcher(value: any, filterValue: any): boolean {
		return this.isFlags ? (value & filterValue) === filterValue : value == filterValue;
	}
}

class SlickColumnFilterRange extends SlickColumnFilterBase {
	/**
	 * @constructs SlickColumnFilterRange
	 * @extends SlickColumnFilterBase
	 * @param {Object} options
	 */
	constructor(options?: SlickColumnFilterRange.Options) {
		options = SlickColumnFilterRange.mixOptions(options, SlickColumnFilterRange.defaultOptions);
		super(options);

		let that = this;
		that.commands = that.options.commands;
		that.menu = new core.ui.Menu(that.options.menu);
		that.menu.bindToPart(that);

		that.bind("change:from", that._triggerFilterChanged, that);
		that.bind("change:to",   that._triggerFilterChanged, that);
	}

	options: SlickColumnFilterRange.Options;
	commands: core.commands.ICommandLazyMap;
	menu: core.ui.Menu;
	protected peFrom: PropertyEditor;
	protected peTo: PropertyEditor;

	static defaultOptions: SlickColumnFilterRange.Options = {
		menu: { items: [
			{ name: "Clear", title: resources.clear }
		]},
		commands: {
			Clear(that: SlickColumnFilterRange): ICommand {
				return new core.commands.BoundCommand(
					that.clear, // execute
					() => !that.isEmpty(), // canExecute
					that
				);
			}
		},
		pe: <core.ui.peDateTime.Options> {
			openPickerOn: "both" // for peDateTime only!
		}
	};

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	from: lang.ObservableProperty<any>;

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	to: lang.ObservableProperty<any>;

	// Filter API
	match(value: any): boolean {
		let that = this,
			from = that.from(),
			to = that.to();
		return (lang.isNullOrEmpty(from) || (value != null && from <= value)) &&
			(lang.isNullOrEmpty(to) || (value != null && value <= to));
	}
	isEmpty(): boolean {
		return lang.isNullOrEmpty(this.from()) && lang.isNullOrEmpty(this.to());
	}
	clear(): void {
		this.from(null);
		this.to(null);
	}
	focus(): void {
		let peFrom = this.peFrom;
		if (peFrom) {
			peFrom.focus();
		}
	}

	// Part API
	protected doRender(domElement: JQuery|HTMLElement): void {
		let that = this;
		super.doRender(domElement);

		let $from = $("<div class='x-pe'></div>");
		that.peFrom = that._createPE({ name: "from" });
		that.peFrom.render($from);

		let $to = $("<div class='x-pe'></div>");
		that.peTo = that._createPE({ name: "to" });
		that.peTo.render($to);

		let $menu = $("<div class='x-menu-bar'></div>"),
			menuPresenter = new core.ui.MenuPresenter({ viewModel: that.menu });
		menuPresenter.render($menu);

		that.$domElement.append($from, $to, $menu);

		that.registerChild(that.peFrom, true);
		that.registerChild(that.peTo, true);
		that.registerChild(menuPresenter, true);
	}
}
namespace SlickColumnFilterRange {
	export interface Options extends SlickColumnFilterBase.Options {
		menu?: core.ui.Menu.Options;
		commands?: core.commands.ICommandLazyMap;
	}
}

// Augment ObjectListColumn interface
declare module "lib/ui/list/.list" {
	export interface ObjectListColumn {
		filter?: string | SlickObjectListDataPresenterAddon.ColumnFilterOptions;
	}
}

// See https://github.com/Microsoft/TypeScript/issues/4890
// TODO: вынести в core.lang?
function override<T>(Super: lang.Constructor<T>, ...methods: string[]): lang.Constructor<T> {
	class C extends (Super as lang.Constructor<Object>) {
	}

	for (let name of methods) {
		C.prototype[name] = Super.prototype[name];
	}

	return C as lang.Constructor<T>;
}

const SlickObjectListDataPresenterOverrides = override(SlickObjectListDataPresenter, "setViewModel", "dispose", "onGridInitialized");

class SlickObjectListDataPresenterAddon extends SlickObjectListDataPresenterOverrides {
	@lang.decorators.constant({
		"value": SlickColumnFilterValue,
		"enum": SlickColumnFilterEnum,
		"range": SlickColumnFilterRange
	})
	ColumnFilterClasses: lang.Map<lang.Constructor<SlickColumnFilterBase>>;

	options: SlickObjectListDataPresenterAddon.Options;

	protected columnFilters: lang.Map<SlickColumnFilterBase>;
	protected applied: boolean;

	setViewModel(viewModel: IList): void {
		let that = this;
		super.setViewModel(viewModel);
		that.viewModel.bind("dataLoaded", that._onListDataLoaded, that);
		that.viewModel.selection.bind("change", that._onSelectionChange, that);
	}

	dispose(): void {
		let that = this;
		that.viewModel.unbind("dataLoaded", null, that);
		that.viewModel.selection.unbind("change", null, that);
		if (that.columnFilters) {
			lang.forEach(that.columnFilters, filter => {
				filter.dispose();
			});
			that.columnFilters = undefined;
		}
		super.dispose();
	}

	protected onGridInitialized(args: { grid: SlickGrid }): void {
		let that = this,
			grid = args.grid;

		if (that.options.columnFilters) {
			that.columnFilters = {};

			for (let col of that.viewModel.columns) {
				let filter = that._createColumnFilter(col);
				if (filter) {
					filter.bind("filterChanged", that._applyColumnFiltersAsync, that);
					that.columnFilters[col.prop] = filter;
				}
			}

			grid.onHeaderCellRendered.subscribe(function (e: JQueryEventObject, args: Slick.OnHeaderCellRenderedEventArgs<any>): void {
				let col: ObjectListColumn = (args.column as GridColumn).source,
					filter = col && col.prop && that.columnFilters[col.prop];
				if (filter) {
					$("<span class='slick-column-filter'></span>")
						.click(that._onColumnFilterClick.bind(that, col))
						.appendTo(args.node);
					if (!filter.isEmpty()) {
						$(args.node).addClass("slick-header-column-filtered");
					}
				}
			});

			grid.onBeforeHeaderCellDestroy.subscribe(function (e: JQueryEventObject, args: Slick.OnBeforeHeaderCellDestroyEventArgs<any>): void {
				$(".slick-column-filter", args.node).remove();
			});

			// Force the grid to re-render the header now that the events are hooked up.
			grid.setColumns(grid.getColumns());
		}

		super.onGridInitialized(args);
	}

	protected _createColumnFilter(col: ObjectListColumn): SlickColumnFilterBase {
		if (!col || col.role !== "data" || !col.prop) { return; }

		let that = this,
			filterOpt = col.filter;

		// filter === null || filter === false => no filter
		if (filterOpt !== undefined && !filterOpt) { return; }

		if (lang.isFunction(filterOpt)) {
			return filterOpt.call(that, col);
		}

		// create options for SlickColumnFilterBase
		let options: SlickColumnFilterBase.Options = {
			column: col,
			pe: {}
		};

		// extend by explicitly specified filter options
		lang.extend(options, filterOpt);
		// extend by domain metadata
		let list = that.viewModel as IDomainObjectList;
		if (list.findDomainProp) {
			let prop: PropertyMeta = list.findDomainProp(col);
			lang.append(options.pe, prop);
		}
		// calculate vt
		options.pe.vt = options.pe.vt || options.vt || col.vt;

		// choose SlickColumnFilterBase implementation
		let Ctor: lang.Constructor<SlickColumnFilterBase>;
		if (lang.isString(filterOpt)) {
			Ctor = that.ColumnFilterClasses[filterOpt];
		} else if (filterOpt && filterOpt.name) {
			Ctor = that.ColumnFilterClasses[filterOpt.name];
		}
		if (!Ctor) {
			switch (options.pe.vt) {
				case "dateTime":
				case "date":
				case "time":
				case "dateTimeTz":
				case "timeTz":
				case "ui1":
				case "i2":
				case "i4":
				case "float":
				case "double":
				case "decimal":
					Ctor = SlickColumnFilterRange;
					break;
				case "enum":
					Ctor = SlickColumnFilterEnum;
					break;
				default:
					Ctor = SlickColumnFilterValue;
					break;
			}
		}

		return new Ctor(options);
	}

	protected _calcColumnFilters(item: any): boolean {
		let that = this;
		if (lang.isFunction(item.hasChanges) && item.hasChanges()) {
			return true;
		}
		return lang.every(that.columnFilters, (filter: SlickColumnFilterBase, prop: string) => {
			let col = filter.column,
				getter = col.getter,
				v = getter ? getter.call(item, col) : lang.get(item, prop);
			return filter.match(v);
		});
	}

	protected _applyColumnFilters(): void {
		let that = this;

		// set 'where' condition for items (selection will be auto-updated)
		that.viewModel.items.where(item => that._calcColumnFilters(item));

		// toggle 'slick-header-column-filtered' css class for headers
		if (that.grid && that.gridElement) {
			let $headers = that.gridElement.find(".slick-header-column");
			let appliedSome = false;
			that.grid.getColumns().forEach((col: GridColumn, i) => {
				let prop = col.source && col.source.prop;
				if (prop) {
					let filter = that.columnFilters[prop];
					let applied = !!(filter && !filter.isEmpty());
					if (applied) { appliedSome = true; }
					$headers.eq(i).toggleClass("slick-header-column-filtered", applied);
				}
			});
			that.applied = appliedSome;
		}
	}

	@lang.decorators.constant(lang.debounce(SlickObjectListDataPresenterAddon.prototype._applyColumnFilters, 200, true))
	protected _applyColumnFiltersAsync: () => void;

	protected _onColumnFilterClick(col: ObjectListColumn, e: JQueryEventObject): void {
		e.preventDefault();
		e.stopPropagation();

		let that = this,
			filter = that.columnFilters[col.prop];

		// NOTE: The filter may be still rendered if previous popup is closing with animation at the moment.
		// This can happen on click to the filter icon when popup is already opened.
		if (!filter || filter.domElement) { return; }

		let $target = $(e.target),
			$headerColumn = $target.closest(".slick-header-column", that.gridElement.get(0)),
			$header = $headerColumn.closest(".slick-header", that.gridElement.get(0)),
			$viewport = $(".slick-viewport", that.gridElement),
			popup = new core.ui.Popup({
				rootCssClass: "x-grid-column-filter",
				unbound: true,
				body: filter,
				preserveBody: true
			});

		function close(): void {
			popup.close();
		}
		function reposition(): void {
			let $popup = popup.$domElement,
				offset = $target.offset(),
				position = {
					top: offset.top + $target.height(),
					left: offset.left
				};
			$popup.within(that.gridElement, position);
		}

		popup.bind("ready", () => {
			$headerColumn.addClass("slick-header-column-active");
			$header.on("affixStuck affixUnstuck", reposition);
			$viewport.on("scroll", close);
			core.$window.on("resize", close);
		});
		popup.bind("unload", () => {
			$headerColumn.removeClass("slick-header-column-active");
			$header.off("affixStuck affixUnstuck", reposition);
			$viewport.off("scroll", close);
			core.$window.off("resize", close);
		});

		popup.render(that.gridElement);
		reposition();

		filter.focus();
	}

	protected _onListDataLoaded(): void {
		let that = this,
			filters = that.columnFilters;
		if (filters) {
			lang.forEach(filters, filter => {
				// NOTE: unbind and bind again to prevent applying each filter separately
				filter.unbind("filterChanged", null, that);
				filter.clear();
				filter.bind("filterChanged", that._applyColumnFiltersAsync, that);
			});
			// apply all filters at once
			that._applyColumnFilters();
		}
	}

	protected _onSelectionChange(sender, args: lang.ObservableCollectionChangeArgs<any>): void {
		let that = this;
		let filters = that.columnFilters;
		if (!filters || !that.applied) { return ; }

		// there is at least one applied (active) column filter

		if (args && args.added) {
			for (let item of args.added) {
				if (that.viewModel.items.indexOf(item) < 0) {
					// we've found the object which is in selection but not in items,
					// this means that it's hidden by filters. clear them.
					that._onListDataLoaded();
					return;
				}
			}
		}
	}
}

namespace SlickObjectListDataPresenterAddon {
	export interface Options extends SlickObjectListDataPresenter.Options {
		columnFilters?: boolean;
	}

	export interface ColumnFilterOptions extends SlickColumnFilterBase.Options {
		name?: string; // key in SlickObjectListDataPresenterAddon.ColumnFilterClasses
	}
}

lang.extend(SlickObjectListDataPresenter.prototype, SlickObjectListDataPresenterAddon.prototype);
