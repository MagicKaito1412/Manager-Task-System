import core = require("core");
import Part = require("lib/ui/Part");
import utils = require("lib/utils");

import lang = core.lang;
import ICommand = core.commands.ICommand;
import CommandArgs = core.commands.CommandArgs;
import INavigationService = core.INavigationService;
import IPart = core.ui.IPart;
import PartCommandOptions = PartCommandMixin.PartCommandOptions;
import PartCommandResult = PartCommandMixin.PartCommandResult;

interface InternalOptions extends PartCommandMixin.Options {
	/**
	 * temporary field to save factory functions for commandOptions and partOptions
	 */
	_commandsHandlers?: lang.Map<lang.Factory<any>>;
}

interface PartCommandMixin extends lang.IEventful {
	navigationService: INavigationService;
}

/**
 * @exports PartCommandMixin
 */
abstract class PartCommandMixin implements lang.IEventful {
	options: PartCommandMixin.Options;
	commands: lang.Map<ICommand>;

	private _commandsOptHandlers: lang.Map<lang.Factory<any>>;

	protected _createCommandOptions<T extends PartCommandOptions>(basicOptions: T, args: T, cmdName: string): T {
		let cmdOptions: T = this.getCommandOptions(args, cmdName);

		// mix with basicOptions
		cmdOptions = lang.extendEx(basicOptions, cmdOptions, { deep: true });

		// set other options
		cmdOptions.activateOptions = cmdOptions.activateOptions || {};
		cmdOptions.activateOptions.freezeUrl = lang.coalesce(cmdOptions.activateOptions.freezeUrl, cmdOptions.freezeUrl, this.options.freezeUrl);

		return cmdOptions;
	}

	protected _createCommandPart(cmdOptions: PartCommandOptions, cmdName: string): IPart {
		let partFactory = cmdOptions.part,
			part: IPart;

		// set part options
		cmdOptions.partOptions = cmdOptions.partOptions || {};
		if (lang.isString(partFactory) || lang.isFunction(partFactory)) {
			// partOptions can be a factory
			let partOptionsHandler = this._commandsOptHandlers && this._commandsOptHandlers[cmdName + "PartOptions"];
			if (partOptionsHandler) {
				let partOptions = partOptionsHandler.call(this, cmdOptions);
				// merge it with property restrictions and runtime options from args
				lang.extendEx(cmdOptions.partOptions, partOptions, {deep: true});
			}
		}

		// execute callback
		let onBeforeCallback = this["onBefore" + cmdName];
		if (onBeforeCallback) {
			onBeforeCallback.call(this, cmdOptions);
		}
		partFactory = cmdOptions.part || partFactory;

		// create part
		if (lang.isString(partFactory)) {
			// option `part` can specify a name of the part ...
			part = core.createPart(partFactory, cmdOptions.partOptions);
		} else if (lang.isFunction(partFactory)) {
			// ... or a factory function ...
			part = partFactory.call(this, cmdOptions.partOptions, cmdOptions);
		} else {
			// ... or an instance of the part
			part = partFactory;
		}

		if (!part.navigationService && part.setNavigationService && this.navigationService) {
			part.setNavigationService(this.navigationService);
		}

		return part;
	}

	protected _openCommandPart(part: IPart, cmdOptions: PartCommandOptions, cmdName: string): PartCommandResult {
		cmdName = cmdName || cmdOptions.name;

		this.onNavigating({
			part: part,
			commandOptions: cmdOptions,
			commandName: cmdName
		});

		let originalOnReturn = cmdOptions.onReturn;
		let resultDeferred = core.lang.Deferred(),
			onAfterCallback = this["onAfter" + cmdName],
			onReturn = (result) => {
				if (onAfterCallback) {
					onAfterCallback.call(this, result, cmdOptions);
				}
				let args = {
					result: result,
					commandOptions: cmdOptions,
					commandName: cmdName
				};
				this.onNavigated(args);

				resultDeferred.resolve(result);

				if (originalOnReturn) {
					return originalOnReturn(result);
				}
			};

		let navigatePromise: core.lang.Promise<IPart>;
		cmdOptions.part = part;
		cmdOptions.onReturn = onReturn;
		navigatePromise = this.navigationService.navigate(<core.INavigationService.NavigateOptions>cmdOptions);
		return {
			part: part,
			opened: navigatePromise,
			closed: resultDeferred.promise()
		};
	}

	protected getCommandOptions<T>(args: T, cmdName?: string): T {
		args = args || <T>{};
		cmdName = cmdName || (<CommandArgs>args).name;
		let that = this,
			handler: lang.Factory<T> = cmdName && that._commandsOptHandlers && that._commandsOptHandlers[cmdName],
			cmdOptions: T;

		// 1. if options.commandsOptions[cmdName] - function then call it, else use it.
		if (handler) {
			cmdOptions = handler.call(that, args);
		}

		// 2. mix with default
		cmdOptions = lang.appendEx(args, cmdOptions, { deep: true });

		// NOTE: args.partOptions может быть функцией

		if (that.options && that.options.commandsOptions && cmdName) {
			cmdOptions = lang.appendEx(cmdOptions, that.options.commandsOptions[cmdName], { deep: true });
		}

		return cmdOptions;
	}

	/**
	 * Create full command arguments, create a part for it and navigate to the part.
	 * @param {Object} basicOptions Default arguments for the command.
	 * @param {Object} args Runtime command arguments.
	 * @param {String} cmdName Command name ("Create", "Edit", so on).
	 * @returns {*}
	 */
	executePartCommand(basicOptions: PartCommandOptions, args: PartCommandOptions, cmdName: string): PartCommandResult {
		cmdName = cmdName || (args && args.name);

		let cmdOptions = this._createCommandOptions(basicOptions, args, cmdName), // runtime options
			// we can have options for part creation or whole part factory
			part = this._createCommandPart(cmdOptions, cmdName);

		return this._openCommandPart(part, cmdOptions, cmdName);
	}

	static mixOptions<T extends PartCommandMixin.Options>(options: T, defaultOptions: T): T;
	static mixOptions<T extends InternalOptions>(options: T, defaultOptions: T): T {
		// save factory functions for commandOptions and partOptions in special field _commandsHandlers inside options object
		// NOTE: we'll remove it later in tweakOptions
		if (defaultOptions && defaultOptions.commandsOptions && options && !options._commandsHandlers) {
			// the part supports commands with options
			options._commandsHandlers = {};
			lang.forEach(options.commandsOptions, function (cmdOptions, cmdName) {
				if (lang.isFunction(cmdOptions)) {
					options._commandsHandlers[cmdName] = cmdOptions;
					options.commandsOptions[cmdName] = undefined;
				} else if (cmdOptions && lang.isFunction(cmdOptions.partOptions)) {
					options._commandsHandlers[cmdName + "PartOptions"] = cmdOptions.partOptions;
					cmdOptions.partOptions = undefined;
				}
			});
		}
		return Part.mixOptions(options, defaultOptions);
	}

	/**
	 * Called before opening a nested part
	 */
	protected onNavigating(args: PartCommandMixin.NavigatingArgs): void {
		this.trigger("navigating", this, args);
	}
	/**
	 * Called after closing a nested part
	 */
	protected onNavigated(args: PartCommandMixin.NavigatedArgs): void {
		this.trigger("navigated", this, args);
	}

	/**
	 * Subscribes methods `onNavigating/onNavigated` in options on events `navigating/navigated`
	 */
	protected subscribeOnNavigation(/*this: lang.Observable*/): void {
		utils.subscribeOnEvents(this, this.options, [ "navigating", "navigated" ]);
	}

	/**
	 * Mixins all required methods from PartCommandMixin to target class
	 * @param targetClass
	 */
	static mixinTo(targetClass: typeof Part): void {
		// mixin all instance members
		targetClass.mixin(PartCommandMixin);
		// mixin static method `mixOptions`
		targetClass.mixOptions = PartCommandMixin.mixOptions;

		// override `tweakOptions`
		// NOTE: Should NOT declare `tweakOptions` inside `PartCommandMixin.prototype`.
		// It calls `super` method, but inside prototype `super` is a `Part`. But it should call a method of base class
		// for `targetClass`. So override `tweakOptions` here.
		lang.override(targetClass.prototype, {
			tweakOptions: function(base, options: InternalOptions) {
				if (options._commandsHandlers) {
					// clear options after executing mixOptions: move options._commandsHandlers to this._commandsOptHandlers
					this._commandsOptHandlers = options._commandsHandlers;
					delete options._commandsHandlers;
				}
				base.call(this, options);
			}
		});
	}
}

declare namespace PartCommandMixin {
	import ObjectEditor = core.ui.ObjectEditor;
	import ObjectSelector = core.ui.ObjectSelector;

	export type IPartFactory = (partOptions: any, commandOptions?: PartCommandOptions) => IPart;

	export interface PartCommandOptions /*extends core.INavigationService.NavigateOptions*/ {
		/**
		 * Name of command
		 */
		name?: string;
		/**
		 * Part name or instance to activate
		 */
		part?: IPart|IPartFactory|string;
		/**
		 * Part's options if `part` is string. The object will be passed into part's constructor.
		 */
		partOptions?: any;
		/**
		 * Optional callback to be call on returning back
		 * @param result
		 */
		onReturn?: (result: any) => void;
		/**
		 * @deprecated Use activateOptions.freezeUrl instead
		 */
		freezeUrl?: boolean;
		openInDialog?: boolean;
		/**
		 * Options for Region.activatePart
		 */
		activateOptions?: core.PartActivateOptions;
		/**
		 * Options for the constructor of Dialog
		 */
		dialogOptions?: any;
	}

	/**
	 * Common options for commands which opens an ObjectEditor
	 */
	export interface EditorCommandOptions extends PartCommandOptions {
		partOptions?: ObjectEditor.Options;
		navigateSiblings?: boolean;
	}
	export import EditorCommandResult = ObjectEditor.Result;

	/**
	 * Common options for commands which opens an ObjectSelector
	 */
	export interface SelectorCommandOptions extends PartCommandOptions {
		partOptions?: ObjectSelector.Options;
	}
	export import SelectorCommandResult = ObjectSelector.Result;

	/**
	 * @deprecated Use EditorCommandOptions instead
	 */
	export type NavigationOptions = EditorCommandOptions;
	/**
	 * @deprecated Use EditorCommandResult instead
	 */
	export type NavigationResult = EditorCommandResult;

	export interface Options extends Part.Options {
		freezeUrl?: boolean;
		commandsOptions?: lang.Map<any|lang.Factory<any>>;
		commands?: core.commands.ICommandLazyMap;

		onNavigating?(sender: IPart, args: NavigatingArgs): void;
		onNavigated?(sender: IPart, args: NavigatedArgs): void;
	}

	export interface NavigatingArgs {
		part: IPart;
		commandOptions: PartCommandOptions;
		commandName: string;
	}

	export interface NavigatedArgs {
		result: any;
		commandOptions: PartCommandOptions;
		commandName: string;
	}

	export interface PartCommandResult {
		part: IPart;
		opened: core.lang.Promise<IPart>;
		closed: core.lang.Promise<any>;
	}
}

export = PartCommandMixin;

