import $ = require("lib/core.jquery");
import lang = require("lib/core.lang");
import binding = require("lib/binding");
import diagnostics = require("lib/core.diagnostics");
import utils = require("lib/utils");
import Handlebars = require("handlebars-ext");
import Part = require("lib/ui/Part");
import StatefulPart = require("lib/ui/StatefulPart");
import formatters = require("lib/formatters");
import waitingTemplate = require("xhtmpl!lib/ui/templates/WaitingModal.hbs");
import resources = require("i18n!lib/nls/resources");

import { IPart, PartCloseOptions } from "lib/ui/.ui";
import RegisterChildOptions = Part.RegisterChildOptions;
import HBTemplate = Handlebars.Template;
import HBHelperOptions = Handlebars.HelperOptions;
import HelperOptions = View.HelperOptions;
import HelperTarget = View.HelperTarget;
import { IObservableCollection } from "lib/core.lang";

type IPartFactory = () => IPart;
type HelperData =  {
	view: View;
	callbacks: { func: Function; args: any[]; }[];
	context: any;
	index?: number;
};

interface ViewTemplate extends HBTemplate {
	isLoading?: boolean;
	dispose?(): void;
}

// NOTE: define global object HBX which is used by generated code (by Handlebars.JavaScriptCompiler)
// The extension contains 'get' method which is being used inside Handlebars.JavaScriptCompiler.prototype.nameLookup,
// which in turn was extended by our xhtmpl rjs-plugin.
// The 'get' method is being used for generating 'get' event on every property access.
window["HBX"] = window["HBX"] || {
	get: lang.Observable.get
};


class View extends StatefulPart {
	static defaultOptions: View.Options = {
		/**
		 * Handlebars template to render the view. Usually you should load template via xhtml RequireJS-plugin
		 * @type {Function}
		 */
		template: undefined,
		/**
		 * Handlebars template to render an error. Usually you should load template via xhtml RequireJS-plugin
		 * @type {Function}
		 */
		errorTemplate: function (error) { return "<span class='label label-danger'>" + error + "</span>"; },
		waitingTemplate: waitingTemplate,
		showWaitingAnimation: false,
		/**
		 * Whether View should be bound to its viewModel changes or not. By default it's bound.
		 * That means that View will rerender on every viewModel change.
		 * @type {Boolean}
		 */
		unbound: false,
		/**
		 * ViewModel.
		 * @type {*}
		 */
		viewModel: undefined
	};

	// prototype members: begin
	traceSource: diagnostics.TraceSource;
	loadingValue: any;
	// prototype members: end

	options: View.Options;
	unbound: boolean;
	suppressAutoLoad: boolean;
	template: ViewTemplate;

	private _isLoading: number;
	private _renderContext: any;

	/**
	 * @constructs View
	 * @extends StatefulPart
	 * @param {View.defaultOptions} options View options
	 */
	constructor(options?: View.Options) {
		options = View.mixOptions(options, View.defaultOptions);
		super(options);

		let that = this;
		that.unbound = that.options.unbound;
		that.suppressAutoLoad = that.options.suppressAutoLoad;

		that._isLoading = 0; // init loading counter

		if (that.options.template) {
			that.setTemplate(that.options.template);
		}
		if (that.options.viewModel) {
			that.setViewModel(that.options.viewModel);
		}
	}

	/**
	 * Indicates that something is loading at the moment.
	 * If the method is invoked without any arguments, it returns true if the internal loading counter is greater than zero.
	 * If the method is invoked with an argument, it increase (an argument is true) or decrease (an argument is false)
	 * the internal loading counter.
	 * @param {Boolean} [v]
	 * @returns {Boolean}
	 */
	isLoading(v?: boolean): boolean {
		let that = this,
			name = "isLoading",
			n: number,
			old: number,
			args: lang.ObservableChangeArgs;

		if (!arguments.length) {
			n = that._isLoading;
			that.trigger("get", that, { prop: name, value: !!n });
			return !!n;
		} else {
			old = that._isLoading;
			if (v) {
				n = old + 1;
			} else {
				n = old - 1;
			}

			if (n < 0) {
				console.error("isLoading counter is less than zero: " + v);
			}

			that._isLoading = n;

			args = { prop: name, value: !!n, oldValue: !!old };
			if (!!n != !!old) {
				that.trigger("change:" + name, that, !!n, !!old);
				that.trigger("change", that, args);
			}
			that.trigger("set", that, args);

			return !!n;
		}
	}

	setViewModel(viewModel): void {
		let that = this,
			oldModel = that.viewModel;
		that.viewModel = viewModel;
		if (that.domElement && oldModel && oldModel !== viewModel) {
			that.rerender();
		}
	}

	setTemplate(template: HBTemplate|string): void {
		let that = this,
			expr: lang.support.ObservableExpressionBase;
		template = that.prepareTemplate(template);
		if (that.options.unbound) {
			that.template = <HBTemplate>template;
		} else {
			expr = lang.support.ObservableExpression.create(<HBTemplate>template, {
				onchange: lang.debounce(that.onTemplateChange.bind(that)),
				loadingValue: that.loadingValue,
				suppressAutoLoad: that.suppressAutoLoad
			});
			that.template = function () {
				let result = expr.evaluate(this, arguments);
				that.onTemplateReturn(result);
				return result;
			};
			that.template.dispose = function () {
				expr.dispose();
			};
		}
	}

	/**
	 *
	 * @param {Function|String} template
	 * @returns {Function}
	 */
	private prepareTemplate(template: HBTemplate|string): HBTemplate {
		let that = this;
		template = View.compileTemplate(template);
		return that.options.unbound ?
			<HBTemplate>template :
			function () {
				// NOTE: call 'isLoading' to observe changing of this property in the template
				this.isLoading();
				return (<HBTemplate>template).apply(this, arguments);
			};
	}

	/**
	 * Called when the observable template is changed.
	 */
	private onTemplateChange(): void {
		let that = this;
		// rerender if View isn't rendered yet and isn't disposed
		if (that.domElement && that.template) {
			that.rerender();
		}
	}

	/**
	 * Called when the observable template returns.
	 * @param {*} result
	 */
	private onTemplateReturn(result: any): void {
		let that = this;
		// NOTE: it isn't enough to call 'isLoading(callCtx.isLoading)',
		// because isLoading can be set by external code

		if (result === that.loadingValue) {
			if (!that.template.isLoading) {
				// set special flag indicating that loading was initiated by the template (not by external code)
				that.template.isLoading = true;
				that.isLoading(true);
			}
		} else {
			if (that.template.isLoading) {
				// decrease isLoading counter if loading was initiated by the template only (not by external code)
				that.isLoading(false);
				that.template.isLoading = undefined;
			}
		}
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		//var profile = Date.now();
		super.doRender(domElement);

		let that = this,
			$container = that.$domElement,
			data: HelperData,
			markup: string,
			loading: boolean;

		try {
			data = {
				view: that,
				callbacks: [],
				context: that._renderContext ? lang.clone(that._renderContext) : {}
			};

			try {
				markup = that.template(that.viewModel || that, { data: data });
				if (that.options.unbound || !that.isLoading()) {
					$container.html(markup);
					View.applyCallbacks(data, $container);
				}
			} finally {
				if (!that.options.unbound && that.isLoading()) {
					if (that.options.showWaitingAnimation && that.options.waitingTemplate) {
						markup = that.options.waitingTemplate({text: resources.wait});
						$container.html(markup.toString());
					} else if (markup) {
						$container.html(markup.toString());
						$container.blocked(true);
					}
					loading = true;
					// NOTE: if something is loading at the moment, template will be rerendered after loading.
					// So there is no need to apply callbacks in this case.
				}
			}
		} catch (error) {
			// if the error occurred during part's data is loading it doesn't mean a real error,
			// 'waiting' was already shown above
			if (loading) { return; }

			if (!that.options.errorTemplate) { throw error; }

			// render an error using errorTemplate
			console.error(error);
			try {
				if (that.options.errorTemplate) {
					markup = that.options.errorTemplate(error);
					$container.html(markup);
				}
			} catch (error2) {
				console.error(error2);
			}
		} finally {
			that.notifyDOMChanged();
			// TODO: надо как-то включить сохранение времени рендеринга: $container.attr("data-render-time", Date.now() - profile);
		}
	}

	protected afterRender(domElement?: JQuery|HTMLElement): void {
		let that = this;
		if (that.isLoading()) {
			that.renderStatus(Part.RenderStatus.waiting);
		} else {
			super.afterRender(domElement);
		}
	}

	unload(options?: PartCloseOptions): void {
		if (this.$domElement) {
			// NOTE: the code below is optimized version of $(that.domElement).blocked(false);
			this.$domElement.removeClass("blocked");
		}
		super.unload(options);
	}

	protected onReady(): void {
		this.trigger("render", this);
	}

	renderContext(v?: any): any {
		let that = this;
		if (arguments.length) {
			that._renderContext = v;
		} else {
			that._renderContext = that._renderContext || {};
		}
		return that._renderContext;
	}

	dispose(options?: PartCloseOptions): void {
		let that = this;
		if (that.template) {
			if (that.template.dispose) { that.template.dispose(); }
			that.template = undefined;
		}
		super.dispose(options);
	}

	/**
	 * @deprecated Do not compile templates in runtime, use xhtmpl plugin to import templates instead
	 */
	static compileTemplate(template: HBTemplate|string): HBTemplate {
		if (typeof template !== "function") {
			if (Handlebars.compile) {
				template = Handlebars.compile(template, { data: true });
			}
		}
		return <HBTemplate>template;
	}

	static newId(): string {
		return lang.uuid("x");
	}

	static addCallback(data: HelperData, callback: Function, callbackArgs: any[]): void {
		data.callbacks.push({
			func: callback,
			args: callbackArgs || []
		});
	}

	static applyCallbacks(data: HelperData, selector: JQuery): void {
		data.callbacks.forEach((callback) => {
			let args = callback.args;
			args.push(selector);

			callback.func.apply(data.view, args);
		});
		data.callbacks.length = 0;
	}

	/**
	 * Finds the specified DOM element.
	 * @param {Object} target Specifies target element.
	 * @param {String} target.id The ID of the target element
	 * @param {String} target.selector The jQuery selector of the target element
	 * @param {jQuery} $root Root element that contains target element.
	 * @returns {jQuery}
	 */
	static findElement(target: HelperTarget|string, $root: JQuery): JQuery {
		let id: string = typeof target === "string" ? target : target.id,
			element,
			$element;

		if (id) {
			// NOTE: document.getElementById is much faster then $.find("#id")
			element = document.getElementById(id);
			// NOTE: корневой элемент может быть не приаттачен к документу
			$element = element ? $(element) : $root.find("#" + id);
		} else if ((<HelperTarget>target).selector === ":container") {
			$element = $root;
		} else {
			$element = $root.find((<HelperTarget>target).selector);
		}

		if (!$element.length) {
			throw new Error("DOM element specified by target " + JSON.stringify(target) + " cannot be found");
		}
		return $element;
	}

	/**
	 * @this {View}
	 */
	static renderChild(target: HelperTarget, part: IPart|IPartFactory, context: any, registerOptions: RegisterChildOptions, $root: JQuery) {
		let element = View.findElement(target, $root);

		if (lang.isFunction(part)) {
			part = (<IPartFactory>part)();
			// NOTE: set disposeOnUnload, if it isn't specified explicitly
			registerOptions = lang.append(registerOptions || {}, { disposeOnUnload: true });
		}
		if (context && (<View>part).renderContext) {
			(<View>part).renderContext(context);
		}
		(<View><any>this).registerChild(<IPart>part, registerOptions);
		// NOTE: теоретически парт уже может быть отрендерен, например логика синхронно среагировала на какое-то событие
		// и вызвала явно render. А потом асинхронно перестроилась вся view, содержащая этот парт
		if ((<IPart>part).renderStatus && (<IPart>part).renderStatus() !== "unloaded") {
			if ((<IPart>part).unload) {
				(<IPart>part).unload();
			}
		}
		return (<IPart>part).render(element);
	}

	static Handlebars = Handlebars;
}

View.mixin({
	defaultOptions: View.defaultOptions,

	traceSource: new diagnostics.TraceSource("ui.handlebars.View"),

	loadingValue: {
		toString: () => {
			return resources["loading"];
		}
	}
});

/**
 * @constant
 * @type {string}
 * @private
 */
const LAST_ID_KEY = "-last-id";

namespace View {
	export interface Options extends Part.Options {
		/**
		 * Handlebars template to render the view. Usually you should load template via xhtml RequireJS-plugin
		 */
		template?: HBTemplate | string;
		/**
		 * Handlebars template to render an error. Usually you should load template via xhtml RequireJS-plugin
		 */
		errorTemplate?: HBTemplate;
		waitingTemplate?: HBTemplate;
		showWaitingAnimation?: boolean;
		/**
		 * Whether View should be bound to its viewModel changes or not. By default it's bound.
		 * That means that View will rerender on every viewModel change.
		 */
		unbound?: boolean;
		/**
		 * ViewModel.
		 */
		viewModel?: any;
		/**
		 * Option for ObservableExpression - `true` to disable auto loading of unloaded object observed during template's function execution
		 */
		suppressAutoLoad?: boolean;
	}

	export interface HelperOptions extends HBHelperOptions {
		data?: HelperData;
	}

	export type HelperTarget = {
		id?: string;
		selector?: string;
	};

	export class HelperMarkup {
		data: HelperData;
		protected _hash: any;

		/**
		 * Provides some methods and properties for rendering Handlebars helpers
		 * @constructs HelperMarkup
		 * @param {Object} helperOptions
		 * @param {Object} helperOptions.data
		 * @param {Object} helperOptions.hash
		 * @param {String} helperOptions.hash.target
		 * @article (Helper "target")[docs:helper-target]
		 */
		constructor(helperOptions: HelperOptions) {
			let that = this,
				data: HelperData = helperOptions.data,
				target: string = helperOptions.hash.target,
				lastId: string;

			if (target === ":pop-id" || target === ":peek-id") {
				lastId = data[LAST_ID_KEY];
				if (!lastId) {
					throw new Error("You must call {{push-id}} helper first.");
				}
				if (target === ":pop-id") {
					data[LAST_ID_KEY] = undefined;
				}
				that.target = {id: lastId};
			} else if (target && target.length) {
				that.target = {selector: target};
			} else {
				that.target = {id: View.newId()};
				that.inplace = true;
			}

			that.data = data;
			that._hash = helperOptions.hash;
		}
		/**
		 * Specified target DOM element
		 * @type {Object}
		 * @property {String} [target.id] The ID of the target element
		 * @property {String} [target.selector] The jQuery selector of the target element
		 * Use View.HelperMarkup.findElement method to find DOM-element by this target.
		 */
		target: HelperTarget;
		/**
		 * Helper must be rendered in-place (because of the target isn't specified)
		 * @type {Boolean}
		 */
		inplace: boolean;

		/**
		 * Returns a clone of the helper hash without service attributes
		 * @returns {Object}
		 */
		getHash(): Object {
			let hash = lang.clone(this._hash);
			delete hash.target;
			return hash;
		}

		/**
		 * Returns helper HTML for using in Handlebars
		 * @returns {Handlebars.SafeString}
		 */
		getHtml(): Handlebars.SafeString {
			let that = this,
				html = "";
			if (that.inplace) {
				html = " id=\"" + that.target.id + "\" ";
			}
			return new Handlebars.SafeString(html);
		}
	}

	/**
	 * @constructs ChildViewMarkup
	 * @extends HelperMarkup
	 */
	export class ChildViewMarkup extends HelperMarkup {
		getHash(): any {
			let hash = View.HelperMarkup.prototype.getHash.call(this);
			delete hash.tag;
			if (this.inplace) {
				delete hash.cssClass;
			}
			return hash;
		}
		getHtml(): Handlebars.SafeString {
			let that = this,
				html: string = "",
				tagName: string,
				cssClass: string;
			if (that.inplace) {
				tagName = that._hash.tag || "span";
				cssClass = that._hash.cssClass;
				html = "<" + tagName + " id='" + that.target.id + "'"; // open tag
				if (cssClass) {
					html += " class='" + cssClass + "'";
				} // class attribute
				html += "></" + tagName + ">"; // close tag
			}
			return new Handlebars.SafeString(html);
		}
		getRegisterOptions(options?: RegisterChildOptions): RegisterChildOptions {
			let that = this,
				hash = that._hash;
			options = options || {};
			["disposeOnUnload", "keepOnUnload", "trackStatus", "name"].forEach((key) => {
				let v = hash[key];
				if (v !== undefined) {
					options[key] = v;
				}
			});
			return options;
		}
		/**
		 * Add a callback that registers the child part and renders it
		 * @param {Part|Function} part An instance of part of a factory that creates part
		 * @param {Object} [options] default options for Part.registerChild method
		 */
		registerPendingChild(part: IPart|IPartFactory, options?: RegisterChildOptions) {
			let that = this,
				data = that.data,
				registerOptions = that.getRegisterOptions(options);
			if (!data || !data.view) {
				throw new Error("HB helper must be inside View template");
			}
			View.addCallback(data, View.renderChild, [that.target, part, data.context, registerOptions]);
		}
	}
}

Handlebars.registerHelper("push-id", function(options: HBHelperOptions) {
	let elementId = View.newId();
	options.data[LAST_ID_KEY] = elementId;
	return new Handlebars.SafeString(elementId);
});

Handlebars.registerHelper("peek-id", function(options: HBHelperOptions) {
	let elementId = options.data[LAST_ID_KEY];
	return new Handlebars.SafeString(elementId);
});

Handlebars.registerHelper("pop-id", function(options: HBHelperOptions) {
	let elementId = options.data[LAST_ID_KEY];
	options.data[LAST_ID_KEY] = undefined;
	return new Handlebars.SafeString(elementId);
});

Handlebars.registerHelper("pre", function(options: HBHelperOptions) {
	return options.fn.call(this, options);
});

Handlebars.registerHelper("observe", function (context, options: HelperOptions) {
	if (arguments.length === 1) {
		options = context;
		context = this;
	}
	let markup = new View.ChildViewMarkup(options),
		viewFactory = () => {
			return new View({
				template: options.fn,
				viewModel: context,
				suppressAutoLoad: options.data && options.data.view && options.data.view.suppressAutoLoad
			});
		};

	markup.registerPendingChild(viewFactory);
	return markup.getHtml();
});

Handlebars.registerHelper("observe-wait", function (context, options: HelperOptions) {
	if (!context) {
		throw new Error("handlebars 'observe-wait' helper: context is null");
	}
	if (!options.hash || !options.hash.expr) {
		throw new Error("handlebars 'observe-wait' helper: expr attribute wasn't specified");
	}

	var markup = new View.ChildViewMarkup(options),
		viewFactory = function () {
			let view,
				waitExpr = lang.observableExpression(options.hash.expr, {onchange: function () {
					let wait = waitExpr.call(context);
					if (!wait && view._waiting) {
						view._waiting = false;
						view.isLoading(false);
					} else if (wait && !view._waiting) {
						view._waiting = true;
						view.isLoading(true);
					}
				}}),
				inverse = function () {
					let res = options.inverse(context);
					if (!res) {
						res = View.defaultOptions.waitingTemplate.apply(this, arguments);
					}
					return res;
				},
				template = function () {
					let wait = waitExpr.call(context);
					if (wait) {
						if (!view._waiting) {
							view.isLoading(true);
							view._waiting = true;
						}
						return lang.support.loadingValue.toString();
					}
					return options.fn.apply(this, arguments);
				};

			view = new View({
				template: template,
				showWaitingAnimation: true,
				waitingTemplate: inverse,
				viewModel: context,
				suppressAutoLoad: options.data && options.data.view && options.data.view.suppressAutoLoad
			});
			return lang.override(view, {
				dispose: function (base, ...args) {
					waitExpr.dispose();
					base.apply(this, args);
				}
			});
		};

	markup.registerPendingChild(viewFactory, { trackStatus: true });
	return markup.getHtml();
});

Handlebars.registerHelper("unbound", function (context, options: HelperOptions) {
	let markup = new View.ChildViewMarkup(options),
		viewFactory = () => {
			return new View({
				template: options.fn,
				viewModel: context,
				unbound: true,
				suppressAutoLoad: options.data && options.data.view && options.data.view.suppressAutoLoad
			});
		};

	markup.registerPendingChild(viewFactory);
	return markup.getHtml();
});

Handlebars.registerHelper("observe-each", function (context, options: HelperOptions) {
	if (!context) {
		throw new Error("handlebars 'observe-each' helper: context is null");
	}

	let items = context && typeof context.all === "function" ? context.all() : context,
		ret = "";
	// NOTE: просто вызываем хелпер observe для каждого элемента
	lang.forEach(items, (item) => {
		ret = ret + Handlebars.helpers["observe"](item, options);
	});
	return ret;
});

/**
 * Наход DOM-элемент, соответствующий элементу коллекции (item).
 * @param {JQuery} $collection Корневой элемент коллекции
 * @param item Элемент коллекци
 * @param opts Опции байндинга
 * @returns {JQuery}
 */
function getCollectionItemElement($collection: JQuery, item: any, opts: CollectionBindingOptions): JQuery {
	let matchAttr = opts.attr;
	// NOTE: в случае таблицы может появиться tbody между table на который указывает target хелпера и tr, которые выводит шаблон
	// TODO: наверное надо опцию при включении которой ищем "*", а по умолчанию как ">*"
	let q = $collection[0].tagName === "TABLE" ? "*": ">*";
	let prop;
	if (opts.prop) {
		prop = lang.get(item, opts.prop);
	} else {
		// TODO: Это не работает для удаленных обектов (removed) - надо передавать индексы удаленных в параметрамх события
		// prop = collection.indexOf(item);
		throw new Error("each2 helper: missing required argument prop");
	}
	return $collection.find(q + "[" + matchAttr + "='" + prop + "']");
}
function collectionBind(data: HelperData, target: HelperTarget, collection: IObservableCollection<any>, that, execIteration, inverse, opts: CollectionBindingOptions, $root: JQuery) {
	let element = View.findElement(target, $root);
	if (!collection) {
		return "";
	}
	let matchAttr = opts.attr;
	let q = ">*";
	if (element[0].tagName === "TABLE") {
		q = "*";
	}
	let disposable = collection.subscribe("change", function(sender, args) {
		let dataNew = lang.extend({}, data);
		dataNew.callbacks = [];

		let count = collection.count();
		if (count === 0) {
			// коллекция стала пустой
			element.html(inverse(that));
			return;
		}
		if (args.removed) {
			for (let item of args.removed) {
				getCollectionItemElement(element, item, opts).remove();
			}
		}
		if (args.added) {
			// если коллекция была пустая (т.е. ничего не удаляли), то надо очистить элемент, т.к. в нем может быть результат else
			if (count === args.added.length && (!args.removed || !args.removed.length)) {
				element.empty();
			}

			if (args.addedIndices && args.addedIndices.length === args.added.length) {
				if (count === args.added.length) {
					// все что добавили, это теперь текущая коллкция, поэтому insert эквивалентен add
					let ret = "";
					for (let i = 0; i < args.added.length; i++) {
						ret  += execIteration(dataNew, i, i, count);
					}
					$(ret).appendTo(element);
				} else {
					// insert into the middle
					for (let i = 0; i < args.added.length; i++) {
						let targetIdx = args.addedIndices[i];
						html  = execIteration(dataNew, targetIdx + i, targetIdx + i, count);
						let nodeInsert;
						if (targetIdx > 0) {
							let item = collection.get(targetIdx - 1);
							nodeInsert = getCollectionItemElement(element, item, opts);
							$(html).insertAfter(nodeInsert);
						} else {
							// targetIdx==0, (в коллекции были элементы до вставки)
							// найдем первый DOM-элемент и вставим перед ним
							nodeInsert = element.find(q + "[" + matchAttr + "]").first();
							$(html).insertBefore(nodeInsert);
						}
					}
				}
			} else {
				// there're no indices, so we'll add new items at the bottom
				let ret = "";
				for (let i = count - args.added.length; i < count; i++) {
					ret  += execIteration(dataNew, i, i, count);
				}
				$(ret).appendTo(element);
			}
		}
		//
		View.applyCallbacks(dataNew, element);
	});
	binding.setupNodeDisposables(element).push(disposable);

	let count = collection.count();
	let html = "";
	// данный метод вызывает в рамках applyCallbacks дочернего вью CollectionView, т.е. при итерации data.callbacks.
	// в процессе рендеринга (execIteration) могут добавляться дополнительные колбэки (байндинги/дочерние view),
	// их нельзя добавлять в тот же data, т.к. итерация уже идет,
	// кроме того необходимо добавить созданный html ДО вызова этих колбеков
	let dataNew = lang.extend({}, data);
	dataNew.callbacks = [];
	for (let i = 0; i < count; i++) {
		html  += execIteration(dataNew, i, i, count);
	}
	if (count === 0) {
		html = inverse(that);
	}
	element.html(html);
	View.applyCallbacks(dataNew, element);
	// для каждого dom-элемента, соответствующему элементу коллекции, надо установить атрибиты
	if (count > 0) {
		element.children().each((index, elem) => {
			if (opts.prop) {
				elem.setAttribute(matchAttr, lang.get(collection.get(index), opts.prop));
			} else {
				elem.setAttribute(matchAttr, index.toString());
			}
		});
	}
}
class CollectionView extends View {
	bindOptions: any;
	viewModel: lang.IObservableCollection<any>;
	constructor(options: CollectionView.Options) {
		super(options);
		this.bindOptions = options.bindOptions;
	}
}
namespace CollectionView {
	export interface Options extends View.Options {
		bindOptions?: any[];
	}
}

Handlebars.registerHelper("each2", function (context, options: HBHelperOptions) {
	// NOTE: ожидаем, что context - это ObservableCollection
	let data = options.data;
	let markup = new View.ChildViewMarkup(options);
	if (data.view && data.view instanceof CollectionView) {
		// мы уже внутри CollectionView (шаблон тот же)
		View.addCallback(data, collectionBind, [data].concat(data.view.bindOptions));
		return markup.getHtml();
	}

	// первый вызов хелпера - обернем шаблон хелпера в CollectionView с самим собой в качестве шаблона
	if (!context) {
		if (options.inverse) {
			return options.inverse(this);
		}
		return "";
	}
	if (!lang.ObservableCollection.isObservableCollection(context)) {
		throw new Error("each2 helper expects context to be an ObservableCollection");
	}
	let fn = options.fn;
	// NOTE: код execIteration практически без изменений взят из Handlebars
	function execIteration(data: any, field: string, index: number, last: number): string {
		if (data) {
			data.key = field;
			data.index = index;
			data.first = index === 0;
			data.last = !!last;
			/*if (contextPath) {
			 data.contextPath = contextPath + field;
			 }*/
		}
		return fn(context.get(field), {
			data: data,
			blockParams: Handlebars.Utils.blockParams([context[field], field], [field, null])
		});
	}
	let opts: CollectionBindingOptions = {
		// matchBy: options.hash["match-prop"] ? "prop" : "index",
		prop: options.hash["match-prop"],
		attr: options.hash["match-attr"] || "data-match"
	};
	if (!opts.prop) {
		throw new Error("each2 helper: missing required argument 'match-prop'");
	}
	let that = this;
	let viewFactory = function () {
			return new CollectionView({
				template: "{{#each2 this}}{{/each2}}",
				viewModel: context,
				bindOptions: [markup.target, context, that, execIteration, options.inverse, opts],
				suppressAutoLoad: options.data && options.data.view && options.data.view.suppressAutoLoad
			});
		};
	markup.registerPendingChild(viewFactory);

	return markup.getHtml();
});
interface CollectionBindingOptions {
	prop: string;
	attr: string;
}
const hb_each_helper = Handlebars.helpers["each"];
Handlebars.registerHelper("each", function (context, options: HBHelperOptions) {
	let items = context && typeof context.all === "function" ? context.all() : context;
	return hb_each_helper(items, options);
});

function databind(target: HelperTarget, obj, propName, bindingName: string, $root: JQuery) {
	let element;
	try {
		element = View.findElement(target, $root);
	} catch (e) {
		throw new Error("View: data-bind helper ('" + bindingName + "') failed to find DOM-element for expression '" + propName +"'. Original error: " + e);
	}
	let bindableElement = binding.html(element, bindingName);
	let bindableProp = binding.expr(obj, propName);
	binding.databind(bindableElement, bindableProp);
}
Handlebars.registerHelper("data-bind", function (options: HelperOptions) {
	let that = this,
		markup = new View.HelperMarkup(options);
	lang.forEach(markup.getHash(), function (value, key) {
		View.addCallback(options.data, databind, [markup.target, that, value, key]);
	});
	return markup.getHtml();
});

function databindblock(target: HelperTarget, obj, hash, $root: JQuery) {
	let propName = hash.expr || hash.prop;
	let element;
	try {
		element = View.findElement(target, $root);
	} catch(e) {
		throw new Error("View: data-bind helper failed to find DOM-element for expression '" + propName +"'. Original error: " + e);
	}
	let bindableElement = binding.html(element, hash),
		bindableProp = binding.expr(obj, propName);
	binding.databind(bindableElement, bindableProp);
}
Handlebars.registerHelper("data-bind-block", function (options: HelperOptions) {
	let that = this,
		markup = new View.HelperMarkup(options),
		hash = markup.getHash();

	View.addCallback(options.data, databindblock, [markup.target, that, hash]);

	return markup.getHtml();
});

function toggleClassBind(target: HelperTarget, obj, propName, cssClass: string, $root: JQuery) {
	let element = View.findElement(target, $root),
		bindableElement = binding.html(element, { name: "cssClassToggle", cssClass: cssClass }),
		bindableProp = binding.expr(obj, propName);
	binding.databind(bindableElement, bindableProp);
}

/**
 * HB-Helper "toggleClass"
 * @example
 * <span {{toggleClass -disabled="disabled"}}></span>
 * Element will get css class '-disabled' when and only when the expression "disabled" will be true.
 * In the simplest case expression is a prop name in the current context
 */
Handlebars.registerHelper("toggleClass", function (options: HelperOptions) {
	let that = this,
		markup = new View.HelperMarkup(options);
	lang.forEach(markup.getHash(), function (value, key) {
		View.addCallback(options.data, toggleClassBind, [markup.target, that, value, key]);
	});
	return markup.getHtml();
});

function commandbind(target: HelperTarget, cmd, args, $root: JQuery) {
	let element = View.findElement(target, $root);
	if (!cmd) {
		throw new Error("Error in command-binding for element with target " + JSON.stringify(target) + ": no command");
	}

	binding.commandBind(element, cmd, args);
}
Handlebars.registerHelper("command-bind", function (context, options: HelperOptions) {
	if (!context && (!options || !options.hash.canBeEmpty)) {
		throw new Error("handlebars 'command-bind' helper: context is null");
	}
	if (!context) { return null; }

	let markup = new View.HelperMarkup(options);
	View.addCallback(options.data, commandbind, [markup.target, context, markup.getHash()]);
	return markup.getHtml();
});

Handlebars.registerHelper("render", function (context, options: HelperOptions) {
	if (!context) {
		throw new Error("handlebars 'render' helper: context is null");
	}

	let markup = new View.ChildViewMarkup(options);
	markup.registerPendingChild(context);
	return markup.getHtml();
});

Handlebars.registerHelper("expr", function (context) {
	let expr = lang.support.ExpressionFactory.get(context);
	return expr.call(this);
});

/**
 * @deprecated Use 'compare' helper
 */
Handlebars.registerHelper("if-eq", function(v1: any, v2: any, options: HBHelperOptions) {
	if (v1 === v2) {
		return options.fn(this);
	} else {
		return options.inverse(this);
	}
});

/**
 * @deprecated Use standard 'unless' helper
 */
Handlebars.registerHelper("if-not", function(v: any, options: HBHelperOptions) {
	if (!v) {
		return options.fn(this);
	} else {
		return options.inverse(this);
	}
});

Handlebars.registerHelper("if-not-last", function (options: HBHelperOptions) {
	let len = options.hash.total,
		index;
	if (len === undefined) {
		throw new Error("handlebars 'if-not-last' helper: total length is undefined");
	}

	if (options.data) {
		index = options.data.index;
	}

	if (index !== len - 1)
		return options.fn(this);
	else
		return options.inverse(this);
});

const hb_compare_operators = {
	'==': function (l, r) { return l == r; },
	'===': function (l, r) { return l === r; },
	'!=': function (l, r) { return l != r; },
	'!==': function (l, r) { return l !== r; },
	'<': function (l, r) { return l < r; },
	'>': function (l, r) { return l > r; },
	'<=': function (l, r) { return l <= r; },
	'>=': function (l, r) { return l >= r; },
	'typeof': function (l, r) { return typeof l == r; }
};

Handlebars.registerHelper("compare", function (lvalue: any, operator: string, rvalue: any, options: HBHelperOptions) {
	if (arguments.length < 3) {
		throw new Error("Handlerbars Helper 'compare' needs at least 2 arguments");
	}

	if (options === undefined) {
		options = rvalue;
		rvalue = operator;
		operator = "===";
	}

	let op = hb_compare_operators[operator];
	if (!op) {
		throw new Error("Handlerbars Helper 'compare': unknown operator " + operator);
	}

	let result = op(lvalue, rvalue);

	if (result) {
		return options.fn(this);
	} else {
		return options.inverse(this);
	}
});

Handlebars.registerHelper("first", function(context, options: HBHelperOptions) {
	// NOTE: this helper is mostly copy-paste of 'each' helper
	let fn = options.fn, inverse = options.inverse;
	let data, key;

	if (options.data) {
		data = Handlebars.createFrame(options.data);
	}

	if (context) {
		if (lang.ObservableCollection.isObservableCollection(context)) {
			return fn(context.get(0), { data: data });
		}
		if (lang.isArray(context)) {
			if (context.length > 0)
				return fn(context[0], { data: data });
		} else {
			key = Object.keys(context)[0];
			if (key)
				return fn(context[key], {data: data});
		}
	}
	return inverse(this);
});

Handlebars.registerHelper("debug", function(optionalValue?) {
	console.log("Current Context");
	console.log("====================");
	console.log(this);

	if (optionalValue) {
		console.log("Value");
		console.log("====================");
		console.log(optionalValue);
	}
});

Handlebars.registerHelper("format", function() {
	let context = arguments.length > 1 ? arguments[0] : this, // context is optional
		options: HBHelperOptions = arguments[arguments.length - 1],
		hash = options.hash,
		formatter = hash.formatter;
	if (lang.isFunction(formatter)) {
		// formatter-as-function:
		//   {{format "prop1" formatter=this.['getFormatted']}} => this.getFormatted("prop1)
		//   {{format prop1 "value1" formatter=options.['myFormatter']}} => options.myFormatter(prop1_val,"value1")

		// pass all arguments except the last one (it's options) to the formatter
		let args = lang.concatExceptLast.apply(null, arguments);
		return formatter.apply(this, args);
	}
	let prop = hash.prop;
	if (prop) {
		// prop-as-string:
		//    {{format prop="prop1" vt="date" format="LL"}}

		// try to get domain metadata
		let propMeta = context.meta && context.meta.props && context.meta.props[prop];
		if (propMeta) {
			hash = lang.extend({}, propMeta, hash);
		}
		// move context to property value
		context = lang.get(context, prop);
	}
	return formatters.formatPropValue(hash, context);
});

Handlebars.registerHelper("or", function(): boolean {
	// NOTE: omit the last argument - options
	for (let i = 0; i<arguments.length-1; i++) {
		let v =  arguments[i];
		if (v) { return true; }
	}
	return false;
});

Handlebars.registerHelper("and", function(): boolean {
	// NOTE: omit the last argument - options
	for (let i = 0; i<arguments.length-1; i++) {
		let v =  arguments[i];
		if (!v) { return false; }
	}
	return arguments.length > 1;
});

Handlebars.registerHelper("not", function(): boolean {
	return !arguments[0];
});

// Process another template in the same context
Handlebars.registerHelper("template", function(template: HBTemplate, options: HBHelperOptions) {
	if (!template) { return null; }

	if ((lang.isObject(template) || lang.isArray(template)) && options.hash.key !== undefined) {
		template = template[options.hash.key];
	}
	let data = options.data ? Handlebars.createFrame(options.data) : undefined,
		markup = template(options.hash.context || this, {data: data});
	return new Handlebars.SafeString(markup);
});

Handlebars.registerHelper("object", function(options: HBHelperOptions) {
	return options.hash;
});

export = View;
