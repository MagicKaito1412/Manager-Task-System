import core = require("core");

import ObjectEditor = require("lib/ui/editor/ObjectEditor");
import EditorPage = require("lib/ui/editor/EditorPage");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");

import lang = core.lang;
import {ObservableChangeArgs } from "lib/core.lang";

class EditorPageController extends lang.CoreClass implements EditorPage.IController {
	page: EditorPage;
	options: EditorPageController.Options[];
	viewModel: lang.Observable;
	private _dispoables: lang.IDisposable[];

	static is(value: any): value is EditorPage.IController {
		return value && value.start && value.stop;
	}

	/**
	 * @constructs EditorPageController
	 * @example
	 *  controller: [
	 *      {
	 *          onchange: "prop1",
	 *          apply: [
	 *              {
	 *                  condition: {"equal": false},
	 *                  disable: "prop2",
	 *                  enable: "prop3",
	 *                  else: {
	 *                    enable: "prop2",
	 *                    disable: "prop3",
	 *                  }
	 *              },
	 *              {
	 *                  condition: function(v) {return !v},
	 *                  goto: "prop3.prop31.prop312"
	 *              }
	 *          ]
	 *      }
	 *  ]
	 * @param {EditorPage} page EditorPage object
	 * @param {Object} options
	 */
	constructor (page: EditorPage, options: EditorPageController.Options[]) {
		super();
		this.page = page;
		this.options = options;
	}

	static behaviors: EditorPageController.KnownBehaviors = {
		disable: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe){
				pe.disabled(true);
			}
		},
		enable: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.disabled(false);
			}
		},
		hide: function (value: string): void{
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.hidden(true);
			}
		},
		show: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.hidden(false);
			}
		},
		notnull: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.notnull(true);
			}
		},
		nullable: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.notnull(false);
			}
		},
		goto: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.focus();
			}
		},
		validate: function (value: string): void {
			let pe = this.getPropertyEditor(value);
			if (pe) {
				pe.runValidation();
			}
		},
		goToNext: function(): void {
			let pe = this.page.getActivePropertyEditor();
			if (pe) {
				pe = this.page.getNextPropertyEditor(pe);
				if (pe){
					pe.disabled(false);
					pe.focus();
				}
			}
		},
		execute: function (func: (page: EditorPage, propValue: any, propName?: string) => void, propValue: any, propName?: string): void {
			func(this.page, propValue, propName);
		}
	};

	getPropertyEditor (value: string): PropertyEditor {
		return this.page.getPropertyEditorByPath(value);
	}

	start (page: EditorPage): void {
		let that = this,
			vm = page.viewModel;
		this.page = page;
		if (lang.Observable.isObservable(vm)) {
			that.viewModel = vm;
		} else {
			console.error("EditorPageController: cannot be used with page viewModel that is not Observable");
			return;
		}
		that._dispoables = [];
		lang.forEach(that.options, (desc: EditorPageController.Options) => {
			try {
				let handler = function (propValue: any, propName?: string): void {
					lang.forEach(desc.apply, (beh: EditorPageController.Behavior) => {
						that._executeBehavior(beh, propValue, propName);
					});
				};
				let val = that.subscribe(desc.onchange, handler, desc.onchangeReason);
				if (desc.onstart && val !== undefined && val !== lang.support.loadingValue) {
					lang.forEach(desc.apply, (beh: EditorPageController.Behavior) => {
						that._executeBehavior(beh, val);
					});
				}
			}
			catch (ex) {
				console.error("Error on page controller initialization for onchange '" + desc.onchange + "', see next error");
				console.error(ex);
			}
		});
	}

	/**
	 *
	 * @param beh behavior options
	 * @param propValue Prop value
	 * @param propName Prop name only for the case of "*" subscription
	 * @private
	 */
	protected _executeBehavior(beh: EditorPageController.Behavior, propValue: any, propName?: string): void {
		let that = this;
		let apply = true;
		let condition = beh.condition;

		if (lang.isFunction(condition)) {
			apply = (condition(propValue));
		} else if (lang.isObject(condition)) {
			apply = that._executeCondition(condition, propValue);
		}

		if (apply) {
			that._applyBehavior(beh, propValue, propName);
		} else if (beh["else"]) {
			that._applyBehavior(beh["else"], propValue, propName);
		}
	}

	protected _executeCondition (condition: EditorPageController.Condition, propValue: any): boolean {
		if (condition.hasOwnProperty("equal"))
			return propValue == condition.equal;
		if (condition.hasOwnProperty("equal-strict"))
			return propValue === condition["equal-strict"];
		if (condition.hasOwnProperty("not-equal"))
			return propValue != condition["not-equal"];
		if (condition.hasOwnProperty("not-equal-strict"))
			return propValue !== condition["not-equal-strict"];

		return false;
	}

	protected _applyBehavior (beh: EditorPageController.Behavior, propValue: any, propName?: string): void {
		let names = Object.keys(beh);
		lang.forEach(names, (name: string) => {
			let handler = EditorPageController.behaviors[name];
			if (handler) {
				let prop = beh[name];
				// NOTE: в качестве значения опции бехейвера может быть имя или массив свойств, к которым его надо применить,
				// либо, для execute - функция + аргументы события "change" при изменении свойства.
				// Т.е. для бехейвера "execute" 1-ый параметр (prop) - это функция, которую мы передаем в бихейер,
				// там он ее вызовет со вторым параметром. Плюс для execute и onchange="*" передается propName.
				if (lang.isArray(prop)) {
					prop.forEach((prop) => {
						handler.call(this, prop, propValue);
					});
				} else {
					handler.call(this, prop, propValue, propName);
				}
			}
		});
	}

	protected subscribe (onchangeExpr: string, handler: (val: any) => void, onchangeReason?: EditorPageController.OnChangeReasonFilter): any {
		let that = this,
			obj = that.viewModel,
			val;

		if (onchangeExpr === "*") {
			let handlerWrap = (sender, args: ObservableChangeArgs) => {
				//if (!args || args.reason === "change") {
				if (!args  || that.checkReason(args.reason, onchangeReason)) {
					// NOTE: при использовании OE юзеры получат значение свойства, а не raw-значение,
					// поэтому тут тоже надо так же (для массивных свойств они будут отличаться)
					let val = lang.get(sender, args.prop);
					// NOTE: значение может быть незагружено, и в отличии от OE само оно не загрузится
					if (val && lang.support.isNotLoaded(val)) {
						val.load().then(() => {
							val = lang.get(sender, args.prop);
							handler.call(that, val, args.prop);
						});
					} else {
						handler.call(that, val, args.prop);
					}
				}
			};
			obj.bind("change", handlerWrap);
			that._dispoables.push({
				dispose: () => {
					obj.unbind("change", handlerWrap);
				}
			});
		} else {
			let exprOptions: lang.support.ObservableExpression.Options = {};
			let expr = lang.observableExpression(onchangeExpr, exprOptions);
			exprOptions.onchange = (reason) => {
				if (that.checkReason(reason, onchangeReason)) {
					let value = expr.call(obj);
					if (value !== lang.support.loadingValue) {
						handler.call(that, value);
					}
				}
			};
			// to create actual subscriptions (on "get" events) we need to execute observable-expression
			val = expr.call(obj);

			that._dispoables.push(expr);
		}
		return val;
	}

	protected checkReason(reason: lang.ObservableNotifyReason, reasonSpec: EditorPageController.OnChangeReasonFilter): boolean{
		if (!reason || reasonSpec === "*" ||
			!reasonSpec && (reason === "change" || reason === "autoLoad")) {
			return true;
		}
		if (lang.isArray(reasonSpec)) {
			return reasonSpec.indexOf(reason) > -1;
		} else {
			return reason === reasonSpec;
		}
	}

	/*
		navigateToObject: function(obj, path) {
		var parts,
			i;
		if (path.indexOf(".") === -1)
			return {object: obj, prop: path};
		parts = path.split(".")
		for(i = 0; i < parts.length - 1; ++i) {
			obj = obj[parts[i]]();
			if (!obj)
				return null;
		}
		return {object: obj, prop: parts[parts.length - 1]};
	},*/

	stop (): void {
		lang.forEach(this._dispoables, (disposable) => {
			disposable.dispose();
		});
	}
}

namespace EditorPageController {
	export interface Options {
		/**
		 * name or expression for a property, or "*" (execute apply for all props)
		 */
		onchange: string;
		onchangeReason?: OnChangeReasonFilter;
		/**
		 * execute apply on page start
		 */
		onstart?: boolean;
		/**
		 * Array of behaviors - what to do when onchange expression/prop is changed (on just on start if onstart=true)
		 */
		apply: Behavior[];
	}
	export type OnChangeReasonFilter = "*" | lang.ObservableNotifyReason | lang.ObservableNotifyReason[];

	export interface Behavior {
		/**
		 * Condition (object or callback) to check for executing the behavior
		 */
		condition?: Condition | Function;
		/**
		 * Contrary behavior to execute when condition was not satisfied (this nested behavior cannot contain condition/else)
		 */
		"else"?: Behavior;
		/**
		 * Any known behaviors to execute when condition was satisfied, see KnownBehaviors
		 */
		[key: string]: any;
	}
	export interface Condition {
		"equal"?: any;
		"equal-strict"?: any;
		"not-equal"?: any;
		"not-equal-strict"?: any;
	}
	export interface KnownBehaviors extends lang.Map<Function> {
		disable?: Function;
		enable?: Function;
		hide?: Function;
		show?: Function;
		notnull?: Function;
		nullable?: Function;
		goto?: Function;
		goToNext?: Function;
		execute?: Function;
	}
}

EditorPageController.mixin({
	behaviors : EditorPageController.behaviors
});

//core.ui.EditorPageController = EditorPageController ;
export = EditorPageController;
