import $ = require("jquery");
import core = require("core");
import Component = require("lib/ui/Component");
import View = require("lib/ui/handlebars/View");
import EditorPage = require("lib/ui/editor/EditorPage");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import NavigationPropertyEditor = require("lib/ui/pe/NavigationPropertyEditor");
import validation = require("lib/validation");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import Menu = require("lib/ui/menu/Menu");
import Carousel = require("lib/ui/Carousel");
import ConcurrencyErrorPart = require("lib/ui/editor/ConcurrencyErrorPart");
import ViolationInfoPart = require("lib/ui/validation/ViolationInfoPart");
import utils = require("lib/utils");
import WaitingModal = require("lib/ui/WaitingModal");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import resources = require("i18n!lib/nls/resources");
import fatalErrorTemplate = require("xhtmpl!lib/ui/templates/EditorFatalError.hbs");
import {
	ContextPartComponentMixin,
	IContextPart
} from "lib/ui/validation/ContextPartMixin";

import domain = require("lib/domain/.domain");
import UnitOfWork = require("lib/domain/UnitOfWork");

import lang = core.lang;
import ObservableCollection = lang.ObservableCollection;
import ObservableProperty = lang.ObservableProperty;
import Promise = lang.Promise;
import Promisable = lang.Promisable;
import SystemEvent = core.SystemEvent;
import DomainObject = domain.DomainObject;
import DomainObjectData = domain.DomainObjectData;
import PropertyMeta = domain.metadata.PropertyMeta;
import EntityMeta = domain.metadata.EntityMeta;
import IPart = core.ui.IPart;
import PartCloseOptions = core.ui.PartCloseOptions;
import HostContextOptions = core.ui.HostContextOptions;
import ICommand = core.commands.ICommand;

import Options = ObjectEditor.Options;
import KnownMenus = ObjectEditor.KnownMenus;
import KnownCommands = ObjectEditor.KnownCommands;
import Model = ObjectEditor.Model;
import Result = ObjectEditor.Result;
import PartState = ObjectEditor.PartState;
import EditorContext = ObjectEditor.EditorContext;
import Violation = ObjectEditor.Violation;

import PageCreatedEventArgs = ObjectEditor.PageCreatedEventArgs;
import ValidatingEventArgs = ObjectEditor.ValidatingEventArgs;
import ValidatedEventArgs = ObjectEditor.ValidatedEventArgs;
import PageSwitchingEventArgs = ObjectEditor.PageSwitchingEventArgs;
import PageEventArgs = ObjectEditor.PageEventArgs;
import SavingEventArgs = ObjectEditor.SavingEventArgs;
import SavedEventArgs = ObjectEditor.SavedEventArgs;
import FinishingEventArgs = ObjectEditor.FinishingEventArgs;
import AcceptingEventArgs = ObjectEditor.AcceptingEventArgs;
import FinishedEventArgs = ObjectEditor.FinishedEventArgs;
import QueryUnloadEventArgs = ObjectEditor.QueryUnloadEventArgs;

import FinishCommandArgs = ObjectEditor.FinishCommandArgs;
import ApplyCommandArgs = ObjectEditor.ApplyCommandArgs;
import PageCommandArgs = ObjectEditor.PageCommandArgs;

import {
	ObjectIdentity, InteropError, OptimisticConcurrencyException,
	BusinessLogicException
} from "lib/interop/.interop";

const Events = {
	INITIALIZING: "initializing",
	INITIALIZED: "initialized",
	PAGE_CREATED: "pageCreated",
	PAGE_STARTING: "pageStarting",
	PAGE_STARTED: "pageStarted",
	PAGE_UNLOADING: "pageUnloading",
	PAGE_UNLOADED: "pageUnloaded",
	PAGE_SWITCHING: "pageSwitching",
	VALIDATING: "validating",
	VALIDATED: "validated",
	ACCEPTING: "accepting",
	FINISHING: "finishing",
	FINISHED: "finished",
	SAVING: "saving",
	SAVED: "saved",
	SAVE_ERROR: "saveError",
	QUERY_UNLOAD: "queryUnloaded",
	UNLOADED: "unloaded",
	DISPOSED: "disposed"
};

class ObjectEditor extends Component {

	static defaultOptions: Options = {
		title: undefined,
		subtitle: undefined,
		/**
		 * @type {Array}
		 */
		pages: undefined,
		/**
		 * Class of presenter
		 * @type {Function}
		 */
		Presenter: undefined,
		cssRootClass: "x-editor-base x-editor",
		/**
		 * Array of validation rules
		 * @type {Array}
		 */
		rules: undefined,
		editorContext: {nested: false},
		navigationService: undefined,
		/**
		 * Type name of viewModel (EntityType)
		 * @type {String}
		 */
		type: undefined,
		/**
		 * Object identifier
		 * @type {String}
		 */
		id: undefined,
		viewModel: undefined,
		menu: undefined,
		commands: undefined,
		pageValidation: "none", // loose, strict
		skipSaveState: false,
		blockingSave: false,
		traceSourceName: undefined,
		onSetViewModel: undefined,
		onCreatePage: undefined,
		onCreatePropEditor: undefined,
		onPageUnloading: undefined,
		onPageUnloaded: undefined,
		onPageStarting: undefined,
		onPageStarted: undefined,
		onValidating: undefined,
		onValidated: undefined,
		onAccepting: undefined,
		onFinishing: undefined,
		onFinished: undefined,
		onSaving: undefined,
		onSaved: undefined,
		onQueryUnload: undefined,
		onUnloaded: undefined,
		navigateSiblings: undefined,
		contextName: undefined,
		/**
		 * Prevent auto load unloaded objects in observable expressions.
		 * It's option for presenter's View. Can be passed via `presenterOptions` as well.
		 */
		suppressAutoLoad: undefined,
		navigateOptions: {
			dialogOptions: {
				menu: false,
				wide: true
			}
		},
		userSettings: {
			props: {
				"contextParts": true
				// contextParts: {
				// 	isPinned: true
				// }
			}
		},
		commandsOptions: {} // required for PartCommandMixin
	};

	static hostDefaultOptions: lang.Map<Options> = {};

	static events = Events;

	@lang.decorators.constant(Events)
	events: typeof Events;

	static defaultMenus: KnownMenus = {
		Editor: { items: [
			{ name: "SaveAndClose", title: resources["ok"], icon: "ok", hotKey: "ctrl+enter", hint: resources["objectEditor.command_hint.saveAndClone"] },
			{ name: "CancelAndClose", title: resources["cancel"], icon: "cancel", hint: resources["objectEditor.command_hint.cancelAndClose"] }
		] },
		RootEditor: { items: [
			{ name: "SaveAndClose", title: resources["save_close"], icon: "save", hotKey: "ctrl+enter", hint: resources["objectEditor.command_hint.saveAndClone"], items: [
				{ name: "Apply", title: resources["apply"], icon: "ok", hotKey: "ctrl+shift+s", hint: resources["objectEditor.command_hint.apply"] }
			]
			}, { name: "CancelAndClose", title: resources["cancel"], icon: "cancel", hint: resources["objectEditor.command_hint.cancelAndClose"] }
		] }
	};

	@lang.decorators.constant(ObjectEditor.defaultMenus)
	defaultMenus: KnownMenus;

	/**
	 * Currently active page of the editor.
	 * @observable-property {EditorPage}
	 */
	@lang.decorators.observableAccessor()
	currentPage: ObservableProperty<EditorPage>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	saving: ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isBusy: ObservableProperty<boolean>;

	/**
	 * context name for property editors
	 */
	@lang.decorators.constant("editor")
	contextName: string;

	options: Options;
	app: core.Application;
	viewModel: Model;
	presenter: ObjectEditor.IPresenter;
	traceSource: core.diagnostics.TraceSource;
	title: string;
	subtitle: string;
	rules: validation.ObjectRule[];
	pages: ObservableCollection<EditorPage>;
	violations: ObservableCollection<Violation>;
	editorContext: EditorContext;
	contextParts: ObservableCollection<IContextPart>;
	initializationTask: Promise<void>;
	error: string;
	menu: Menu;
	commands: KnownCommands;

	protected siblingsCarousel: Carousel<Options>;
	protected _isIsolated: boolean;
	protected _isClosing: boolean;
	protected _state: PartState;
	protected _uowStateName: string;
	protected _appState: core.AppState;
	protected _errorView: View;

	private _ownUow: UnitOfWork;
	private _originalOptions: Options;

	/**
	 * @constructs ObjectEditor
	 * @extends Component
	 * @param {Object} options
	 */
	constructor(options?: Options) {

		let originalOptions = options;
		options = ObjectEditor.mixOptions(options, ObjectEditor.defaultOptions);
		super(options);

		this._originalOptions = originalOptions;

		this.app = core.Application.current;
		this.traceSource = new core.diagnostics.TraceSource("ui.ObjectEditor", this.options.traceSourceName);

		this.title = this.options.title;
		this.subtitle = this.options.subtitle;

		this.rules = this.options.rules;
		this.pages = new ObservableCollection<EditorPage>();
		this.violations = new ObservableCollection<Violation>();
		this.violations.bind("change", this._onViolationsChanged, this);

		this.currentPage(null);
		this.editorContext = options.editorContext || {nested: false};
		this._isIsolated = lang.coalesce(
			this.options.isIsolated,
			!(options.uow || (options.viewModel && options.viewModel.uow))
		);
		this.navigationService = options.navigationService || null;
		this.contextParts = new ObservableCollection<IContextPart>();
		this.userSettings = core.UserSettings.create(this.options.userSettings);

		utils.subscribeOnEvents(this, options, Events);

		let viewModel: Model = this.options.viewModel,
			uow: UnitOfWork = (viewModel && viewModel.uow) || options.uow;
		if (uow) {
			this.onSaveState(uow);
		}

		if (this.options.initialJson) {
			// restore a draft
			uow = uow || (this._ownUow = this.app.createUnitOfWork({connected: true}));
			uow.attachChanges(this.options.initialJson);
		}

		// NOTE: don't create viewModel when option `viewModel` is null
		if (viewModel === undefined) {
			if (!options.type) {
				options.type = this.options.urlSuffix;
			}
			if (options.type && options.id) {
				// load existing object
				uow = uow || (this._ownUow = this.app.createUnitOfWork({connected: true}));
				viewModel = uow.get(options.type, options.id);
			} else if (options.type) {
				// create a new object
				// NOTE: we must call saveState before creating an object
				uow = uow || (this._ownUow = this.app.createUnitOfWork({connected: true}));
				viewModel = uow.create(options.type);
			}
		}
		if (viewModel) {
			this.setViewModel(viewModel);
		}

		this._initializeMenu();

		// save current app state, it can be used in queryUnload/dispose to save a draft
		this._appState = this.app.stateManager.getCurrentState();

		this.initPresenter();
	}

	applyHostContext(opt: HostContextOptions): core.INavigationService.NavigateOptions {
		let navOpt = super.applyHostContext(opt);
		this.mixHostOptions(opt.host, ObjectEditor.hostDefaultOptions);
		return navOpt;
	}

	protected tweakOptions(options: Options): void {
		lang.appendEx(options, {
			presenterOptions: {
				suppressAutoLoad: options.suppressAutoLoad
			}
		}, { deep: true });
		super.tweakOptions(options);
	}

	protected _initState(viewModel: Model): void {
		let that = this,
			id = that._getViewModelId(viewModel) || that.options.id;
		// set part's state so in case of initialization fails the part has some meaningful state (see getState):
		that._state = {
			type: viewModel.meta ? viewModel.meta.name : that.options.type
		};
		if (id) {
			that._state.id = id;
		}
		if (that.options.page) {
			that._state.page = that.options.page;
		}
	}

	setViewModel(viewModel: Model): void {
		let that = this;
		that._initState(viewModel);

		let promisable: Promisable<Model> = viewModel;
		if (lang.isFunction(viewModel.load)) {
			if (that.options.preloads) {
				promisable = viewModel.load({ preloads: that.options.preloads });
			} else if (!viewModel.isLoaded) {
				promisable = viewModel.load();
			}
		}

		promisable = <Promisable<Model>>lang.async.then(promisable, v => that.onSetViewModel(v) || v);

		let task = lang.async.then(promisable, v => { that._setViewModelComplete(v); });
		if (lang.isPromise(task)) {
			that.initializationTask = task;
			task.fail(error => {
				delete that.initializationTask;
				/*
				 NOTE: error can be an interop-error from DataFacade, like:
				 {
				 	error: "Internal Server Error"
				 	exception: "java.lang.NullPointerException"
				 	httpStatus: 500
					message: "No message available"
				 }
				 */
				if (error && error.message) {
					that.error = error.message;
				} else {
					that.error = error;
				}

				that.traceSource.error(error);
			});
		}
	}

	protected onSetViewModel(viewModel: Model): Promisable<Model> {
		// that.options.onSetViewModel
		if (this.isDisposed) { return; }

		let onSetViewModel = this.options.onSetViewModel;
		if (viewModel && onSetViewModel) {
			viewModel = onSetViewModel.call(this, viewModel) || viewModel;
		}
		return viewModel;
	}

	protected _setViewModelComplete(viewModel: Model): void {
		let that = this;
		delete that.initializationTask;
		if (that.isDisposed) { return; }

		if (that.title === undefined && viewModel.meta) {
			that.title = viewModel.meta.descr;
		}

		let uow: UnitOfWork = viewModel.uow,
			oldUow: UnitOfWork = that.viewModel && that.viewModel.uow;
		if (oldUow && oldUow !== uow) {
			that._disposeUow(oldUow);
		}
		if (uow) {
			uow.bind("detach", that._onObjectDetached, that);
		}

		that.error = undefined;
		super.setViewModel(viewModel);
		if (that.pages.isEmpty()) {

			that._initialize();

			if (that.domElement) {
				this.rerender();
			}
		} else {
			// NOTE: Это не первый вызов setViewModel, страницы уже инициализированы.
			// Удалим их все и выполним новую инициализацию. Можно было бы оставить и пройти по всем PE и задать новую VM,
			// но могут быть также кастомные шаблоны, которые зависят от VM. Проще все удалить.
			let domElement = that.domElement;
			if (that.domElement) {
				domElement = that.domElement;
				that.unload();
			}
			that.currentPage(null);
			// it's not the first initialization, we should to remove previous pages
			that.pages.forEach((page) => {
				if (lang.isFunction(page.unload)) {
					page.unload({reason: "dispose"});
				}
			});
			that.pages.forEach(page => {
				if (lang.isFunction(page.dispose)) {
					page.dispose();
				}
			});
			that.pages.clear();
			that._initialize();
			if (domElement) {
				this.render(domElement);
			}
		}
	}

	protected _initialize(): void {
		let that = this,
			pagesInfo = that.options.pages;

		try {
			that.onInitializing();
			if (pagesInfo) {
				for (let pageInfo of pagesInfo) {
					that._createPage(pageInfo);
				}
				if (that.options.page) {
					let page = that.getPageByName(that.options.page);
					if (page) {
						that.currentPage(page);
					}
				}
			} else {
				that._createDefaultPage();
			}
			that.onInitialized();
		} catch (error) {
			that.error = error;
			that.traceSource.error(error);

			if (that.app.config.isDebug) {
				throw error;
			}
		}
	}

	protected _onObjectDetached(sender: UnitOfWork, obj: DomainObject): void {
		if (!this.pages) { return; } // already disposed

		this.pages.forEach(page => {
			let editors = page.editors;
			if (!editors) { return; }

			for (let key of Object.keys(editors)) {
				let pe = editors[key];
				if (pe.viewModel === obj) {
					delete editors[key];
					if (!pe.isDisposed) {
						pe.dispose();
					}
				}
			}
		});
	}

	protected onInitializing(): void {
		this.trigger(Events.INITIALIZING, this);
	}

	protected onInitialized(): void {
		this.trigger(Events.INITIALIZED, this);
	}

	/**
	 * Create an url query for initialization via navigating to a url
	 */
	getState(partOptions?: Options): PartState {
		let that = this;
		if (partOptions) {
			return {
				type: partOptions.type,
				id: partOptions.id,
				page: partOptions.page
			};
		}

		let state = that._getViewModelState();
		if (state) {
			if (that.pages && that.pages.count() > 1) {
				let curPage = that.currentPage();
				if (curPage && curPage !== that.pages.get(0)) {
					state.page = curPage.name;
				}
			}
			that._state = state;
		}
		return that._state;
	}

	protected _getViewModelState(): PartState {
		let viewModel = this.viewModel,
			state: PartState;
		if (viewModel) {
			state = {};
			let meta = viewModel.meta;
			if (meta) {
				state.type = meta.name;
			}
			let id = this._getViewModelId(viewModel);
			if (id) {
				state.id = id;
			}
		}
		return state;
	}

	protected _getViewModelId(viewModel: Model): string {
		let id = viewModel.id;
		if (id) {
			let isNew = lang.isFunction(viewModel.isNew) ? viewModel.isNew() : false;
			if (!isNew) {
				return id;
			}
		}
	}

	protected onStateChanged(state?: PartState): boolean {
		let that = this,
			curPage = that.currentPage();
		if (state && curPage && state.page !== curPage.name) {
			let page = state.page ?
				that.getPageByName(state.page) :
				that.pages.get(0);
			if (page) {
				that.setCurrentPage(page, /*skipValidation=*/ false);
				return true;
			}
		}
		return false;
	}

	protected _initializeMenu(): void {
		let that = this;
		// initialize editor menu & commands
		that.commands = lang.extend(that.createCommands(), that.options.commands || {});
		that.menu = that.createMenu();
		that.menu.bindToPart(that);

		if (that.options.navigateSiblings && that.options.navigateSiblings.length > 1) {
			that.siblingsCarousel = new Carousel({
				items: that.options.navigateSiblings,
				formatter: null
			});
			let pos = that._getObjectIndex(that.options.navigateSiblings);
			if (pos > -1) {
				that.siblingsCarousel.position(pos);
			}
			that.siblingsCarousel.bind("moving", that._onSiblingNavigate, that);
		}
	}

	protected _onSiblingNavigate(sender: Carousel<Options>, args: Carousel.MovingEventArgs): void {
		let that = this;
		if (that._isClosing) { return; }
		if (!that.navigationService.replace) { return; }

		let item = sender.items().get(args.to);
		if (item) {
			that._isClosing = true;
			// NOTE: in any case we're preventing changing Carousel's position:
			//  if it's forbidden by queryUnload then it won't change
			//  if it's allowed (by default) it will be changed in editor being opened
			args.cancel = true;
			let result = that.queryNavigateSibling();
			lang.async.chain(result)
				.then(reasonToStay => {
					if (!reasonToStay) {
						return that._doNavigateSibling(item);
					}
				})
				.always(() => {
					that._isClosing = false;
				});
		}
	}

	protected queryNavigateSibling(): Promisable<string> {
		let that = this;
		// NOTE: Вызывать queryUnload для вложенного редактора нельзя, т.к. он проверяет наличие изменений
		// во всей uow, и таким образом будет предупреждать о наличие изменений, которые мы не делали.
		if (that._isIsolated) {
			// navigationService.replace() вызовет unload() текущего парта с reason:"close", но не вызовет
			// queryUnload(). Явно позовем queryUnload() с той же причиной.
			// NOTE: queryUnload переопределяется модулем черновиков, но в случае reason === "close",
			// черновик создаваться не будет
			return that.queryUnload({ reason: "close" });
		}
		if (that._uowStateName && that.viewModel.uow.hasChangesSince(that._uowStateName)) {
			let dialog = new ConfirmDialog({
				header: this.title,
				text: resources["objectEditor.nested_query_unload_prompt"],
				menu: {items: [
					{ name: "yes", title: resources["yes"], isDefaultAction: true },
					{ name: "no",  title: resources["no"] },
					{ name: "cancel", title: resources["cancel"] }
				]}
			});
			return dialog.open().then(result => {
				if (result === "cancel") {
					return resources["closing_canceled"];
				}
				if (result === "yes") {
					// accept changes but do not close
					return that.finish({skipClose: true});
				}
			});
		}
	}

	protected _doNavigateSibling(partOptions: Options): Promise<IPart> {
		let that = this;
		return that.navigationService.replace({
			part: that.name,
			partOptions: lang.extend(partOptions, {
				navigateSiblings: that.options.navigateSiblings,
				page: that.currentPage().name
			})
		});
	}

	protected _getObjectIndex(siblings: Options[]): number {
		if (!lang.isArray(siblings)) { return -1; }

		let viewModel = this.options.viewModel,
			id = (viewModel && viewModel.id) || this.options.id;
		return lang.findIndex(siblings,
			item => (viewModel && item.viewModel === viewModel) || (id && item.id === id)
		);
	}

	protected getCloseResult(result: Result): Result {
		let that = this;
		if (that.options.navigateSiblings && that.viewModel) {
			result.selectedId = that.viewModel.id;
		}
		return result;
	}

	protected createMenuDefaults(): Menu.Options {
		let key = this._isIsolated ? "RootEditor" : "Editor";
		return Menu.defaultsFor(this.defaultMenus[key], key, this._getType());
	}

	protected createMenu(): Menu {
		return new Menu(this.createMenuDefaults(), this.options.menu);
	}

	protected _getType(): string {
		let that = this;
		return that.options.type || (that.viewModel && that.viewModel.meta && that.viewModel.meta.name);
	}

	protected _getPropertyEditorMd(viewModel: Model, prop: PropertyEditor.Options|string): PropertyEditor.Options {
		let that = this,
			typeMd: EntityMeta = viewModel.meta,
			propMd: PropertyEditor.Options;

		if (typeof prop === "string") {
			if (typeMd) {
				propMd = typeMd.props[prop] || typeMd.complex[prop];
				if (propMd) {
					// fast-simple case: prop is string and we found a metaprop in VM's entity for it
					return propMd;
				}
			}
			if (that.app.config.isDebug && !propMd && prop && prop.indexOf(".") < 0)
				throw new Error("ObjectEditor's viewModel doesn't have a property with name '" + prop + "'");

			// Prop is a string, but it contains ".", so it can be a prop-chain (like "prop1.prop2")
			prop = { name: prop };
		}
		if (!prop.name) {
			throw new Error("ObjectEditor: property editor metadata does not contain required field 'name'");
		}
		if (typeMd) {
			let propMdDeclared = typeMd.props[prop.name] || typeMd.complex[prop.name];
			if (!propMdDeclared) {
				// no metaprop in VM's entity, prop can be a chain ("prop1.prop1")
				let parts = prop.name.split(".");
				if (parts.length > 1) {
					prop.chain = {
						props: []
					};
					for (let i = 0; i < parts.length; ++i) {
						// NOTE: тут может быть сложный случай: 1-я часть навигируемое свойство, 2-ая комплексное,
						// например: "organizer.address.street".
						// TODO: для поддержки навигируемых свойств в комплексных типах потребуется доработка,
						// т.к. нельзя просто брать до первой точки, первое навигируемое св-во может быть быть с точкой
						// (complexProp.navPropOfComplexProp.otherNestedProp)
						propMdDeclared = typeMd.props[parts[i]];
						if (propMdDeclared) {
							if (propMdDeclared.ref && propMdDeclared.ref.kind === "entity") {
								typeMd = <EntityMeta>propMdDeclared.ref;
							}
							prop.chain.props.push(propMdDeclared);
							// it should be the last part of the chain
						} else if (typeMd.complex[parts[i]]) {
							// current part - is a complex prop, join the rest parts to get a valuable prop
							let propName = parts[i];
							for (let j = i + 1; j < parts.length; ++j) {
								propName = propName  + "." + parts[j];
							}
							// NOTE: теоретически цепочка может кончатся также комплексным, если для него написали РЕ
							propMdDeclared = typeMd.props[propName] || typeMd.complex[propName];
							if (!propMdDeclared && that.app.config.isDebug)
								throw new Error(`ObjectEditor's viewModel doesn't have a property with name '${prop.name}'`);

							prop.chain.props.push(propMdDeclared);
							break;
						}
					}
				}
			}
			propMd = that._mergePropMd(propMdDeclared, prop);
		} else {
			propMd = prop;
		}

		return propMd;
	}

	protected _mergePropMd(...propMds: PropertyEditor.Options[]): PropertyEditor.Options {
		return lang.extend({}, ...propMds);
	}

	protected _createPage(pageInfo: EditorPage.Options): EditorPage | undefined {
		if (!pageInfo) {
			throw new Error("ObjectEditor: pageInfo wasn't specified");
		}

		let that = this,
			page = that._onCreatePage(pageInfo);

		if (!page) { return; }
		if (page.setObjectEditor) {
			page.setObjectEditor(that);
		} else {
			page.editor = that;
		}

		if (pageInfo.properties) {
			for (let prop of pageInfo.properties) {
				let propMd = that._getPropertyEditorMd(that.viewModel, prop);
				if (propMd) {
					page.editors[propMd.name] = that._createEditorForProp(page, propMd, that.viewModel);
				}
			}
		} else if (!pageInfo.template) {
			// auto create editor for ALL properties
			that._generateAllEditors(page);
		}

		// sections - additional grouping of PEs:
		that.initSections(page, pageInfo);

		that._doAddPage(page);

		return page;
	}

	protected initSections(page: EditorPage, pageInfo: EditorPage.Options) {
		let sectionsOpts = pageInfo.sections;
		if (sectionsOpts && sectionsOpts.length && page.editors) {
			let sections: EditorPage.Section[] = [];
			// пересортируем редакторы (pe) в editors так, чтобы они шли в порядке секций, а pe без секции первым
			let peToSection = {}; // pe's name to its section (contains only pe with section)
			// group editors by sections
			sectionsOpts.forEach((section) => {
				if (!section.name || !section.properties || !section.properties.length) return;
				section.properties.forEach(propRef => {
					peToSection[propRef] = section.name;
				});
			});
			//let editors = {}; // reordered page.editors
			let emptySection = new EditorPage.Section();
			// pe's w/o section first
			lang.forEach(page.editors, (pe, name) => {
				if (!peToSection[name]) {
					// pe without section
					emptySection.editors.push(pe);
				}
			});
			if (emptySection.editors.length) {
				sections.push(emptySection);
			}
			// then other w/section in the order of section -> section.properties
			sectionsOpts.forEach((sectionOpt) => {
				if (!sectionOpt.name) { return ; }
				let section = new EditorPage.Section(sectionOpt);
				sections.push(section);
				sectionOpt.properties.forEach(propRef => {
					let pe = page.editors[propRef];
					if (pe) {
						section.editors.push(pe);
					}
				});
				if (sectionOpt.autoHide) {
					// hide section when all its editors are hidden
					let allHidden = true;
					section.editors.forEach((pe) => {
						pe.bind("change:hidden", section.recalculateHidden, section);
						allHidden = allHidden && pe.hidden();
					});
					section.hidden(allHidden);
				}
			});
			page.sections = sections; // (new lang.ObservableCollection(sections));
		}
	}

	private _onCreatePage(pageInfo: EditorPage.Options): EditorPage | undefined {
		let that = this;
		pageInfo.contextName = that.contextName;
		let name = pageInfo.name;
		if (name) {
			// NOTE: page name will be used in DOM ids, it shouldn't contain spaces
			name = name.replace(/\s/gi, "_");
		} else {
			name = "page-" + (that.pages.count() + 1);
		}
		pageInfo.name = name;

		if (that.options.suppressAutoLoad) {
			pageInfo.presenterOptions = pageInfo.presenterOptions || {};
			pageInfo.presenterOptions.suppressAutoLoad = true;
		}
		return that.onCreatePage(pageInfo);
	}

	protected onCreatePage(pageInfo: EditorPage.Options): EditorPage | undefined {
		let onCreatePage = this.options.onCreatePage;
		if (onCreatePage) {
			let page = onCreatePage.call(this, pageInfo, this.viewModel);
			if (page) {
				return page;
			} else if (page === false) {
				return;
			}
		}
		let PageClass = lang.isFunction(pageInfo.Class) ? pageInfo.Class : EditorPage;
		return new PageClass(pageInfo, this.viewModel);
	}

	protected _doAddPage(page: EditorPage): void {
		let that = this,
			args: PageCreatedEventArgs = { page: page };
		that.onPageCreated(args);
		page = args.page;
		that.pages.add(page);
	}

	/**
	 * Create a default page in case when editor's options have no pages metadata.
	 * @protected
	 */
	protected _createDefaultPage(): EditorPage {
		let pageInfo = { name: "", title: ""};
		return this._createPage(pageInfo);
	}

	protected onPageCreated(args: PageCreatedEventArgs): void {
		this.trigger(Events.PAGE_CREATED, this, args);
	}

	protected _generateAllEditors(page: EditorPage): void {
		let that = this,
			viewModel = that.viewModel,
			meta = viewModel.meta;
		if (meta) {
			for (let propName in meta.props) {
				let propMd = meta.props[propName];
				if (propMd && !lang.isFunction(propMd)) {
					page.editors[propMd.name] = that._createEditorForProp(page, propMd, viewModel);
				}
			}
		}
	}

	protected _createEditorForProp(page: EditorPage, propMd: PropertyEditor.Options, viewModel: Model): PropertyEditor {
		let that = this,
			mixedPropMd = that._onCreatePropEditor(page, propMd, viewModel),
			propEditor = PropertyEditor.DefaultMapping.create(mixedPropMd, viewModel);

		propEditor.setNavigationService(page.navigationService);

		if (propEditor.userSettings) {
			that.userSettings.attach("pe_" + page.name + "_" + mixedPropMd.name, propEditor.userSettings);
		}
		return propEditor;
	}

	protected _onCreatePropEditor(page: EditorPage, propMd: PropertyEditor.Options, viewModel: Model): PropertyEditor.Options;
	protected _onCreatePropEditor(page: EditorPage, propMd: NavigationPropertyEditor.Options, viewModel: Model): PropertyEditor.Options {
		let that = this,
			mixedPropMd = lang.extend({}, propMd);

		mixedPropMd = that.onCreatePropEditor(page, mixedPropMd, viewModel) || mixedPropMd;

		// во вложенном редакторе редактор обратного свойств относительно того, откуда нас открыли - readonly
		if (propMd.opposite && that.editorContext.parentProp && that.editorContext.parentProp === propMd.opposite) {
			mixedPropMd.readOnly = true;
		}

		// set PE context option
		mixedPropMd.contextName = that.contextName;

		if (that.options.suppressAutoLoad) {
			mixedPropMd.presenterOptions = mixedPropMd.presenterOptions || {};
			mixedPropMd.presenterOptions.suppressAutoLoad = true;
		}

		return mixedPropMd;
	}

	protected onCreatePropEditor(page: EditorPage, propMeta: PropertyEditor.Options, viewModel: Model): PropertyEditor.Options {
		let onCreatePropEditor = this.options.onCreatePropEditor;
		if (onCreatePropEditor) {
			return onCreatePropEditor.call(this, page, propMeta, viewModel);
		}
		return propMeta;
	}

	/**
	 * @protected
	 * @returns {{SaveAndClose: (Command), Apply: (Command), CancelAndClose: (Command), SwitchToPage: (Command)}}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			cmdSaveClose = core.commands.createBoundCommand(that.doSaveAndClose, that.canSaveAndClose, that),
			cmdApply = core.commands.createBoundCommand(that.doApply, that.canApply, that),
			cmdCancel = core.createCommand({
				execute: () => { that.cancel(); },
				name: "CancelAndClose"
			}),
			cmdSwitchToPage = core.createCommand({
				execute: (args: PageCommandArgs) => { that.switchToPage(args.pageName); },
				name: "SwitchToPage"
			});

		return {
			SaveAndClose: cmdSaveClose,
			Apply: cmdApply,
			CancelAndClose: cmdCancel,
			SwitchToPage: cmdSwitchToPage
		};
	}

	findPropertyEditor(viewModel: Model, propName: string): ObjectEditor.FindPropertyEditorResult {
		for (let i = 0, l = this.pages.count(); i < l; i++) {
			let page = this.pages.get(i),
				pe = page.getPropertyEditor(propName, viewModel);
			if (pe)
				return {
					pe: pe,
					pageName: page.name
				};
		}
	}

	findPropertyEditorPage(propertyEditor: PropertyEditor): EditorPage {
		return this.pages.find(page => {
			let pe = page.getPropertyEditor(propertyEditor.viewModelProp, propertyEditor.viewModel);
			return pe && pe === propertyEditor;
		});
	}

	/**
	 * Executes 'iterator' function for each property editor of each page
	 * @param {Function} iterator
	 * @param {*} [context] this arguments for iterator
	 */
	forEachPE(iterator: (pe: PropertyEditor) => void, context?: any): void {
		this.pages.forEach(page => {
			lang.forEach(page.editors, pe => {
				iterator.call(context, pe);
			});
		});
	}

	/**
	 * Return array of descriptions of editor page.
	 * @param {EditorPage} page
	 * @returns {Array}
	 */
	getPageSummary(page: EditorPage): PropertyEditor.Summary[] {
		let summary: PropertyEditor.Summary[] = [];
		lang.forEach(page.editors, (pe) => {
			let viewModel = pe.viewModel,
				propTitle = pe.title(),
				propName = pe.viewModelProp,
				propMeta = viewModel.meta && viewModel.meta.props[propName],
				propVal;

			if (propMeta) {
				propTitle = propTitle || propMeta.descr;
				propVal = viewModel.getFormatted
					? viewModel.getFormatted(propName)
					: undefined;
			}

			if (propVal === undefined) {
				propVal = lang.get(viewModel, propName);
				if (propVal) {
					propVal = propVal.toString();
				}
			}

			if (propVal) {
				summary.push({
					title: propTitle || propName,
					value: propVal
				});
			}
		});
		return summary;
	}

	protected doSaveAndClose(args: FinishCommandArgs): Promisable<void> {
		return this.finish(args);
	}
	protected canSaveAndClose(): boolean {
		return this.canSave();
	}

	/**
	 * Run validation for object and all pages, then commit all changes (if it's root editor), then close.
	 * @param {Object} [cmdArgs] command arguments
	 * @param {boolean} [cmdArgs.createNext] if specified than an editor for creating a next new object will be opened
	 * @returns {Promise}
	 */
	finish(cmdArgs: FinishCommandArgs = {}): Promise<void> {
		let that = this,
			args: FinishingEventArgs = {
				cancel: false,
				cmdArgs: cmdArgs,
				promise: undefined
			};

		that.onFinishing(args);

		if (args.cancel) { return lang.rejected(); }
		if (args.promise && lang.isPromise(args.promise)) {
			return args.promise.then((result: boolean) => {
				if (result === false) { return lang.rejected(); }
				if (that.isDisposed) { return lang.rejected(); }

				return that._finish2(cmdArgs);
			});
		}

		return that._finish2(cmdArgs);
	}

	protected _finish2(cmdArgs: FinishCommandArgs): Promise<void> {
		let that = this;
		// NOTE: ContextPartComponentMixin._validateBeforeSave will call our runValidation
		return that._validateBeforeSave().then(() => {

			let args: AcceptingEventArgs = {
				reason: that._isIsolated ? "saveAndClose" : "close",
				cmdArgs: cmdArgs,
				cancel: false,
				promise: undefined
			};
			that.onAccepting(args);
			if (args.cancel) { return lang.rejected(); }
			if (args.promise && lang.isPromise(args.promise)) {
				return args.promise.then((result: boolean) => {
					if (result === false) { return lang.rejected(); }
					if (that.isDisposed) { return lang.rejected(); }

					return that._finish3(cmdArgs);
				});
			}
			return that._finish3(cmdArgs);
		});
	}
	protected _finish3(cmdArgs: FinishCommandArgs): boolean|Promise<void> {
		let that = this;
		let res: boolean|Promise<void>;
		if (that._isIsolated) {
			// saving in root context:
			res = that._saveChanges(cmdArgs);
		} else {
			that.onAcceptState();
			that._close(cmdArgs);
			res = true;
		}
		that.onFinished({ result: res });
		return res;
	}

	protected doApply(args: ApplyCommandArgs): Promise<void> {
		return this.save(args ? args.async : false);
	}
	protected canApply(): boolean {
		return this.canSave();
	}

	protected canSave(): boolean {
		// TODO: если это создание нового, то пока объект пустой, сохранить/Ок заблокировано
		// TODO: если при сохранении возникла ошибка и объект удален, то сохранение заблокировано
		// && this.get("viewModel").get("uow").hasChanges();

		if (this._isIsolated && this.saving()) { return false; }
		let obj = this.viewModel;
		if (lang.get(obj, "isRemoved") || lang.get(obj, "isInvalid")) { return false; }
		return true;

		// WAS: return !this._isIsolated || !this.saving();
	}

	/**
	 * Save changes ("Apply")
	 * @param {Boolean} [isAsync=false] 'true' for non blocking save
	 * @returns {jQuery.Promise}
	 */
	save(isAsync?: boolean): Promise<void> {
		let that = this;
		// saving in root context
		if (!that._isIsolated) {
			return lang.rejected();
		}

		// NOTE: ContextPartComponentMixin._validateBeforeSave will call our runValidation
		return that._validateBeforeSave().then(() => {
			let args: AcceptingEventArgs = {
				reason: "save",
				cancel: false,
				promise: undefined
			};
			that.onAccepting(args);
			if (args.cancel) { return lang.rejected(); }
			if (that.isDisposed) { return lang.rejected(); }

			if (args.promise && lang.isPromise(args.promise)) {
				return args.promise.then((result: boolean) => {
					if (result === false) { return lang.rejected(); }
					if (that.isDisposed) { return lang.rejected(); }

					return that._save2(isAsync);
				});
			}
			return that._save2(isAsync);
		});
	}

	protected _save2(isAsync: boolean): Promise<void> {
		let that = this,
			args: SavingEventArgs = {};
		that.onSaving(args);
		if (args.cancel) { return lang.rejected(); }

		that.saving(true);
		that._disposeParts();

		if (!isAsync) {
			that.isBusy(true);
		}
		let saveOptions = { onError: that._onSyncSaveError.bind(that) };
		return that.doSave(saveOptions)
			.always(() => {
				if (that.isDisposed) { return; }

				that.saving(false);
				if (!isAsync) {
					that.isBusy(false);
				}
			})
			.then(() => {
				if (that.isDisposed) { return; }
				that.onSaved({blockingSave: !isAsync});
			});
	}

	protected onAccepting(args: AcceptingEventArgs): void {
		this.trigger(Events.ACCEPTING, this, args);
	}
	protected onFinishing(args: FinishingEventArgs): void {
		this.trigger(Events.FINISHING, this, args);
	}
	protected onFinished(args: FinishedEventArgs): void {
		this.trigger(Events.FINISHED, this, args);
	}

	protected onSaving(args: SavingEventArgs): void {
		this.trigger(Events.SAVING, this, args);
	}
	protected onSaved(args: SavedEventArgs): void {
		this.trigger(Events.SAVED, this, args);
	}

	protected onSaveError(args: { objects: DomainObjectData[]; error: Error }): void {
		this.trigger(Events.SAVE_ERROR, this, args);
	}

	protected _close(cmdArgs: FinishCommandArgs): Promisable<any> {
		let that = this;
		if (cmdArgs && cmdArgs.skipClose) {
			return;
		}
		if (cmdArgs && cmdArgs.createNext) {
			return that.navigationService.replace({
				part: that.name,
				partOptions: that._originalOptions
			});
		} else {
			return that.navigationService.close(that.getCloseResult({object: that.viewModel, success: true}));
		}
	}

	protected _leave(success: boolean|Promise<void>, cmdArgs: FinishCommandArgs): Promise<void> {
		let that = this;
		if (cmdArgs && cmdArgs.skipClose) {
			return lang.rejected();
		}
		return that.navigationService.leave(that.getCloseResult({
			object: that.viewModel,
			success: success
		}));
	}

	protected _saveChanges(cmdArgs: FinishCommandArgs = {}): Promise<void> {
		let that = this,
			args: SavingEventArgs = {
				// NOTE: SaveAndCreate mode won't work without blockingSave=true
				blockingSave: lang.coalesce(cmdArgs.blockingSave, that.options.blockingSave, cmdArgs.createNext),
				onAsyncError: that._onAsyncSaveError.bind(that),
				onSyncError: that._onSyncSaveError.bind(that),
				cancel: undefined
			};
		that.onSaving(args);
		if (args.cancel) { return lang.rejected(); }

		that._disposeParts();
		that.saving(true);

		let saveOptions: UnitOfWork.SaveOptions = {},
			promiseSave: Promise<void>;
		if (args.blockingSave) {
			that.isBusy(true);
			saveOptions.onError = args.onSyncError;
			saveOptions.interop = {suppressProcessEvent: true};
			promiseSave = lang.when(that.doSave(saveOptions))
				.always(() => {
					if (that.isDisposed) { return; }
					that.saving(false);
					that.isBusy(false);
				}).then(() => {
					if (that.isDisposed) { return; }
					that.onSaved({blockingSave: true});
					that._close(cmdArgs);
				});
			// NOTE: we're NOT closing the editor here
		} else {
			let deferredSave = lang.deferred<void>();
			promiseSave = deferredSave.promise();

			// NOTE: Сначала закрываем редактор, а затем запускаем сохранение. В противном случае могут
			// возникнуть проблемы, если сохранение завершилось синхронно. Например, если при ошибке в процессе
			// синхронного сохранения успели выполнить команду "Вернуться к редактированию", то редактор
			// все равно будет закрыт.
			let promiseLeave = that._leave(promiseSave, cmdArgs);
			saveOptions.onError = args.onAsyncError;
			lang.when(that.doSave(saveOptions))
				.done(() => {
					that.saving(false);
					that.onSaved({blockingSave: false});
					deferredSave.resolve();
				}).fail((err) => {
					that.saving(false);
					deferredSave.reject(err);
				});

			// уничтожаем редактор только после того, как мы ушли из него и сохранение успешно завершилось
			lang.when<any>(promiseSave, promiseLeave).then(() => {
				// уничтожаем редактор
				that._disposeInner();
			});
		}

		return promiseSave;
	}

	protected doSave(saveOptions?: UnitOfWork.SaveOptions): Promise<UnitOfWork.SaveResult>  {
		// NOTE: this method must not throw any exception
		try {
			return this.viewModel.uow.save(saveOptions);
		} catch (ex) {
			this.traceSource.error(ex);
			return lang.rejected(ex);
		}
	}

	protected _onConcurrencyError(error: OptimisticConcurrencyException): void {
		let that = this,
			type = that.viewModel.meta.name,
			id = that.viewModel.id,
			deletedIdentities = error.deletedObjects,
			isRootDeleted = lang.some(deletedIdentities,
				// todo: remove objectID , left for backward compatibility
				(deletedObject: ObjectIdentity) => deletedObject.type === type && (deletedObject.id === id || deletedObject.objectID === id)),
			errorPart;

		if (isRootDeleted) {
			// root object deleted. we can't resolve this - show blocking error: "Saving and continuing working with data are impossible."
			errorPart = new ViolationInfoPart({
				message: error.message +
					(lang.stringEndsWith(error.message, ".") ? " " : ". ") +
					resources["interop.error.save_conflict_critical"],
				severity: "critical"
			});

		} else if (error.obsoleteObjects && error.obsoleteObjects.length) {
			// if root object is not deleted and there're obsolete objects - try resolve
			errorPart = new ConcurrencyErrorPart({
				editor: that,
				error: error
			});
			errorPart.promise.done(() => {
				that.closeContextPart(errorPart);
			});
		} else if (deletedIdentities && deletedIdentities.length) {
			// NOTE: устаревших объектов нет, но есть устаревшие-удаленные и это не корневой объект,
			// объекты из deletedObjects будут помечены как invalid в результате завершения обработки (см. UoW._onSaveFailed).
			// Если есть другие изменения в UoW, то можно повторить сохранение, оно уже выполнится без invalid-объектов,
			// правда ссылки на них остануться. Но если это старые ссылки, то на сервере их уже нет.
			// Если это новые локальные ссылки (изменные значения свойств), то при сохранении будут новые ошибки.

			// Если мы просто удалим invalid-объекты, то все свойства с ссылками на них станут модифицированными,
			// и при следующем сохранении объекты-владельцы этих свойств вызовут OptimisticConcurrency, т.к. ts у них остались старые.

			// Поэтому сначала мы перезагрузим все объекты со ссылками на invalid-объекты (из deletedObjects).
			// После этого могут остаться только локальные (несохраненые) ссылки. Они уже невалидны.
			// И после этого удалим всё со ссылками.
			that.viewModel.uow.purgeWithCascade(deletedIdentities);
			// prevent default handing in UoW._onSaveFailed as we've removed and detached all objects already
			error.deletedObjects = null;
			error.serverError.deletedObjects = null;	// todo: remove

			errorPart = new ViolationInfoPart({
				message: resources["interop.error.save_conflict_partial"],
				severity: "critical"
			});

			// no obsolete objects only obsolete-deleted (but not the root),
			// "(Объект <> удален | Объекты <..> удалены) на сервере, их сохранение невозможно.
			// Если вы выполнили другие изменения, нажмите Сохранить для повтора."
		} else {
			// just in case
			errorPart = new ViolationInfoPart({
				message: error.message,
				severity: "critical"
			});
		}
		that.contextParts.add(errorPart);
	}

	protected _onSyncSaveError(args: UnitOfWork.SaveErrorArgs): void {
		let that = this,
			error: InteropError = args.error;

		// NOTE: в принципе saving/isBusy сбрасываются в continuation промиса от UoW.save,
		// но данный метод вызывается раньше, т.к. он передается как опция onError для UoW.save
		// поэтому сбросим тут, чтобы как можно раньше.
		that.saving(false);
		that.isBusy(false);

		if (core.eth.isOptimisticConcurrency(error)) {
			// process concurrency error
			that._onConcurrencyError(error);
		} else {
			// defer which we're passing into createSaveErrorEvent can be used in event's commands
			let event = that.app.dataFacade.createSaveErrorEvent(error, args.options, args.objects);

			let part = that.createSaveErrorInfoPart(args, event);
			if (part) {
				that.contextParts.add(part);
			}
		}

		// return control to Uow.save - complete: rejecting with the error - it'll reject promise returned from uow.save
		args.complete();

		that.onSaveError(args);
	}

	protected createSaveErrorInfoPart(args: UnitOfWork.SaveErrorArgs, event: core.SystemEvent): ViolationInfoPart {
		let part = new ViolationInfoPart({
			message: event.message,
			menu: event.menu,
			persistent: true
		});
		// extract violation from server exception
		let violations = (event.error as BusinessLogicException).violations;
		if (violations && violations.length) {
			// TODO: почему берется первый violation? Надо для каждого создать парт.
			// in server violation object is identity (type/id), we need DomainObject
			let violation = violations[0];
			if (this.viewModel && this.viewModel.uow && violation.object) {
				if (this.viewModel.meta.name === violation.object.type &&
					this.viewModel.id === violation.object.id) {
					violation.object = this.viewModel;
				} else {
					violation.object = this.viewModel.uow.find(violation.object.type, violation.object.id);
				}
				this._normalizeViolationArray([violation]);
				part.violation = violation;
			}
		}

		// при выполнении любой команды из меню (if any), надо закрыть парт
		event.menu.onceExecuted(() => {
			this.closeContextPart(part);
		});

		return part;
	}

	protected _onAsyncSaveError(args: UnitOfWork.SaveErrorArgs): void {
		let that = this,
			event = that.createAsyncSaveErrorEvent(args);

		if (event) {
			window.setTimeout(() => {
				that.app.eventPublisher.publish("interop.save.error", event);
			});
		} else {
			args.complete();
		}
	}

	/**
	 * Create an event object for publishing via EventPublisher.
	 * @param {Object} args
	 * @param {Object} args.error
	 * @param {Object} args.options
	 * @param {Object} args.objects Json object which were passed in dataFacade.save from UnitOfWork.save
	 * @param {Object} args.states
	 * @param {Object} args.deferred
	 * @param {Function} args.complete Function to call for completion of save operation. This will signal (resolve/reject) on promise returned by UnitOfWork.save
	 * @param {Function} args.resolve UnitOfWork's success handler
	 * @param {Function} args.reject UnitOfWork's error handler
	 * @returns {Object} Event object
	 */
	createAsyncSaveErrorEvent(args: UnitOfWork.SaveErrorArgs): SystemEvent {
		let that = this,
			states: string[] = args.states,
			event = that.app.dataFacade.createSaveErrorEvent(args.error, args.options, args.objects);
		event.kind = core.SystemEvent.Kind.actionRequest;

		let menu: Menu.Options = { items: [
			{
				name: "ReturnToEdit",
				title: resources["objectEditor.return_to_edit"],
				icon: "edit",
				command: core.createCommand({
					execute: function (): void {
						// let's open the same editor instance
						that.navigationService
							.navigate({ part: that })
							.done(() => {
								that._onSyncSaveError(args);
							});
					}
				})
			}, {
				name: "Cancel",
				title: resources["cancel"],
				command: core.createCommand({
					execute: function (): void {
						args.complete();

						// откатываем все состояния, кроме последнего (оно содержит изменения, сделанные во время сохранения)
						if (states && lang.isArray(states)) {
							states.forEach((state, i) => {
								if (i < states.length - 1) {
									that.viewModel.uow.rollbackState(state);
								}
							});
						}

						// уничтожаем редактор
						that._disposeInner();
					}
				})
			}
		]};
		event.menu.mergeWith(menu);
		return event;
	}

	cancel(): void {
		// NOTE: rollback will be done on dispose
		this.navigationService.close(this.getCloseResult({success: false}));
	}

	protected onSaveState(uow: UnitOfWork): void {
		let that = this,
			uowStateName = that.options.uowStateName;
		uow = uow || (that.viewModel && that.viewModel.uow);
		if (uow && !that.options.skipSaveState) {
			if (!uowStateName) {
				// если имя состояния uow не задано, то используем сгенерированное uow
				that._uowStateName = uow.saveState();
			} else {
				// иначе создаем именованное состояние, но только если оно уже не было создано ранее
				that._uowStateName = uow.hasState(uowStateName) ? uowStateName : uow.saveState(uowStateName);
			}
		}
	}
	protected onRollbackState(): void {
		let that = this,
			uow = that.viewModel && that.viewModel.uow;
		if (uow && that._uowStateName) {
			// NOTE: if UoW has no such state it will do nothing
			uow.rollbackState(that._uowStateName);
			delete that._uowStateName;
		}
	}
	protected onAcceptState(): void {
		let that = this,
			uow = that.viewModel && that.viewModel.uow;
		if (uow && that._uowStateName) {
			// NOTE: if UoW has no such state it will do nothing
			uow.acceptState(that._uowStateName);
			delete that._uowStateName;
		}
	}

	protected _renderError(domElement: JQuery|HTMLElement, msg: string): void {
		let that = this;
		that._errorView = new View({
			template: fatalErrorTemplate,
			unbound: true,
			viewModel: {
				title: that.title,
				message: msg,
				CloseCommand: core.createCommand({
					execute: () => { that.navigationService.close(that.getCloseResult({ success: false })); }
				})
			}
		});
		that._errorView.render(domElement);
		that.reportState(/*replaceState*/false);
	}

	protected _setError(domElement: JQuery|HTMLElement, error: string): void {
		let that = this;
		that.error = error;
		that.$domElement = $(domElement);
		that.domElement = that.$domElement[0];
		that._renderError(domElement, error);
	}

	protected doRender(domElement: JQuery|HTMLElement): Promisable<void> {
		let that = this;
		if (core.lang.isPromise(that.initializationTask) && that.initializationTask.state() === "pending") {
			return super.doRender(domElement);
		}
		return that._render(domElement);
	}

	protected _render(domElement: JQuery|HTMLElement): Promisable<void> {
		let that = this;

		if (that.error) {
			that._renderError(domElement, that.error);
			return lang.rejected();
		}
		if (!that.viewModel) {
			that._setError(domElement, "No viewModel was defined for ObjectEditor");
			return lang.rejected();
		}
		if (!that.pages || that.pages.count() === 0) {
			that._setError(domElement, "No pages were defined for ObjectEditor");
			return lang.rejected();
		}

		let firstPageToShow = that.currentPage() || that.pages.find(p => !p.hidden());
		if (!firstPageToShow) {
			that._setError(domElement, "No visible pages were defined for ObjectEditor");
			return lang.rejected();
		}

		if (that.app.dataFacade) {
			that.app.dataFacade.beginBatch();
		}

		super.doRender(domElement);

		let task = that._activatePage(firstPageToShow);
		return task.always(() => {
			if (that.app.dataFacade) {
				that.app.dataFacade.completeBatch();
			}
		});
	}

	getPageByName(name: string): EditorPage {
		return this.pages.find(page => page.name === name);
	}

	/**
	 * удаляет из текущего набора нарушений, нарушения связанные с указанной страницей
	 * @param {Array|EditorPage|Object} pages - массив экземпляров EditorPage или метаданных страниц
	 * @protected
	 */
	protected _removePageViolations(pages: EditorPage|EditorPage[]): void {
		if (!pages) { return; }

		let that = this,
			pageArray = lang.array(pages),
			violationsToRemove = that.violations.all().filter(v => {
				return pageArray.some(page => v.pageName === page.name);
			});
		that.violations.remove(violationsToRemove);
	}

	/**
	 * Run validation.
	 * @param {EditorPage} [page] a page to validate, can be empty when validating on closing (that means we're validating all pages)
	 * @return {Array} An array with violations
	 */
	runValidation(page?: EditorPage): Violation[] {
		let that = this,
			violations: Violation[] = that._validate(page),
			violationsOnOtherPages: Violation[];

		that._triggerPropsViolationEvents(violations, page || that.currentPage());

		if (page) {
			// если валидация идет по странице (такое происходит только при навигации по вкладкам в режимах loose & strict) -
			// нужно удалить все нарушения по этой странице
			// все прошлые нарушения кроме нарушений по валидируемой странице
			violationsOnOtherPages = that.violations.all().filter((v) => v.pageName !== page.name);
		}

		if (violations && violations.length) {
			if (page) {
				// из новых нарушений отфильтровываем только те, которые относятся к проверяемой странице
				violations = that._filterPagesViolations(violations, page.name);
				// общий скоуп
				violations = violations.concat(violationsOnOtherPages);
			}
			// сортировка по номеру страницы
			violations = that._sortViolations(violations);
			that.violations.reset(violations);
		}
		else {
			// нарушений нет
			if (page) {
				// тогда нужно убрать из общего списка нарушения по этой странице (если есть)
				that.violations.reset(violationsOnOtherPages);
			} else {
				// в случае общей валидации - просто очищаем
				that.violations.clear();
			}
		}
		return violations || [];
	}

	protected _validate(page?: EditorPage): Violation[] {
		let that = this;

		that.onValidating({ page: page });

		// 1. validate each PropertyEditor from all pages or a particular one
		let violations: Violation[];
		if (page) {
			violations = that._validatePage(page);
		} else if (that.pages.count() > 0) {
			that.pages.forEach(page => {
				violations = that._validatePage(page, violations);
			});
		}

		// 2. validate object (WITHOUT props) and get all its errors (if any)
		let violationsObj: Violation[] = validation.validateObject(that.viewModel);
		if (violationsObj && violationsObj.length) {
			violations = validation.appendViolation(violationsObj, violations);
		}

		// 3. call editor's rules/validators and get all its errors
		if (that.rules) {
			for (let rule of that.rules) {
				let violation = rule.validate(that.viewModel);
				if (violation) {
					violations = validation.appendViolation(violation, violations);
				}
			}
		}

		let args = { page: page, result: violations };
		that.onValidated(args);
		violations = args.result;

		// normalize violation objects
		that._normalizeViolationArray(violations);

		return violations;
	}

	protected _validatePage(page: EditorPage, violations?: Violation[]): Violation[] {
		let violationsNew: Violation[] = page.runValidation();

		if (violationsNew && violationsNew.length) {
			if (violations && violations.length) {
				violations = violations.concat(violationsNew);
			} else {
				violations = violationsNew;
			}
		}
		return violations;
	}

	/**
	 * Handles PropertyEditor.violation changes.
	 * @param {PropertyEditor} pe
	 * @param {Violation} newVal
	 * @param {Violation} oldVal
	 * @private
	 */
	protected _onPEViolationChanged(pe: PropertyEditor, newVal: Violation, oldVal: Violation): void {
		let that = this,
			violations: Violation[];

		//  we should remove previous violation
		if (oldVal) {
			if (!oldVal.pageName) {
				let page = that.findPropertyEditorPage(pe);
				if (page) {
					oldVal.pageName = page.name;
				}
			}
			if (oldVal.props && oldVal.props.length > 1) {
				// if the old violation is multi-prop, then we should clear other PEs
				for (let p of oldVal.props) {
					if (p === pe.viewModelProp) { continue; }

					let otherPE = that.findPropertyEditor(pe.viewModel, p);
					if (otherPE && otherPE.pe.violation() === oldVal) {
						// here's a tricky point: when we're setting violation(null) for the other PE _onPEViolationChanged will fire again with the same violation as oldVal
						otherPE.pe.violation(null);
					}
				}
			}
			violations = that.violations.all().filter(v => !lang.isEqual(v, oldVal));
		}
		// add the new violation
		if (newVal) {
			if (!newVal.pageName) {
				let page = that.findPropertyEditorPage(pe);
				if (page) {
					newVal.pageName = page.name;
				}
			}
			if (newVal.props && newVal.props.length > 1) {
				// if the new violation is multi-prop, then we should set it for other PEs
				for (let p of newVal.props) {
					if (p === pe.viewModelProp) { continue; }

					let otherPE = that.findPropertyEditor(pe.viewModel, p);
					if (otherPE && otherPE.pe.violation() !== newVal) {
						otherPE.pe.violation(newVal);
					}
				}
			}

			if (!violations) {
				violations = that.violations.all().slice(0);
			}
			violations.push(newVal);
		}

		if (violations) {
			violations = that._sortViolations(violations);
			that.violations.reset(violations);
		}
	}

	protected _sortViolations(violations: Violation[]): Violation[] {
		let that = this,
			pages = that.pages.all();
		return lang.sort(violations, (v1, v2) => {
			if (!v1.pageName && !v2.pageName) { return 0; }
			if (!v1.pageName) { return 1; }
			if (!v2.pageName) { return -1; }
			return pages.indexOf(that.getPageByName(v1.pageName)) -
				pages.indexOf(that.getPageByName(v2.pageName));
		});
	}

	protected onValidating(args: ValidatingEventArgs): void {
		this.trigger(Events.VALIDATING, this, args);
	}
	protected onValidated(args: ValidatedEventArgs): void {
		this.trigger(Events.VALIDATED, this, args);
	}

	protected _normalizeViolationArray(violations: (Violation|string)[]): void {
		if (!lang.isArray(violations)) { return; }

		// NOTE: по идее строк в массиве уже не может быть
		for (let i = 0; i < violations.length; ++i) {
			let item = violations[i],
				violation: Violation;
			if (lang.isString(item)) {
				violations[i] = violation = { error: item };
			} else {
				violation = item;
			}
			let pageName: string;
			if (!violation.pageName && (pageName = this._tryFindViolationPageName(violation))) {
				violation.pageName = pageName;
			}
		}
	}

	/**
	 * Фильтрует переданынй массив нарушений и возвращает массив нарушений страниц, т.е. нарушения,
	 * у которых указано имя страницы (pageName), либо в редакторе объекта
	 * для нарушения в свойстве объекта можно найти редактор свойства.
	 * @param {Array} violations - массив объектов нарушений
	 * с нарушениями (для того, что бы их можно было отнести к нарушениям страницы)
	 * @param {String} [pageName]
	 */
	protected _filterPagesViolations(violations: Violation[], pageName?: string): Violation[] {
		let that = this,
			pagesViolations: Violation[] = [];

		if (violations) {
			for (let violation of violations) {
				if (violation.pageName && (!pageName || violation.pageName === pageName)) {
					pagesViolations.push(violation);
				} else {
					let violationPageName = that._tryFindViolationPageName(violation);
					if (violationPageName && (!pageName || violationPageName === pageName)) {
						violation.pageName = violationPageName;
						pagesViolations.push(violation);
					}
				}
			}
		}
		return pagesViolations;
	}

	protected _tryFindViolationPageName(violation: Violation): string {
		if (violation.object && violation.props && violation.props.length > 0) {
			let pe = this.findPropertyEditor(violation.object, violation.props[0]);
			if (pe) {
				return pe.pageName;
			}
		}
	}

	protected _bindPropEditorViolationChanged(page: EditorPage): void {
		if (!page) { return; }
		lang.forEach(page.editors, pe => {
			pe.bind("change:violation", this._onPEViolationChanged, this);
		});
	}

	protected _unbindPropEditorViolationChanged(page: EditorPage): void {
		if (!page) { return; }
		lang.forEach(page.editors, pe => {
			pe.unbind("change:violation", null, this);
		});
	}

	/**
	 * Сгенерировать в доменных объектах при наличии нарушений у свойств события "error:{propName}"
	 * На данные события подписываются редакторы свойств (см. PropertyEditor) для отображения статуса "ошибка".
	 * @param {Array} violations - array of violations
	 * @param {EditorPage} [page] - события генерируются только для нарушений на указанной странице
	 * @private
	 */
	protected _triggerPropsViolationEvents(violations: Violation[], page?: EditorPage): void {
		if (!violations) { return; }

		for (let v of violations) {
			if ((!page || v.pageName === page.name) && v.object && v.props && v.props.length) {
				for (let propName of v.props) {
					v.object.trigger("error:" + propName, v);
				}
			}
		}
	}

	/**
	 * Change current page onto a new one
	 * @param {EditorPage} page New page to go to
	 * @param {Boolean} [skipValidation=false] if true then there will be no validation for the current page
	 * @returns {$.Deferred.promise} resolved - page was changed, otherwise - rejected
	 */
	setCurrentPage(page: EditorPage, skipValidation?: boolean): Promise<void> {
		let that = this,
			oldPage = that.currentPage();

		if (oldPage === page) { return lang.rejected<void>(); }

		return lang.when(that._pageSwitching(oldPage, page)).then(() => {
			let deactivateTask: Promisable<void>;
			if (oldPage) {
				// validating page on leaving
				if (!skipValidation && that.options.pageValidation !== "none") {

					let violations = that.runValidation(oldPage);

					// in 'strict' mode preventing page leaving if there are any errors on it
					if (that.options.pageValidation === "strict") {
						let pageViolations = that._filterPagesViolations(violations, oldPage.name);
						if (that._hasValidationErrors(pageViolations)) {
							return lang.rejected();
						}
					}
				}
				that._pageUnloading(oldPage);
				deactivateTask = lang.when(that._deactivatePage(oldPage))
					.then(() => { that._pageUnloaded(oldPage); });
				//deactivateTask = that._deactivatePage(oldPage);
			}
			if (page) {
				return lang.when(deactivateTask)
					.then(() => that._activatePage(page))
					.done(() => { that.reportState(/*replaceState*/false); });
			}
			return lang.resolved();
		});
	}

	protected _activatePage(page: EditorPage): Promise<void> {
		let that = this,
			task: Promisable<void>;

		that.traceSource.debug("ObjectEditor._activatePage");
		page.setNavigationService(that.navigationService);
		that.currentPage(page);
		that._pageStarting(page);
		if (that.presenter.activatePage) {
			task = that.presenter.activatePage(page);
		}

		return lang.async.then(task, () => {
			that._pageStarted(page);
			// If the current page has errors then signal its PEs so they can render error statuses.
			// (errors could be due to previous checking on the page leaving in not 'none' mode or as result of Save)
			if (page.hasViolations()) {
				that._triggerPropsViolationEvents(that.violations.all(), page);
			}
			that._bindPropEditorViolationChanged(page);
			return lang.resolved();
		});
	}

	protected _deactivatePage(page: EditorPage): Promise<void> {
		let that = this,
			task: Promisable<void>;

		if (that.presenter.deactivatePage) {
			task = that.presenter.deactivatePage(page);
		}
		return lang.when(task).done(() => {
			that._unbindPropEditorViolationChanged(page);
			page.unload();
		});
	}

	private _pageSwitching(oldPage: EditorPage, newPage: EditorPage): Promise<void> {
		let args: PageSwitchingEventArgs = {
				pageFrom: oldPage,
				pageTo: newPage,
				cancel: false,
				defer: undefined
			};
		this.onPageSwitching(args);
		if (args.cancel) { return lang.rejected(); }
		return args.defer || lang.resolved();
	}
	protected onPageSwitching(args: PageSwitchingEventArgs): void {
		this.trigger(Events.PAGE_SWITCHING, this, args);
	}

	private _pageUnloading(oldPage: EditorPage): void {
		let args: PageEventArgs = { page: oldPage, index: this.pages.indexOf(oldPage) };
		this.onPageUnloading(args);
		if (oldPage.onUnloading) {
			oldPage.onUnloading();
		}
	}
	protected onPageUnloading(args: PageEventArgs): void {
		this.trigger(Events.PAGE_UNLOADING, this, args);
	}

	private _pageUnloaded(page: EditorPage): void {
		let args: PageEventArgs = { page: page, index: this.pages.indexOf(page) };
		this.onPageUnloaded(args);
		if (page.onUnloaded) {
			page.onUnloaded();
		}
	}
	protected onPageUnloaded(args: PageEventArgs): void {
		this.trigger(Events.PAGE_UNLOADED, this, args);
	}

	private _pageStarting(page: EditorPage): void {
		let args: PageEventArgs = { page: page, index: this.pages.indexOf(page) };
		this.onPageStarting(args);
		if (page.onStarting) {
			page.onStarting();
		}
	}
	protected onPageStarting(args: PageEventArgs): void {
		this.trigger(Events.PAGE_STARTING, this, args);
	}

	private _pageStarted(page: EditorPage): void {
		let args: PageEventArgs = { page: page, index: this.pages.indexOf(page) };
		this.onPageStarted(args);
		if (page.onStarted) {
			page.onStarted();
		}
	}
	protected onPageStarted(args: PageEventArgs): void {
		this.trigger(Events.PAGE_STARTED, this, args);
	}

	/**
	 * Switch to a page with specified name
	 * @param {string} name a page name
	 * @returns {JQueryPromise}
	 */
	switchToPage(name: string): Promise<void> {
		let page = this.getPageByName(name);
		if (page) {
			return this.setCurrentPage(page, /*skipValidation=*/ false);
		}
		return lang.rejected();
	}

	queryUnload(options?: PartCloseOptions): Promisable<string> {
		if (this.error) { return; }

		let reason = super.queryUnload(options);
		if (reason) {
			return reason;
		}

		let reasons = this.pages.all()
			.map(page => {
				if (typeof page.queryUnload === "function") {
					return page.queryUnload(options);
				}
			})
			.filter(reason => !!reason);
		if (reasons.length > 0) {
			return reasons[0];
		}
		return this.onQueryUnload(options);
	}

	protected onQueryUnload(options: PartCloseOptions): Promisable<string> {
		let that = this,
			args: QueryUnloadEventArgs = { editor: that, preventingReason: undefined };
		that.trigger(that.events.QUERY_UNLOAD, that, args);
		if (args.preventingReason) {
			return args.preventingReason;
		}

		if (that.viewModel && that.viewModel.uow && !that.saving()) {
			/*if (!that.viewModel.uow.hasChangesSince(that._uowStateName)) {
			 return false;
			 }*/
			let changes = that.viewModel.uow.getChanges();
			if (that._hasMeaningfulChanges(changes)) {
				return that.onQueryUnloadWithChanges(options);
			}
		}
	}

	protected _hasMeaningfulChanges(changes: DomainObjectData[]): boolean {
		if (!changes || changes.length === 0) {
			return false;
		}
		// objects with something more that just 'id' and '__metadata' (we expect they always exist):
		return lang.some(changes, obj => Object.keys(obj).length > 2);
	}

	protected onQueryUnloadWithChanges(options: PartCloseOptions): Promise<string> {
		let dialog = new ConfirmDialog({
				header: this.title,
				text: resources["objectEditor.query_unload_prompt"]
			});
		return dialog.open().then(result => {
			if (result === "no") {
				return resources["closing_canceled"];
			}
		});
	}

	unload(options?: PartCloseOptions): void {
		let that = this;
		if (!that.domElement) { return; } // already unloaded

		if (that.error) {
			super.unload(options);
			return;
		}

		let oldPage = that.currentPage();
		if (oldPage) {
			that._pageUnloading(oldPage);
			that._unbindPropEditorViolationChanged(oldPage);
			that.pages.forEach(page => {
				if (lang.isFunction(page.unload)) {
					page.unload(options);
				}
			});
			that._pageUnloaded(oldPage);
		}

		// NOTE: All pages must be unloaded first. Otherwise base method will clear DOM, but some PE use their DOM
		// element when unloading (e.g. peSlickObjectListPresenter detaches DOM element on unload and reinsert it
		// on render).
		super.unload(options);

		that.onUnloaded(options);
	}
	protected onUnloaded(options?: PartCloseOptions): void {
		this.trigger(Events.UNLOADED, this, options);
	}

	protected _disposeInner(): void {
		this.dispose({ reason: "close" });
	}

	protected _disposeUow(uow: UnitOfWork): void {
		if (!uow) { return; }

		let that = this;
		uow.unbind("detach", null, that);
		if (that._ownUow) {
			uow.dispose();
			that._ownUow = undefined;
		}
	}

	dispose(options?: PartCloseOptions): void {
		let that = this;

		if (that.saving()) {
			that.traceSource.error("Disposing editor while saving");
		}
		if (that.isDisposed) { return; }

		options = options || {};
		that.onDisposed(options);

		// NOTE: base `dispose` calls `unload` which unloads all pages,
		// so we can't relate on base dispose at the end (as page.unload would be called for disposed objects),
		// and we can't call base dispose here as it clears viewModel (
		if (that.domElement) {
			that.unload({reason: "dispose"});
		}
		// NOTE: base `dispose` calls presenter's dispose (see Component.dispose),
		// but presenter ObjectWizardStackedPresenter uses viewModel/pages to unsubscribe, so we should dispose it first
		that.disposePresenter();

		if (that.pages) {
			that.pages.forEach(page => {
				if (lang.isFunction(page.dispose)) {
					page.dispose(options);
				}
			});
			that.pages.dispose();
			that.pages = undefined;
		}

		that.violations.unbind("change", null, that);
		that.violations.dispose();

		if (that._errorView) {
			that._errorView.dispose();
		}

		that._disposeParts();
		that.contextParts.dispose();

		// NOTE: rollback should be done after disposing pages and other. Otherwise UI may be updated during rollback.
		that.onRollbackState();
		that._disposeUow(that._ownUow);

		super.dispose(options);
	}

	protected onDisposed(options: PartCloseOptions): void {
		let that = this;
		if (that.error) { return; }
		that.trigger(that.events.DISPOSED, that, options);
	}

	getTextPresentation(): string {
		return this.title + "\n" + this.viewModel.toString();

		/*that.pages.all().forEach(function (page) {
			if (page.getTextPresentation) {
				text += page.getTextPresentation();
			}
			text += "\n";
		});*/
	}
}

interface ObjectEditor extends PartCommandMixin, ContextPartComponentMixin { }

ObjectEditor.mixin({
	defaultOptions: ObjectEditor.defaultOptions,
	contextDefaultOptions: ObjectEditor.hostDefaultOptions
});

// mix methods from PartCommandMixin
PartCommandMixin.mixinTo(ObjectEditor);

ObjectEditor.mixin(ContextPartComponentMixin);

namespace ObjectEditor {
	export interface Options extends Component.Options, PartCommandMixin.Options {
		traceSourceName?: string;
		title?: string;
		subtitle?: string;
		pages?: EditorPage.Options[];
		/**
		 * Array of validation rules
		 */
		rules?: validation.ObjectRule[];
		editorContext?: EditorContext;
		navigationService?: core.INavigationService;
		/**
		 * Type name of viewModel (EntityType)
		 * @type {String}
		 */
		type?: string;
		/**
		 * Url suffix is a partName's part after ":".
		 * For example, for "ObjectEditor:User", "User" is suffix. In editor suffix will be used as type if it's not provided.
		 * It's recommended to use `type` option explicitly always.
		 * Suffix is set by `core.createPart`.
		 * @deprecated Use type
		 */
		urlSuffix?: string;
		/**
		 * Object identifier
		 * @type {String}
		 */
		id?: string;
		viewModel?: Model|null;
		uow?: UnitOfWork;
		uowStateName?: string;
		/**
		 * The flag to explicitly mark or unmark the editor as isolated (root).
		 * If unspecified then the editor is considered as isolated if nor `uow` neither `viewModel.uow` is specified.
		 */
		isIsolated?: boolean;
		preloads?: string|string[];
		/**
		 * Prevent auto load unloaded objects in observable expressions.
		 * It's option for presenter's View. Can be passed via `presenterOptions` as well.
		 */
		suppressAutoLoad?: boolean;
		/**
		 * JSON objects to fill created UnifOfWork with (uow.attachChanges will be used).
		 */
		initialJson?: DomainObjectData[] | lang.Map<DomainObjectData>;

		menu?: Menu.Options;
		commands?: lang.Map<ICommand>;
		page?: string;

		pageValidation?: "none" | "loose" | "strict";
		skipSaveState?: boolean;
		blockingSave?: boolean;
		cssRootClass?: string;
		navigateSiblings?: Options[];

		presenter?: IPresenter;
		Presenter?: new (editor: ObjectEditor, options?: any) => IPresenter;

		onSetViewModel?: (viewModel: Model) => Promisable<Model>;
		onCreatePage?: (pageInfo: EditorPage.Options, viewModel: Model) => EditorPage | false;
		onCreatePropEditor?: (page: EditorPage, propMeta: PropertyEditor.Options, viewModel: Model) => PropertyEditor.Options;

		onInitializing?: (sender: ObjectEditor) => void;
		onInitialized?: (sender: ObjectEditor) => void;
		onPageCreated?: (sender: ObjectEditor, args: PageCreatedEventArgs) => void;
		onPageStarting?: (sender: ObjectEditor, args: PageEventArgs) => void;
		onPageStarted?: (sender: ObjectEditor, args: PageEventArgs) => void;
		onPageUnloading?: (sender: ObjectEditor, args: PageEventArgs) => void;
		onPageUnloaded?: (sender: ObjectEditor, args: PageEventArgs) => void;
		onPageSwitching?: (sender: ObjectEditor, args: PageSwitchingEventArgs) => void;
		onValidating?: (sender: ObjectEditor, args: ValidatingEventArgs) => void;
		onValidated?: (sender: ObjectEditor, args: ValidatedEventArgs) => void;
		onAccepting?: (sender: ObjectEditor, args: AcceptingEventArgs) => void;
		onFinishing?: (sender: ObjectEditor, args: FinishingEventArgs) => void;
		onFinished?: (sender: ObjectEditor, args: FinishedEventArgs) => void;
		onSaving?: (sender: ObjectEditor, args: SavingEventArgs) => void;
		onSaved?: (sender: ObjectEditor, args: SavedEventArgs) => void;
		onSaveError?: (sender: ObjectEditor, args: UnitOfWork.SaveErrorArgs) => void;
		onQueryUnload?: (sender: ObjectEditor, args: QueryUnloadEventArgs) => void;
		onUnloaded?: (sender: ObjectEditor, args: PartCloseOptions) => void;
		onDisposed?: (sender: ObjectEditor, args: PartCloseOptions) => void;
	}

	export interface KnownMenus extends lang.Map<Menu.Options> {
		Editor?: Menu.Options;
		RootEditor?: Menu.Options;
	}

	export interface KnownCommands extends lang.Map<ICommand> {
		SaveAndClose?: ICommand;
		Apply?: ICommand;
		CancelAndClose?: ICommand;
		SwitchToPage?: ICommand;
		CloseContextPart?: ICommand;
	}

	export type Model = DomainObject | {
		uow?: UnitOfWork;
		id?: string;
		meta?: EntityMeta;
		isLoaded?: boolean;
		load?(options?: domain.LoadOptions): lang.Promise<Model>;
		isNew?(): boolean;
		fromJson?(json: DomainObjectData, options?: domain.FromJsonOptions, propOptions?: domain.SetPropOptions): Model;
		toJson?(options?: domain.ToJsonOptions): DomainObjectData;
	};
	// NOTE: Тип модели может быть произвольный, не обязательно DomainObject. По идее тип нужно описать вот так:
	// export type Model = DomainObject | {};
	// Но в этом случае TS ругается на проверки вида:
	// if (viewModel.meta) { ... }
	// Возможно, в TS2.0 ситуация изменится.

	export interface Result {
		success?: boolean|Promise<void>;
		object?: Model;
		selectedId?: string;
	}

	export interface PartState {
		type?: string;
		id?: string;
		page?: string;
	}

	export interface EditorContext {
		nested?: boolean;
		parentProp?: PropertyMeta;
		parentObject?: DomainObject;
		[key: string]: any;
	}

	export interface Violation extends validation.Violation {
		pageName?: string;
	}

	export interface FindPropertyEditorResult {
		pe: PropertyEditor;
		pageName: string;
	}

	export interface IPresenter extends IPart {
		activatePage?(page: EditorPage): Promisable<void>;
		deactivatePage?(page: EditorPage): Promisable<void>;
		activateContextParts?(): void;
	}

	// Event args
	export interface PageCreatedEventArgs {
		page: EditorPage;
	}

	export interface ValidatingEventArgs {
		page: EditorPage;
	}

	export interface ValidatedEventArgs {
		page: EditorPage;
		result: Violation[];
	}

	export interface PageSwitchingEventArgs {
		pageFrom: EditorPage;
		pageTo: EditorPage;
		cancel: boolean;
		defer?: Promise<void>;
	}

	export interface PageEventArgs {
		page: EditorPage;
		index: number;
	}

	export interface SavingEventArgs {
		cancel?: boolean;
		blockingSave?: boolean;
		onAsyncError?: (args: UnitOfWork.SaveErrorArgs) => void;
		onSyncError?: (args: UnitOfWork.SaveErrorArgs) => void;
	}

	export interface SavedEventArgs {
	}

	export interface FinishingEventArgs {
		cancel?: boolean;
		cmdArgs?: FinishCommandArgs;
		promise?: Promise<boolean>;
	}
	export interface AcceptingEventArgs {
		reason: "save" | "close" | "saveAndClose";
		cancel?: boolean;
		cmdArgs?: FinishCommandArgs;
		promise?: Promise<boolean>;
	}

	export interface FinishedEventArgs {
		result?: boolean|Promise<void>;
	}

	export interface QueryUnloadEventArgs {
		editor: ObjectEditor;
		preventingReason?: string;
	}

	// Command args
	export interface FinishCommandArgs {
		blockingSave?: boolean;
		createNext?: boolean;
		/**
		 * do not call navigationService close/leave/replace
		 */
		skipClose?: boolean;
	}

	export interface ApplyCommandArgs {
		async?: boolean;
	}

	export interface PageCommandArgs {
		pageName: string;
	}
}

core.ui.ObjectEditor = ObjectEditor;
export = ObjectEditor;
