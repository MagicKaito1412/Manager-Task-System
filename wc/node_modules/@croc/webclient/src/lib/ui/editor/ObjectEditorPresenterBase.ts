import $ = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import WaitingModal = require("lib/ui/WaitingModal");
import Menu = require("lib/ui/menu/Menu");
import ObjectEditor = require("lib/ui/editor/ObjectEditor");
import ContextPartCarousel = require("lib/ui/validation/ContextPartCarousel");
import ViolationInfoPart = require("lib/ui/validation/ViolationInfoPart");
import resources = require("i18n!lib/nls/resources");
import "lib/ui/menu/MenuPresenter";
import "xcss!lib/ui/styles/objectEditor.css";
import "xcss!lib/ui/styles/contextParts.css";

import { HostContextOptions, IPart, PartCloseOptions } from "lib/ui/.ui";
import EditorPage = require("lib/ui/editor/EditorPage");
import Violation = ObjectEditor.Violation;
import lang = core.lang;

abstract class ObjectEditorPresenterBase extends View implements ObjectEditor.IPresenter {
	static defaultOptions: ObjectEditorPresenterBase.Options = {
		/**
		 * allow pages switching animation
		 * @type {Boolean}
		 */
		animatePageActivation: true,
		/**
		 * Affix tabs
		 * @type {Boolean}
		 */
		affixNavigation: undefined,
		/**
		 * Affix menu
		 *@type {Boolean}
		 */
		affixMenu: undefined,
		/**
		 * Affix context parts area
		 *@type {Boolean}
		 */
		affixParts: undefined,
		/**
		 * Render editor.title
		 * @type {Boolean}
		 */
		showTitle: true,
		hideMenu: undefined,
		menuCssClass: "x-menu-bar x-menu--contrast",
		/**
		 * Add "copy to clipboard" popup-button near title
		 * @type {Boolean}
		 */
		showCopy: undefined,
		showHelpTooltips: true,
		loadingText: resources.wait,
		savingText: resources.saving
	};

	static hostDefaultOptions: lang.Map<ObjectEditorPresenterBase.Options> = {
		dialog: {
			affixMenu: false,
			affixNavigation: false,
			affixParts: false
		}
	};

	partsCarousel: ContextPartCarousel;
	viewModel: ObjectEditor;
	eventPublisher: core.IEventPublisher;
	options: ObjectEditorPresenterBase.Options;
	protected container: JQuery;
	private _busyElement: WaitingModal;
	private _clipboardBtn: core.ui.clipboard.CopyButton;
	private $menuContainer: JQuery;

	/**
	 * @constructs ObjectEditorPresenterBase
	 * @extends View
	 * @param {Object} options
	 */
	constructor (options?: ObjectEditorPresenterBase.Options) {
		options = ObjectEditorPresenterBase.mixOptions(options, ObjectEditorPresenterBase.defaultOptions);
		// NOTE: core.ui.clipboard may be not initialized yet when defaultOptions are initializing.
		// Therefore we should initialize `showCopy` here.
		options.showCopy = lang.coalesce(options.showCopy, core.ui.clipboard && core.ui.clipboard.isSupported);
		super(options);

		this.partsCarousel = new ContextPartCarousel();
		this.partsCarousel.bind("moved", () => {
			this._activateViolation(this.partsCarousel.currentViolation());
		});

		this.container = null;	// it's editor root DOMElement
		if (this.options.hideMenu) {
			this.options.affixMenu = false;
		}
	}

	applyHostContext (opt: HostContextOptions): core.INavigationService.NavigateOptions {
		super.applyHostContext(opt);
		this.mixHostOptions(opt.host, ObjectEditorPresenterBase.hostDefaultOptions);
		return null;
	}

	setViewModel (viewModel: ObjectEditor): void {
		super.setViewModel(viewModel);

		if (viewModel) {
			let that = this;
			that.eventPublisher = viewModel.app.eventPublisher;

			that.partsCarousel.items().source(viewModel.contextParts);
			if (that.viewModel.userSettings) {
				that.viewModel.userSettings.attach("contextParts", that.partsCarousel.userSettings);
			}
		}
	}

	protected beforeRender (domElement?: JQuery|HTMLElement): void {
		if (this.options.affixParts) {
			this.partsCarousel.initAffix(domElement, ".x-editor-pages");
		}

		super.beforeRender(domElement);
	}

	protected canRenderInitialization (): boolean {
		return this.options.canRenderInitialization !== undefined ? this.options.canRenderInitialization : false;
	}

	protected doRender (domElement: JQuery|HTMLElement): void {
		let that = this;
		let promise = that.viewModel.initializationTask;
		if (promise && promise.state() === "pending") {
			if (that.canRenderInitialization()) {
				super.doRender(domElement);
			} else {
				that.$domElement = $(domElement);
				that.domElement = that.$domElement[0];
				let markup = that.options.waitingTemplate({text: that.options.loadingText});
				$(domElement).html(markup.toString());
			}
		} else {
			super.doRender(domElement);
		}
	}

	/**
	 * Called by ObjectEditor in its render method.
	 */
	protected afterRender (domElement?: JQuery|HTMLElement): void {
		let that = this,
			$container = that.container, // must be set by child classes in `doRender`
			menu = that.viewModel.menu;
		super.afterRender();
		that.viewModel.bind("change:isBusy", that._onBusyChanged, that);

		let $carousel = that.partsCarousel.$domElement;
		if ($carousel) {
			$carousel.on("click", ".x-context-part", (e) => {
				e.preventDefault();
				that._activateViolation(that.partsCarousel.currentViolation());
			});
		}

		$container.on("focusin", ".x-pe-container.-invalid", (e) => {
			let $container = $(e.currentTarget),
				page = that.viewModel.currentPage(),
				presenter = <any>page.presenter,
				pe = presenter && presenter.findContainerPE && presenter.findContainerPE($container);
			if (!pe) { return; }

			lang.some(that.partsCarousel.items().all(), (part, i) => {
				let v = (part as ViolationInfoPart).violation;
				if (v && v.pageName === page.name &&
					v.object &&
					v.props && v.props.length && v.props.indexOf(pe.viewModelProp) >= 0) {
					that.partsCarousel.position(i);
					return true;
				}
			});
		});

		if (menu) {
			$container.on("keyup", (e) => {
				return !menu.executeHotkey(e);
			});
		}

		if (that.options.showCopy) {
			let $btnCopy = $container.find(".btn-copy");
			if ($btnCopy.length) {
				that._clipboardBtn = new core.ui.clipboard.CopyButton($btnCopy[0], {
					text: (/*trigger*/) => {
						if (that.viewModel.getTextPresentation) {
							return that.viewModel.getTextPresentation();
						}
						return that.viewModel.title;
					},
					tooltip: {placement: "right"}
				});
			}
		}
	}

	/**
	 * Called by ObjectEditor to show activated page.
	 * @param {EditorPage} page
	 */
	abstract activatePage(page: EditorPage): lang.Promisable<void>;

	/**
	 * Called by ObjectEditor to hide deactivated page.
	 * @param {EditorPage} page
	 */
	deactivatePage (page: EditorPage): lang.Promisable<void> {
		let that = this,
			pageContainer = that._getPageByName(page.name);

		if (that.options.animatePageActivation) {
			let task = lang.deferred<void>();
			pageContainer.fadeOut(100, () => {
				task.resolve();
			});
			return task.promise();
		} else {
			pageContainer.hide();
		}
	}

	activateContextParts (): void {
		this.partsCarousel.activate();
	}

	/**
	 * Called by ObjectEditor after current page is shown.
	 */
	protected onReady (): void {
		let that = this,
			eventPublisher = that.eventPublisher,
			$container = $(that.container);

		if (eventPublisher && that.options.affixMenu) {
			if (that.$menuContainer) {
				eventPublisher.publish("ui.affix.remove_element", {
					element: that.$menuContainer
				});
			}
			that.$menuContainer = $container.find(".x-editor-menu-container");
			eventPublisher.publish("ui.affix.add_element", {
				element: that.$menuContainer,
				controlledBy: $container.find(".x-editor-pages"),
				affixTo: "bottom"
			});
		}

		if (that.options.showHelpTooltips) {
			that._initHintTooltips($container);
		}
	}

	protected _initHintTooltips($container: JQuery): void {
		let that = this;
		$container.tooltip({
			selector: ".x-pe-help",
			title: function (this: HTMLElement) { // DO NOT change it to arrow function!
				// NOTE: 'this' is the element that the tooltip is attached to
				let propName = $(this).parents(".x-pe-container").prop("id");
				if (propName) {
					let pe = that.viewModel.currentPage().editors[propName];
					if (pe && pe.options) {
						return pe.options.hint;
					}
				}
			},
			html: true,
			placement: "auto",
			delay: { show: 500 },
			trigger: "hover"
		});
	}

	protected _getPageByName (name: string): JQuery {
		return this.container.find(".x-editor-page[data-page='" + name + "']").first();
	}

	unload (options?: PartCloseOptions): void {
		let that = this,
			eventPublisher = that.eventPublisher;

		if (that._clipboardBtn) {
			that._clipboardBtn.dispose();
		}

		if (eventPublisher && that.options.affixMenu && that.$menuContainer) {
			eventPublisher.publish("ui.affix.remove_element", {
				element: that.$menuContainer
			});
		}

		that.container = undefined;
		that.viewModel.unbind("change:isBusy", null, that);

		super.unload(options);
	}

	dispose (options?: PartCloseOptions): void {
		this.partsCarousel.dispose();
		super.dispose(options);
	}

	protected _onBusyChanged (sender: ObjectEditor, value: boolean): void {
		let that = this;
		if (value) {
			that._busyElement = new WaitingModal({ text: that.options.savingText });
			that._busyElement.render();
		} else if (that._busyElement) {
			that._busyElement.dispose();
			delete that._busyElement;
		}
	}

	protected _activateViolation (violation: Violation): void {
		// focus PE for violation from part, if any
		if (violation && violation.pageName) {
			let page = this.viewModel.getPageByName(violation.pageName);
			if (page && !page.hidden()) {
				lang.when(this.viewModel.setCurrentPage(page, true /*skipValidation*/))
					.always(() => {
						if (violation.props && violation.props.length) {
							let pe = page.getPropertyEditor(violation.props[0], violation.object);
							if (pe) {
								pe.activate();
							}
						}
					});
			}
		}
	}
}

namespace ObjectEditorPresenterBase {
	export interface Options extends View.Options {
		/**
		 * allow pages switching animation
		 * @type {Boolean}
		 */
		animatePageActivation?: boolean;
		/**
		 * Affix tabs
		 * @type {Boolean}
		 */
		affixNavigation?: boolean;
		/**
		 * Affix menu
		 *@type {Boolean}
		 */
		affixMenu?: boolean;
		/**
		 * Affix context parts area
		 *@type {Boolean}
		 */
		affixParts?: boolean;
		/**
		 * Render editor.title
		 * @type {Boolean}
		 */
		showTitle?: boolean;
		/**
		 * Hide editor menu
		 * @type {Boolean}
		 */
		hideMenu?: boolean;
		/**
		 * Additional CSS class for editor menu
		 * @type {String}
		 */
		menuCssClass?: string;
		/**
		 * Add "copy to clipboard" popup-button near title
		 * @type {Boolean}
		 */
		showCopy?: boolean;
		/**
		 * Tabs position: above ("top") or left ("left")
		 * @type {"left"|"top"}
		 */
		tabsPosition?: "left" | "top";
		/**
		 * Tabs width for tabsPosition='left' mode
		 */
		tabsWidth?: number;
		/**
		 * Show content help tooltips for PEs (with hint option)
		 */
		showHelpTooltips?: boolean;
		/**
		 * Presenter's custom template can handle initialization state of Editor
		 */
		canRenderInitialization?: boolean;
		/**
		 * Text for WaitingModal on initialization
		 */
		loadingText?: string;
		/**
		 * Text for WaitingModal on saving (sync)
		 */
		savingText?: string;
	}
}

ObjectEditorPresenterBase.mixin({
	defaultOptions: ObjectEditorPresenterBase.defaultOptions,
	hostDefaultOptions: ObjectEditorPresenterBase.hostDefaultOptions,
	/**
	 * @deprecated use hostDefaultOptions
	 */
	contextDefaultOptions: ObjectEditorPresenterBase.hostDefaultOptions
});

core.ui.ObjectEditorPresenterBase = ObjectEditorPresenterBase;
export = ObjectEditorPresenterBase;
