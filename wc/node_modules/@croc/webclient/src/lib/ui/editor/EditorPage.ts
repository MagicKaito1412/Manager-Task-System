import core = require("core");
import Component = require("lib/ui/Component");
import EditorPageController = require("lib/ui/editor/EditorPageController");
import validation = require("lib/validation");
import domain = require("lib/domain/.domain");

import Menu = require("lib/ui/menu/Menu");
import lang = core.lang;
import ObjectEditor = core.ui.ObjectEditor;
import Model = ObjectEditor.Model;
import Violation = ObjectEditor.Violation;
import PropertyEditor = core.ui.PropertyEditor;
import PropertyMeta = domain.metadata.PropertyMeta;
import IPart = core.ui.IPart;
import PartCloseOptions = core.ui.PartCloseOptions;
import Options = EditorPage.Options;
import IPresenter = EditorPage.IPresenter;
import IController = EditorPage.IController;
import { SafeHtml } from "lib/formatters";
import { Constructor } from "lib/core.lang";

class EditorPage extends Component {
	static defaultOptions: Options = {
		labelColumnRatio: 4,
		cssColumnPrefix: "col-md-",
		hidden: false,
		bound: undefined,
		highlightFocused: true
	};

	static contextDefaultOptions: lang.Map<Options> = {
		filter: {
			highlightFocused: false
		}
	};

	options: Options;
	viewModel: Model;
	presenter: IPresenter;
	editor: ObjectEditor;
	editors: lang.Map<PropertyEditor>;
	name: string;
	title: string;
	tab: EditorPage.TabOptions;
	//titleHtml: string;
	rules: validation.ObjectRule[];
	labelColumnRatio: number;
	peColumnRatio: number;
	controller: IController;

	//@lang.decorators.observableAccessor()
	//sections: lang.ObservableProperty<lang.ObservableCollection<EditorPage.Section>>;
	sections: EditorPage.Section[];

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	hidden: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	hasViolations: lang.ObservableProperty<boolean>;

	/**
	 * @constructs EditorPage
	 * @extends Component
	 * @param options
	 * @param viewModel
	 */
	constructor(options: Options, viewModel: Model) {
		options = EditorPage.mixContextOptions(options, EditorPage.defaultOptions, EditorPage.contextDefaultOptions);
		super(options);

		this.initTab();
		this.rules = this.options.rules;
		this.initLayout();
		this.viewModel = viewModel;
		this.editors = {};
		if (this.options.hidden) {
			this.hidden(this.options.hidden);
		}
		this.initController();
		this.initPresenter();
	}

	protected initTab(): void {
		let that = this;
		that.name = that.options.name;
		that.tab = {};
		if (lang.isString(that.options.title)) {
			that.title = <string>that.options.title;
			that.tab = {
				title: that.title,
				html: that.title
			};
		} else if (that.options.title) {
			let tabOptions = <EditorPage.TabOptions>that.options.title;
			that.title = tabOptions.title;
			that.tab = core.lang.extendEx({}, tabOptions, {
				title: that.title,
				html: tabOptions.html || Menu.getItemHtml(tabOptions)
			}, {deep: true});
		}
		that.title = that.title || that.name;
		that.tab.html = that.tab.html || that.title;
	}

	protected initLayout(): void {
		let that = this;
		// соотношение ширины столбцов "label"|"propEditor" в терминах разметки bootstrap
		that.labelColumnRatio = that.options.labelColumnRatio;
		if (that.labelColumnRatio >= 12 || that.labelColumnRatio <= 0) {
			that.labelColumnRatio = EditorPage.defaultOptions.labelColumnRatio;
		}

		that.peColumnRatio = 12 - that.labelColumnRatio;
	}

	protected initController(): void {
		let that = this;
		let controller = that.options.controller;
		if (controller) {
			if (EditorPageController.is(controller)) {
				that.controller = controller;
			} else {
				that.controller = new EditorPageController(that, controller);
			}
		}
	}

	protected tweakOptions(options: Options): void {
		lang.append(options, {
			bound: !!options.template
		});
		lang.appendEx(options, {
			presenterOptions: {
				template: options.template,
				bound: options.bound,
				cssClass: options.cssClass,
				highlightFocused: options.highlightFocused,
				peFocusOnClickContainer: options.peFocusOnClickContainer
			}
		}, { deep: true });
		super.tweakOptions(options);
	}

	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;

		if (that.controller && that.controller.prepare) {
			that.controller.prepare(that);
		}

		return super.doRender(domElement);
	}

	/**
	 * Called by ObjectEditor before page is activated
	 * Optional
	 */
	onStarting?(): void;
	/**
	 * Called by ObjectEditor after page is activated
	 */
	onStarted(): void {
		let that = this;
		that.focusFirstPE(false /*force*/);
		if (that.controller) {
			that.controller.start(that);
		}
	}
	/**
	 * Called by ObjectEditor before page is unloaded
	 * Optional
	 */
	onUnloading?(): void;
	/**
	 * Called by ObjectEditor after page is unloaded
	 * Optional
	 */
	onUnloaded?(): void;

	/**
	 * Set focus on first property editor
	 * @param {boolean} force if true - skip check for already focused DOM element
	 */
	focusFirstPE(force?: boolean): void {
		let presenter = this.presenter;
		if (presenter && presenter.focusFirstPE) {
			presenter.focusFirstPE(force);
		}
	}

	setNavigationService(navigationService: core.INavigationService): void {
		this.navigationService = navigationService;
		// Set up navigationService for all nested property editors
		lang.forEach(this.editors, pe => {
			pe.setNavigationService(navigationService);
		});
	}

	setObjectEditor(editor: ObjectEditor): void {
		let that = this;
		that.editor && that.editor.violations.unbind("change", null, that);
		that.editor = editor;
		that.editor.violations.bind("change", that._onViolationsChanged, that);
	}

	protected _onViolationsChanged(): void {
		let that = this,
			hasViolations = that.editor.violations.all().some(v => v.pageName === that.name);
		that.hasViolations(hasViolations);
	}

	queryUnload(options?: PartCloseOptions): lang.Promisable<string> {
		let reason: lang.Promisable<string>;
		lang.some(this.editors, pe => {
			if (lang.isFunction(pe.queryUnload)) {
				reason = pe.queryUnload(options);
				return !!reason;
			}
		});
		return reason || super.queryUnload(options);
	}

	unload(options?: PartCloseOptions): void {
		let controller = this.controller;
		if (controller) {
			controller.stop();
		}
		super.unload(options);
	}

	dispose(options?: PartCloseOptions): void {
		super.dispose(options);

		let that = this;
		that.editor.violations.unbind("change", null, that);
		// NOTE: EditorPage's presenter (a View) doesn't own PEs and as so, it didn't dispose them in unload (see View.unload)
		lang.forEach(that.editors, pe => {
			if (lang.isFunction(pe.dispose)) {
				pe.dispose(options);
			}
		});
		that.editors = undefined;
	}

	getPropertyEditor(propName: string, viewModel?: any): PropertyEditor {
		let that = this;
		viewModel = viewModel || that.viewModel;
		if (that.editors) {
			return lang.find(that.editors, pe => pe.viewModel === viewModel && pe.viewModelProp === propName);
		}
	}

	getPropertyEditorByPath(propPath: string): PropertyEditor {
		let that = this;
		if (propPath.indexOf(".") < 0) {
			that.getPropertyEditor(propPath, that.viewModel);
		}

		let parts = propPath.split("."),
			obj = that.viewModel,
			propName: string = propPath;
		if (obj.meta) {
			for (let i = 0; i < parts.length; ++i) {
				propName = parts[i];
				// TODO: в случае реализации поддержки навигируемых свойств в комплексных типах (WC-1595), потребуется доработка
				if (obj.meta.complex[propName]) {
					// перед нами комплексное свойство - значит остаток цепочки это полное наименование примитивного свойства (prop1.prop2.prop3)
					for (let j = i + 1; j < parts.length; ++j) {
						propName = propName + "." + parts[j];
					}
					break;
				}
				if (obj.meta.props[propName]) {
					if (i === parts.length - 1) { break; }

					obj = obj[propName]();
					if (!obj) { return null; }
					/*
					 TODO: support syntax like "questions.10.name", where "10" is an index in 'questions' property
					 if (prop.many || lang.isArray(obj)) {
					 if (new RegExp("\[(\d+)\]").test(parts[i + 1])) {}
					 } */
				}
			}
		}
		return that.getPropertyEditor(propName, obj);
	}

	getPrevPropertyEditor(pe: PropertyEditor): PropertyEditor {
		// TODO: надо учитывать порядок tabIndex'ов
		let that = this,
			keys = Object.keys(that.editors);
		for (let i = 1; i < keys.length; ++i) {
			let peCur = that.editors[keys[i]];
			if (peCur === pe) {
				return that.editors[keys[i - 1]];
			}
		}
	}

	getNextPropertyEditor(pe: PropertyEditor): PropertyEditor {
		// TODO: надо учитывать порядок tabIndex'ов
		let that = this,
			keys = Object.keys(that.editors);
		for (let i = 0; i < keys.length - 1; ++i) {
			let peCur = that.editors[keys[i]];
			if (peCur === pe) {
				return that.editors[keys[i + 1]];
			}
		}
	}

	/**
	* Run validation for all property editors (pe) on the page.
	* It also updates hasViolations property.
	* @return {Array|null} array of violation objects or undefined if there was no errors.
	*/
	runValidation(): Violation[] {
		let that = this,
			violations: Violation[] = [];

		if (!that.shouldValidate()) { return null; }

		if (that.rules) {
			lang.forEach(that.rules, rule => {
				let violation = rule.validate(that.viewModel);
				if (violation) {
					violations = validation.appendViolation(violation, violations);
				}
			});
		}
		if (that.editors) {
			lang.forEach(that.editors, pe => {
				let violation = pe.runValidation();
				if (violation) {
					violations = validation.appendViolation(violation, violations);
				}
			});
		}

		if (violations.length) {
			for (let violation of violations) {
				violation.pageName = that.name;
			}
			return violations;
		}
		return null;
	}

	shouldValidate(): boolean {
		return !this.hidden();
	}

	getTextPresentation(): string {
		// TODO: formattedValue - это специфика peViewOnly
		interface peFormattable extends PropertyEditor {
			formattedValue?(): string;
		}

		let that = this,
			text = "";
		if (that.editors) {
			lang.forEach(that.editors, (pe: peFormattable) => {
				text = text + pe.title() + ": ";
				if (pe.formattedValue) {
					text += pe.formattedValue();
				} else {
					text += pe.value();
				}
				text += "\n";
			});
		}
		return text;
	}
}

namespace EditorPage {
	export interface Options extends Component.Options {
		Class?: new (options: Options, viewModel: any) => EditorPage;
		properties?: ((PropertyEditor.Options & lang.Map<any>) | string)[];
		template?: HandlebarsTemplateDelegate;
		name?: string;
		title?: string | EditorPage.TabOptions;
		rules?: validation.ObjectRule[];
		labelColumnRatio?: number;
		cssColumnPrefix?: string;
		cssClass?: string;
		hidden?: boolean;
		bound?: boolean;
		/**
		 * see EditorParePresenter.Options.highlightFocused
		 */
		highlightFocused?: boolean;
		/**
		 * see EditorParePresenter.Options.peFocusOnClickContainer
		 */
		peFocusOnClickContainer?: boolean;
		controller?: IController | EditorPageController.Options[];
		sections?: SectionOptions[];
	}
	export interface TabOptions extends Menu.PresentationItem {

	}

	export interface SectionOptions {
		/**
		 * Mandatory name of section
		 */
		name?: string;
		/**
		 * Title for html
		 */
		title?: string | SafeHtml;
		/**
		 * Section is hidden (even if title is specified)
		 */
		hidden?: boolean;
		/**
		 * Array of properties names for this section (these names are the same as in `properties` option in page)
		 */
		properties?: string[];
		autoHide?: boolean;
	}

	export class Section extends lang.Observable {
		name: string;

		@lang.decorators.observableAccessor()
		title: lang.ObservableProperty<string | SafeHtml>;

		@lang.decorators.observableAccessor()
		hidden: lang.ObservableProperty<boolean>;

		editors: PropertyEditor[];

		constructor(options?: SectionOptions) {
			super();
			options = options || {};
			this.name = options.name;
			this.title(options.title);
			this.hidden(options.hidden || false);
			this.editors = [];
		}

		recalculateHidden () {
			let hiddenAll = lang.every(this.editors, (pe) => {
				return pe.hidden();
			});
			this.hidden(hiddenAll);
		}
	}

	export interface IPresenter extends IPart {
		focusFirstPE?(force?: boolean): void;
	}

	export interface IController {
		prepare?(page: EditorPage): void;
		start(page: EditorPage): void;
		stop(): void;
	}
}

EditorPage.mixin({
	defaultOptions: EditorPage.defaultOptions,
	contextDefaultOptions: EditorPage.contextDefaultOptions
});

core.ui.EditorPage = EditorPage;
export = EditorPage;

