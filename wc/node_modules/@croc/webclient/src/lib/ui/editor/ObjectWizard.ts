import $ = require("jquery");
import core = require("core");
import ObjectEditor = require("lib/ui/editor/ObjectEditor");
import EditorPage = require("lib/ui/editor/EditorPage");
import Menu = require("lib/ui/menu/Menu");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;
import Promise = lang.Promise;
import ICommand = core.commands.ICommand;
import Command = core.commands.Command;
import Options = ObjectWizard.Options;
import KnownMenus = ObjectWizard.KnownMenus;
import KnownCommands = ObjectWizard.KnownCommands;

class ObjectWizard extends ObjectEditor {
	static defaultOptions: Options = {
		pageValidation: "loose",    // strict, none
		getNextStep: undefined,
		menuPage: undefined,
		cssRootClass: "x-editor-base x-editor-wizard"
	};

	static defaultMenus: KnownMenus = {
		Page: {
			items: [
				{
					name: "Forward",
					title: resources["wizard.Forward"],
					hotKey: "ctrl+enter",
					hideIfDisabled: true,
					isDefaultAction: true,
					icon: "arrow-right"
				}
			]
		},
		Wizard: {
			items: [
				{
					name: "SaveAndClose",
					title: resources["save"],
					icon: "save",
					hotKey: "ctrl+enter",
					hideIfDisabled: true
				},
				{
					name: "CancelAndClose",
					title: resources["cancel"],
					icon: "cancel"
				}
			]
		}
	};

	@lang.decorators.constant(ObjectWizard.defaultMenus)
	defaultMenus: KnownMenus;

	options: Options;
	commands: KnownCommands;
	menuPage: Menu;

	/**
	 * @constructs ObjectWizard
	 * @extends ObjectEditor
	 * @param {Object} options
	 */
	constructor(options?: Options) {
		options = ObjectWizard.mixOptions(options, ObjectWizard.defaultOptions);

		super(options);
	}

	/**
	 * Returns flag indicating whether current wizard is linear (true) and non-linear (false).
	 * @returns {boolean}
	 */
	isLinear(): boolean {
		return !lang.isFunction(this.options.getNextStep);
	}

	/**
	 * Returns a metadata for next page in non-linear wizard.
	 * @param {EditorPage} [fromPage] Can be null for the first page
	 * @param {Number} [nextIndex] Index of the next page (a page to return)
	 * @returns {Object} Page metadata (supplied to ObjectEditor._createPage)
	 */
	getNextStep(fromPage: EditorPage, nextIndex: number): EditorPage.Options {
		return this.options.getNextStep.call(this, fromPage, nextIndex);
	}

	/**
	 * Create a default page in case when editor's options have no pages metadata.
	 * @protected
	 */
	protected _createDefaultPage(): EditorPage {
		let that  = this,
			pageInfo: EditorPage.Options;

		if (that.isLinear()) {
			pageInfo = { name: "", title: ""};
		} else {
			pageInfo = that.getNextStep(undefined, 0);
		}
		return that._createPage(pageInfo);
	}

	protected _initializeMenu(): void {
		let that = this;
		// initialize editor menu & commands
		that.commands = lang.extend(that.createCommands(), that.options.commands || {});

		that.menu = that.createWizardMenu();
		if (that.menu) {
			that.menu.bindToPart(that);
		}

		that.menuPage = that.createPageMenu();
		if (that.menuPage) {
			that.menuPage.bindToPart(that);
		}
	}

	protected createWizardMenu(): Menu {
		return new Menu(this.createWizardMenuDefaults(), this.options.menu);
	}
	protected createWizardMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(this.defaultMenus.Wizard, "Wizard", this._getType());
	}
	protected createPageMenu(): Menu {
		return new Menu(this.createPageMenuDefaults(), this.options.menuPage);
	}
	protected createPageMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(this.defaultMenus.Page, "WizardPage", this._getType());
	}

	/**
	 * @protected
	 * @override
	 * @returns {Object.<string, Command>}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			commands = super.createCommands() as KnownCommands;

		commands.Backward = core.createCommand({
			execute: () => { that.back(); },
			name: "Backward"
		});
		commands.Forward = core.createCommand({
			execute: () => { that.forward(); },
			name: "Forward"
		});

		return commands;
	}

	/**
	 * Create an url query for initialization via navigating to a url
	 */
	getState(partOptions?: Options): ObjectEditor.PartState {
		if (partOptions) {
			return {
				type: partOptions.type,
				id: partOptions.id,
				page: partOptions.page
			};
		}
		let state = this._getViewModelState();
		if (state) {
			this._state = state;
		}
		return this._state;
	}

	protected onPageStarted(args: ObjectEditor.PageEventArgs): void {
		this.updateWizardCommands(args.page);
		super.onPageStarted(args);
	}

	protected _activatePage(page: EditorPage): Promise<void> {
		let that = this;

		if (!that.isLinear()) {
			// for non-linear wizard we should remove all pages which are to the right from newPage
			let newPageIdx = that.pages.indexOf(page);
			if (newPageIdx < that.pages.count() - 1) {
				let remItems = that.pages.all().slice(newPageIdx + 1);
				remItems.forEach(page => {
					if (lang.isFunction(page.dispose)) {
						page.dispose();
					}
				});
				that.pages.remove(remItems);
				// also remove pages' violations
				that._removePageViolations(remItems);
			}
		}

		return super._activatePage(page);
	}

	/**
	 * Move wizard to a next page
	 * @returns {Boolean} true if wizard changed current page, otherwise - false
	 */
	forward(): Promise<void> {
		let that = this,
			curIdx = that.pages.indexOf(that.currentPage()),
			page: EditorPage;

		if (that.isLinear()) {
			if (curIdx < that.pages.count() - 1) {
				page = that.pages.get(curIdx + 1);
			}
		} else {
			let pageInfo: EditorPage.Options = that.getNextStep(that.currentPage(), curIdx + 1);
			if (!pageInfo) {
				return lang.rejected();
			}
			page = lang.find(that.pages.all(), page => page.name === pageInfo.name);
			page = page || that._createPage(pageInfo);
		}
		if (!page) {
			return lang.rejected();
		}
		return that.setCurrentPage(page, /*skipValidation=*/ false).then(() => {
			// focus first pe after forward command is done
			page.focusFirstPE(true /*force*/);
		}, () => {
			// switching was cancelled (probably due to violation checks), remove created page for non-linear wizard
			if (!that.isLinear()) {
				if (lang.isFunction(page.dispose)) {
					page.dispose();
				}
				that.pages.remove(page);
			}
		});
	}

	back(): Promise<void> {
		let that = this,
			curIdx = that.pages.indexOf(that.currentPage());
		if (curIdx > 0) {
			return that.setCurrentPage(that.pages.get(curIdx - 1), /* skipValidation=*/true);
		}
		return lang.rejected();
	}

	protected updateWizardCommands(page?: EditorPage): void {
		let that = this;
		page = page || that.currentPage();

		let index = that.pages.indexOf(page),
			isLast = that.isLinear() ?
				index === that.pages.count() - 1 :
				!(that.getNextStep(page, index + 1));

		that.canSaveAndClose(isLast); // canExecute for BoundCommand `SaveAndClose`
		that.commands.Forward.canExecute(!isLast);
		that.commands.Backward.canExecute(index > 0);
	}

	protected canSaveAndClose(): boolean;
	protected canSaveAndClose(v: boolean): void;
	/**
	 * Override base method canSaveAndClose to make it an observable property
	 * @observable-property {boolean}
	 */
	protected canSaveAndClose(v?: boolean): boolean {
		if (!arguments.length) {
			return ObjectWizard._get(this, "canSaveAndClose") && super.canSaveAndClose();
		}
		ObjectWizard._set(this, "canSaveAndClose", v);
	}
}

namespace ObjectWizard {
	export interface Options extends ObjectEditor.Options {
		getNextStep?: (fromPage: EditorPage, nextIndex: number) => EditorPage.Options;
		menuPage?: Menu.Options;
	}

	export interface KnownMenus extends lang.Map<Menu.Options> {
		Page?: Menu.Options;
		Wizard?: Menu.Options;
	}

	export interface KnownCommands extends ObjectEditor.KnownCommands {
		Backward?: Command;
		Forward?: Command;
	}
}

ObjectWizard.mixin({
	defaultOptions: ObjectWizard.defaultOptions
});

core.ui.ObjectWizard = ObjectWizard;
export = ObjectWizard;
