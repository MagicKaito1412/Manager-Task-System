import core = require("core");
import View = require("lib/ui/handlebars/View");
import Menu = require("lib/ui/menu/Menu");
import resources = require("i18n!lib/nls/resources");
import defaultTemplate = require("xhtmpl!lib/ui/templates/ConcurrencyErrorPart.hbs");

import lang = core.lang;
import ObjectEditor = require("./ObjectEditor");
import { ViolationSeverity } from "lib/validation";
import { DomainObjectData, ObjectIdentity, SaveInteropError, OptimisticConcurrencyException } from "lib/interop/.interop";

class ConcurrencyErrorPart extends View {
	static defaultOptions: ConcurrencyErrorPart.Options  = {
		template: defaultTemplate,
		severity: "critical",
		unbound: false
	};

	/**
	 * @enum {String}
	 */
	static actions = {
		keepServer: "keepServer",
		keepLocal: "keepLocal",
		resolve: "resolve"
	};

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isBusy: lang.ObservableProperty<boolean>;

	options: ConcurrencyErrorPart.Options;
	error: SaveInteropError;
	severity: ViolationSeverity;
	editor: ObjectEditor;

	private _defer: lang.Deferred<void>;
	promise: lang.Promise<void>;

	commands: ConcurrencyErrorPart.KnownCommands;
	menu: Menu;

	/**
	 * Object editor concurrency error resolver part
	 * @class ConcurrencyErrorPart
	 * @extends View
	 */
	constructor(options: ConcurrencyErrorPart.Options) {
		options = ConcurrencyErrorPart.mixOptions(options, ConcurrencyErrorPart.defaultOptions);
		super(options);
		this.error = options.error;
		this.severity = options.severity;
		this.editor = options.editor;

		this._defer = core.lang.deferred<void>();
		this.promise = this._defer.promise();

		this.commands = this.createCommands();
		this.menu = this.createMenu();
		this.menu.bindToPart(this);

		this.bind("change:isBusy", this._onBusyChanged, this);
		this.isBusy(false);
	}

	/**
	 * @protected
	 * @returns {{KeepLocal: (Command), KeepServer: (Command), Resolve: (Command)}}
	 */
	protected createCommands (): ConcurrencyErrorPart.KnownCommands {
		let that = this;
		return {
			KeepLocal: core.createCommand({
				execute: function() {
					that._onExecute(ConcurrencyErrorPart.actions.keepLocal);
				}
			}),
			KeepServer: core.createCommand({
				execute: function() {
					that._onExecute(ConcurrencyErrorPart.actions.keepServer);
				}
			}),
			Resolve: core.createCommand({
				execute: function() {
					that._onExecute(ConcurrencyErrorPart.actions.resolve);
				}
			})
		};
	}

	createMenu (): Menu {
		return Menu.create({
			items: [
				{
					name: "KeepLocal",
					title: resources["concurrencyErrorPart.keepLocal"],
					hint: resources["concurrencyErrorPart.keepLocal.hint"],
					icon: "save"
				}, {
					name: "KeepServer",
					title: resources["concurrencyErrorPart.keepServer"],
					hint: resources["concurrencyErrorPart.keepServer.hint"],
					icon: "download"
				}, {
					name: "Resolve",
					title: resources["concurrencyErrorPart.resolve"],
					hint: resources["concurrencyErrorPart.resolve.hint"],
					icon: "settings"
				}
			]
		});
	}

	protected _onBusyChanged (sender, value: boolean) {
		let that = this;
		that.commands.KeepLocal.canExecute(!value);
		that.commands.KeepServer.canExecute(!value);
		that.commands.Resolve.canExecute(!value);
	}

	protected findOriginalObject (originalObjects: DomainObjectData[], obsoleteObject: ObjectIdentity): DomainObjectData {
		return core.lang.find(originalObjects, function (obj: DomainObjectData) {
			// todo: remove objectID , left or backward compatibility
			return obj.__metadata.type === obsoleteObject.type &&
				(obj.id === obsoleteObject.id || obj.id === obsoleteObject.objectID);
		});
	}

	/**
	 * @param {ConcurrencyErrorPart#actions} action
	 * @private
	 */
	protected _onExecute (action: string): void {
		let that = this,
			local,
			originalObject,
			uow = that.editor.viewModel.uow,
			obsoleteObjects = (<OptimisticConcurrencyException>that.error.serverError).obsoleteObjects,
			originalObjects = that.error.originalObjects,
			deferred = [];

		that.isBusy(true);

		switch (action) {
			case ConcurrencyErrorPart.actions.keepServer:
				uow.rollbackState();
				obsoleteObjects.forEach((obsoleteObject) => {
					// todo: remove objectID , left or backward compatibility
					deferred.push(uow.reload(obsoleteObject.type, obsoleteObject.id || obsoleteObject.objectID));
				});
				core.lang.whenAll(deferred)
					.done(() => {
						that._defer.resolve();
					})
					.always(() => {
						that.isBusy(false);
					});
				break;
			case ConcurrencyErrorPart.actions.keepLocal:
				obsoleteObjects.forEach((obsoleteObject) =>{
					originalObject = that.findOriginalObject(originalObjects, obsoleteObject);
					if (originalObject) {
						let objToUpdate = uow.find(originalObject.__metadata.type, originalObject.id);
						if (objToUpdate) {
							objToUpdate.setTs(originalObject.__metadata.ts);
						}
					}
				});
				that._defer.resolve();
				break;
			case ConcurrencyErrorPart.actions.resolve:
				core.lang.async.forEach(obsoleteObjects, (obsoleteObject: ObjectIdentity) => {
					let resolveTask = core.lang.deferred<void>(),
						part;
					// todo: remove objectID , left or backward compatibility
					local = uow.find(obsoleteObject.type, obsoleteObject.id || obsoleteObject.objectID);
					originalObject = that.findOriginalObject(originalObjects, obsoleteObject);
					if (local) {
						part = new core.ui.ObjectResolutionPart({
							title: that.editor.title,
							local: local.toJson({ onlyChanged: true }),
							original: originalObject
						});
						that.navigationService.navigate({
							part: part,
							activateOptions: {
								freezeUrl: true
							},
							onReturn: (result) => {
								part.dispose();
								if (result && result.resolved) {
									if (result.changes) {
										local = uow.fromJson(result.changes, { dirty: true });
									}
									resolveTask.resolve();
								} else {
									resolveTask.reject();
								}
							}
						});
						return resolveTask;
					}
				})
					.done(() => {
						that._defer.resolve();
					})
					.always(() => {
						that.isBusy(false);
					});
				break;
		}
	}
}

ConcurrencyErrorPart.mixin({
	defaultOptions: ConcurrencyErrorPart.defaultOptions,
	actions: ConcurrencyErrorPart.actions
});

namespace ConcurrencyErrorPart {
	export interface Options extends View.Options {
		error?: SaveInteropError;
		editor?: ObjectEditor;
		severity?: ViolationSeverity;
	}

	export interface KnownCommands extends lang.Map<core.commands.Command> {
		KeepLocal?: core.commands.Command;
		KeepServer?: core.commands.Command;
		Resolve?: core.commands.Command;
	}
}

export = ConcurrencyErrorPart;
