import $ = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import EditorPage = require("lib/ui/editor/EditorPage");
import utils = require("lib/utils");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");
import templateDef = require("xhtmpl!lib/ui/templates/EditorPagePresenter.hbs");
import templatePeContainer  = require("xhtmpl!lib/ui/templates/EditorPage.peContainer.hbs");

import "xcss!lib/ui/styles/objectEditor.css";

import Part = require("lib/ui/Part");
import Handlebars = require("handlebars-ext");

class EditorPagePresenter extends View {
	static defaultOptions: EditorPagePresenter.Options = {
		template: templateDef,
		bound: undefined,
		cssClass: "has-bs-grid",
		sectionHeadings: true,
		peFocusOnClickContainer: true
	};

	options: EditorPagePresenter.Options;
	viewModel: EditorPage;

	/**
	 * @constructs EditorPagePresenter
	 * @extends View
	 * @param {Object} options
	 */
	constructor (options: EditorPagePresenter.Options) {
		options = EditorPagePresenter.mixOptions(options, EditorPagePresenter.defaultOptions);
		options.unbound = !options.bound;
		super(options);
	}

	protected doRender(domElement: JQuery|HTMLElement): core.lang.Promisable<void> {
		let that = this,
			$element = $(domElement);

		// до рендеринга, т.к. рендерящиеся pe могут сигнализировать о наличии нарушений
		// NOTE: "pe.invalid" is our custom DOM event - see PropertyEditor._renderError
		that.jqOn($element, "pe.invalid", ".x-pe-container", function(e, error) {
			if (!that._isEventOwn(e)) { return; }

			let $current = $(e.currentTarget);
			// toggle -invalid on container element:
			$current.toggleClass("-invalid", !!error);
			// toggle -invalid on label and PE's element:
			$current
				.find(".x-pe-label")
				.not($current.find(".x-pe-container .x-pe-label")) // exclude labels in nested x-pe-container
				.toggleClass("-invalid", !!error);
		});

		let renderCtx = that.renderContext();
		renderCtx.editorPage = that.viewModel;
		//renderCtx.sections = {}; - для хелпера peSection (удалено в 1.34)

		super.doRender(domElement);

		// add CSS class to container element
		$element.addClass(that.options.cssClass);

		if (that.options.peFocusOnClickContainer) {
			// NOTE: Don't use $(".x-pe-container", domElement) for binding to events - the set of .x-pe-container
			// may change in the future, if page content is dynamic. So we should use the jQuery method 'on'
			// with additional selector ".x-pe-container".
			that.jqOn($element, "click", ".x-pe-container", function (e: JQueryEventObject): void {
				if (!that._isEventOwn(e)) { return; }

				let $current = $(e.currentTarget);
				//if ($current.find(":focus").length) { return; }
				// NOTE: previous check isn't correct in IE, where focused element can be the parent DIV here.
				// We need more advanced check:
				if ($current.has(":input:focus, a:focus").length) { return; }

				let pe = that.findContainerPE($current);
				if (pe && !pe.disabled()) {
					pe.focus();
				}
			});
		}

		if (that.options.highlightFocused) {
			that.jqOn($element, "focusin", ".x-pe-container", function (e: JQueryEventObject): void {
				if (that.options.highlightFocused && that._isEventOwn(e)) {
					$(e.currentTarget).addClass("x-pe-container--focused");
				}
			});
			that.jqOn($element, "focusout", ".x-pe-container", function (e: JQueryEventObject): void {
				if (that.options.highlightFocused)
					$(e.currentTarget).removeClass("x-pe-container--focused");
			});
		}

		// we need to match DOM elements to PE;
		// so add class .x-pe and data 'pe-key' to DOM elements of all PE
		core.lang.forEach(that.viewModel.editors, (pe, key) => {
			if (!pe.domElement) { return; }

			let $pe = pe.$domElement;
			$pe.data("pe-key", key);
			$pe.addClass("x-pe");
		});
	}

	/**
	 * Set focus on first property editor
	 * @param {boolean} force if true - skip check for already focused DOM element
	 */
	focusFirstPE (force: boolean): void {
		let that = this;
		// focus on the first PE except mobile devices where it's useless
		if (!core.platform.isMobileDevice) {
			window.setTimeout(() => {
				if (!that.domElement) { return; }

				// the document can already have a focused element (inside or outside of the current part)
				if (!force && core.html.focused()) { return; }

				// find first enable PE - use class '.x-pe' and data 'pe-key' added earlier
				that.$domElement.find(".x-pe").each(function() {
					let $pe = $(this),
						peKey = $pe.data("pe-key"),
						pe = that.viewModel.editors[peKey];
					if (pe && !pe.disabled()) {
						pe.focus();
						return false;
					}
				});
			});
		}
	}

	findContainerPE ($container: JQuery): PropertyEditor|undefined {
		let page = this.viewModel,
			peKey = $container.data("pe-key");

		if (peKey) {
			return page.editors[peKey];
		}

		// find the PE rendered in the target container (slow method!)
		//page.editor.traceSource.warn("Set 'data-pe-key' attribute on elements with '.x-pe-container' for better performance");
		return core.lang.find(page.editors, (pe: PropertyEditor, key: string): boolean => {
			if (!pe || !pe.domElement) { return false; }

			// find parent container for the PE
			let $current = pe.$domElement.closest(".x-pe-container");
			if (!$current.length) { return false; }

			// cache the PE key in the data attached to the container DOM-element
			if (!$current.data("pe-key")) {
				$current.data("pe-key", key);
			}
			return $current[0] === $container[0];
		});
	}

	/**
	 * Checks if a jQuery event was triggered inside the current page (not nested)
	 * @param {JQueryEventObject} e
	 * @returns {boolean}
	 * @private
	 */
	protected _isEventOwn(e: JQueryEventObject): boolean {
		// NOTE: Событие может произойти во вложенном редакторе/фильтре. Чтобы различить свой pe-container
		// и чужой, найдем ближайший элемент EditorPage к элементу сгенерировавшем событие, и сравним со своим
		// элементом $domElement.
		let $pageEl = $(e.target).closest(".x-editor-page");
		return this.$domElement[0] === $pageEl[0];
	}

	static makeColumnsRatioHelperData (options: View.HelperOptions): any {
		let data = Handlebars.createFrame(options.data),
			peLayout = data.peLayout ? core.lang.clone(data.peLayout) : {},
			editorPage = data.context && data.context.editorPage,
			ratio = options.hash.columnsRatio, //e.g. "4:8"
			colonIndex;
		if (ratio) {
			colonIndex = ratio.indexOf(":");
			if (colonIndex > 0) {
				peLayout.labelColumnRatio = ratio.slice(0, colonIndex);
				peLayout.peColumnRatio = ratio.slice(colonIndex + 1);
			}
		}
		if (options.hash.noLabel !== undefined) {
			peLayout.noLabel = !!options.hash.noLabel;
		}
		if (editorPage) {
			peLayout.labelColumnRatio = peLayout.labelColumnRatio || editorPage.labelColumnRatio;
			peLayout.peColumnRatio = peLayout.peColumnRatio || editorPage.peColumnRatio;
		}
		data.peLayout = peLayout;
		return data;
	}
}

namespace EditorPagePresenter {
	export interface Options extends View.Options {
		/**
		 * Highligh PE container (label + PE) while PE is focused
		 */
		highlightFocused?: boolean;
		/**
		 * Focus inside PE when user click on PE container
		 */
		peFocusOnClickContainer?: boolean;
		bound?: boolean;
		cssClass?: string;
		sectionHeadings?: boolean;
	}
}


const makeColumnsRatioHelperData = EditorPagePresenter.makeColumnsRatioHelperData;

/**
 * Register HB helper 'peLayout'. The helper sets a ratio of label width to PE width for all nested PEs.
 * @example
 * {{peLayout columnsRatio="4:8"}}
 */
Handlebars.registerHelper("peLayout", function (options: View.HelperOptions): Handlebars.SafeString {
	let data = makeColumnsRatioHelperData(options);
	return options.fn.call(this, this, { data: data });
});

/* удалено в 1.34:
Handlebars.registerHelper("peSection", function (options: View.HelperOptions): Handlebars.SafeString {
	let pe: PropertyEditor = this;
	let editorPage = options.data.context && options.data.context.editorPage;
	if (!pe || !editorPage) { return; }
	let showHeadings = (<EditorPagePresenter.Options>editorPage.presenter.options).sectionHeadings;
	if (editorPage.sections && showHeadings) {
		let sections = options.data.context.sections || (options.data.context.sections = {});
		let section = core.lang.find(editorPage.sections, (section: EditorPage.SectionOptions) => {
			return section.properties && section.properties.indexOf(pe.fullName || pe.options.name) > -1;
		});
		if (section && !sections[section.name]) {
			// pe belongs to a section and it has not rendered yet
			sections[section.name] = section;
			return options.fn.call(this, section, { data: options.data });
			// alternatives:
			//1) compile template-text from options: HB.compile(editorPage.presenter.options.sectionTemplate)(section);
			//2) simple template: editorPage.presenter.options.sectionTemplate.replace(/{{name}}/, section.name)
			//3) hard-code: "<" + tag + " id='section-" + section.name + "'>" + section.title + "</" + tag + "><hr>";
			//return new Handlebars.SafeString(html);
		}
	}
});
*/


/**
 * Register partial HB template 'peContainer'
 * @example
 * {{> peContainer editors.title}}
 */
Handlebars.registerPartial("peContainer", templatePeContainer);

/**
 * Register HB helper 'peContainer'.
 * @example
 * {{peContainer editors.title columnsRatio="4:8"}}
 * In fact it's the same as
 * {{#peLayout columnsRatio="4:8"}}
 *   {> peContainer editors.title}}
 * {{/peLayout}}
 */
Handlebars.registerHelper("peContainer", function (context: any, options: View.HelperOptions): Handlebars.SafeString {
	let data = makeColumnsRatioHelperData(options),
		html = Handlebars.partials["peContainer"].call(this, context, { data: data });
	return new Handlebars.SafeString(html);
});

/**
 * Register HB helper 'pe'
 * @example
 * {{pe name='propName'}}
 */
Handlebars.registerHelper("pe", function (options: View.HelperOptions): Handlebars.SafeString {
	if (!options || !options.hash) {
		throw new Error("Incorrect 'pe' HB-helper using: no hash object specified (make sure it's used as: {{pe name='prop'}})");
	}

	let markup = new View.ChildViewMarkup(options),
		propName = options.hash.name,
		viewModel = options.hash.viewModel || this,
		// NOTE: запомним индекс для использования в peFactory. Там нельзя использовать options.data.index,
		// так как это всегда будет последний индекс в коллекции
		index = options.data.index,
		peMd = markup.getHash(), // все свойства хелпера, кроме известных, считаем свойствами объекта метаданнных
		// get parent view (it can be EditorPagePresenter or nested view, e.g. added via {{observe}})
		view: View = options.data.view,
		editorPage = view.renderContext().editorPage,
		registerOptions: Part.RegisterChildOptions = { disposeOnUnload: false }; // PE не нужно dispose-ить при unload-е

	if (!editorPage) {
		throw new Error("handlebars 'pe' helper: cannot find EditorPage object");
	}
	if (!editorPage.editor || !editorPage.editors) {
		throw new Error("handlebars 'pe' helper: there was EditorPage expected in current view's renderContext");
	}
	if (!propName) {
		throw new Error("handlebars 'pe' helper: 'name' attribute should be specified");
	}

	delete peMd.viewModel;

	// функция-фабрика, возвращающая экземпляр PE
	function peFactory(): PropertyEditor {
		let pe: PropertyEditor,
			peKey: string;

		// поищем PE среди уже созданных на странице
		core.lang.some(editorPage.editors, (editor: PropertyEditor, key: string): boolean => {
			if (editor.viewModel === viewModel && editor.viewModelProp === propName) {
				pe = editor;
				peKey = key;
				return true;
			}
		});

		if (!pe) {
			// создаем сам PE
			utils.parseObject(peMd);
			peMd = editorPage.editor._getPropertyEditorMd(viewModel, peMd);
			if (!peMd.vt) {
				throw new Error("handlebars 'pe' helper: unknown property '" + propName + "' and no 'vt' attribute specified");
			}
			pe = editorPage.editor._createEditorForProp(editorPage, peMd, viewModel);

			// вычисляем ключ, под которым будет зарегистрирован PE
			if (peMd.keyPrefix) {
				peKey = index !== undefined ?
				peMd.keyPrefix + "." + index + "." + propName :
				peMd.keyPrefix + "." + propName;
				delete peMd.keyPrefix;
			} else {
				peKey = editorPage.viewModel === viewModel ?
					peMd.name :
					pe.createId(viewModel, propName);
			}

			editorPage.editors[peKey] = pe;
		}

		// NOTE: Эта функция-фабрика будет вызвана перед регистрацией PE как дочернего парта. При этом для
		// регистрации будет использован объект опций registerOptions (передаваемый по ссылке). Поэтому здесь
		// мы можем поменять свойства этого объекта и эти измененения будут подхвачены при регистрации.
		registerOptions.name = peKey;
		return pe;
	}

	markup.registerPendingChild(peFactory, registerOptions);
	return markup.getHtml();
});

EditorPage.defaultOptions.Presenter = EditorPagePresenter;
export = EditorPagePresenter;

