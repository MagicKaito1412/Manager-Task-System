import $ = require("jquery");
import core = require("core");
import ObjectEditor = require("lib/ui/editor/ObjectEditor");
import Menu = require("lib/ui/menu/Menu");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import resources = require("i18n!lib/nls/resources");
import "xcss!lib/ui/styles/objectFilter.css";

import domain = require("lib/domain/.domain");
import PropertyEditor = require("lib/ui/pe/PropertyEditor");

import lang = core.lang;
import Promise = lang.Promise;
import Promisable = lang.Promisable;
import ICommand = core.commands.ICommand;
import Command = core.commands.Command;
import DomainObject = domain.DomainObject;

import PropertyData = ObjectFilter.PropertyData;
import FilterData = ObjectFilter.FilterData;
import RestrictionsData = ObjectFilter.RestrictionsData;
import SavedRestrictions = ObjectFilter.SavedRestrictions;
import IFilterPart = core.ui.IFilterPart;
import PropertyMeta = domain.metadata.PropertyMeta;
import SetPropOptions = domain.metadata.PropertyMeta;

class SaveFilterEditor extends ObjectEditor {
	static defaultMenu: Menu.Options = {
		items: [
			{ name: "Ok", title: resources.ok, isDefaultAction: true},
			{ name: "Cancel", title: resources.cancel}
		]
	};

	restrictions: SavedRestrictions[];
	filterData: FilterData;
	filterDesc: PropertyEditor.Summary[];
	viewModel: SaveFilterEditor.Model;

	/**
	 * @constructs SaveFilterEditor
	 * @extends ObjectEditor
	 * @param restrictions
	 * @param filterData
	 * @param filterDesc
	 */
	constructor(restrictions: SavedRestrictions[], filterData: FilterData, filterDesc: PropertyEditor.Summary[]) {
		if (!lang.isArray(restrictions)) {
			restrictions = [];
		}
		let options = SaveFilterEditor.createDefaultOptions(restrictions, filterDesc);
		super(options);

		this.restrictions = restrictions;
		this.filterData = filterData;
		this.filterDesc = filterDesc;
	}

	protected static createDefaultOptions(restrictions: SavedRestrictions[], filterDesc: PropertyEditor.Summary[]): ObjectEditor.Options {
		if (!lang.isArray(restrictions)) {
			restrictions = [];
		}

		let viewModel = SaveFilterEditor.createViewModel(restrictions, filterDesc);

		let enumFilters = { name: "filters", vt: "string", members: [] };
		for (let item of restrictions) {
			enumFilters.members.push({ descr: item.title, value: item.title });
		}

		return {
			title: resources["objectFilter.saveFilter"],
			pages: [ {
				name: "main",
				properties: [
					{
						name: "filterDesc",
						vt: "string",
						descr: resources["objectFilter.saveFilter.currentRestrictions"],
						nullable: true,
						PropertyEditor: core.ui.peViewOnly
					}, <core.ui.peBoolean.Options>{
						name: "isNew",
						vt: "boolean",
						presentation: "switch",
						nullable: false,
						trueTitle: resources["objectFilter.saveFilter.saveAsNew"],
						falseTitle: resources["objectFilter.saveFilter.saveAsExisting"],
						layout: { noLabel: true }
					}, <any>{
						name: "existingFilter",
						vt: "enum",
						hidden: true,
						descr: resources["objectFilter.saveFilter.existingFilter"],
						nullable: true,
						ref: enumFilters,
						presentation: "select2",
						noResultsText: resources["objectFilter.noSavedFilters"],
						placeholder: resources["objectFilter.saveFilter.chooseFilter"]
					}, {
						name: "name",
						vt: "string",
						descr: resources.name,
						nullable: true,
						maxLength: 512,
						hideLetterCounter: true,
						menu: { items: [{
							name: "CopyRest",
							hint: resources["objectFilter.saveFilter.copyCurrentRestrictions"],
							icon: "copy",
							command: core.createCommand({
								execute: () => {
									viewModel.name(viewModel.filterDesc());
								}
							})
						}]}
					}, {
						name: "existingFilterDesc",
						vt: "string",
						hidden: true,
						descr: resources["objectFilter.saveFilter.chosenFilterRestrictions"],
						nullable: true,
						PropertyEditor: core.ui.peViewOnly
					}
				]
			} ],
			viewModel: viewModel
			/*presenterOptions: {
				hideMenu: true,
				showTitle: false,
				affixParts: false
			}*/
		};
	}

	protected static createViewModel(restrictions: SavedRestrictions[], filterDesc: PropertyEditor.Summary[]): SaveFilterEditor.Model {
		let viewModel: SaveFilterEditor.Model = lang.observe({
			filterDesc: ObjectFilter.formatFilterDesc(filterDesc),
			isNew: true,
			name: "",
			existingFilter: "",
			existingFilterDesc: "",
			validate: function (): ObjectEditor.Violation | string {
				if (this.isNew()) {
					if (!this.name()) {
						return resources["objectFilter.saveFilter.empty_name_error"];
					}
					let newFilterName = this.name();
					if (newFilterName && restrictions.some(item => item.title === newFilterName)) {
						return {
							error: resources["objectFilter.saveFilter.non_unique_error"],
							menu: new Menu({
								items: [{
									title: resources.overwrite,
									name: "Overwrite",
									command: core.createCommand({
										execute: () => {
											viewModel.isNew(false);
											viewModel.existingFilter(viewModel.name());
										}
									})
								}]
							})
						};
					}
				} else {
					if (!this.existingFilter()) {
						return resources["objectFilter.saveFilter.empty_existingFilter_error"];
					}
					if (!this.name()) {
						return resources["objectFilter.saveFilter.empty_name_error"];
					}
				}
			}
		});

		return viewModel;
	}

	protected onSetViewModel(viewModel: SaveFilterEditor.Model): SaveFilterEditor.Model {
		let that = this;
		viewModel.bind("change:existingFilter", (obj: SaveFilterEditor.Model, val: string) => {
			if (val) {
				for (let item of that.restrictions) {
					if (item.title === val) {
						obj.existingFilterDesc(ObjectFilter.formatFilterDesc(item.descr));
						obj.name(item.title);
						break;
					}
				}
			} else {
				obj.existingFilterDesc(null);
			}
		});
		viewModel.bind("change:isNew", (obj: SaveFilterEditor.Model, val: boolean) => {
			that.findPropertyEditor(viewModel, "existingFilter").pe.hidden(val);
			that.findPropertyEditor(viewModel, "existingFilterDesc").pe.hidden(val);
		});
		return viewModel;
	}

	protected createMenu(): Menu {
		return new Menu(SaveFilterEditor.defaultMenu);
	}

	protected createCommands(): lang.Map<ICommand> {
		let that = this;
		return {
			Ok: core.createCommand({
				execute: () => {
					let violations = that.runValidation();
					if (!violations || !violations.length) {
						that.navigationService.close(that.updateRestrictions());
					}
				}
			}),
			Cancel: core.createCommand({
				execute: () => {
					that.navigationService.close();
				}
			})
		};
	}

	protected updateRestrictions(): SavedRestrictions[] {
		let that = this,
			viewModel = that.viewModel;
		if (viewModel.isNew()) {
			that.restrictions.push({
				title: viewModel.name(),
				restrictions: that.filterData,
				descr: that.filterDesc,
				created: new Date()
			});
		} else {
			let title = viewModel.existingFilter();
			for (let item of that.restrictions) {
				if (item.title === title) {
					item.title = viewModel.name();
					item.restrictions = that.filterData;
					item.descr = that.filterDesc;
					item.updated = new Date();
					break;
				}
			}
		}
		return that.restrictions;
	}
}

namespace SaveFilterEditor {
	export interface Model extends lang.Observable {
		filterDesc: lang.ObservableProperty<string>;
		isNew: lang.ObservableProperty<boolean>;
		name: lang.ObservableProperty<string>;
		existingFilter: lang.ObservableProperty<string>;
		existingFilterDesc: lang.ObservableProperty<string>;
		validate(): ObjectEditor.Violation|string;
	}
}


class ObjectFilter extends ObjectEditor implements core.ui.IFilterPart {
	/**
	 * context name for property editors
	 * @constant {String}
	 */
	@lang.decorators.constant("filter")
	contextName: string;

	/**
	 * Filter is able display violations by itself
	 * @constant {Boolean}
	 */
	@lang.decorators.constant(true)
	canDisplayViolations: boolean;

	/**
	 * @type {Object}
	 * @property {Object} comparers
	 * @property {Object} presenterOptions
	 * @property {Boolean} savedFilters
	 */
	static defaultOptions: ObjectFilter.Options = {
		comparers: undefined,
		cssRootClass: "x-editor-base x-editor-filter",
		savedFilters: true,
		onRestrictionsRestored: undefined,
		userSettings: {
			props: {
				"contextParts": false,
				"restrictions": true,
				"savedRestrictions": true
			}
		}
	};

	/**
	 * @type {Object}
	 */
	static defaultMenu: Menu.Options = {
		items: [
			{
				name: "ClearFilter",
				title: resources["objectFilter.clear"],
				icon: "clear",
				order: 15
			}, {
				name: "ManageFilters",
				title: resources["objectFilter.filters"],
				icon: "filter",
				order: 16,
				// NOTE: getMenu is initialized in runtime, but we must specify some value here:
				// otherwise this item will be removed in ObjectEditor._initializeMenu
				getMenu: () => ({})
			}
		]
	};

	@lang.decorators.constant(ObjectFilter.defaultMenu)
	defaultMenu: Menu.Options;

	options: ObjectFilter.Options;
	viewModel: DomainObject; // NOTE: получается, что нельзя использовать фильтр с не-доменной viewModel
	commands: ObjectFilter.KnownCommands;
	comparers: ObjectFilter.PropertyComparerMap;
	/**
	 * Restrictions object corresponding to "empty" state (after Clear command executed)
	 */
	private _emptyRestrictions: FilterData;
	private _applyingRestrictions: boolean;

	/**
	 * @constructs ObjectFilter
	 * @extends ObjectEditor
	 * @param {Object} options
	 */
	constructor(options?: ObjectFilter.Options) {
		options = ObjectFilter.mixOptions(options, ObjectFilter.defaultOptions);
		super(options);

		this.comparers = this.options.comparers || {};

		this._emptyRestrictions = this._createEmptyRestrictions();

		this.bind("change:restrictions", this._onRestrictionsChange, this);
		if (this.userSettings) {
			this.userSettings.bindToProp(this, "restrictions");
		}

		if (this.options.savedFilters) {
			let item = this.menu.getItem("ManageFilters");
			if (item) {
				item.getMenu = this._getManageFilterMenu.bind(this);
			}
			if (this.userSettings) {
				this.userSettings.bindToProp(this, "savedRestrictions");
			}
		}
	}

	/**
	 * @observable-property {Object}
	 * Restrictions JSON extracted from viewModel.
	 * Latest restrictions created in getRestrictions.
	 * DO NOT USE it directly, it's observable property for saving/restoring from UserSettings.
	 * NOTE: it's NOT  the same object as was returned from getRestrictions method.
	 */
	@lang.decorators.observableAccessor()
	restrictions: lang.ObservableProperty<FilterData>;

	/**
	 * @observable-property {Array}
	 * Saved filters.
	 */
	@lang.decorators.observableAccessor()
	savedRestrictions: lang.ObservableProperty<SavedRestrictions[]>;

	/** Implementation class of "Save filter" editor */
	@lang.decorators.constant(SaveFilterEditor)
	SaveFilterEditor: typeof SaveFilterEditor;

	protected createMenuDefaults(): Menu.Options {
		let menuOptions = Menu.defaultsFor(this.defaultMenu, "Filter", this._getType());
		if (!this.options.savedFilters) {
			menuOptions = Menu.merge(menuOptions, { remove: [ "ManageFilters" ] });
		}
		return menuOptions;
	}

	/**
	 * @protected
	 * @override
	 * @returns {{ClearFilter: (Command), SaveFilter: (Command)}}
	 */
	protected createCommands(): ObjectFilter.KnownCommands {
		let that = this,
			cmdClear = core.createCommand({
				name: "ClearFilter",
				execute: () => {
					that.clearRestrictions();
				}
			}),
			cmdSave = core.createCommand({
				name: "SaveFilter",
				execute: () => {
					that.saveFilter();
				}
			}),
			cmdRestore = core.createCommand({
				name: "RestoreFilter",
				execute: (args: ObjectFilter.RestoreSavedFilterEventArgs) => {
					let restrictions = args.restrictions;
					if (restrictions) {
						that.clearRestrictions();
						that.applyRestrictions(restrictions, "RestoreFilterCommand");
					}
				}
			}),
			cmdMerge = core.createCommand({
				name: "MergeFilter",
				execute: (args: ObjectFilter.RestoreSavedFilterEventArgs) => {
					let restrictions = args.restrictions;
					if (restrictions) {
						that.applyRestrictions(restrictions, "MergeFilterCommand");
					}
				}
			}),
			cmdDeleteFilter = core.createCommand({
				name: "DeleteFilter",
				execute: (args: ObjectFilter.DeleteSavedFilterEventArgs) => {
					let i = args.index,
						restrictions = that.savedRestrictions();
					if (restrictions && i != null) {
						restrictions.splice(i, 1);
						that.savedRestrictions(restrictions);
						that.trigger("change:savedRestrictions", that, restrictions, restrictions);
					}
				}
			}),
			cmdDeleteFilters = core.createCommand({
				name: "DeleteFilters",
				execute: () => {
					let confirm = new ConfirmDialog({
						text: resources["objectFilter.delete_all_filters_prompt"]
					});
					confirm.open().done(result => {
						if (result === "yes") {
							that.savedRestrictions(null);
							// TODO: publish acknowledge
						}
					});
				}
			});
		return {
			ClearFilter: cmdClear,
			SaveFilter: cmdSave,
			RestoreFilter: cmdRestore,
			MergeFilter: cmdMerge,
			DeleteFilter: cmdDeleteFilter,
			DeleteFilters: cmdDeleteFilters
		};
	}

	protected _getManageFilterMenu(): Menu.Options {
		let that = this,
			filterData = that._toJson(that.viewModel),
			items: Menu.Item[] = [
				{
					name: "SaveFilter",
					title: resources["objectFilter.saveFilter"] + "...",
					icon: "x-icon-download-2",
					command: that.commands.SaveFilter
				}, {
					name: "divider"
				}
			];

		// disable "SaveFilter" if current restrictions are empty
		that.commands.SaveFilter.canExecute(lang.some(filterData, v => v != null && v !== ""));

		let restrictions = that.savedRestrictions(),
			runtimeRestrictions = that.options.filters,
			hasRestrictions = lang.isArray(restrictions) && restrictions.length,
			hasRuntimeRestrictions = lang.isArray(runtimeRestrictions) && runtimeRestrictions.length;
		if (hasRestrictions || hasRuntimeRestrictions) {
			items.push({
				name: "header",
				title: resources["objectFilter.filters"]
			});
			if (hasRuntimeRestrictions) {
				runtimeRestrictions.forEach(item => {
					let menuItem = that._createFilterMenuItem(item, true /*isRuntime*/);
					items.push(menuItem);
				});
			}
			if (hasRestrictions) {
				restrictions.forEach((item, i) => {
					let menuItem = that._createFilterMenuItem(item, false /*isRuntime*/);
					menuItem.items.unshift({
						name: "Delete",
						title: resources["objectFilter.deleteSavedFilter"],
						command: that.commands.DeleteFilter,
						params: { index: i }
					});
					items.push(menuItem);
				});
				items.push({
					name: "divider"
				});
				items.push({
					name: "DeleteFilters",
					icon: "delete",
					title: resources["delete_all"],
					command: that.commands.DeleteFilters
			});
			}
		} else {
			items.push({
				name: "Info",
				title: resources["objectFilter.noSavedFilters"],
				disabled: true
			});
		}

		return {
			items: items
		};
	}

	protected _createFilterMenuItem(restrictionItem: SavedRestrictions, isRuntime: boolean): Menu.Item {
		let commands = this.commands;
		return {
			title: restrictionItem.title,
			name: restrictionItem.title,
			params: { restrictions: restrictionItem.restrictions, descr: restrictionItem.descr, isRuntime: isRuntime },
			command: commands.RestoreFilter,
			hint:  restrictionItem.descr ? ObjectFilter.formatFilterDesc(restrictionItem.descr) : null,
			items: [
				{
					name: "Merge",
					title: resources["objectFilter.mergeSavedFilter"],
					icon: "filter",
					command: commands.MergeFilter,
					params: { restrictions: restrictionItem.restrictions, descr: restrictionItem.descr, isRuntime: isRuntime }
				}
			]
		};
	}

	protected _saveFilter(filterData: FilterData, filterDesc: PropertyEditor.Summary[]): void {
		let that = this,
			restrictions = that.savedRestrictions(),
			editor = new that.SaveFilterEditor(restrictions, filterData, filterDesc);
		that.navigationService.openModal({
			part: editor,
			/*dialogOptions: {
				header: resources["objectFilter.saveFilter"]
			},*/
			onReturn: (restrictions: SavedRestrictions[]) => {
				if (restrictions) {
					that.savedRestrictions(restrictions);
					that.trigger("change:savedRestrictions", that, restrictions, restrictions);
					// TODO: publish acknowledge
				}
			}
		});
	}

	saveFilter(): void {
		let that = this;

		if (!that.viewModel.uow) { return; }

		let json: FilterData = that._toJson(that.viewModel);
		if (!json || lang.isEmptyObject(json)) { return; }

		// remove empty props
		for (let key of Object.keys(json)) {
			let v = json[key];
			if (v === undefined || v === null || v === "") {
				delete json[key];
			}
		}
		if (lang.isEmptyObject(json)) { return; }

		// create descr with restrictions description
		let filterDescr: PropertyEditor.Summary[] = [];
		that.pages.forEach(page => {
			let summary: PropertyEditor.Summary[] = that.getPageSummary(page);
			if (summary) {
				summary.forEach(item => {
					filterDescr.push(item);
				});
			}
		});
		that._saveFilter(json, filterDescr);
	}

	protected _fromJson(viewModel: ObjectEditor.Model, data: FilterData): void {
		if (viewModel.fromJson) {
			viewModel.fromJson(data, { dirty: true }, { original: false, norollback: true });
		}
	}

	protected _toJson(viewModel: ObjectEditor.Model): FilterData {
		// TODO: what if there is no toJson?
		return viewModel.toJson({ nometa: true });
	}

	setViewModel(viewModel: ObjectEditor.Model): void {
		if (this.options.emptyRestrictions) {
			this._fromJson(viewModel, this.options.emptyRestrictions);
		}
		super.setViewModel(viewModel);
	}

	isEmpty(): boolean {
		return lang.isEqual(this._emptyRestrictions, this._toJson(this.viewModel));
	}

	clearRestrictions(): void {
		let that = this;

		// set autoValidate to false for each PE to prevent validation when clearing properties
		that.forEachPE(pe => {
			pe.autoValidate(false);
		});

		that.viewModel.clear();
		if (that.options.emptyRestrictions) {
			that._fromJson(that.viewModel, that.options.emptyRestrictions);
		}
		// update emptyRestrictions-object as props could change after clear (init:"now")
		that._emptyRestrictions = that._toJson(that.viewModel);

		// remove all violations and restore autoValidate for each PE
		that.violations.clear();

		that.forEachPE(pe => {
			pe.violation(null);
			pe.autoValidate(true);
		});
	}

	/**
	 * Applying new restrictions - set them as viewModel.
	 * @param {Object|Promise|Function} restrictions New restrictions as JSON, or Promise of JSON, or function returning JSON or Promise of JSON
	 * @param {string} [source]
	 */
	applyRestrictions(restrictions: lang.Lazy<Promisable<FilterData>>, source?: string): void {
		let that = this,
			data: Promisable<FilterData>;
		if (lang.isFunction(restrictions)) {
			data = restrictions.call(that);
		} else {
			data = restrictions;
		}

		lang.when(data).done(restrictions => {
			that.onApplyRestriction(restrictions, source);
		});
	}

	protected onApplyRestriction(restrictions: FilterData, source: string): void {
		let res = true;
		if (source === "RestoreSettings") {
			res = this.onRestrictionsRestored(restrictions);
		}

		if (res !== false) {
			this._fromJson(this.viewModel, restrictions);
		}
	}

	protected onRestrictionsRestored(restrictions: FilterData): boolean {
		let that = this,
			onRestrictionsRestored = that.options && that.options.onRestrictionsRestored;
		if (onRestrictionsRestored) {
			return onRestrictionsRestored.call(that, restrictions);
		}

		let curJson = that._toJson(that.viewModel);
		// when restoring restrictions from UserSettings they should NOT overwrite current nonempty prop values in VM (WC-1406)
		lang.forEach(restrictions, (value, prop) => {
			let curVal = curJson[prop];
			// but if the value is default value from init facet or emptyRestrictions option
			// then it should be overwritten
			if (curVal !== undefined && curVal !== that._emptyRestrictions[prop]) {
				delete restrictions[prop];
			}
		});

		return true;
	}

	protected onSaveRestrictions(restrictions: FilterData): FilterData {
		// filter non-empty properties
		let json: FilterData = {};
		lang.forEach(restrictions, (value, prop) => {
			if (value !== undefined && this._emptyRestrictions[prop] !== value) {
				json[prop] = value;
			}
		});
		return json;
	}

	getRestrictions(): RestrictionsData {
		let that = this,
			violations = that.runValidation();
		if (violations && violations.length) {
			let err: IFilterPart.GetRestrictionsError = new Error(resources["objectFilter.error_get_restrictions"]);
			err.violations = violations;
			throw err;
		}

		// TODO: support nested objects/prop-chains
		let json: FilterData = that._toJson(that.viewModel);
		let restrictions = that._createRestrictions(json);

		// set observable property 'restrictions' which is bound to userSettings
		that._applyingRestrictions = true;
		json = that.onSaveRestrictions(json) || json;
		that.restrictions(json);
		that._applyingRestrictions = false;

		return restrictions;
	}

	protected _onRestrictionsChange(sender: ObjectFilter, value: FilterData): void {
		let that = this;
		if (!that._applyingRestrictions) {
			if (value) {
				that.applyRestrictions(value, "RestoreSettings");
			} else {
				that.clearRestrictions();
			}
		}
	}

	protected _createRestrictions(json: FilterData): RestrictionsData {
		let that = this,
			restrictions: RestrictionsData = {};
		lang.forEach(json, (v, key) => {
			if (v !== undefined && v !== null && v !== "") {
				that._addRestriction(restrictions, key, v);
			}
		});
		return restrictions;
	}

	protected _createEmptyRestrictions(): FilterData {
		let that = this;
		let viewModel = that.viewModel;
		let emptyJson = that.options.emptyRestrictions;
		if (!viewModel || !viewModel.meta) {
			return emptyJson || {};
		}
		// NOTE: create a new object in the separated UoW
		let uow = that.app.createUnitOfWork({connected: false});
		let obj = uow.create(viewModel.meta);
		if (emptyJson) {
			that._fromJson(obj, emptyJson);
		}
		let json = that._toJson(obj);
		uow.dispose();
		return json;
	}

	protected _addRestriction(restrictions: RestrictionsData, key: string, v: PropertyData): void {
		let comparer = this.comparers[key],
			map: RestrictionsData;
		if (comparer) {
			if (lang.isFunction(comparer)) {
				map = comparer.call(this, v);
			} else if (typeof comparer === "object") {
				map = comparer;
			} else { // string
				map = {
					[key]: {
						[comparer]: v
					}
				};
			}
		} else {
			map = {
				[key]: v
			};
		}

		this._mergeRestrictions(restrictions, map);
	}

	protected _mergeRestrictions(objTo: RestrictionsData, objFrom: RestrictionsData): void {
		for (let key of Object.keys(objFrom)) {
			let v = objTo[key];
			if (v) {
				// equality comparer by default
				// NOTE: we use isPlainObject instead of isObject, because isObject returns true for Dates
				//let comp = lang.isObject(v) ? v : { eq: v };
				let comp = lang.isPlainObject(v) ? v : { eq: v };
				v = lang.extend(comp, objFrom[key]);
			} else {
				v = objFrom[key];
			}
			objTo[key] = v;
		}
	}

	static formatFilterDesc(desc: PropertyEditor.Summary[]): string {
		if (!desc || !desc.length) { return ""; }
		// let hint = "";
		// desc.forEach(propDesc => {
		// 	if (hint) { hint += "; "; }
		// 	hint += propDesc.title + ": " + propDesc.value;
		// });
		// return hint;

		return desc.map(propDesc => propDesc.title + ": " + propDesc.value).join("; ");
	}
}

namespace ObjectFilter {
	export interface Options extends ObjectEditor.Options {
		comparers?: PropertyComparerMap;
		savedFilters?: boolean;
		filters?: SavedRestrictions[];
		onRestrictionsRestored?: (restrictions: {}) => boolean;
		emptyRestrictions?: FilterData;
	}

	// primitive or array of primitives
	// NOTE: Dates are serialized to strings
	export type PropertyData = string | number | boolean | string[] | number[] | boolean[];
	//export type PropertyData = string | number | boolean | Date | string[] | number[] | boolean[] | Date[];

	export interface PropertyComparison {
		[op: string]: PropertyData;
	}

	/**
	 * Json представление фильтра без подстановки comparers
	 */
	export interface FilterData {
		[propName: string]: PropertyData;
	}

	/**
	 * Итоговые органичения фильтра после подстановки comparers
	 */
	export interface RestrictionsData {
		[propName: string]: PropertyData | PropertyComparison;
	}

	export type PropertyComparer =
			// Comparer can be a string which specifies comparison operator (e.g. `"contains"`) ...
			string |
			// ... or a plain object with restrictions (e.g. `{ title: { contains: "foo" } }`) ...
			RestrictionsData |
			// ... or a function which returns such object. The function takes a single argument - the property value,
			// `this` is the current ObjectFilter instance (e.g. `function (v) { return { title: { contains: v } }; }`)
			((v: any) => RestrictionsData);

	export interface PropertyComparerMap {
		[propName: string]: PropertyComparer;
	}

	export interface SavedRestrictions {
		title?: string;
		descr?: PropertyEditor.Summary[];
		restrictions?: lang.Lazy<Promisable<FilterData>>;
		created?: Date;
		updated?: Date;
	}

	export interface KnownCommands extends lang.Map<ICommand> {
		ClearFilter?: Command;
		SaveFilter?: Command;
		RestoreFilter?: Command;
		MergeFilter?: Command;
		DeleteFilter?: Command;
		DeleteFilters?: Command;
	}

	export interface RestoreSavedFilterEventArgs {
		restrictions: lang.Lazy<Promisable<FilterData>>;
	}

	export interface DeleteSavedFilterEventArgs {
		index: number;
	}
}

ObjectFilter.mixin({
	defaultOptions: ObjectFilter.defaultOptions
});

core.ui.ObjectFilter = ObjectFilter;
export = ObjectFilter;
