import $ = require("jquery");
import core = require("core");
import ObjectEditorPresenterBase = require("lib/ui/editor/ObjectEditorPresenterBase");
import tmplEditor = require("xhtmpl!lib/ui/templates/Editor.hbs");
import tmplTabs = require("xhtmpl!lib/ui/templates/Editor.tabs.hbs");

import ObjectEditor = require("lib/ui/editor/ObjectEditor");
import ObjectFilter = require("lib/ui/editor/ObjectFilter");

import EditorPage = require("lib/ui/editor/EditorPage");

class ObjectEditorPresenter extends ObjectEditorPresenterBase {
	static defaultOptions: ObjectEditorPresenter.Options = {
		template: tmplEditor,
		unbound: true,
		hideMenu: false,
		affixNavigation: true,
		affixMenu: true,
		affixParts: true,
		menuCssClass: "x-menu-bar x-menu--contrast",
		tabsPosition: "top", // "left"
		partialTemplates: {
			tabs: tmplTabs
		}
	};

	options: ObjectEditorPresenter.Options;
	private $tabs: JQuery;

	/**
	 * @constructs ObjectEditorPresenter
	 * @extends ObjectEditorPresenterBase
	 * @param {Object} [options]
	 */
	constructor (options?: ObjectEditorPresenter.Options) {
		options = ObjectEditorPresenter.mixOptions(options, ObjectEditorPresenter.defaultOptions);
		super(options);
	}

	protected doRender (domElement: JQuery|HTMLElement): void {
		let that = this;

		super.doRender(domElement);

		that.container = $(domElement).children().first();

		if (that.viewModel.pages.count() > 1) {
			that._renderTabs();
		}
	}

	/**
	 * Called by ObjectEditor after current page is shown.
	 */
	protected onReady (): void {
		let that = this,
			editor = this.viewModel,
			app = editor.app;

		if (app && that.options.affixNavigation) {
			if (that.$tabs) {
				app.eventPublisher.publish("ui.affix.remove_element", {
					element: that.$tabs
				});
			}
			that.$tabs = that.container.find(".x-editor-tabs");
			app.eventPublisher.publish("ui.affix.add_element", {
				element: that.$tabs,
				controlledBy: that.container.find(".x-editor-pages"),
				affixTo: "top"
			});
		}

		super.onReady();
	}

	protected _renderTabs (): void {
		let that = this,
			$tabs = that.container.find(".x-editor-tabs");

		// Bootstrap's Tabs plugin needs tab links' 'data-target' attribute to contain jq-selector of the tab's content
		let onlyIconic = true;
		$tabs.find("li").each(function(): void {
			let $this = $(this),
				$anchor = $this.find("a"),
				pageName = $this.attr("data-page"),
				id;

			// bind tab with its content
			let pageContentSel = that.container.find(".x-editor-page[data-page='" + pageName + "']");
			if (pageContentSel.length) {
				id = that._generatePageId(pageName);
				pageContentSel[0].id = id;
				$anchor.attr("data-target", "#" + id);
			}

			let page = that.viewModel.getPageByName(pageName);
			if (page) {
				if (page.tab.presentation !== "icon") {
					onlyIconic = false;
				}
				if ((page.tab.hint || page.tab.tooltip ||
					(page.tab.presentation === "icon" && page.tab.title))) {
					$this.tooltip({
						title: page.tab.hint || page.tab.tooltip || page.tab.title,
						html: true,
						placement: "auto",
						delay: { show: 500 },
						trigger: "hover",
						viewport: that.container
					});
				}
				if (page.tab.cssClass) {
					$this.addClass(page.tab.cssClass);
				}
				if (page.tab.badge) {
					$("<span class='badge' style='display: inline;'>" + page.tab.badge + "</span>").appendTo($anchor);
				}
			}
		});

		$tabs.on("click", "a", function (e: JQueryMouseEventObject): void {
			e.preventDefault();
			let pageName = $(this).closest("li").attr("data-page");
			that.viewModel.switchToPage(pageName);
		});

		if (that.options.tabsPosition === "left") {
			//that.options.affixNavigation = false;
			let $pages = that.container.find(".x-editor-pages");
			let $content = that.container.find(".x-editor-tab-content");
			$pages.addClass("x-editor-pages--left-tabs");
			if (onlyIconic) {
				$pages.addClass("x-editor-pages--left-tabs-narrow");
			} else if (that.options.tabsWidth) {
				$tabs.css("width", that.options.tabsWidth + "px");
				$content.css("margin-left", that.options.tabsWidth + "px");
			} // else if (that.options.autoWidth) {}

			// NOTE: если presentation=="both", то текст по умолчанию имеет responsive breakpoint hidden-xs (может быть переопределен)
			// Для hidden-xs лейбл скроется на ширине 767px, надо адаптировать ширины закладок соответствующим образом
			// Но делать это надо только, если breakpoint используется для всех табов.
			// Если хотя бы одна из закладок просто тест, то уменьшать ширину нельзя.
			// А раз ширину мы не уменьшаем, то и брейкоинты для других закладок бессмысленны - их надо удалить.
			let countXs = 0;
			let countSm = 0;
			let countMd = 0;
			let countEmpty = 0;
			let $labels = $tabs.find("> li > a > span:not(.x-icon)");
			$labels.each(function (): void {
				let $this = $(this);
				if ($this.hasClass("hidden-md")) {
					countMd++;
				} else if ($this.hasClass("hidden-sm")) {
					countSm++;
				} else if ($this.hasClass("hidden-xs")) {
					countXs++;
				} else {
					countEmpty++;
				}
			});
			if (countEmpty > 0) {
				// если хотя бы одна закладка без брейкпоинта, удалим их для остальных
				$labels.removeClass("hidden-xs hidden-sm hidden-md");
			} else if (countXs > 0) {
				$pages.addClass("x-editor-pages--left-tabs-narrow-xs");
			} else if (countSm > 0) {
				$pages.addClass("x-editor-pages--left-tabs-narrow-sm");
			} else if (countMd > 0) {
				$pages.addClass("x-editor-pages--left-tabs-narrow-md");
			}

			// make tab-content (page) to have min-height equals to height of tabs
			$content.css("min-height", $tabs.height() + "px");
		}
	}

	protected _generatePageId (pageName: string): string {
		return core.lang.uuid("page_" + pageName + "_");
	}

	protected _getTabByName (name: string): JQuery {
		return this.container.find(".x-editor-tabs li[data-page='" + name + "']").first();
	}

	activatePage (page: EditorPage): void {
		let that = this,
			app = that.viewModel.app,
			pageSel = that._getPageByName(page.name),
			tabSel = that._getTabByName(page.name);

		if (!pageSel.length) {
			throw new Error("ObjectEditorPresenter: page container was not found");
		}
		if (tabSel) {
			tabSel.addClass("active");
		}

		page.render(pageSel);
		pageSel.show();
		if (app) {
			that.notifyDOMChanged();
		}
	}

	deactivatePage (page: EditorPage) {
		let that = this,
			tabSel = that._getTabByName(page.name);
		tabSel.removeClass("active");

		return super.deactivatePage(page);
	}

	unload (): void {
		let that = this,
			vm = that.viewModel;

		if (vm.app && that.options.affixNavigation && that.$tabs) {
			vm.app.eventPublisher.publish("ui.affix.remove_element", {
				element: that.$tabs
			});
		}

		super.unload.apply(that, arguments);
	}
}

namespace ObjectEditorPresenter {
	export interface Options extends ObjectEditorPresenterBase.Options {
		partialTemplates?: core.lang.Map<HandlebarsTemplateDelegate>;
	}
}

ObjectEditorPresenter.mixin({
	defaultOptions: ObjectEditorPresenter.defaultOptions,
});


class ObjectFilterPresenter extends ObjectEditorPresenter {
	static defaultOptions: ObjectEditorPresenter.Options = {
		hideMenu: true,
		showTitle: false,
		affixNavigation: false,
		affixMenu: false,
		affixParts: false
	};

	/**
	 * @constructs ObjectFilterPresenter
	 * @extends ObjectEditorPresenter
	 * @param {Object} options
	 */
	constructor (options: ObjectEditorPresenter.Options) {
		options = ObjectFilterPresenter.mixOptions(options, ObjectFilterPresenter.defaultOptions);
		super(options);
	}
}

ObjectFilterPresenter.mixin({
	defaultOptions: ObjectFilterPresenter.defaultOptions,
});

ObjectEditor.defaultOptions.Presenter = ObjectEditorPresenter;
core.ui.ObjectEditorPresenter = ObjectEditorPresenter;
ObjectFilter.defaultOptions.Presenter = ObjectFilterPresenter;
core.ui.ObjectFilterPresenter = ObjectFilterPresenter;

export  = ObjectEditorPresenter;
