import core = require("core");
import Carousel = require("lib/ui/Carousel");
import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import PartCarouselTemplate = require("xhtmpl!lib/ui/templates/ContextPartCarousel.hbs");

import { IPart, PartCloseOptions } from "lib/ui/.ui";
import { ICommand } from "lib/core.commands";
import { Violation } from "lib/validation";
import { IContextPart } from "./ContextPartMixin";
import ViolationInfoPart = require("./ViolationInfoPart");
import lang = core.lang;

enum ContextPartSeverities {
	critical = 1,
	error = 2,
	warning = 3,
	info = 4
}

class ContextPartCarousel extends Carousel<IContextPart> {
	static Severities: typeof ContextPartSeverities = ContextPartSeverities;

	static defaultOptions: ContextPartCarousel.Options = {
		template: PartCarouselTemplate,
		unbound: true
	};

	options: ContextPartCarousel.Options;
	items: lang.ObservableGetter<ObservableCollectionView<IContextPart>>;
	eventPublisher: core.IEventPublisher;

	protected $controlledBy: JQuery;

	private _countOld: number;
	private _affixed: lang.Map<boolean>;
	private _affixParent: JQuery|HTMLElement;
	private _affixSelector: string;

	/**
	 * @constructs ContextPartCarousel
	 * @extends Carousel
	 * @param {Object} options
	 **/
	constructor(options?: ContextPartCarousel.Options) {
		options = ContextPartCarousel.mixOptions(options, ContextPartCarousel.defaultOptions);
		super(options);

		let that = this;

		that.userSettings = core.UserSettings.create(that.options.userSettings);
		if (that.userSettings) {
			that.userSettings.bindToProp(that, "isPinned");
		}

		that.items().bind("change", that._onItemsChanged, that);
	}

	protected createItemsCollection(): ObservableCollectionView<IContextPart> {
		// NOTE: create ObservableCollectionView sorted by severity
		let items = new ObservableCollectionView<IContextPart>();
		items.orderBy({
			getter(): ContextPartSeverities {
				let part = this as IContextPart;
				return (part.severity && ContextPartSeverities[part.severity]) || ContextPartSeverities.info;
			},
			comparer(s1: ContextPartSeverities, s2: ContextPartSeverities): number {
				return s1 - s2;
			}
		});
		return items;
	}

	activate(): void {
		let that = this;
		if (!that.domElement) { return; }

		if (that.isPinned()) {
			that.blink();
		} else {
			core.html.scrollToElement({
				element: that.domElement,
				align: "bottom",
				onAfter: () => {
					that.blink();
				}
			});
		}
	}

	blink(): void {
		if (this.$domElement) {
			let $carousel = this.$domElement.find(".x-context-parts-carousel");
			// add css class and remove it asynchronously to start background-color transition
			$carousel.addClass("active");
			window.setTimeout(() => {
				$carousel.removeClass("active");
			}, 50);
		}
	}

	createCommands(): ContextPartCarousel.KnownCommands {
		let that = this,
			commands: ContextPartCarousel.KnownCommands = super.createCommands();

		commands.CloseContextPart = core.commands.createCommand({
			execute(): void {
				let part = that.removeCurrent();
				if (part && part.dispose) {
					part.dispose();
				}
			},
			name: "CloseContextPart"
		});

		// NOTE: add PinContextParts command if and only if affixing is supported
		if (core.Application.current && core.Application.current.affixManager) {
			commands.PinContextParts = core.commands.createCommand({
				execute(): void {
					that.togglePinned();
				},
				canExecute(): boolean {
					return that.canPin();
				},
				name: "PinContextParts"
			});
		}

		return commands;
	}

	currentViolation(): Violation {
		let part = this.current() as ViolationInfoPart;
		return part && part.violation || undefined;
	}

	/**
	 * Used in templates
	 * @returns {string} css class for parts badge
	 */
	badgeCssClass(): string {
		let part: IContextPart = this.current(),
			cssClass = "x-context-parts-badge";
		if (part) {
			cssClass += " x-context-parts-badge--" + (part.severity || "info");
		}
		return cssClass;
	}

	isPinned(v: boolean): void;
	isPinned(): boolean;
	isPinned(v?: boolean): boolean|void {
		if (!arguments.length) {
			return ContextPartCarousel._get(this, "isPinned");
		}
		if (ContextPartCarousel._set(this, "isPinned", v)) {
			this.affix(v);
		}
	}


	isUnpinned(): boolean {
		return !this.isPinned();
	}

	togglePinned(): void {
		if (this.canPin()) {
			this.isPinned(!this.isPinned());
		}
	}

	canPin(): boolean {
		return !!this.$controlledBy;
	}

	/**
	 * Initializes affixing. Should be called before render.
	 * @param {JQuery|HTMLElement} $parent
	 * @param {string} [selector]
	 */
	initAffix($parent: JQuery|HTMLElement, selector?: string): void {
		// NOTE: child element may not be created yet, we must find it later in beforeRender
		this._affixParent = $parent;
		this._affixSelector = selector;
	}

	protected beforeRender(domElement?: JQuery|HTMLElement): void {
		let parent = this._affixParent,
			selector = this._affixSelector,
			$controlledBy = parent && (selector ? $(selector, parent) : $(parent));
		this.$controlledBy = $controlledBy && $controlledBy.length ? $controlledBy : undefined;

		super.beforeRender(domElement);
	}

	protected afterRender(domElement?: JQuery|HTMLElement): void {
		super.afterRender(domElement);
		this.affix();
	}

	unload(options?: PartCloseOptions): void {
		this.unaffix();
		super.unload(options);
	}

	protected affix(pinned: boolean = !!this.isPinned()): void {
		this.affixParts(pinned);
		this.affixBadge(!pinned);
	}

	protected unaffix(): void {
		this.affixParts(false);
		this.affixBadge(false);
	}

	protected affixParts(affixed: boolean): void {
		this.affixElement(".x-context-parts-carousel", affixed, true /*resizable*/);
	}

	protected affixBadge(affixed: boolean): void {
		this.affixElement(".x-context-parts-badge", affixed);
	}

	protected affixElement(selector: string, affixed: boolean, resizable: boolean = false): void {
		let that = this;
		if (!that.domElement) { return; }

		let $controlledBy = that.$controlledBy;
		if (!$controlledBy || !$controlledBy.length) { return; }

		let $element = $(selector, that.domElement);
		if (!$element.length) { return; }

		let eventPublisher = that.eventPublisher || core.Application.current.eventPublisher;
		if (!eventPublisher) { return; }

		let affixedSelectors = that._affixed = that._affixed || {};
		if (!affixedSelectors[selector] === !affixed) { return; }

		if (affixed) {
			eventPublisher.publish("ui.affix.add_element", {
				element: $element,
				controlledBy: $controlledBy,
				affixTo: "bottom",
				// NOTE: Обычно прилепленные элементы не меняют размеры и, чтобы не было лишнего обновления affix-а,
				// событие domChanged на них давится. Подробнее см. в AffixManager.addElement.
				// Область с contextParts может менять высоту, если парты разного размера.
				// Чтобы отключить подавление domChanged, задаем опцию resizable.
				resizable: resizable
			});
		} else {
			eventPublisher.publish("ui.affix.remove_element", {
				element: $element
			});
		}
		affixedSelectors[selector] = !!affixed;
	}

	protected _onItemsChanged(sender: ObservableCollectionView<IPart>, args: lang.ObservableCollectionChangeArgs<IPart>): void {
		let that = this;

		that.position(0);

		// rerender when `items().count()` changes from 0 to 1 and vice versa
		let count = that.items().count(),
			countOld = that._countOld || 0;
		if (!count !== !countOld && that.domElement) {
			that.rerender();
		}
		that._countOld = count;

		if (!count) {
			window.setTimeout(() => {
				// if there is no context parts, and carousel control (prev|next part buttons) has focus
				// we need move focus to next focusable element, because carousel will be removed by rerender
				let currentFocus = $(document.activeElement),
					focusable;
				if (currentFocus.length && currentFocus.hasClass("x-carousel-control")) {
					// WARNING! :focusable selector is part of jquery UI
					// in other case we can use this approach
					// http://stackoverflow.com/a/7668761
					focusable = $(":focusable");
					focusable.slice(focusable.index(currentFocus))
						.not(".x-carousel-control")
						.first()
						.focus();
				}
				//that.notifyDOMChanged();
			});
		} else if (args) {
			// blink if new contextPart was added
			// NOTE: contextParts are usually updated in the batch via `reset`, so checking only `added` is not enough.
			// Ideally, we should find difference between `added` and `removed`, but comparing lengths is good enough.
			let added = args.added && args.added.length || 0,
				removed = args.removed && args.removed.length || 0;
			if (added > removed) {
				that.blink();
			}
		}
	}
}

namespace ContextPartCarousel {
	export interface Options extends Carousel.Options {
		// ???
	}

	export interface KnownCommands extends Carousel.KnownCommands {
		CloseContextPart?: ICommand;
		PinContextParts?: ICommand;
	}

	export type Severities = ContextPartSeverities;
}

export = ContextPartCarousel;