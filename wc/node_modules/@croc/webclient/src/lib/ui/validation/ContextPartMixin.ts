import core = require("core");
import Menu = require("lib/ui/menu/Menu");
import Component = require("lib/ui/Component");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import ContextPartCarousel = require("./ContextPartCarousel");
import ViolationInfoPart = require("./ViolationInfoPart");
import resources = require("i18n!lib/nls/resources");

import { IPart } from ".ui";
import { Violation, ViolationSeverity } from "lib/validation";
import lang = core.lang;
import Part = core.ui.Part;

// extend Violation interface: add `menu` field
declare module "lib/validation" {
	export interface Violation {
		menu?: Menu;
	}
}

export interface IContextPart extends IPart {
	severity?: ViolationSeverity;
}

export interface IContextPartsPresenter extends IPart {
	activateContextParts?(): void;
}

export abstract class ContextPartComponentMixin {
	title: string;
	violations: lang.ObservableCollection<Violation>;
	contextParts: lang.ObservableCollection<IContextPart>;
	userSettings: core.IUserSettings;
	presenter: IContextPartsPresenter;

	// must be implemented in concreate classes
	abstract runValidation(): Violation[];

	protected _onViolationsChanged(): void {
		let that = this,
			parts = that.contextParts.all().slice();

		// remove violation parts
		parts = parts.filter(part => {
			let partVio = part as ViolationInfoPart;
			// remove (and dispose) part of local violation
			if (!!partVio.violation && !partVio.persistent) {
				part.dispose();
				return false;
			}
			return true;
		});

		that.violations.forEach(violation => {
			if (!violation) { return; }

			let message = violation.error;
			if (message) {
				let violationPart = new ViolationInfoPart({
					message: message,
					severity: violation.severity,
					menu: violation.menu
				});
				if (violation.menu) {
					// при выполнении любой команды из меню (if any), надо закрыть парт
					violation.menu.onceExecuted(() => {
						that.closeContextPart(violationPart); }
					);
				}
				violationPart.violation = violation;
				parts.push(violationPart);
			}
		});

		that.contextParts.reset(parts);
	}

	protected _disposeParts(): void {
		this.contextParts.forEach(part => {
			if (part.dispose) {
				part.dispose();
			}
		});
		this.contextParts.clear();
	}

	protected _hasValidationErrors(violations: Violation[]): boolean {
		return violations && violations.length && violations.filter(v => !v.severity || v.severity === "error").length > 0;
	}

	protected _canIgnoreViolations(violations: Violation[]): lang.Promise<void> {
		if (!violations || !violations.length) { return lang.resolved(); }

		let errors = violations.filter(v => !v.severity || v.severity === "error");
		if (errors.length > 0) { return lang.rejected(); }

		// NOTE: there are only ignorable violations (warnings and infos). Ask user about them.
		let dialog = new ConfirmDialog({
			header: this.title,
			text: resources["validation.ui.ignore_warnings_prompt"]
		});
		return dialog.open().then(result => {
			if (result !== "yes") {
				return lang.rejected();
			}
		});
	}

	protected _validateBeforeSave(): lang.Promise<void> {
		let violations = this.runValidation();
		return this._canIgnoreViolations(violations)
			.done(() => {
				this.violations.clear();
			})
			.fail(() => {
				if (this.presenter.activateContextParts) {
					this.presenter.activateContextParts();
				}
			});
	}

	/**
	 * Remove context part from editor and dispose it
	 * @param {ViolationInfoPart} part - part to close
	 */
	protected closeContextPart(part: IContextPart): void {
		if (!part) {
			throw new Error("No part were defined for 'closeContextPart' method");
		}

		this.contextParts.remove(part);
		if (part.dispose) {
			part.dispose();
		}
	}
}