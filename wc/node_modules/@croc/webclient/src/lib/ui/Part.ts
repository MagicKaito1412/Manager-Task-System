import * as $ from "jquery";
import * as lang from "lib/core.lang";
import * as html from "lib/core.html";

import { INavigationService, IUserSettings } from "lib/.core";
import { IPart, PartCloseOptions, HostContextOptions } from "lib/ui/.ui";
import { RenderStatus } from "./.ui.types";
import RegisterChildOptions = Part.RegisterChildOptions;
import CloseOptions = Part.CloseOptions;

type PartChild = {
	part: IPart;
	name?: string;
	disposeOnUnload?: boolean;
	keepOnUnload?: boolean;
	trackStatus?: boolean;
	subscription?: lang.IDisposable;
};

type _RenderStatusType = RenderStatus;
const _RenderStatusConst = RenderStatus;

class Part extends lang.Observable implements IPart {
	name: string;
	options: Part.Options;
	viewModel: any;
	navigationService: INavigationService;
	userSettings: IUserSettings;
	domElement: HTMLElement;
	$domElement: JQuery;
	isDisposed: boolean;

	private _children: PartChild[];
	private _jqEventNs: string;

	// backward compatibility:
	renderStatuses: typeof RenderStatus;

	/**
	 * Common base class for a part implementation. A part should implement at least one method - `render`.
	 * But this class also support some common practice for part.
	 * @article [Part](docs:part)
	 * @constructs Part
	 * @extends Observable
	 */
	constructor(options?: Part.Options) {
		super();

		if (!this.options) {
			this.options = options || {};
		} else {
			// backward compatibility (before TS 1.8)
			if (options && options !== this.options) {
				this.options = lang.appendEx(this.options, options, {deep: true});
			}
		}

		this.tweakOptions(this.options);

		// initial state for `renderStatus` property - `unloaded`
		this["_renderStatus"] = RenderStatus.unloaded;
		//this.renderStatus(Part.prototype.renderStatuses.unloaded);
	}

	renderStatus(v: RenderStatus): void;
	renderStatus(): RenderStatus;
	/**
	 * @observable-property {Part.RenderStatus}
	 * @description Current state of part rendering.
	 *  lifecycle: unloaded -> ready -> unloaded
	 *  lifecycle: unloaded -> waiting -> unloaded -> ready -> unloaded
	 *  @since 0.17
	 */
	renderStatus(v?: RenderStatus): RenderStatus|void {
		if (!arguments.length) {
			return Part._get(this, "renderStatus");
		}
		let args = Part._set(this, "renderStatus", v);
		if (args) {
			this.onRenderStatusChange(v, args.oldValue);
		}
	}

	protected onRenderStatusChange(value: RenderStatus, oldValue: RenderStatus): void {
		let that = this;
		if (value === RenderStatus.ready) {
			that.onReady();
			that.trigger("ready", that);
		} else {
			if (oldValue === RenderStatus.ready) {
				that.onUnready();
			}
			if (value === RenderStatus.unloaded) {
				that.trigger("unload", that);
			} else if (value === RenderStatus.waiting) {
				that.trigger("waiting", that);
			}
		}
	}

	/**
	 * @deprecated Use static method Part.mixOptions
	 */
	protected mixOptions<T extends Part.Options>(options: T, defaultOptions: T): T {
		if (defaultOptions && defaultOptions === this.options) {
			throw new Error("Field 'this.options' references to defaultOptions objects. Don't define field 'options' in the prototype.");
		}
		return Part.mixOptions(<T>this.options || options, defaultOptions);
	}

	/**
	 * Формирует опции парта, задавая значения по умолчанию.
	 * Вызывать в конструкторе парта ДО вызова родительского конструктора. Не переопределяйте этот метод.
	 * Если вы используете этот метод, не определяйте поле options в прототипе класса.
	 * Вычисление runtime опций, зависящих от других опций, рекомендуется выполнять непосредственно в конструкторе
	 * перед вызовом базового конструктора. Также можно переопределить метод `tweakOptions` (но не вызывать его).
	 * @static
	 * @param {Object} options Опции, переданные в конструктор
	 * @param {Object} defaultOptions Опции по умолчанию. Если определены в прототипе, то передавать как поле прототипа, не используя `this` (иначе возможно некорректное поведение при наследовании).
	 * @returns {*}
	 * @example
	 * constructor: function (options) {
	 *     options = MyPart.mixOptions(options, MyPart.prototype.defaultOptions);
	 *     options.superOption = options.myOption; // fill runtime options (you can override `tweakOptions` also)
	 *     MyPart.Super.call(this, options);
	 *     // some code
	 * },
	 * defaultOptions: {
	 *     // some options
	 * }
	 */
	static mixOptions<T extends Part.Options>(options: T, defaultOptions: T): T {
		return lang.appendEx(options || {}, defaultOptions, { deep: true });
	}

	/**
	 * @deprecated Use static method Part.mixContextOptions
	 */
	protected mixContextOptions<T extends Part.ContextOptions>(
		options: T, defaultOptions: T, contextDefaultOptions: lang.Map<T>): T
	{
		return Part.mixContextOptions(<T>this.options || options, defaultOptions, contextDefaultOptions);
	}

	/**
	 * Формирует опции парта с учетом контекста. Фактически данный метод формирует defaultOptions с учетом контекста,
	 * а затем вызывает `mixOptions`.
	 * Вызывать в конструкторе парта ДО вызова родительского конструктора. Не переопределяйте этот метод.
	 * Вычисление runtime опций, зависящих от других опций, рекомендуется выполнять непосредственно в конструкторе
	 * перед вызовом базового конструктора. Также можно переопределить метод `tweakOptions` (но не вызывать его).
	 * @static
	 * @param {Object} options Опции, переданные в конструктор
	 * @param {Object} defaultOptions Опции по умолчанию. Если определены в прототипе, то передавать как поле прототипа, не используя this (иначе возможно некорректное поведение при наследовании).
	 * @param {Object} [contextDefaultOptions] Контекстные опции по умолчанию. Если определены в прототипе, то передавать как поле прототипа, не используя this (иначе возможно некорректное поведение при наследовании).
	 * @returns {*}
	 * @example
	 * constructor: function (options) {
	 *     options = MyPart.mixContextOptions(options, MyPart.prototype.defaultOptions, MyPart.prototype.contextDefaultOptions);
	 *     options.superOption = options.myOption; // fill runtime options (you can override `tweakOptions` also)
	 *     MyPart.Super.call(this, options);
	 *     // some code
	 * },
	 * defaultOptions: {
	 *     // some options
	 * }
	 * contextDefaultOptions: {
	 *     filter: {
	 *	       commandsOptions: {
	 *             Select: {
	 *                 openInDialog: true
	 *             }
	 *         }
	 *     }
	 * }
	 */
	static mixContextOptions<T extends Part.ContextOptions>(
		options: T, defaultOptions: T, contextDefaultOptions: lang.Map<T>): T
	{
		let contextName: string, contextOptions: T;
		if (options && contextDefaultOptions &&
			(contextName = options.contextName) &&
			(contextOptions = contextDefaultOptions[contextName])
		) {
			defaultOptions = lang.extendEx({}, defaultOptions, contextOptions, {deep: true});
		}
		// NOTE: `this` is a class here, not an instance
		return this.mixOptions(options, defaultOptions);
	}

	/**
	 * Корректирует опции парта, вычисляя их значения в runtime.
	 * Переопределите этот метод, если необходимо вычислить значения опций в зависимости от некоторых runtime условий.
	 * Типичное использование - задать значение одной опции в зависимости от другой опции (например, в зависимости
	 * от опции текущего класса нужно задать значение для опции базового класса). Подобную инициализацию также можно
	 * выполнять непосредственно в конструкторе перед вызовом базового конструктора.
	 * Если необходимо просто задать значения опций по умолчанию и они известны в design time, то удобней использовать
	 * методы `mixOptions` и `mixContextOptions`.
	 * Не вызывайте данный метод из наследников, он должен вызываться только в базовом конструкторе класса Part.
	 * @param {Object} options Опции парта (после задания значений по умолчанию). Всегда заданы.
	 * @virtual
	 * @example
	 * constructor: function (options) {
	 *     options = MyPart.mixOptions(options, MyPart.prototype.defaultOptions);
	 *     MyPart.Super.call(this, options);
	 *     // some code
	 * },
	 * defaultOptions: {
	 *     // some options
	 * },
	 * tweakOptions: function (options) {
	 *     options.superOption = options.myOption;
	 *     MyPart.Super.prototype.tweakOptions.call(this, options);
	 * }
	 */
	protected tweakOptions(options: Part.Options): void {
		// do not change anything by default
	}

	applyHostContext(opt: HostContextOptions): INavigationService.NavigateOptions {
		let navOpts = this.options.navigateOptions;
		if (navOpts && navOpts.openInDialog) {
			opt.host = "dialog";
		}

		let dlgOpts: INavigationService.OpenModalOptions;
		if (opt.host === "dialog" && this.getDialogOptions) {
			// for backward compatibility before 1.26:
			dlgOpts = {
				dialogOptions: this.getDialogOptions()
			};
		}

		if (navOpts || dlgOpts) {
			return lang.extendEx({}, dlgOpts, navOpts, { deep: true });
		}
	}

	protected mixHostOptions<T extends Part.Options> (host: string, hostDefaultOptions: lang.Map<T>): void {
		if (host && hostDefaultOptions) {
			// TODO: это перезапишит опции, заданные в конструкторе!
			this.options = lang.extendEx(this.options, hostDefaultOptions[host], {deep: true});
		}
	}

	/**
	 * Bind the part with a view model.
	 * @param {Object} viewModel
	 */
	setViewModel(viewModel: any): void {
		/**
		 * @description View model of the part. It's a way to associate logic (part) with data (viewModel). View model should be set via `setViewModel` method.
		 * @type {*}
		 * */
		this.viewModel = viewModel;
	}

	/**
	 * Bind the part with NavigationService.
	 * @param {NavigationService} navigationService
	 */
	setNavigationService(navigationService: INavigationService): void {
		let that = this;
		/**
		 * @description Navigation service which can be used by the part to navigate to nested parts.
		 * @type {NavigationService}
		 */
		that.navigationService = navigationService;

		if (that._children) {
			that._children.forEach(function (child) {
				if (child.part.setNavigationService) {
					child.part.setNavigationService(navigationService);
				}
			});
		}
	}

	/**
	 * Render the part into DOM element. Core method of presentation model.
	 * @param {JQuery|HTMLElement} domElement Part's container element
	 */
	render(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;
		that._throwIfDisposed();
		that.beforeRender(domElement);

		let task = that.doRender(domElement);
		if (lang.isPromise(task) && task.state() === "pending") {
			that.renderStatus(RenderStatus.waiting);
			task.always(function renderContinuation() {
				that.afterRender(domElement);
			});
			return task;
		}

		that.afterRender(domElement);
		return task;
	}

	/**
	 * It's called in the begging of Part.render.
	 * By default the method does nothing (extension point).
	 * @param {HTMLElement|jQuery} domElement Part's container element
	 */
	protected beforeRender(domElement?: JQuery|HTMLElement): void {
	}

	/**
	 * Does all heavy lifting of rendering.
	 * Default implementation just sets renderStatus to `renderStatuses.rendering` and assigns `domElement` field.
	 * It's the method it's recommended to override (instead of `render`).
	 * @param {HTMLElement|jQuery} domElement Part's container element
	 */
	protected doRender(domElement: JQuery|HTMLElement): lang.Promisable<void> {
		let that = this;
		if (!domElement) {
			throw new Error("Part.render was called without domElement");
		}
		if (that.domElement) {
			throw new Error("Part.render was called repeatedly without unload ");
		}
		that.renderStatus(RenderStatus.rendering);
		that.$domElement = $(domElement);
		that.domElement = that.$domElement[0];
	}

	/**
	 * It's called at the end of part's rendering.
	 * By default the method updates `renderStatus` taking into account children's states.
	 */
	protected afterRender(domElement?: JQuery|HTMLElement): void {
		let that = this;

		if (that._children) {
			that._children.forEach((child) => {
				if (child.part.renderStatus && child.trackStatus /*&& child.part.renderStatus() !== Part.RenderStatus.ready*/) {
					child.subscription = (<Part>child.part).subscribe("change:renderStatus", function childRenderStatusChangeHandler (sender, value) {
						if (value === RenderStatus.rendering) {
							that.renderStatus(RenderStatus.rendering);
						} else if (that.renderStatus() !== RenderStatus.unloaded) {
							// NOTE: if current part is already unloaded then ignore the child status changing
							that._updateRenderStatus(false);
						}
					});
				}
			});
		}
		//
		that._updateRenderStatus(true);
	}

	private _updateRenderStatus(afterRender: boolean): void {
		let that = this,
			allready = true;

		if (that._children) {
			allready = that._children.every((child: PartChild) => {
				return !child.trackStatus || !child.part.renderStatus
					|| child.part.renderStatus() === RenderStatus.ready
					|| afterRender && child.part.renderStatus() === RenderStatus.unloaded;
			});
		}
		if (allready) {
			that.renderStatus(RenderStatus.ready);
		} else {
			that.renderStatus(RenderStatus.waiting);
		}
	}

	/**
	 * The method is called on "ready" event which is fired when `renderStatues` changes to `rendered`.
	 * By default the method does nothing (extension point).
	 * Please note that the method is subscribed on the event in `Part.constructor`. So a descendant class should not forget to call the base constructor.
	 * @since 0.17
	 */
	protected onReady(): void {}

	/**
	 * The method is called on "unload" and "waiting" events which are fired when `renderStatues` changes to `unloaded` and `waiting`.
	 * By default the method does nothing (extension point).
	 * Please note that the method is subscribed on the event in `Part.constructor`. So a descendant class should not forget to call the base constructor.
	 * @since 0.17
	 */
	protected onUnready(): void {}

	/**
	 * Helper method for generating DOM event `domChanged` on part's element.
	 * Actually it uses html.notifyDOMChanged method.
	 */
	protected notifyDOMChanged(): void {
		html.notifyDOMChanged(this.domElement);
	}

	/**
	 * Unload the part and render it again in the same DOM element.
	 */
	rerender(): void {
		let $domElement = this.$domElement;
		if (!$domElement) {
			throw new Error("Part.rerender was called without render");
		}

		//that.renderStatus(RenderStatus.rendering);
		this.unload({reason: "rerender"});
		this.render($domElement);
		// TODO: highlight in debug
	}

	/**
	 * Unload the part and its children.
	 */
	unload(options?: Part.CloseOptions): void {
		let rerender = options && options.reason === "rerender",
			that = this,
			i, child;

		if (that.isDisposed) { return; }
		if (!rerender) {
			that.renderStatus(RenderStatus.unloaded);
		}
		// unload children, if a child was created during render then we'll dispose and remove it
		if (that._children) {
			for (i = that._children.length - 1; i >= 0; i--) {
				child = that._children[i];
				// NOTE: reason='rerender' нельзя передавать в дочерний парт,
				// иначе он решит, что он ререндерится и не установит renderStatus в 'unload'.
				that._unloadChild(child, options && options.reason != 'rerender' ? options : undefined);
				if (child.disposeOnUnload || !child.keepOnUnload) {
					that._children.splice(i, 1);
				}
			}
		}

		if (that.$domElement) {
			// NOTE (to commented below): domElement is NOT privately owned by the part, e.g. parent part
			// has access to the same DOM element and can subscribe to some DOM event on it. Therefore
			// it's incorrect to unsubscribe all handlers from all events:
			// 	$(that.domElement).off()
			// Every part should unsubscribe its own handlers itself.

			let $element = that.$domElement;
			$element.empty();

			// if there were handlers for namespaced events (subscribed via jqOn), remove them all at once
			if (that._jqEventNs) {
				$element.off(that._jqEventNs);
				that._jqEventNs = undefined;
			}
		}
		that.domElement  = undefined;
		that.$domElement = undefined;
	}

	/**
	 * Dispose the part and its children. If it's needed unload first.
	 * The instance should not be used after call of dispose.
	 */
	dispose(options?: Part.CloseOptions): void {
		let that = this;
		if (that.isDisposed) { return; }

		if (that.domElement) {
			that.unload(lang.append({}, options, {reason: "dispose"}));
		}
		if (that._children) {
			that._children.forEach((child: PartChild) => {
				if (child.part.dispose) {
					child.part.dispose(options);
				}
			});
			that._children.length = 0;
		}

		super.dispose();
		that.viewModel = undefined;
		that.navigationService  = undefined;
		that.isDisposed = true;
	}

	protected _throwIfDisposed(): void {
		if (this.isDisposed) {
			throw new Error("Part was disposed");
		}
	}

	/**
	 * Register a child part
	 * @param {Part} part
	 * @param {Object|Boolean} [options]
	 * @param {Boolean} [options.disposeOnUnload] dispose the child part on current part unload
	 * @param {Boolean} [options.keepOnUnload] reuse the child part on unload, i.e. unload it but keep the reference
	 * @param {Boolean} [options.trackStatus] create dependent binding for renderStatus of the current part on child's renderStatus
	 * @param {Boolean} [options.name] name of the child part, can be used in `getChild`
	 * @since 0.17
	 */
	registerChild(part: IPart, options?: RegisterChildOptions|boolean): void {
		let that = this,
			i,
			child: PartChild,
			item: PartChild = { part: part };

		that._throwIfDisposed();
		if (lang.isBoolean(options)) {
			item.disposeOnUnload = options;
		} else if (options) {
			item.disposeOnUnload = options.disposeOnUnload;
			item.keepOnUnload = options.keepOnUnload;
			item.name = options.name;
			item.trackStatus = options.trackStatus;
		}
		if (!that._children) {
			that._children = [];
		} else if (that._children.length) {
			for (i = that._children.length - 1; i >= 0; i--) {
				child = that._children[i];
				if (child && child.part === part) {
					// the part is already registered, just overwrite its options
					lang.extendEx(child, item, {});
					return;
				}
			}
		}
		if (that.navigationService && part.setNavigationService) {
			part.setNavigationService(that.navigationService);
		}
		that._children.push(item);
	}

	/**
	 * Return a registered child part by name or by index.
	 * @param {String|Number} name Name or index of child part
	 * @return {Part}
	 * @since 0.17
	 */
	getChild(name: string|number): IPart {
		let that = this,
			i,
			child;
		if (that._children) {
			if (lang.isNumber(name)) {
				child = that._children[name];
				if (child) {
					return child.part;
				}
				return null;
			}
			for (i = that._children.length - 1; i >= 0; i--) {
				child = that._children[i];
				if (child && child.name === name) {
					return child.part;
				}
			}
			// TODO: if (recursive) // go deeper
		}
	}

	/**
	 * Opposite method to resiterChild. Unload and remove child part.
	 * @param {Part} part
	 * @since 0.17
	 */
	unregisterChild(part: IPart): void {
		let that = this,
			i,
			child;
		if (that._children) {
			for (i = that._children.length - 1; i >= 0; i--) {
				child = that._children[i];
				if (child && child.part === part) {
					that._children.splice(i, 1);
					that._unloadChild(child);
					return;
				}
			}
		}
	}

	private _unloadChild(child: PartChild, options?: Part.CloseOptions): void {
		if (child.disposeOnUnload && child.part.dispose) {
			child.part.dispose(options);
		} else if (child.part.unload) {
			child.part.unload(options);
		}
		if (child.subscription) {
			child.subscription.dispose();
			child.subscription = undefined;
		}
	}

	protected jqOn(event: string, handler: (eventObject: JQueryEventObject, ...args: any[]) => any): JQuery;
	protected jqOn(event: string, filter: string, handler: (eventObject: JQueryEventObject, ...args: any[]) => any): JQuery;
	protected jqOn($element: JQuery|HTMLElement, event: string, handler: (eventObject: JQueryEventObject, ...args: any[]) => any): JQuery;
	protected jqOn($element: JQuery|HTMLElement, event: string, filter: string, handler: (eventObject: JQueryEventObject, ...args: any[]) => any): JQuery;
	/**
	 * Subscribe part's domElement on event(s) via jQuery.on method
	 * automatically adding a namespace for event(s) which will be used in `unload`
	 * to automatically unsubscribe from thet event(s).
	 * @param args
	 */
	protected jqOn(...args): JQuery {
		let that = this,
			$element: JQuery,
			events: string,
			nextArgs = -1;
		if (args[0] instanceof $) {
			// ($element: JQuery, event: string, cb)
			// ($element: JQuery, event: string, filter: string, cb)
			$element = args[0];
			events = args[1];
			nextArgs = 2;
		} else if (args[0].nodeType !== undefined) {
			// ($element: JQuery, event: string, cb)
			// ($element: JQuery, event: string, filter: string, cb)
			$element = $(args[0]);
			events = args[1];
			nextArgs = 2;
		} else {
			// (event, filter, cb) or (event, cb)
			$element = that.$domElement;
			events = args[0];
			nextArgs = 1;
		}
		let eventsArray = ( events || "" ).match(/\S+/g) || [ "" ];
		let jqNS = that._jqEventNs;
		if (!jqNS) {
			jqNS = that._jqEventNs = "." + (that.name || "") + lang.uuid();
		}

		for (let event of eventsArray) {
			$element.on.apply($element, [event + jqNS].concat(args.slice(nextArgs)));
		}

		return $element;
	}

	protected jqOff(event?: string): JQuery;
	protected jqOff($element: JQuery|HTMLElement, event?: string): JQuery;
	/**
	 * Unsubscribe from event(s) previously subscribed via `jqOn` method
	 */
	protected jqOff(...args): JQuery {
		let that = this;
		let jqNS = that._jqEventNs;
		if (!jqNS) { return; }

		let	$element: JQuery,
			events: string;
		if (args.length > 1 && args[0] instanceof $) {
			$element = args[0];
			events = args[1];
		} else if (args.length > 1 && args[0].nodeType !== undefined) {
			$element = $(args[0]);
			events = args[1];
		} else {
			$element = that.$domElement;
			events = args[0];
		}

		if (events) {
			let eventsArray = ( events || "" ).match(/\S+/g) || [""];
			for (let event of eventsArray) {
				$element.off(event + jqNS);
			}
		} else {
			$element.off(jqNS);
		}
	}

	/**
	 * Helper method to open specified part via current navigationService (in the region of the current part).
	 * @param {String|Object} part Part instance or part name
	 * @param {Object} [partOptions] Options that will be passed into part's constructor (if part is String) (see NavigationService.navigate)
	 * @param {Function} [onReturn] Callback to be called when user returns from opened part (see NavigationService.navigate)
	 * @returns {*}
	 */
	openPart(part: IPart|string, partOptions?: any, onReturn?: (v: any) => void): lang.Promise<IPart> {
		if (!this.navigationService)
			throw new Error("Current part has no navigationService");
		return this.navigationService.navigate({
			part: part,
			partOptions: partOptions,
			onReturn: onReturn
		});
	}

	/**
	 * Method can return dialog options, which will be used in applyHostContext, also they can be specified in `navigationOptions` option.
	 * NOTE: Subject to kill. Prefer using navigationOptions option.
	 */
	getDialogOptions?(): any;
}

namespace Part {
	export interface Options {
		navigateOptions?: INavigationService.NavigateOptions;
		userSettings?: false | IUserSettings.Options;
		// NOTE: до версии 1.32 тут был index signature:
		//[key: string]: any;
		// но начиная с TS 2.2 это убивает всю типизацию для опций, поэтому убрали
	}

	export interface ContextOptions extends Options {
		contextName?: string;
	}

	export interface RegisterChildOptions {
		/**
		 * Dispose the child part on current part unload
		 */
		disposeOnUnload?: boolean;
		/**
		 * Reuse the child part on unload, i.e. unload it but keep the reference
		 */
		keepOnUnload?: boolean;
		/**
		 * Create dependent binding for renderStatus of the current part on child's renderStatus
		 */
		trackStatus?: boolean;
		/**
		 * Name of the child part, can be used in `getChild`
		 */
		name?: string;
	}

	export interface CloseOptions extends PartCloseOptions { }

	// actual definitions see in .ui.types.ts (as they are shared with .ui::IPart)
	export type RenderStatus = _RenderStatusType;
	export const RenderStatus = _RenderStatusConst;
}

Part.mixin({
	// backward compatibility:
	renderStatuses: RenderStatus
});

export = Part;
