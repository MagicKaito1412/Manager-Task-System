import core = require("core");
import View = require("lib/ui/handlebars/View");
import defaultTemplate = require("xhtmpl!lib/ui/templates/Carousel.hbs");
import controlsTemplate = require("xhtmpl!lib/ui/templates/Carousel.controls.hbs");

import "xcss!lib/ui/styles/carousel.css";

import lang = core.lang;
import KnownCommands = Carousel.KnownCommands;

class Carousel<T> extends View {
	static defaultOptions: Carousel.Options = {
		template: defaultTemplate,
		unbound: true,
		/**
		 * @type Array|ObservableCollection
		 */
		items: undefined,
		formatter: (item): string => {
			return item == null ? "" : item.toString();
		},
		commands: undefined
	};

	/**
	 * @observable-getter {Array}
	 */
	@lang.decorators.observableAccessor({field: "_items"})
	items: core.lang.ObservableGetter<lang.IObservableCollection<T>>;
	// backing field for items property
	private _items: lang.IObservableCollection<T>;

	/**
	 * @observable-property {Number}
	 */
	@lang.decorators.observableAccessor()
	position: lang.ObservableProperty<number>;

	options: Carousel.Options;
	commands: Carousel.KnownCommands;

	private _itemsOwner: boolean;

	/**
	 * @constructs Carousel
	 * @extends View
	 * @param {Object} [options]
	 * */
	constructor (options?: Carousel.Options) {
		options = Carousel.mixOptions(options, Carousel.defaultOptions);
		super(options);

		let items = this.options.items || [];
		if (lang.ObservableCollection.isObservableCollection(items)) {
			this._items = items;
		} else {
			//that._items = new lang.ObservableCollection(<any[]>items);
			this._items = this.createItemsCollection(items as T[]);
			this._itemsOwner = true;
		}
		this.position(0);
		if (!lang.isFunction(this.options.formatter)) {
			this.options.formatter = () => { return ""; };
		}
		this.commands = lang.extend(this.createCommands(), this.options.commands || {});
	}

	dispose (options?: core.ui.Part.CloseOptions): void {
		if (this._itemsOwner) {
			let items = this.items() as (lang.IDisposable & lang.IObservableCollection<T>);
			if (lang.isDisposable(items)) {
				items.dispose();
			}
		}
		super.dispose(options);
	}

	setViewModel (): void {
		// NOTE: viewModel для шаблона (т.е. this) является сам объект Carousel, поэтому задавать viewModel нельзя
	}

	current (): T {
		return this.items().get(this.position());
	}

	count (): number {
		return this.items().count();
	}
	text (): string {
		let that = this;
		return that.options.formatter.call(that, that.current());
	}

	counterText (): string {
		let that = this;
		return (that.position() + 1) + " / " + that.items().count();
	}

	/**
	 * Removes current item
	 * @returns {*} removed item
	 */
	removeCurrent (): T {
		let that = this,
			items = that.items(),
			pos = that.position(),
			item = items.get(pos);
		// TODO: need removeAt method
		items.remove(item);
		if (pos >= items.count()) {
			that.position(pos - 1);
		}
		return item;
	}

	/**
	 * @protected
	 * @returns {{Backward: (Command), Forward: (Command)}}
	 */
	createCommands (): Carousel.KnownCommands {
		let cmdBackward = core.createCommand({
				execute: function (args) {
					args.part._moveBackward();
				}
			}),
			cmdForward = core.createCommand({
				execute: function (args) {
					args.part._moveForward();
				}
			});
		return {
			Backward: cmdBackward,
			Forward: cmdForward
		};
	}

	protected createItemsCollection(items?: T[]): lang.IObservableCollection<T> {
		return new lang.ObservableCollection(items);
	}

	protected _moveBackward (): void {
		let that = this,
			len = that.count(),
			posFrom = that.position(),
			posTo = (posFrom + len - 1) % len;

		that._move(posFrom, posTo);
	}

	protected _moveForward (): void {
		let that = this,
			len = that.count(),
			posFrom = that.position(),
			posTo = (posFrom + 1) % len;

		that._move(posFrom, posTo);
	}

	protected _move (posFrom: number, posTo: number): void {
		let that = this,
			args = {from: posFrom, to: posTo, total: that.count(), cancel: false};

		that.trigger("moving", that, args);
		if (!args.cancel) {
			that.position(posTo);
			that.trigger("moved", that, args);
		}
	}

}

namespace Carousel {
	export interface Options extends View.Options {
		items?: Array<any> | lang.IObservableCollection<any>;
		formatter?: (item: any) => string;
		commands?: KnownCommands;
	}

	export interface KnownCommands {
		Backward?: core.commands.Command;
		Forward?: core.commands.Command;
	}

	export interface MovingEventArgs {
		from: number;
		to: number;
		total: number;
		cancel: boolean;
	}
}

View.Handlebars.registerPartial("carousel-controls", controlsTemplate);

core.ui.Carousel = Carousel;

export = Carousel;
