import core = require("core");
import ObjectTree = require("lib/ui/tree/ObjectTree");
import Menu = require("lib/ui/menu/Menu");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;
import { TreeNode, Identity } from "lib/ui/tree/Tree";

import Application = core.Application;
import MenuOptions = Menu.Options;
import ICommand = core.commands.ICommand;
import CommandArgs = core.commands.CommandArgs;
import Dialog = core.ui.Dialog;
import Options = ObjectTreeSelector.Options;

class ObjectTreeSelector extends ObjectTree {
	static defaultOptions: Options = {
		autoLoad: true,
		navigateOptions: {
			activateOptions: {
				freezeUrl: true
			}
		},
		presenterOptions: {
			hideMenuNode: false
		}
	};

	static defaultMenus: ObjectTree.KnownMenus = {
		TreeNode: { items: [
			{
				name: "Select",
				title: resources["ok"],
				icon: "ok",
				isDefaultAction: true
			}, {
				name: "Close",
				title: resources["cancel"],
				icon: "cancel",
				params: { result: false }
			}
		] }
	};

	@lang.decorators.constant(lang.append(ObjectTreeSelector.defaultMenus, ObjectTree.prototype.defaultMenus))
	defaultMenus: ObjectTree.KnownMenus;

	static hostDefaultOptions: lang.Map<Options> = {};

	options: Options;

	/**
	 * @constructs ObjectTreeSelector
	 * @extends ObjectTree
	 * @param {Application} app
	 * @param {Object} options
	 */
	constructor(app: Application, options?: Options) {
		options = ObjectTreeSelector.mixOptions(options, ObjectTreeSelector.defaultOptions);
		super(app, options);

		if (!this.title && this.options.entityType) {
			let entityMeta = this.app.model.meta.entities[this.options.entityType];
			if (entityMeta) {
				this.title = lang.stringFormat(resources["objectSelector.title"], entityMeta.descr);
			}
		}
	}

	applyHostContext(opt?: {host: string}): core.INavigationService.NavigateOptions {
		let navOpt = super.applyHostContext(opt);
		this.mixHostOptions(opt.host, ObjectTreeSelector.hostDefaultOptions);
		return navOpt;
	}

	protected createNodeMenuDefaults(node: TreeNode): MenuOptions {
		let identity = this.getNodeIdentity(node);
		return Menu.defaultsFor(ObjectTreeSelector.defaultMenus.TreeNode, "ObjectTreeSelectorNode", identity.type);
	}

	protected createCommands(): lang.Map<ICommand> {
		let that = this;
		return lang.append(super.createCommands(), {
			Select: new core.commands.BoundCommand(that.doSelect, that.canSelect, that),
			Close: new core.commands.BoundCommand(that.doClose, that)
		});
	}

	protected _isNodeSelectable(node: TreeNode): boolean {
		if (!super._isNodeSelectable(node)) {
			return false;
		}

		let that = this,
			entityType = that.options.entityType,
			excludeIds = that.options.excludeIds,
			identity: Identity;

		if (entityType) {
			identity = that.getNodeIdentity(node);
			if (identity && identity.type !== entityType) {
				return false;
			}
		}
		if (excludeIds && excludeIds.length) {
			identity = identity || that.getNodeIdentity(node);
			if (identity && excludeIds.indexOf(identity.id) >= 0) {
				return false;
			}
		}
		return true;
	}

	protected doSelect(): void {
		let selectionData = this.currentNodes().map(node => node.data());
		// NOTE: different nodes may have the same data, make unique
		selectionData = lang.unique(selectionData);
		this.close({
			result: { selection: selectionData }
		});
	}

	protected canSelect(): boolean {
		return !!this.currentNodes().length;
	}

	protected doClose(): void {
		this.close();
	}

	protected close(args?: CommandArgs): void {
		let nav = this.navigationService;
		if (nav) {
			nav.close(args && args.result);
		}
	}
}

ObjectTreeSelector.mixin(/** @lends ObjectTreeSelector.prototype */ {
	defaultOptions: ObjectTreeSelector.defaultOptions,
	contextDefaultOptions: ObjectTreeSelector.hostDefaultOptions
});

namespace ObjectTreeSelector {
	export interface Options extends ObjectTree.Options {
		entityType?: string;
		excludeIds?: string[];
	}
}

core.ui.ObjectTreeSelector = ObjectTreeSelector;

export = ObjectTreeSelector;
