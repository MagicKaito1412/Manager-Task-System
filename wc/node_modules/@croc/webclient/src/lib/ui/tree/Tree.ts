import core = require("core");
import Component = require("lib/ui/Component");
import Menu = require("lib/ui/menu/Menu");
import formatters = require("lib/formatters");
import resources = require("i18n!lib/nls/resources");
import lang = core.lang;
import Deferred = lang.Deferred;
import Promise = lang.Promise;
import Application = core.Application;
import MenuOptions = Menu.Options;
import ICommand = core.commands.ICommand;
import Options = Tree.Options;
import Identity = Tree.Identity;
import TreeNodeData = Tree.TreeNodeData;
import TreeNodeIdentifierCallback = Tree.TreeNodeIdentifierCallback;
import TreeNodeFormatterCallback = Tree.TreeNodeFormatterCallback;
import TreeNodeLoadCallback = Tree.TreeNodeLoadCallback;
import TreeNodeIconizerCallback = Tree.TreeNodeIconizerCallback;
type TreeNodeExport = TreeNode;
import ITreeLoader  = Tree.ITreeLoader;
import { ICommandLazyMap } from "lib/core.commands";

class TreeNode extends lang.Observable {
	/**
	 * @deprecated Use Tree.NodeState
	 */
	static States: typeof Tree.NodeState;

	private _state: Tree.NodeState;
	private _children: lang.ObservableCollection<TreeNode>;
	private _data: any;

	/**
	 * @constructs TreeNode
	 * @extends Observable
	 */
	constructor(data: any, isLeaf?: boolean) {
		super();

		this._state = isLeaf ? Tree.NodeState.loaded : Tree.NodeState.initial;
		this._children = new lang.ObservableCollection([]);
		this._data = data || {};

		this.bind("change:state", this._onStateChange, this);

		if (data.load && !data.isLoaded) {
			lang.when(data.load()).done((loaded) => {
				this.data(loaded);
			});
		}
	}

	dispose(): void {
		let that = this;
		that._children.dispose();
		that.state(Tree.NodeState.disposed);

		super.dispose();
	}

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	data: lang.ObservableProperty<any>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	icon: lang.ObservableProperty<string>;

	/**
	 * @observable-property {Tree.NodeState}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<Tree.NodeState>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	message: lang.ObservableProperty<string>;

	/**
	 * @observable-property {TreeNode}
	 */
	@lang.decorators.observableAccessor()
	parent: lang.ObservableProperty<TreeNode>;

	/**
	 * @observable-getter {ObservableCollection}
	 */
	@lang.decorators.observableGetter()
	children: lang.ObservableGetter<lang.IObservableCollection<TreeNode>>;

	protected _onStateChange(sender: TreeNode, v: Tree.NodeState): void {
		if (v !== Tree.NodeState.failed) {
			this.message(null);
		}
	}
}
namespace TreeNode {}

interface TreeNodeInternal extends TreeNode {
	//_loader: lang.IDisposableFunction;
	_loader: lang.support.IObservableExpression;
	_loadingDeferred: lang.Promise<void>;
}

/**
 * @callback TreeNodeFilterCallback
 * @param {Tree} tree
 * @param {TreeNode} node
 * @returns {boolean}
 */


/**
 * Returns an identity of the TreeNode
 * @callback TreeNodeIdentifierCallback
 * @param {Tree} tree
 * @param {TreeNode} node
 * @returns {{type: string, id: string}}
 */

/**
 * Returns a text presentation of the TreeNode
 * @callback TreeNodeFormatterCallback
 * @param {Tree} tree
 * @param {TreeNode} node
 * @returns {String}
 */

/**
 * Returns children data of the TreeNode
 * @callback TreeNodeLoadCallback
 * @param {Tree} tree
 * @param {TreeNode} node
 * @param {object} params
 * @param {Object} options
 * @param {String} [options.reason]
 */

/**
 * Returns icon of the TreeNode
 * @callback TreeNodeIconizerCallback
 * @param {Tree} tree
 * @param {TreeNode} node
 * @returns {String}
 */

/**
 * A component for loading Tree
 * @typedef {Object} ITreeLoader
 * @property {TreeNodeLoadCallback} loadChildren
 */

class Tree extends Component {
	static defaultOptions: Options = {
		presenter: undefined,
		Presenter: undefined,
		presenterOptions: {},

		navigateOptions: {
			dialogOptions: {
				menu: false
			}
		},

		/**
		 * @type Boolean
		 */
		hasCheckboxes: false,
		/**
		 * @type Boolean
		 */
		hasNumbering: true,

		commands: undefined,
		/**
		 * @type {Object|Function}
		 */
		menuTree: undefined,
		/**
		 * @type {Object|Function}
		 */
		menuNode: undefined,
		/**
		 * @type {TreeNodeIdentifierCallback}
		 */
		identifier: undefined,
		/**
		 * @type {TreeNodeFormatterCallback}
		 */
		formatter: undefined,
		/**
		 * @type {TreeNodeIconizerCallback}
		 */
		iconizer: undefined,
		/**
		 * @type {TreeLoader}
		 */
		loader: undefined,
		/**
		 * @type Boolean
		 */
		autoLoad: true,
		strings: {
			not_loaded: resources["objectTree.state.not_loaded"],
			load_failed: resources["objectTree.state.load_failed"],
			no_data: resources["objectTree.state.no_data"]
		}
	};

	@lang.decorators.constant(TreeNode)
	Node: typeof TreeNode;

	@lang.decorators.constant("ROOT")
	ROOT_NODE_NAME: string;

	options: Options;
	app: core.Application;
	commands: lang.Map<ICommand>;
	menuTree: Menu;
	menuNode: Menu;
	menuSelection: Menu;

	private _root: TreeNode;
	private _selection: lang.ObservableCollection<TreeNode>;
	protected traceSource: core.diagnostics.TraceSource;

	/**
	 * @constructs Tree
	 * @extends Component
	 */
	constructor(app: Application, options?: Options) {
		if (!app) { throw new Error("ArgumentException: app can't be null"); }

		options = Tree.mixOptions(options, Tree.defaultOptions);
		super(options);

		this.app = app;
		this.userSettings = core.UserSettings.create(this.options.userSettings);

		this._initializeProps();

		this._initializeMenus();

		this.initPresenter();

		this.bind("change:activeNode", this._onActiveNodeChanged, this);
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		let that = this;
		that.removeNode(that.root());

		super.dispose(options);
	}

	/**
	 * Root node of the tree.
	 * @observable-getter {TreeNode}
	 */
	@lang.decorators.observableGetter()
	root: lang.ObservableGetter<TreeNode>;

	/**
	 * Active node of the tree.
	 * @observable-property {TreeNode}
	 */
	@lang.decorators.observableAccessor()
	activeNode: lang.ObservableProperty<TreeNode>;

	/**
	 * Selected (checked) nodes.
	 * @observable-getter {Array}
	 */
	@lang.decorators.observableGetter()
	selection: lang.ObservableGetter<lang.IObservableCollection<TreeNode>>;

	/**
	 * Additional message reporting something useful for the user
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	hintMessage: lang.ObservableProperty<string>;

	protected tweakOptions(options: Options): void {
		lang.appendEx(options, {
			presenterOptions: {
				hasCheckboxes: options.hasCheckboxes,
				hasNumbering: options.hasNumbering,
				columns: options.columns,
				dnd: (options.dnd && options.dnd.dragStart && options.dnd.dragDrop) ? true : false
			}
		}, { deep: true });
		super.tweakOptions(options);
	}

	/**
	 * Returns an array of selected nodes (if any) or an array with single activeNode (if any).
	 * If there are no selected and active nodes, returns an empty array;
	 * @returns {Array}
	 */
	currentNodes(): TreeNode[] {
		let that = this, selection,	activeNode;

		selection = that.selection();
		if (selection.count()) {
			return selection.all().filter(that.isNodeSelectable, that);
		}

		activeNode = that.activeNode();
		if (activeNode && that.isNodeSelectable(activeNode)) {
			return [ activeNode ];
		}

		return [];
	}

	/**
	 *
	 * @virtual
	 * @param {TreeNode} node
	 * @returns {{type: string, id: string}}
	 */
	getNodeIdentity(node: TreeNode): Identity {
		let that = this,
			identifier = that.options.identifier;
		return (identifier && identifier(that, node)) || that.defaultIdentifier(that, node) || {};
	}

	protected defaultIdentifier(tree: Tree, node: TreeNode): Identity {
		let data = node && node.data();
		if (!data) { return {}; }
		return {
			id: data.id,
			type: data.type || data.toString()
		};
	}

	/**
	 *
	 * @virtual
	 * @param {TreeNode} node
	 * @returns {string}
	 */
	getNodeTitle(node: TreeNode): string {
		let that = this,
			formatter = that.options.formatter;
		return (formatter && formatter(that, node)) || that.defaultFormatter(that, node) || "";
	}

	protected defaultFormatter(tree: Tree, node: TreeNode): string {
		let data = node && node.data(),
			title = !data ? "" : (lang.isPlainObject(data) && data.title) || data.toString();
		return lang.encodeHtml(title);
	}

	/**
	 *
	 * @virtual
	 * @param {TreeNode} node
	 * @returns {String}
	 */
	getNodeIcon(node: TreeNode): string {
		let that = this,
			iconizer = that.options.iconizer;
		return node.icon() ||
			(iconizer && iconizer(that, node)) ||
			(that.defaultIconizer(that, node));
	}

	protected defaultIconizer(tree: Tree, node: TreeNode): string {
		let data = node && node.data(),
			iconProvider = core.ui.iconProvider;
		return (data && iconProvider && iconProvider.getObjectIconName(data)) || null;
	}

	/**
	 *
	 * @virtual
	 * @param {TreeNode} node
	 * @param {Object} column
	 * @returns {String}
	 */
	getNodeColumnValue(node: TreeNode, column: Tree.TreeColumn): string | formatters.SafeHtml {
		let res;
		if (column.getter) {
			res = column.getter(node);
		} else {
			res = core.lang.get(node.data(), column.name);
		}
		if (column.html) {
			return formatters.safeHtml(res);
		}
		return res;
	}

	/**
	 *
	 * @method
	 * @virtual
	 * @param {TreeNode} node
	 * @param {*} params
	 * @param {*} options
	 * @returns {Deferred}
	 */
	getNodeChildren(node: TreeNode, params?: any, options?: any): TreeNodeData[]|Promise<TreeNodeData[]> {
		let that = this,
			loader = that.options.loader;
		//that.traceSource.debug("getNodeChildren of '" + that.getNodeTitle(node) + "'");

		return (loader && loader.loadChildren(that, node, params, options)) ||
			(that.defaultLoader && that.defaultLoader.loadChildren(that, node, params)) ||
			null;
	}

	@lang.decorators.constant(null)
	protected defaultLoader: ITreeLoader;

	/**
	 *
	 * @virtual
	 * @param node
	 * @returns {*}
	 */
	getNodeLoadParams(node: TreeNode): any {
		return {};
	}

	getNodeParent(node: TreeNode): TreeNode {
		return node.parent();
	}

	getNodePath(node: TreeNode): Identity[] {
		let that = this,
			path = [ that.getNodeIdentity(node) ];
		while (node = that.getNodeParent(node)) {
			path.push(that.getNodeIdentity(node));
		}
		return path.reverse();
	}

	/**
	 * Checks if the node can be selected
	 * @param node
	 * @returns {boolean}
	 */
	isNodeSelectable(node: TreeNode): boolean {
		let that = this,
			filter = that.options.selectionFilter;
		return !!lang.coalesce(filter && filter(that, node), that._isNodeSelectable(node));
	}

	/**
	 * Checks if the node can be selected by default (w/o option selectionFilter)
	 * @param node
	 * @returns {boolean}
	 */
	protected _isNodeSelectable(node: TreeNode): boolean {
		return true;
	}

	addNode(node: TreeNode, targetNode?: TreeNode, suppressEvent?: boolean): void {
		let that = this,
			parentNode = targetNode || that.root();

		node.parent(parentNode);

		parentNode.children().add(node);
		// TOTHINK: нужно ли?
		//parentNode.state(parentNode.states.loaded);

		node.bind("change", that._onNodeChange, that);

		if (!suppressEvent) {
			that.trigger("change:nodes", that, { added: [ node ] });
		}
	}

	addJson(json: TreeNodeData, targetNode?: TreeNode): TreeNode {
		let that = this,
			node = new that.Node(json.data, (json.children && !json.children.length) || !!json.isLeaf);

		if (json.icon) {
			node.icon(json.icon);
		}

		that.addNode(node, targetNode);

		if (json.children) {
			json.children.forEach(function (childJson) {
				that.addJson(childJson, node);
			});
		}

		return node;
	}

	addJsons(childrenData: TreeNodeData[], targetNode?: TreeNode): void {
		let that = this;
		let children: TreeNode[] = [];
		let grandChildren: number[] = [];
		for (let i = 0; i < childrenData.length; i++) {
			let json = childrenData[i];
			let child = new that.Node(json.data, (json.children && !json.children.length) || !!json.isLeaf);
			if (json.icon) {
				child.icon(json.icon);
			}
			// NOTE: we need the created node only for creating its children below
			children.push(child);
			if (json.children && json.children.length) {
				grandChildren.push(i);
			}

			that.addNode(child, targetNode, /*suppressEvent: */true);
		}
		that.traceSource.time("trigger change:nodes");
		that.trigger("change:nodes", that, { added: children });
		that.traceSource.timeEnd("trigger change:nodes");

		// recursively process sub-children
		for (let idx of grandChildren) {
			that.addJsons(childrenData[idx].children, children[idx]);
		}
	}

	removeNode(node: TreeNode): void;
	removeNode(node: TreeNodeInternal): void {
		let that = this,
			parent = node.parent(),
			activeChildIndex = -1;


		// NOTE: dispose 'loader' observable expression, which can be cached by loadNodeChildren
		if (node._loader) {
			node._loader.dispose();
			node._loader = undefined;
		}

		if (parent) {
			// memorize active child node
			let activeNode = that.activeNode();
			if (node === activeNode || that.isDescendantNode(activeNode, node)) {
				activeChildIndex = parent.children().indexOf(node);
			}

			parent.children().remove(node);
			node.parent(null);
		}

		that.removeNodeChildren(node); // recursive

		node.unbind("change", null, that);

		// restore active child node
		if (activeChildIndex >= 0) {
			that._activateChild(parent, activeChildIndex);
		}
		that.selection().remove(node);

		that.trigger("change:nodes", that, { removed: [ node ] });

		node.dispose();
	}

	removeNodeChildren(node: TreeNode): void {
		node.children().all().slice().forEach((childNode) => {
			this.removeNode(childNode);
		});
	}

	loadNodeChildren(node: TreeNode, options?: any): Promise<void>;
	loadNodeChildren(node: TreeNodeInternal, options?: any): Promise<void> {
		// TODO: cancellation

		if (node._loadingDeferred) {
			return node._loadingDeferred;
		}
		let that = this;

		let params = that.getNodeLoadParams(node);
		// NOTE: null params mean there was an error during getting params
		if (params == null) { return; }

		let deferred = lang.deferred<void>();
		deferred.always(() => {
			node._loadingDeferred = undefined;
		});
		node._loadingDeferred = deferred;

		if (node._loader) {
			node._loader.dispose();
		}
		// TODO: allow disabling OE creation at all
		if (that.options.loaderObsExp === "disabled" || that.options.loaderObsExp === false) {
			node._loader = {
				evaluate: function(tree, args): TreeNodeData[]|Promise<TreeNodeData[]> {
					//[node, params, options]
					//node: TreeNode, params?: any, options?: any): TreeNodeData[]|Promise<TreeNodeData[]> {
					return tree.getNodeChildren.apply(tree, args);
				},
				dispose: lang.noop,
				suppress: lang.noop,
				resume: lang.noop
			};
		} else {
			// NOTE: observe execution of 'getNodeChildren' method to refill children when something will change,
			// It can be auto-load of some observed not loaded objects, so it's important to signal to the same deferred
			node._loader = lang.support.ObservableExpression.create(that.getNodeChildren, {
				onchange: lang.debounce(() => {
					that._fillNodeChildren(node, params, deferred, lang.append({ reason: "change" }, options));
				}),
				autoLoad: "onerror"
			});
		}

		that._fillNodeChildren(node, params, deferred, lang.extend({ reason: "load" }, options));
		return deferred;
	}

	protected _fillNodeChildren(node: TreeNodeInternal, params: any, deferred: Deferred<void>, options: any): void {
		let that = this;

		try
		{
			if (node.state() === Tree.NodeState.disposed) { return; }

			node.state(Tree.NodeState.loading);
			that.hintMessage(undefined);
			that.traceSource.time("Node children load");
			let ret = node._loader.evaluate(that, [node, params, options]);
			if (ret === lang.support.loadingValue) {
				// Метод загрузки детей в лоадере упал, т.к. встретились незагруженные объекты.
				return;
			}
			// loader's expression returns a value (not failure), suppress OE's tracking till all children loaded
			node._loader.suppress();

			// memorize the active child node to restore it after loading
			let activeNode = that.activeNode(),
				activeNodeData,
				activeChildIndex = -1;
			if (activeNode) {
				activeNodeData = activeNode.data();
				activeChildIndex = lang.findIndex(node.children().all(),
					childNode => childNode === activeNode || that.isDescendantNode(activeNode, childNode));
				if (activeChildIndex >= 0) {
					// reset activeNode to skip activating any node while removing
					that.activeNode(null);
				}
				activeNode = null;
			}

			that.removeNodeChildren(node);
			lang.when(ret).then((childrenData: TreeNodeData[]) => {
				try {
					if (childrenData) {
						that.addJsons(childrenData, node);

						if (activeChildIndex >= 0 ) {
							for (let child of node.children().all()) {
								if (activeNodeData === child.data()) {
									that.activeNode(child);
									break;
								}
							}
							// we could't find memorized node - activate child node with same index as before
							if (!that.activeNode()) {
								that._activateChild(node, activeChildIndex);
							}
						}
					}

					node.state(Tree.NodeState.loaded);
					that.traceSource.timeEnd("Node children load");

					node._loader.resume();
					deferred.resolve();
				} catch (ex) {
					that._failNode(node, ex);
					deferred.reject(ex);
				}
			}).fail((ex) => {
				node._loader.resume();
				that._failNode(node, ex);
				deferred.reject(ex);
			});
		} catch (ex) {
			node._loader.resume();
			that._failNode(node, ex);
			deferred.reject(ex);
		}
	}

	protected _activateChild(node: TreeNode, index: number): void {
		let children = node.children(),
			n = children.count(),
			activeNode: TreeNode;
		if (n === 0) {
			activeNode = node;
		} else if (index < n) {
			activeNode = children.get(index);
		} else {
			activeNode = children.get(n - 1);
		}
		this.activeNode(activeNode);
	}

	protected _failNode(node: TreeNode, ex: Error): void {
		this.traceSource.error(ex);
		node.message(ex.message);
		node.state(Tree.NodeState.failed);
	}

	visit(node: TreeNode, iterator: (item: TreeNode) => void, context?: any): void {
		let that = this;
		node = node || that.root();
		iterator.call(context, node);
		node.children().all().forEach((child) => {
			if (child) {
				that.visit(child, iterator, context);
			}
		});
	}

	isDescendantNode(node: TreeNode, ancestor: TreeNode): boolean {
		while (node = node && node.parent()) {
			if (node === ancestor) { return true; }
		}
		return false;
	}

	/**
	 * @protected
	 * @returns {Object.<string, Command>}
	 */
	protected createCommands(): ICommandLazyMap {
		return this.options.commands || {};
	}

	protected createTreeMenuDefaults(): MenuOptions {
		return null;
	}

	protected createTreeMenu(): Menu {
		let menu = lang.unlazy(this.options.menuTree, this);
		return new Menu(this.createTreeMenuDefaults(), menu);
	}

	protected createNodeMenuDefaults(node?: TreeNode): MenuOptions {
		return null;
	}

	protected createNodeMenu(node?: TreeNode): Menu {
		let menu = lang.unlazy(this.options.menuNode, this, node);
		return new Menu(this.createNodeMenuDefaults(node), menu);
	}

	protected createSelectionMenuDefaults(): MenuOptions {
		return null;
	}

	protected createSelectionMenu(): Menu {
		let menu = lang.unlazy(this.options.menuSelection, this);
		return new Menu(this.createSelectionMenuDefaults(), menu);
	}

	protected _onNodeChange(sender: TreeNode, ea: lang.ObservableChangeArgs): void {
		this.trigger("itemChange", this, lang.extend({ changed: sender }, ea));
	}

	protected _initializeProps(): void {
		let that = this;
		that.traceSource = new core.diagnostics.TraceSource("ui.Tree", that.options.traceSourceName || that.name);
		that._root = new that.Node({ type: that.ROOT_NODE_NAME });
		that._selection = new lang.ObservableCollection<TreeNode>();
	}

	protected _initializeMenus(): void {
		let that = this;

		let commands = that.createCommands();
		that.commands = core.commands.unlazyCommands(commands, that);

		that.menuTree = that.createTreeMenu();
		that._initMenu(that.menuTree);

		that.menuNode = that.createNodeMenu();
		that._initMenu(that.menuNode);

		if (that.options.hasCheckboxes) {
			that.menuSelection = that.createSelectionMenu();
			that._initMenu(that.menuSelection);
		}
	}

	protected _initMenu(menu: Menu): void {
		if (menu) {
			menu.bindToPart(this, { tree: this });
		}
	}

	protected beforeRender (domElement?: JQuery|HTMLElement): void {
		let that = this;
		// auto-load data before first render
		// NOTE: don't do this in the constructor (see WC-1521)
		let root = that.root();
		if (that.options.autoLoad && root.state() === Tree.NodeState.initial) {
			that.loadNodeChildren(root);
		}
		super.beforeRender(domElement);
	}

	protected _onActiveNodeChanged(sender: Tree, node: TreeNode): void {
		let menuNode = this.createNodeMenu(node);
		this._initMenu(menuNode);
		this.set("menuNode", menuNode);
	}

	appendToSelection(nodes: TreeNode[]): void {
		let that = this,
			selection = that.selection(),
			added: TreeNode[];

		added = nodes.filter(that.isNodeSelectable, that);
		if (selection.count() > 0) {
			added = added.filter((node) => {
				return selection.indexOf(node) < 0;
			});
		}

		if (added.length) {
			selection.add(added);
		}
	}

	protected doSelectChildren(): void {
		let activeNode = this.activeNode() || this.root(),
			selection = activeNode.children().all();
		this.appendToSelection(selection);
	}
	protected canSelectChildren(): boolean {
		let activeNode = this.activeNode() || this.root();
		return activeNode && activeNode.children().count() > 0;
	}

	protected doSelectSiblings(): void {
		let activeNode = this.activeNode(),
			parent = activeNode && activeNode.parent(),
			selection;
		if (parent) {
			selection = parent.children().all();
			this.appendToSelection(selection);
		}
	}
	protected canSelectSiblings(): boolean {
		let activeNode = this.activeNode(),
			parent = activeNode && activeNode.parent();
		return parent && parent.children().count() > 1;
	}

	protected doSelectNone(): void {
		this.selection().clear();
	}
	protected canSelectNone(): boolean {
		return this.selection().count() > 0;
	}

	public doReloadActive(): Promise<void> {
		let node = this.activeNode();
		if (node) {
			return this.loadNodeChildren(node, { reason: "reload" });
		}
	}
	protected canReloadActive(): boolean {
		return !!this.activeNode();
	}

	public doReloadRoot(): Promise<void> {
		return this.loadNodeChildren(this.root(), { reason: "reload" });
	}
	protected canReloadRoot(): boolean {
		return this.root().state() !== Tree.NodeState.loading;
	}

	dragStart(node: TreeNode): boolean {
		return this.options.dnd && this.options.dnd.dragStart && this.options.dnd.dragStart(node);
	}
	dragEnter(node: TreeNode, otherNode: TreeNode): boolean {
		return this.options.dnd && this.options.dnd.dragEnter && this.options.dnd.dragEnter(node, otherNode);
	}
	dragDrop(node: TreeNode, otherNode: TreeNode): lang.Promise<boolean>|boolean|undefined {
		return this.options.dnd && this.options.dnd.dragDrop && this.options.dnd.dragDrop(node, otherNode);
	}
}

Tree.mixin(/** @lends Tree.prototype */ {
	defaultOptions: Tree.defaultOptions
});

namespace Tree {
	export import Node = TreeNode;

	export interface Options extends Component.Options {
		hasCheckboxes?: boolean;
		hasNumbering?: boolean;
		commands?: core.commands.ICommandLazyMap;
		menuTree?: Menu.Options | ((tree: Tree) => Menu.Options);
		menuNode?: Menu.Options | ((tree: Tree, node: TreeNode) => Menu.Options);
		menuSelection?: Menu.Options | ((tree: Tree) => Menu.Options);
		identifier?: TreeNodeIdentifierCallback;
		formatter?: TreeNodeFormatterCallback;
		iconizer?: TreeNodeIconizerCallback;
		selectionFilter?: TreeNodeFilterCallback;
		loader?: ITreeLoader;
		loaderObsExp?: "disabled" | boolean;
		autoLoad?: boolean;
		traceSourceName?: string;
		columns?: TreeColumn[];
		dnd?: DragAndDropHandler;
		strings?: {
			not_loaded?: string;
			load_failed?: string;
			no_data?: string;
		};
	}
	export interface DragAndDropHandler {
		dragStart(node: TreeNode): boolean;
		dragEnter(node: TreeNode, otherNode: TreeNode): boolean;
		dragDrop(node: TreeNode, otherNode: TreeNode): lang.Promise<boolean>|boolean|undefined;
	}

	export const NodeState = {
		initial: "initial" as "initial",
		loading: "loading" as "loading",
		loaded: "loaded" as "loaded",
		failed: "failed" as "failed",
		disposed: "disposed" as "disposed"
	};
	export type NodeState = (typeof NodeState)[keyof typeof NodeState];

	export interface Identity {
		type?: string;
		id?: string;
	}

	export interface TreeNodeData {
		data?: any;
		icon?: string;
		children?: TreeNodeData[];
		isLeaf?: boolean;
	}

	export interface TreeColumn {
		name: string;
		title?: string;
		html?: boolean;
		colspan?: (node: TreeNode) => number;
		getter?: (node: TreeNode) => string | formatters.SafeHtml;
	}

	export type TreeNode = TreeNodeExport;

	export type TreeNodeFilterCallback = (tree: Tree, node: TreeNode) => boolean;

	export type TreeNodeIdentifierCallback = (tree: Tree, node: TreeNode) => Identity;

	export type TreeNodeFormatterCallback = (tree: Tree, node: TreeNode) => string;

	export type TreeNodeLoadCallback = (tree: Tree, node: TreeNode, params?: any, options?: any) => TreeNodeData[]|Promise<TreeNodeData[]>;

	export type TreeNodeIconizerCallback = (tree: Tree, node: TreeNode) => string;

	export interface ITreeLoader {
		loadChildren: TreeNodeLoadCallback;
	}
}
// backward compatibility
TreeNode.States = Tree.NodeState;
// backward compatibility
TreeNode.mixin({
	/**
	 * @deprecated Use Tree.NodeState
	 */
	states: Tree.NodeState
});

core.ui.Tree = Tree;
core.ui.TreeNode = TreeNode;

export = Tree;
