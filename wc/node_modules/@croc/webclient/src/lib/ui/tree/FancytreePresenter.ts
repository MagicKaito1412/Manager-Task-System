import $ = require("jquery");
import core = require("core");
import binding = require("lib/binding");
import View = require("lib/ui/handlebars/View");
import Menu = require("lib/ui/menu/Menu");
import Tree = require("lib/ui/tree/Tree");
import formatters = require("lib/formatters");
import defaultTemplate = require("xhtmpl!lib/ui/templates/TreePresenter.hbs");
import resources = require("i18n!lib/nls/resources");

import "lib/ui/ExpandablePanel";
import "vendor/fancytree/jquery.fancytree";
import "vendor/fancytree/jquery.fancytree.table";
import "vendor/fancytree/jquery.fancytree.glyph";
import "xcss!lib/ui/styles/tree.css";
import "xcss!lib/ui/styles/FancytreePresenter.css";

import lang = core.lang;
import { INavigationService } from "lib/.core";
import { HostContextOptions } from "lib/ui/.ui";


/*
 * Extension for Fancytree to strip rows
 */
function doStripe(tree): void {
	let even = false;

	tree.visit((node) => {
		if (!node.tr) { return "skip"; }

		if (even && node._parity !== "even") {
			node._parity = "even";
			$(node.tr).addClass("-even").removeClass("-odd");
		} else if (!even && node._parity !== "odd") {
			node._parity = "odd";
			$(node.tr).addClass("-odd").removeClass("-even");
		}

		even = !even;
		return !node.expanded ? "skip" : true;
	});
}

function stripeTree(tree, async?: boolean): void {
	if (!async) {
		window.clearTimeout(tree.__stripeTimeout);
		delete tree.__stripeTimeout;
		doStripe(tree);
	} else if (!tree.__stripeTimeout) {
		tree.__stripeTimeout = window.setTimeout(() => {
			delete tree.__stripeTimeout;
			doStripe(tree);
		});
	}
}

$.ui.fancytree.registerExtension({
	name: "table-stripped",
	version: "0.2.0",
	nodeRenderStatus: function (ctx) {
		this._super(ctx);

		let node = ctx.node;
		let parity = node._parity;

		if (parity === "odd") {
			$(node.tr).addClass("-odd");
		} else if (parity === "even") {
			$(node.tr).addClass("-even");
		} else {
			// NOTE: if several nodes are added or removed at the same time, we want recalculate
			// the parity of nodes only once. So call 'stripeTree' asynchronously (via setTimeout).
			stripeTree(ctx.tree, /*async*/ true);
		}
	},
	nodeSetExpanded: function (ctx, flag, opts) {
		let expanded = !!ctx.node.expanded;
		return this._super(ctx, flag, opts).always(() => {
			if (expanded === !!ctx.node.expanded) { return; } // expanded state wasn't changed

			let children = ctx.node.children;
			if (!children || !children.length) { return; }

			stripeTree(ctx.tree);
		});
	}
});

class FancytreePresenter extends View {
	static defaultOptions: FancytreePresenter.Options = {
		template: defaultTemplate,
		unbound: true,
		autoHeight: true,
		affixMenu: true,
		hasCheckboxes: true,
		hasNumbering: true,
		//hideMenuNode: false,
		//hideMenuTree: false,
		showTitle: true,
		menuNodeCssClass: "x-menu-bar x-menu--contrast",
		menuTreeCssClass: "x-menu-bar",
		treeOptions: {
			extensions: ["table", "table-stripped", "glyph"],
			glyph: {
				map: {
					checkbox: "",
					checkboxSelected: "",
					checkboxUnknown: "",
					expanderClosed: "x-icon x-icon-angle-bracket-right",
					expanderLazy: "x-icon x-icon-angle-bracket-right",
					expanderOpen: "x-icon x-icon-angle-bracket-bottom",
					loading: "x-icon x-icon-loading x-icon-anim-rotating",
					error: "x-icon x-icon-warning-triangle",
					nodata: "",
					doc: "",
					docOpen: "",
					folder: "",
					folderOpen: "",
					//dragHelper: "x-icon x-icon-warning-triangle",
					dropMarker: "x-icon x-icon-add",
				}
			}
		},
		scrollToActiveNode: true
	};

	static hostDefaultOptions: lang.Map<FancytreePresenter.Options> = {
		dialog: {
			autoHeight: false,
			affixMenu: false
			//hideMenuNode: true,
			//showTitle: false
		}
	};

	options: FancytreePresenter.Options;
	uiTree: Fancytree.Fancytree;
	eventPublisher: core.IEventPublisher;
	_selecting: boolean;
	_activating: boolean;
	_timeoutAffix: number;
	viewModel: Tree;

	/**
	 * @constructs FancytreePresenter
	 * @extends View
	 */
	constructor(options?: FancytreePresenter.Options) {
		options = FancytreePresenter.mixOptions(options, FancytreePresenter.defaultOptions);
		super(options);

		// NOTE: если нет extension-а "table", то по умолчанию будет использоваться эффекты jq-ui (toggle("blind"),
		// которые не подключены.
		if (!this.options.treeOptions.extensions || this.options.treeOptions.extensions.indexOf("table") < 0) {
			this.options.treeOptions.toggleEffect = null;
		}
		this.eventPublisher = core.Application.current.eventPublisher;

		this._selecting = undefined;
		this._activating = undefined;
	}

	applyHostContext(opt: HostContextOptions): INavigationService.NavigateOptions {
		super.applyHostContext(opt);
		this.mixHostOptions(opt.host, FancytreePresenter.hostDefaultOptions);
		return null;
	}

	protected doRender(domElement: JQuery|HTMLElement): void {
		let that = this;

		if (that.options.hideMenuTree === undefined) {
			that.options.hideMenuTree = !that.viewModel.menuTree || that.viewModel.menuTree.isEmpty();
		}

		if (that.options.hideMenuNode === undefined) {
			// NOTE: изначально обычно меню узла пустое, т.к. узел не выбран, если menuSelection нет,
			// то мы рискуем скрыть строку меню навсегда.
			// Поэтому, скроем строку меню только в случае, если оба меню заданы пустыми в опциях
			let optMenuSelection = that.viewModel.options.menuSelection;
			let optMenuNode = that.viewModel.options.menuNode;
			that.options.hideMenuNode =
				(!optMenuNode ||
					(lang.isEmpty((<Menu.Options>optMenuNode).items) && !lang.isFunction(optMenuNode))
				) &&
				(!optMenuSelection ||
					(lang.isEmpty((<Menu.Options>optMenuSelection).items) && !lang.isFunction(optMenuSelection))
				);
		}

		super.doRender(domElement);

		let $tree = $(domElement).find(".x-tree-data-table");
		if (!$tree.length) { return; }

		that.uiTree = that.createUiTree($tree);

		let uiRoot = that.uiTree.rootNode;
		let root = that.viewModel.root();
		uiRoot.data.model = root;

		if (root.children()) {
			that.uiTree.enableUpdate(false);
			root.children().all().forEach((node) => {
				uiRoot.addChildren(that.createUiNodeData(node));
			});
			that.uiTree.enableUpdate(true);
		}

		that.selectNodes(that.viewModel.selection().all(), true);
		that.activateNode(that.viewModel.activeNode(), { expand: true });

		that.viewModel.bind("change:nodes", that._onTreeNodesChange, that);
		that.viewModel.bind("itemChange", that._onTreeNodeChange, that);
		that.viewModel.bind("change:activeNode", that._onActiveNodeChange, that);
		that.viewModel.selection().bind("change", that._onSelectionChange, that);

		// activate first node when focusing by TAB
		that.jqOn($tree, "keyup", function (e: JQueryEventObject) {
			if (e.which !== core.html.keyCode.TAB) { return; }
			that._onExternalFocus();
			that.scrollToSelf();
		});

		// tree menu hotkey handler
		that.jqOn(that.$domElement, "keyup", function (e: JQueryEventObject) {
			if (core.html.keyCode.isNavigationKey(e)) { return; }
			let tree = that.viewModel;
			if (tree.menuTree && tree.menuTree.executeHotkey(e)) {
				return false;
			}
		});

		if (that.options.affixMenu && !that.options.hideMenuNode && that.eventPublisher) {
			that.eventPublisher.publish("ui.affix.add_element", {
				element: $(".x-tree-menu-node", that.domElement),
				controlledBy: $(".x-tree-body", that.domElement),
				affixTo: "bottom"
			});
		}
	}

	createUiTree($tree: JQuery): Fancytree.Fancytree {
		let that = this,
			treeOptions = lang.extendEx({
				//extensions: [ "table", "table-stripped" ],
				source: [],
				checkbox: that.options.hasCheckboxes,
				// NOTE: autoScroll runs when node get focus. But we have own handlers of `focus` and `focusTree`
				// events, which can change an active node and conflict with autoScroll therefore.
				// So turn autoScroll off and scroll the tree manually - see `_scrollToUiNode` method.
				//autoScroll: !that.options.autoHeight,
				autoScroll: false,
				titlesTabbable: true,
				scrollParent: $tree.parent(),
				scrollOfs: { top: 7, bottom: 7 }, // 7px is default padding of the row
				selectMode: 2, //1:single, 2:multi, 3:multi-hier (default: 2)
				strings: {
					loading: resources.loading + "&#8230;",
					//loadError: //(core.ui.iconProvider && core.ui.iconProvider.getIcon("error")) + resources["objectTree.error.node_load"]
					loadError: resources["objectTree.error.node_load"]
				},
				debugLevel: 1, // TODO
				table: {
					checkboxColumnIdx: 0,
					nodeColumnIdx: (that.options.hasCheckboxes ? 1 : 0) + (that.options.hasNumbering ? 1 : 0)
				},
				lazyLoad: that._onUiLazyLoad.bind(that),
				activate: that._onUiActivate.bind(that),
				deactivate: that._onUiDeactivate.bind(that),
				//focus: that._onUiFocus.bind(that),
				focusTree: that._onUiFocusTree.bind(that),
				blurTree: that._onUiBlurTree.bind(that),
				expand: that._onUiExpandCollapse.bind(that),
				collapse: that._onUiExpandCollapse.bind(that),
				createNode: that._onUiCreateNode.bind(that),
				renderColumns: that._onUiRenderColumns.bind(that),
				dblclick: that._onUiDblClick.bind(that),
				keydown: that._onUiKeyDown.bind(that),
				select: that._onUiSelect.bind(that)
			}, that.options.treeOptions, { deep: true });

		if (that.options.dnd) {
			treeOptions.extensions.push("dnd");
			// NOTE: позвоним переопределить опции dnd через treeOptions
			treeOptions["dnd"] = lang.extendEx({
				autoExpandMS: 400,
				//focusOnClick: true,
				preventRecursiveMoves: true,
				preventVoidMoves: true,
				// NOTE: ВАЖНО задать smartRevert=false,
				// это заставляет dnd-плагин не устанавливать опцию revert=true для jQ draggable,
				// т.к. при revert!==false включается анимация ("возврата узла") - см. draggable._mouseStop,
				// которая переопределяется плагином jquery.animate-enhanced (и выполняетя через CSS-трансформацию),
				// но если анимация выполняется для невидимого узла, то колбэк не срабатывает.
				// В итоге "draggable" плагин залипает в состоянии "dragging" и узлы перестают перетаскиваться.
				smartRevert: false,
				dropMarkerOffsetX: -48,
				initHelper: function (sourceNode, ctx) {
					let $helper = ctx.ui.helper;
					let $nodeTag = $(sourceNode.span);
					$nodeTag.find(".fancytree-icon").clone().insertBefore($helper.find(".fancytree-title"));
				},
				dragStart: function (uiNode: Fancytree.FancytreeNode, ctx: Fancytree.DndEventData) {
					let node: Tree.Node = uiNode.data.model;
					if (!node) { return false; }
					return that.viewModel.dragStart(node) ? true : false;
				},
				dragEnter: function (uiNode: Fancytree.FancytreeNode, ctx: Fancytree.DndEventData) {
					// return ["before", "over", "after"];
					if (!ctx.otherNode || !uiNode.data.model) {
						// NOTE: data.otherNode may be null for non-fancytree droppables
						// NOTE: uiNode.data.model is null for non-data nodes (statusNodeType)
						return false;
					}
					return that.viewModel.dragEnter(ctx.otherNode.data.model, uiNode.data.model) ? "over" : false;
				},
				dragDrop: function (uiNode: Fancytree.FancytreeNode, ctx: Fancytree.DndEventData) {
					uiNode.setExpanded(true).always(() => {
						// Wait until expand finished, then add the additional child
						let promise = that.viewModel.dragDrop(ctx.otherNode.data.model, uiNode.data.model);
						lang.async.then(promise, (res) => {
							if (res) {
								// handler asks us to move the node,
								// otherwise it'll be moved by binding
								ctx.otherNode.moveTo(uiNode, ctx.hitMode);
							}
						});
					});
				}
				/* не надо?
				 dragExpand: null,     // Callback(targetNode, data), return false to prevent autoExpand
				 dragLeave: null       // Callback(targetNode, data)
				*/
			}, that.options.treeOptions["dnd"], { deep: true });

		}
		if (that.options.columns) {
			// multi-column tree
			let i;
			let $table = that.$domElement.find(".x-tree-data-table");
			// change last column width from default "100%" to "0*":
			$table.find(">colgroup >col:last").attr("width", "0*");
			// set width for columns w/o widths (numbering/checkbox)
			$table.find(">colgroup >col:not([width])").attr("width", "10px");
			// add additional columns
			for (i = 0; i < that.options.columns.length; i++) {
				$("<col width='0*'/>").appendTo($table.children("colgroup").get(0));
				$("<th></th>").appendTo($tree.find("thead>tr").get(0));
			}
		}

		$tree.fancytree(treeOptions);
		return $tree.fancytree("getTree");
	}

	unload(): void {
		let that = this;

		that.viewModel.unbind("change:nodes", null, that);
		that.viewModel.unbind("itemChange", null, that);
		that.viewModel.unbind("change:activeNode", null, that);
		that.viewModel.selection().unbind("change", null, that);

		if (that.options.affixMenu && !that.options.hideMenuNode && that.eventPublisher) {
			that.eventPublisher.publish("ui.affix.remove_element", {
				element: $(".x-tree-menu-node", that.domElement)
			});
		}

		if (that.uiTree) {
			that.uiTree.widget.destroy();
			that.uiTree = undefined;
		}

		super.unload();
	}

	focus(): void {
		let that = this;
		if (!that.uiTree) { return; }

		if (!that.uiTree.$container.find(":focus").length) {
			that._onExternalFocus();
			that.uiTree.$container.focus();
		}
	}

	scrollToSelf(): void {
		let that = this;
		if (!that.uiTree) { return; }

		let uiNode = that.uiTree.getFocusNode();
		core.html.scrollToElement({
			element: (uiNode && uiNode.tr) || that.domElement,
			align: "center"
		});
	}

	findUiNode(node: Tree.Node): Fancytree.FancytreeNode {
		if (!node) { return null; }

		let that = this;
		let result: Fancytree.FancytreeNode = null;
		that.uiTree.rootNode.visit(function (uiNode: Fancytree.FancytreeNode) {
			if (uiNode.data.model === node) {
				result = uiNode;
				return false; // stop iteration
			}
		}, /*includeSelf*/true);
		return result;
	}

	createUiNodeData(node: Tree.Node): Fancytree.NodeData {
		let that = this,
			state = node.state(),
			isLazy = state === Tree.NodeState.initial || state === Tree.NodeState.loading;
		return {
			title: "", // title will be set via binding in _onUiCreateNode
			lazy: isLazy,
			unselectable: !that.viewModel.isNodeSelectable(node),
			data: { model: node },
			children: isLazy ? null :
				node.children().all().map((childNode: Tree.Node) => {
					return that.createUiNodeData(childNode);
				})
		};
	}

	activateNode(node: Tree.Node, options?: { expand: boolean }): void {
		let that = this;

		if (that._activating) { return; }
		try {
			that._activating = true;
			let uiNode = that.findUiNode(node);
			if (uiNode) {
				uiNode.makeVisible({ scrollIntoView: false }).done(() => {
					uiNode.setActive();
					if (options && options.expand && node.state() === Tree.NodeState.loaded) {
						uiNode.setExpanded(true);
					}
					// scroll to active node
					if (that.options.scrollToActiveNode) {
						that._scrollToUiNode(uiNode);
					}
				});
			} else {
				that.uiTree.activateKey(false); // reset active node
			}
		} finally {
			that._activating = undefined;
		}
	}

	/**
	 * Select or deselect tree nodes
	 * @param {TreeNode|Array} nodes A single tree node or an array of nodes.
	 * @param {Boolean} [select=true] Should be nodes selected (by default) or deselected.
	 * @returns {jQuery.Promise}
	 * NOTE: This method doesn't modify viewModel.selection()
	 */
	selectNodes(nodes: Tree.Node|Tree.Node[], select?: boolean): lang.Promise<void> {
		let that = this;
		if (that._selecting) { return; }

		that._selecting = true;
		nodes = lang.isArray(nodes) ? nodes : [nodes];
		let promises = nodes.map((node: Tree.Node) => {
			let uiNode = that.findUiNode(node);
			return uiNode && uiNode.makeVisible({ scrollIntoView: false }).done(() => {
					uiNode.setSelected(select);
				});
		});
		return lang.whenAll(promises).always(() => {
			that._selecting = undefined;
		});
	}

	_scrollToUiNode(uiNode: Fancytree.FancytreeNode): void {
		if (uiNode && uiNode.tr) {
			// scroll viewPort if it has a fixed height
			if (!this.options.autoHeight) {
				uiNode.scrollIntoView();
			}
			core.html.scrollToElement({ element: uiNode.tr, align: "center" });
		}
	}

	_onUiActivate(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let that = this;

		if (that._activating) { return; }
		try {
			that._activating = true;
			that.viewModel.activeNode(ctx.node.data.model);
			// scroll to active node
			if (that.options.scrollToActiveNode) {
				that._scrollToUiNode(ctx.node);
			}
		} finally {
			that._activating = undefined;
		}
	}

	_onUiDeactivate(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let that = this;

		if (that._activating) { return; }
		try {
			that._activating = true;
			that.viewModel.activeNode(null);
		} finally {
			that._activating = undefined;
		}
	}

	// удалено для лечения WC-1703 ObjectTree: в диалоге при клике на любой узел всегда фокусируется текущий выделенный узел
	// На вид поведение не изменилось, кроме того, что разворачивании узла не активируется первый узел. но так даже лучше
	// Смысл логики не очень понятен: при установке фокуса на узел мы берем текущий активный и устанавливаем фокус на него.
/*
	_onUiFocus(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let uiActiveNode = ctx.tree.getActiveNode();
		if (uiActiveNode) {
			if (ctx.node !== uiActiveNode) {
				uiActiveNode.setFocus();
			}
		} else {
			ctx.node.setActive();
		}
	}
*/

	_onUiFocusTree(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let uiActiveNode = ctx.tree.getActiveNode();
		if (uiActiveNode) {
			uiActiveNode.setFocus();
		}
	}

	_onUiBlurTree(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let uiFocusedNode = ctx.tree.getFocusNode();
		if (uiFocusedNode) {
			uiFocusedNode.setFocus(false);
		}
	}

	_onUiExpandCollapse(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		if (e.type === "fancytreecollapse") {
			// remove selected, active and focus flags for the nodes which became invisible after collapsing
			ctx.node.visit(function (uiNode) {
				if (uiNode.isActive()) {
					uiNode.setActive(false);
				}
				if (uiNode === ctx.tree.focusNode) { // no isFocus() method
					uiNode.setFocus(false);
				}
				if (uiNode.isSelected()) {
					uiNode.setSelected(false);
				}
			});
		}

		if (ctx.targetType === "expander") {
			let uiFocusedNode = ctx.tree.getFocusNode();
			if (!uiFocusedNode) {
				ctx.node.setFocus();
			}
		}

		this._refreshAffixAsync(ctx.tree.options.toggleEffect ? ctx.tree.options.toggleEffect.duration : 0);
	}

	_onUiLazyLoad(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		ctx.result = false; // control loading manually
		this.viewModel.loadNodeChildren(ctx.node.data.model);
	}

	_onUiCreateNode(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let that = this;
		if (!ctx.node.data.model) { return; } // it may be status node
		if (!ctx.node.span) { return; } // it may be not rendered node

		let $node = $(ctx.node.span);
		let $title = $node.find(".fancytree-title");
		let $icon = $node.find(".fancytree-icon");

		binding.databind(
			binding.html($title, "html"),
			binding.expr(ctx.node.data.model, function () {
				return that.viewModel.getNodeTitle(this);
			})
		);
		binding.databind(
			binding.html($node, "cssClass"),
			binding.expr(ctx.node.data.model, function () {
				let obj = this.data();
				return {
					"-new-item": lang.get(obj, "isNew"),
					"-modified-item": lang.get(obj, "isModified"),
					"-removed-item": lang.get(obj, "isRemoved")
				};
			})
		);
		binding.databind(
			binding.html($icon, "cssClass"),
			binding.expr(ctx.node.data.model, function () {
				let iconName = that.viewModel.getNodeIcon(this),
					iconProvider = core.ui.iconProvider,
					iconClass = iconName && iconProvider && iconProvider.getIconCssClass(iconName);
				return iconClass ? "fancytree-icon " + iconClass : "fancytree-icon";
			})
		);

		// NOTE: bindings will be auto-disposed when somebody clear a markup via jQuery
		// (it will be done when the node is removed or the tree is unloaded)
	}

	_onUiRenderColumns(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let that = this;
		let columns = that.options.columns,
			node = ctx.node,
			tree = ctx.tree,
			i,
			$tdList = $(node.tr).find(">td");

		// TODO: ввести роли как в списке, то можно будет настраивать последовательность стандартных колонок
		// (role: "number"[?], "check"[?], "title"[1], "aux"[*])
		if (that.options.hasNumbering) {
			// number column is always after checkbox column
			$tdList.eq(that.options.hasCheckboxes ? 1 : 0).text(node.getIndexHier());
		}
		if (columns && columns.length) {
			let auxColCount = columns.length;
			// columnCount - общее кол-во колонок (включая кастомые, созданные выше)
			let columnCount = tree.widget.element.find("thead >tr:last >th").length;
			let offset = columnCount - auxColCount;
			for (i = 0; i < auxColCount; i++) {
				let column = columns[i];
				let text = that.viewModel.getNodeColumnValue(node.data.model, column);
				if (text) {
					if (formatters.isHtml(text)) {
						$tdList.eq(offset + i).html(text.toHTML());
					} else {
						$tdList.eq(offset + i).text(lang.encodeHtml(text));
					}
				}
				if (column.colspan) {
					let colspan = column.colspan(node.data.model);
					if (colspan > 1) {
						// current column should be merged with next ones
						// NOTE: colspan==2 means join with the next column
						$tdList.eq(offset + i).attr("colspan", colspan);
						for (let n = offset + i + 1; n < offset + i + colspan; n++) {
							$tdList.eq(n).remove();
						}
						i = i + colspan - 1; // skip merged columns
					}
				}
			}
		}
	}

	_onUiDblClick(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		if (e.ctrlKey || e.shiftKey || e.metaKey) { return; }
		if (ctx.targetType === "checkbox" || ctx.targetType === "expander") { return; }

		e.preventDefault();
		e.stopPropagation();
		this._executeDefaultMenuItem();
	}

	_onUiKeyDown(e: JQueryEventObject): void {
		let that = this,
			menuNode = that.viewModel.menuNode,
			menuTree = that.viewModel.menuTree;

		if ((menuNode && menuNode.executeHotkey(e)) || (menuTree && menuTree.executeHotkey(e))) {
			// menu hotkeys
			e.preventDefault();
			e.stopPropagation();
		} else if (!e.ctrlKey && !e.shiftKey && !e.metaKey && e.which === core.html.keyCode.ENTER) {
			// Enter
			e.preventDefault();
			e.stopPropagation();
			that._executeDefaultMenuItem();
		} else if (e.ctrlKey && !e.shiftKey && (e.which === core.html.keyCode.C || e.which === core.html.keyCode.INSERT)) {
			// Ctrl+C or Ctrl+Ins
			that._copyToClipboad();
		}
	}

	_onUiSelect(e: JQueryEventObject, ctx: Fancytree.EventData): void {
		let that = this,
			node = ctx.node.data.model;
		if (!node) { return; }

		if (that._selecting) { return; }
		try {
			that._selecting = true;
			if (ctx.node.isSelected()) {
				that.viewModel.selection().add(node);
			} else {
				that.viewModel.selection().remove(node);
			}
		} finally {
			that._selecting = undefined;
		}
	}

	_executeDefaultMenuItem(): void {
		let that = this,
			menu = that.viewModel.menuNode,
			menuItem = menu && menu.getDefaultItem();
		if (menuItem) {
			menu.executeItem(menuItem, { tree: that.viewModel });
		}
	}

	_onExternalFocus(): void {
		let that = this,
			uiFocusedNode;
		if (!that.uiTree) { return; }

		uiFocusedNode = that.uiTree.getFocusNode();
		if (!uiFocusedNode) {
			uiFocusedNode = that.uiTree.getFirstChild();
			if (uiFocusedNode) {
				uiFocusedNode.setFocus();
			}
		}
	}

	_addNewNodes(nodes: Tree.Node[]): void {
		let that = this;
		if (!nodes || !nodes.length) { return; }
		let uiParent;
		let curParent = nodes[0].parent();
		let children = [that.createUiNodeData(nodes[0])];
		for (let i = 1; i < nodes.length; i++) {
			let node = nodes[i];
			let parent = node.parent();
			if (curParent !== parent) {
				// parent has changed, add all accumulated nodes to the previous parent,
				// and start accumulating children of the new parent
				uiParent = that.findUiNode(curParent);
				if (uiParent) {
					uiParent.addChildren(children);
				}
				children = [];
				curParent = parent;
			}
			// the same parent as before,
			children.push(that.createUiNodeData(node));
		}

		uiParent = that.findUiNode(curParent);
		if (uiParent) {
			uiParent.addChildren(children);
		}

		/*
		 WAS: before 1.30 we added every child at once:
		 nodes.forEach(function (node) {
		 var uiParent = that.findUiNode(node.parent());
		 if (uiParent) {
		 uiParent.addChildren(that.createUiNodeData(node));
		 }
		 });
		 */
	}

	_onTreeNodesChange(tree: Tree, ea): void {
		let that = this;
		let scheduleAffixRefresh;
		if (!that.uiTree) { return; }

		// NOTE: возможность оптимизации через выключение/включение enableUpdate, но кажется это не нужно
		/*
		 // if Tree "changed" was produced by adding or removing big number of nodes then we'll use batch mode
		 var batch = ea.added && ea.added.length > that.options.batchThreshold || ea.added && ea.added.length > that.options.batchThreshold;
		 if (batch) {
		 that.uiTree.enableUpdate(false);
		 }
		 */
		if (ea.added) {
			// NOTE: мы не знаем наверняка, являются ли все добавленные узлы (ea.added) братьями,
			// но скорее всего это так (разворачивают их родителя). Поэтому намного оптимальней добавить их всех сразу
			that._addNewNodes(ea.added);
			scheduleAffixRefresh = true;
		}

		if (ea.removed) {
			ea.removed.forEach((node: Tree.Node) => {
				let uiNode = that.findUiNode(node);
				if (uiNode && uiNode !== that.uiTree.rootNode) {
					uiNode.remove();
				}
			});
			scheduleAffixRefresh = true;
		}
		/*
		 if (batch) {
		 that.uiTree.enableUpdate(true);
		 }
		 */
		if (scheduleAffixRefresh) {
			that._refreshAffixAsync();
		}
	}

	_onTreeNodeChange(tree: Tree, ea): void {
		let that = this,
			node = ea.changed,
			uiNode;
		if (!node || !that.uiTree) { return; }

		if (ea.prop === "state") {
			uiNode = that.findUiNode(node);
			if (uiNode) {
				switch (ea.value) {
					case "loading":
						// remember that node was expanded
						if (uiNode.isExpanded() && uiNode.children) {
							uiNode.data.expand = true;
						}
						uiNode.setStatus("loading");
						if (uiNode.isLazy()) {
							uiNode.resetLazy(); // this also reset expanded state
						}
						break;
					case "loaded":
						// empty lazy node became loaded, but without children
						if (!uiNode.children) {
							uiNode.children = [];
						}
						uiNode.setStatus("ok");
						// restore expanded state
						if (uiNode.data.expand) {
							uiNode.setExpanded();
							delete uiNode.data.expand;
						}
						break;
					case "failed":
						uiNode.setStatus("error", node.message());
						break;
				}
				// WAS: before 1.30 was (see WC-1428)
				// uiNode.render();
			}
		}
	}

	_onActiveNodeChange(tree: Tree, node: Tree.Node): void {
		this.activateNode(node);
	}

	_onSelectionChange(sender, ea) {
		let that = this;

		if (that._selecting) { return; }
		// NOTE: _selecting flag will be set in the method 'selectNodes'

		// NOTE: the same node can be in removed and in added collections
		lang.async.done(ea.removed && that.selectNodes(ea.removed, false), () => {
			return ea.added && that.selectNodes(ea.added, true);
		});
	}

	_refreshAffixAsync(delay?: number): void {
		let that = this;

		if (that._timeoutAffix) {
			window.clearTimeout(that._timeoutAffix);
		}
		that._timeoutAffix = window.setTimeout(() => {
			that._timeoutAffix = undefined;
			that.notifyDOMChanged();
		}, delay);
	}

	_copyToClipboad(): void {
		let clipboard = core.ui.clipboard;
		if (!clipboard || !clipboard.isSupported) { return; }

		// NOTE: we can handle viewModel.selection() instead of uiTree.getSelectedNodes(),
		// but it's harder to get hierarchical index of nodes in this case.

		let that = this;
		let uiNodes = that.uiTree.getSelectedNodes();
		let text = "";

		if (!uiNodes.length) {
			let uiActiveNode = that.uiTree.getActiveNode();
			if (!uiActiveNode) { return; }

			uiNodes = [uiActiveNode];
		}

		// If there're selected text inside tree - do nothing (i.e. allow browser to copy the selected text)
		if (window.getSelection) {
			let sel = window.getSelection();
			if (sel && sel.toString() && sel.anchorNode && sel.anchorNode.parentNode) {
				if ($.contains(that.domElement, sel.anchorNode.parentElement)) {
					return;
				}
			}
		}

		lang.forEach(uiNodes, (uiNode: Fancytree.FancytreeNode) => {
			let node = uiNode.data.model,
				title;
			if (!node) { return; }

			if (that.options.hasNumbering) {
				text += uiNode.getIndexHier() + "\t";
			}

			title = that.viewModel.getNodeTitle(node);
			// NOTE: title is HTML by default. Support SafeHtml?
			text += lang.htmlText(title) + "\r\n";
		});

		clipboard.copy(text);
	}
}

namespace FancytreePresenter {
	export interface Options extends View.Options {
		autoHeight?: boolean;
		affixMenu?: boolean;
		hasCheckboxes?: boolean;
		hasNumbering?: boolean;
		hideMenuNode?: boolean;
		hideMenuTree?: boolean;
		showTitle?: boolean;
		menuNodeCssClass?: string;
		menuTreeCssClass?: string;
		columns?: Tree.TreeColumn[];
		treeOptions?: Fancytree.FancytreeOptions & {[key: string]: any};
		dnd?: boolean;
		scrollToActiveNode?: boolean;
	}
}

FancytreePresenter.mixin({
	/**
	 * @deprecated
	 */
	defaultOptions: FancytreePresenter.defaultOptions,
	/**
	 * @deprecated
	 */
	hostDefaultOptions: FancytreePresenter.hostDefaultOptions,
	/**
	 * @deprecated
	 */
	contextDefaultOptions: FancytreePresenter.hostDefaultOptions
});

core.ui.FancytreePresenter = FancytreePresenter;
Tree.defaultOptions.Presenter = FancytreePresenter;

export = FancytreePresenter;
