import core = require("core");
import Tree = require("lib/ui/tree/Tree");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import Menu = require("lib/ui/menu/Menu");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import PartWithFilterMixin = require("lib/ui/PartWithFilterMixin");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;
import domain = require("lib/domain/.domain");
import TreeDataSource = require("lib/data/TreeDataSource");

import Promise = lang.Promise;
import IPart = core.ui.IPart;
import IFilterPart = core.ui.IFilterPart;
import ICommand = core.commands.ICommand;
import UnitOfWork = domain.UnitOfWork;
import DomainObject = domain.DomainObject;
import PartCommandOptions = PartCommandMixin.PartCommandOptions;
import PartCommandResult = PartCommandMixin.PartCommandResult;
import EditorCommandOptions = PartCommandMixin.EditorCommandOptions;
import EditorCommandResult = PartCommandMixin.EditorCommandResult;
import CreateOptions = ObjectTree.CreateOptions;
import EditOptions = ObjectTree.EditOptions;
import Identity = Tree.Identity;
import TreeNode = Tree.TreeNode;
import TreeNodeData = Tree.TreeNodeData;
import ITreeLoader = Tree.ITreeLoader;
import TreeNodeState = Tree.NodeState;
import IObjectTreePresenter = ObjectTree.IObjectTreePresenter;
import Options = ObjectTree.Options;
import KnownMenus = ObjectTree.KnownMenus;

class ObjectTreeLoader implements ITreeLoader {
	loadChildren(tree: ObjectTree, node: TreeNode, params?: any, options?: any): Promise<TreeNodeData[]> {
		if (!tree.options.dataSource) { return null; }

		let path = tree.getNodePath(node);
		return tree.options.dataSource.loadChildren(path, params, options).then((response) => {
			return response.result.map((json) => {
				let data = json.data,
					obj = (data.id && data.__metadata && data.__metadata.type) ? tree.uow.fromJson(data) : data;
				return { data: obj, isLeaf: json.isLeaf };
			});
		});
	}
}

class ObjectTree extends Tree /* implements PartCommandMixin */ {
	static defaultOptions: Options = {
		/**
		 * @type TreeDataSource
		 */
		dataSource: undefined,
		/**
		 * @type UnitOfWork
		 */
		uow: undefined,
		/**
		 * @type Boolean
		 */
		editable: false,
		/**
		 * @type {Part|String}
		 */
		filter: undefined,
		/**
		 * @type Boolean
		 */
		filterExpanded: false,
		/**
		 * @type Boolean
		 */
		filterCollapsable: true,
		/**
		 * @type String
		 */
		expandFilterTitle: resources["objectFilter.show"],
		/**
		 * @type String
		 */
		collapseFilterTitle: resources["objectFilter.hide"],

		commandsOptions: {
			/**
			 * Options for 'Create' command
			 * @type {Object|Function}
			 */
			Create: {
				/**
				 * Part name of editor (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of editor (see `ObjectEditor.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening editor in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 */
				openInDialog: undefined
			},
			/**
			 * Options for 'Edit' command
			 * @type {Object|Function}
			 */
			Edit: {
				/**
				 * Part name of editor (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of editor or a callback to create it (see `ObjectEditor.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening editor in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 * */
				openInDialog: undefined,
				/**
				 * Show carousel in editor for navigating sibling objects in list
				 * @type {Boolean}
				 */
				navigateSiblings: true
			}
		},
		userSettings: {
			props: {
				"filterExpanded": true,
				"filter": true
			}
		}
	};

	static defaultMenus: KnownMenus = {
		TreeNode : { items: [
			{ name: "Reload", title: resources.reload, icon: "refresh" },
			{ name: "Edit", title: resources.edit, icon: "edit", isDefaultAction: true }
		]},
		Tree: { items: [
			{ name: "ReloadRoot", title: resources.reload, icon: "refresh", order: 10, isDefaultAction: true }
		]},
		EditableTree: { items: [
			{ name: "ReloadRoot", title: resources.reload, icon: "refresh", order: 10, isDefaultAction: true },
			{ name: "Save",	title: resources.save, icon: "save", order: 20 },
			{ name: "Cancel", title: resources.cancel, icon: "cancel", order: 30 }
		]},
		TreeSelection: { items: [
			{
				name: "Selection",
				title: resources["selection"],
				html: "<span class='x-icon x-icon-select-all visible-xs'></span><span class='hidden-xs'>" + resources.selected + "</span>" +
				" <span class='x-tree-menu-selection-counter'></span>",

				items: [
					{ name: "SelectChildren", title: resources["objectTree.selectChildren"], icon: "selectAll" },
					{ name: "SelectSiblings", title: resources["objectTree.selectSiblings"], icon: "selectAll" },
					{ name: "SelectNone", title: resources["selectNone"] },
					{ name: "divider" },
					{ name: "DeleteSelection", title: resources["delete"], icon: "delete" }
				]
			}
		]}
	};

	@lang.decorators.constant(ObjectTree.defaultMenus)
	defaultMenus: KnownMenus;

	@lang.decorators.constant(new ObjectTreeLoader())
	defaultLoader: ITreeLoader;

	options: Options;
	presenter: IObjectTreePresenter;
	title: string;
	uow: UnitOfWork;
	filter: IFilterPart;

	protected _fieldWithFilterMenu: string;		// it's for PartWithFilterMixin

	/**
	 * Saving is in progress.
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	saving: lang.ObservableProperty<boolean>;

	/**
	 * @constructs ObjectTree
	 * @extends Tree
	 * @param {Application} app
	 * @param {Object} options
	 */
	constructor(app: core.Application, options?: Options) {
		options = ObjectTree.mixOptions(options, ObjectTree.defaultOptions);
		super(app, options);

		this.title = this.options.title;

		this.subscribeOnNavigation();
	}

	protected _initializeProps(): void {
		super._initializeProps();

		let that = this;

		that.uow = that.options.uow || that.app.createUnitOfWork({connected: true});
		that.uow.bind("detach", that.onObjectDetached, that);
		if (!that.options.editable && that.options.dnd) {
			that.traceSource.error("Incompatible Tree options: specified d-n-d but not editable");
			that.options.dnd = null;
		}
		that.initFilter(that.options, that.userSettings);
	}

	getNodeLoadParams(node: TreeNode): any {
		return this.getFilterRestrictions();
	}

	protected showFilterError(error: string): void {
		this.hintMessage(resources["objectTree.getRestrictionsError"] + error);
	}

	protected defaultIdentifier(tree: Tree, node: TreeNode): Identity {
		let data = node && node.data();
		if (!data) { return {}; }
		return {
			id: data.id,
			type: (data.meta && data.meta.name) || data.type || data.toString()
		};
	}

	protected _isNodeSelectable(node: TreeNode): boolean {
		return this.isDomainNode(node);
	}

	/**
	 * @protected
	 * @returns {{Edit: BoundCommand, Create: BoundCommand, Delete: BoundCommand, Reload: BoundCommand, ReloadRoot: BoundCommand, Save: ?BoundCommand, Cancel: ?BoundCommand, DeleteSelection: BoundCommand, SelectChildren: BoundCommand, SelectSiblings: BoundCommand,SelectNone: BoundCommand }}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			/** @type {BoundCommand} */
			BoundCommand = core.commands.BoundCommand,
			commands: any = {
				Edit: new BoundCommand(that.doEdit, that.canEdit, that),
				Create: new BoundCommand(that.doCreate, that.canCreate, that),
				Delete: new BoundCommand(that.doDelete, that.canDelete, that),
				Reload: new BoundCommand(that.doReloadActive, that.canReloadActive, that),
				ReloadRoot: new BoundCommand(that.doReloadRoot, that.canReloadRoot, that),
				DeleteSelection: new BoundCommand(that.doDeleteSelection, that.canDeleteSelection, that),
				SelectChildren: new BoundCommand(that.doSelectChildren, that.canSelectChildren, that),
				SelectSiblings: new BoundCommand(that.doSelectSiblings, that.canSelectSiblings, that),
				SelectNone: new BoundCommand(that.doSelectNone, that.canSelectNone, that)
			};
		if (that.options.editable) {
			commands.Save = new BoundCommand(that.doSave, that.canSave, that);
			commands.Cancel = new BoundCommand(that.doCancel, that.canCancel, that);
		}

		core.lang.extend(commands, that.options.commands);
		return commands;
	}

	protected createTreeMenuDefaults(): Menu.Options {
		let key = this.options.editable ? "EditableTree" : "Tree";
		return Menu.defaultsFor(this.defaultMenus[key], key);
	}

	protected createTreeMenu(): Menu {
		let menu = super.createTreeMenu(),
			filter = this.filter;
		if (filter && filter.menu) {
			menu.mergeWith(filter.menu);
			this._fieldWithFilterMenu = "menuTree";
		}
		return menu ;
	}

	protected createNodeMenuDefaults(node: TreeNode): Menu.Options {
		let identity = this.getNodeIdentity(node);
		return Menu.defaultsFor(this.defaultMenus.TreeNode, "TreeNode", identity.type);
	}

	protected createSelectionMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(this.defaultMenus.TreeSelection, "TreeSelection");
	}

	isDomainNode(node: TreeNode): boolean {
		if (!node) { return false; }
		let that = this,
			identity = that.getNodeIdentity(node);
		return !!(identity.id && identity.type && that.uow.model.meta.entities[identity.type]);
	}
	isOperableNode(node: TreeNode): boolean {
		if (!this.isDomainNode(node)) { return false; }
		let obj = node.data();
		return obj && !core.lang.get(obj, "isRemoved") && !core.lang.get(obj, "isInvalid");
	}

	protected doCreate(args: CreateOptions): Promise<EditorCommandResult> {
		let that = this,
			type = args.type;

		return that.executePartCommand({
			part: "ObjectEditor:" + type,
			partOptions: that.options.editable ?
				{ type: type, uow: that.uow } :
				{ type: type }
		}, args, "Create").closed;
	}
	protected canCreate(): boolean {
		return this.navigationService && !!this.navigationService.navigate;
	}
	protected onBeforeCreate(createOptions: CreateOptions): void {}
	protected onAfterCreate(result: EditorCommandResult, createOptions: CreateOptions): void {
		let that = this,
			type = createOptions.type;

		if (!result.success || !result.object) {
			that.activate();
			return;
		}

		core.lang.when(result.success as Promise<void>).then(() => {
			that.uow
				.get(type, result.object.id) // get create object's stub
				.load({
					policy: {
						loadFirst: "local",
						allowRemote: true,
						allowLocal: true,
						shouldCache: false
					}
				})
				.done((obj: DomainObject) => {
					let parentNode = createOptions.parentNode,
						node: TreeNode;
					if (parentNode && parentNode.state() === Tree.NodeState.loaded && obj) {
						// TODO: load first if state() === "initial"
						node = new that.Node(obj, createOptions.isLeaf);
						that.addNode(node, parentNode);
						that.activeNode(node);
					}
					that.activate();
				});
		});
	}

	protected doEdit(args: EditOptions): Promise<EditorCommandResult> {
		let that = this,
			node = that.activeNode(),
			basicOptions = that._createEditBasicOptions(node);

		return that.executePartCommand(basicOptions, args, "Edit").closed;
	}
	protected canEdit(): boolean {
		let that = this;
		return that.navigationService && that.navigationService.navigate && that.isOperableNode(that.activeNode());
	}
	protected onBeforeEdit(editOptions: EditOptions): void {
		if (!editOptions.navigateSiblings) { return; }

		let that = this,
			activeNode = that.activeNode(),
			parentNode = activeNode && activeNode.parent();
		if (parentNode) {
			let children = parentNode.children().all(),
				activeType = that._getNodeType(activeNode);
			if (children.every(node => activeType === that._getNodeType(node))) {
				let partOptions = editOptions.partOptions = editOptions.partOptions || {};
				partOptions.navigateSiblings = children
					.map((node) => {
						let siblingOptions = that._createEditBasicOptions(node).partOptions;
						return core.lang.append(siblingOptions, partOptions);
					});
				editOptions.parentNode = parentNode;
			}
		}
	}
	protected onAfterEdit(result: EditorCommandResult, editOptions: EditOptions): void {
		if (editOptions.navigateSiblings && result && result.selectedId) {
			let activeNode = this.activeNode(),
				parentNode = activeNode && activeNode.parent();
			// NOTE: activeNode (and its parent) may be changed while editing; check it
			if (parentNode && parentNode === editOptions.parentNode) {
				let selectedNode = parentNode.children().find(node => node.data().id === result.selectedId);
				if (selectedNode) {
					this.activeNode(selectedNode);
				}
			}
		}

		this.activate();
	}
	protected _getNodeType (node: TreeNode): string {
		let identity = this.getNodeIdentity(node);
		return identity.type;
	}
	protected _createEditBasicOptions(node: TreeNode): EditorCommandOptions {
		let that = this,
			obj = node.data(),
			type: string,
			partOptions,
			identity: Identity;

		if (lang.isPlainObject(obj)) {
			identity = that.getNodeIdentity(node);
			type = identity.type;
			partOptions = that.options.editable ?
				{ viewModel: that.uow.get(type, identity.id) } :
				{ type: type, id: identity.id };

		} else {
			type = obj.meta.name;
			partOptions = that.options.editable ?
				{ viewModel: obj } :
				{ type: type, id: obj.id };
		}
		return {
			part: "ObjectEditor:" + type,
			partOptions: partOptions
		};
	}

	protected doDelete(): void {
		let node = this.activeNode(),
			obj: DomainObject;
		if (node) {
			obj = node.data();
			this._deleteObjects([ obj ]);
		}
	}
	protected canDelete(): boolean {
		let that = this;
		if (!that.options.editable && that.saving()) { return false; }

		return that.isOperableNode(that.activeNode());
	}

	protected doDeleteSelection(): void {
		let that = this,
			nodes = that.selection(),
			objects: DomainObject[] = [];
		nodes.forEach((node) => {
			let obj = node.data();
			if (obj) {
				objects.push(obj);
			}
		});
		that._deleteObjects(objects);
	}

	protected canDeleteSelection(): boolean {
		let that = this;
		if (!that.options.editable && that.saving()) { return false; }

		let nodes = that.selection().all();
		return nodes.length && nodes.every(that.isOperableNode, that);
	}

	protected _deleteObjects(objects: DomainObject[]): void {
		let that = this,
			textKey = "objectTree." +
				(that.options.editable ? "editableDelete" : "delete") +
				(objects.length === 1 ? ".one" : ".many");
		if (objects && objects.length > 0) {
			ConfirmDialog.create({
				header: resources["objectTree.name"],
				text: resources[textKey]
			}).render().done((result) => {
				if (result === "yes") {
					objects.forEach((obj) => {
						that.uow.remove(obj);
					});

					// NOTE: a node will be deleted in onObjectDetached handler
					if (!that.options.editable) {
						that.doSave().fail(() => {
							that.uow.rollbackState();
						});
					}
				}
			});
		}
	}

	public doSave(): Promise<any> {
		let that = this;
		that.saving(true);
		return that.uow.save().always(() => {
			that.saving(false);
		});
	}
	protected canSave(): boolean {
		return !this.saving() && this.get("uow").hasChanges();
	}

	protected doCancel(): void {
		let that = this;
		that.uow.rollbackState();
	}
	protected canCancel(): boolean {
		return !this.saving() && this.get("uow").hasChanges();
	}

	protected onObjectDetached(sender: UnitOfWork, obj: DomainObject): void {
		let that = this;
		that.visit(null, (node: TreeNode) => {
			if (node.data() === obj) {
				that.removeNode(node);
			}
		});
	}

	activate(): void {
		let presenter = this.presenter;
		if (!presenter) { return; }
		if (presenter.focus) {
			presenter.focus();
		}
		if (presenter.scrollToSelf) {
			presenter.scrollToSelf();
		}
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		let that = this;

		that.disposeFilter();

		that.uow.unbind("detach", null, that);
		if (!that.options.uow) {
			that.uow.dispose();
		}

		super.dispose(options);
	}
}

interface ObjectTree extends PartCommandMixin, PartWithFilterMixin { }

// mix methods from PartCommandMixin
PartCommandMixin.mixinTo(ObjectTree as any);

ObjectTree.mixin(/** @lends ObjectTree.prototype */ {
	defaultOptions: ObjectTree.defaultOptions,
});
ObjectTree.mixin(PartWithFilterMixin);

namespace ObjectTree {
	export interface Options extends Tree.Options, PartCommandMixin.Options, PartWithFilterMixin.Options {
		dataSource?: TreeDataSource;
		uow?: UnitOfWork;
		editable?: boolean;
		commands?: core.commands.ICommandLazyMap;
		title?: string;
	}

	export interface KnownMenus extends lang.Map<Menu.Options> {
		Tree?: Menu.Options;
		EditableTree?: Menu.Options;
		TreeNode?: Menu.Options;
		TreeSelection?: Menu.Options;
	}

	export interface CreateOptions extends EditorCommandOptions {
		type: string;
		parentNode?: TreeNode;
		isLeaf?: boolean;
	}

	export interface EditOptions extends EditorCommandOptions {
		parentNode?: TreeNode;
	}

	export interface IObjectTreePresenter extends IPart {
		focus?(): void;
		scrollToSelf?(): void;
	}
}

core.ui.ObjectTree = ObjectTree;
core.ui.ObjectTreeLoader = ObjectTreeLoader;

export = ObjectTree;
