import core = require("core");
import ObjectList = require("lib/ui/list/ObjectList");
import Menu = require("lib/ui/menu/Menu");
import resources = require("i18n!lib/nls/resources");
import domain = require("lib/domain/.domain");

import lang = core.lang;
import Application = core.Application;
import ICommand = core.commands.ICommand;
import CommandArgs = core.commands.CommandArgs;
import Dialog = core.ui.Dialog;
import Options = ObjectSelector.Options;
import KnownMenus = ObjectSelector.KnownMenus;
import DomainObject = domain.DomainObject;

class ObjectSelector extends ObjectList {
	static defaultOptions: Options = {
		autoLoad: true,
		readOnly: true,
		hideExportMenu: true,
		presenterOptions: {},
		navigateOptions: {
			activateOptions: {
				freezeUrl: true
			}
		},
		persistentSelection: true,
		/**
		 * Array of ids of objects to exclude from selector
		 * @type Array
		 */
		excludeIds: undefined
	};

	static defaultMenus: KnownMenus = {
		Selector: { items: [
			{
				name: "Reload",
				title: resources["reload"],
				icon: "refresh",
				isDefaultAction: true,
				order: 10
			}
		]},
		SelectorRow: { items: [
			{
				name: "Select",
				title: resources["ok"],
				icon: "ok",
				isDefaultAction: true
			}, {
				name: "Close",
				title: resources["cancel"],
				icon: "cancel",
				params: { result: false }
			}
		]}
	};

	@lang.decorators.constant(lang.append(ObjectSelector.defaultMenus, ObjectList.defaultMenus))
	defaultMenus: KnownMenus;

	static hostDefaultOptions: lang.Map<Options> = {};

	options: Options;

	/**
	 * @constructs ObjectSelector
	 * @extends ObjectList
	 * @param {Application} app
	 * @param {Object} options
	 */
	constructor(app: Application, options?: Options) {
		options = ObjectSelector.mixOptions(options, ObjectSelector.defaultOptions);
		super(app, options);

		if (!this.title && this._entityType) {
			// TODO: в идеале заголовок должен быть "Выбор 'Типа'" (в родительном падеже)
			this.title = lang.stringFormat(resources["objectSelector.title"], this._entityType.descr);
		}
	}

	applyHostContext(opt?: {host: string}): core.INavigationService.NavigateOptions {
		let navOpt = super.applyHostContext(opt);
		this.mixHostOptions(opt.host, ObjectSelector.hostDefaultOptions);
		return navOpt;
	}

	/**
	 * Checks if the node can be selected by default (w/o option selectionFilter)
	 * @param item
	 * @override
	 * @returns {boolean}
	 */
	protected _isItemSelectable(item: DomainObject): boolean {
		let excludeIds = this.options.excludeIds;
		if (excludeIds && excludeIds.length) {
			// object is selectable if it's not contained in excludeIds
			return (excludeIds.indexOf(item.id) < 0);
		}
		return true;
	}

	protected createListMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(ObjectSelector.defaultMenus.Selector, "Selector", this.entityType);
	}
	protected createRowMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(ObjectSelector.defaultMenus.SelectorRow, "SelectorRow", this.entityType);
	}
	/**
	 * @protected
	 * @override
	 * @returns {{Reload: BoundCommand, Select: BoundCommand, Close: BoundCommand}}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this;
		return lang.append(super.createCommands(), {
			Select: new core.commands.BoundCommand(that.select, that.canSelect, that),
			Close: new core.commands.BoundCommand(that.close, that)
		});
	}

	protected canSelect(): boolean {
		return !!this.currentItems().length;
	}
	protected select(): void {
		let that = this;
		that.close({
			result: { selection: that.currentItems() }
		});
	}

	close(args?: CommandArgs): void {
		let nav = this.navigationService;
		if (nav) {
			nav.close(args && args.result);
		}
	}
}

// backward compatibility: access to static fields via prototype
ObjectSelector.mixin(/** @lends ObjectSelector.prototype */ {
	defaultOptions: ObjectSelector.defaultOptions,
	contextDefaultOptions: ObjectSelector.hostDefaultOptions
});

namespace ObjectSelector {
	export interface Options extends ObjectList.Options {
		contextName?: string;
		excludeIds?: string[];
	}

	export interface KnownMenus extends ObjectList.KnownMenus {
		Selector?: Menu.Options;
		SelectorRow?: Menu.Options;
	}

	export interface Result {
		selection: DomainObject[];
	}
}

core.ui.ObjectSelector = ObjectSelector;

export = ObjectSelector;

