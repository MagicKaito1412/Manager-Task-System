import core = require("core");
import View = require("lib/ui/handlebars/View");
import List = require("lib/ui/list/List");
import ObjectListPaginatorBase = require("lib/ui/list/ObjectListPaginatorBase");
import Menu = require("lib/ui/menu/Menu");
import template = require("xhtmpl!lib/ui/templates/ObjectListPager.hbs");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;
import { LoadQueryParams } from "interop/.interop";
import ICommand = core.commands.ICommand;
import LoadOptions = List.LoadOptions;
import DataLoadEventArgs = List.DataLoadEventArgs;
import { DomainObject } from "lib/domain/.domain";

type PageInfo = {
	text: string;
	isCurrent?: boolean;
	loadParams?: { $skip: number };
};

class ObjectListPager extends ObjectListPaginatorBase {
	static defaultOptions: ObjectListPager.Options = {
		template: template,
		pageSize: 100,
		menu: { items: [
			{
				name: "LoadPrev",
				html: "&larr;",
				title: resources["loadPrev"],
				order: 0

			}, {
				name: "LoadNext",
				html: "&rarr;",
				title: resources["loadNext"],
				order: 1000
			}
		]}
	};

	options: ObjectListPager.Options;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	pageStat: lang.ObservableProperty<string>;

	@lang.decorators.observableAccessor()
	currentPage: lang.ObservableProperty<number>;

	/**
	 * Paginator for ObjectList for mode 'pages' (with commands LoadPrev/LoadNext)
	 * @constructs ObjectListPager
	 * @extends ObjectListPaginatorBase
	 * @param options
	 */
	constructor(options?: ObjectListPager.Options) {
		options = ObjectListPager.mixOptions(options, ObjectListPager.defaultOptions);
		options.mode = "pages";
		super(options);

		this.bind("change:currentPage", (s, currentPage) => {
			if (currentPage > 0 && currentPage <= Math.ceil(this._total/this._top)) {
				this.doLoadNext({params: { $skip: this._top * (currentPage-1) }});
			}
		});
	}

	protected _init(list: List<any>): void {
		super._init(list);
		if (list && !this.options.hidePageStat) {
			list.items.bind("change", this._onListItemsChanges, this);
		}
	}

	protected _uninit(list: List<any>): void {
		super._uninit(list);
		if (list && !this.options.hidePageStat) {
			list.items.unbind("change", null, this);
		}
	}

	protected _onListItemsChanges(items: lang.ObservableCollection<DomainObject>, args: lang.ObservableCollectionChangeArgs<DomainObject>): void {
		let that = this;
		// exclude reset/add of collection from load/loadMore (they happen in "loading" state):
		if (that.list().state() === "loaded") {
			//  NOTE: items.count is items count on the current page (not total)
			let total = that._total;
			if (args.added)
				total += args.added.length;
			if (args.removed)
				total -= args.removed.length;
			that._total = total;

			that._updatePageStat(that.skippedItems() + 1, items.count(), total);

			// TODO: в принципе раз мы знаем о новом total, то и количество страниц в меню можно скорректировать (видимо _total надо сделать observable)
		}
	}

	protected _updatePageStat(first: number, pageSize: number, total: number): void {
		let last = first + pageSize - 1;
		if (pageSize === 0) {
			// current page has no more items
			this.pageStat("");
		} else {
			this.pageStat(
				lang.stringFormat(resources["objectList.pager.stat"], first, last, total)
			);
		}
	}

	private _total: number;

	/**
	 * @protected
	 * @virtual
	 * @returns {Object.<String,ICommand>}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this;
		return {
			LoadPrev: new core.commands.BoundCommand(that.doLoadPrev, that.canLoadPrev, that),
			LoadNext: new core.commands.BoundCommand(that.doLoadNext, that.canLoadNext, that),
			LoadPage: new core.commands.BoundCommand(that.doLoadPage, that.canLoadPage, that)
		};
	}

	protected doLoadPrev(args: LoadOptions = {}): lang.Promise<any[]> {
		let that = this,
			pageParams = {
				$skip: Math.max((that._loadParams.$skip || 0) - that._top, 0),
				$top: that._top,
				$fetchTotal: false
			};

		args.params = lang.append(args.params || {}, pageParams, that._loadParams);
		return that.list().reload(args);
	}
	protected canLoadPrev(): boolean {
		let that = this;
		return !that.list().isLoading() && that._loadParams && that._loadParams.$skip > 0 && that._top >= 0;
	}

	protected doLoadNext(args: LoadOptions): lang.Promise<any[]> {
		let that = this,
			pageParams: LoadQueryParams = {
				$skip: (that._loadParams.$skip || 0) + that._top,
				$top: that._top,
				$fetchTotal: false
			};

		args.params = lang.append(args.params || {}, pageParams, that._loadParams);
		return that.list().reload(args);
	}
	protected canLoadNext(): boolean {
		let that = this;
		return !that.list().isLoading() && that._hasNext && that._loadParams && that._top >= 0 &&
			(that._total == null || that._total > (that._loadParams.$skip || 0) + that._top);
	}

	protected doLoadPage(args: LoadOptions): lang.Promise<any[]> {
		let that = this,
			pageParams: LoadQueryParams = {
				// $skip should be set in args.params
				$top: that._top,
				$fetchTotal: false
			};

		args.params = lang.append(args.params || {}, pageParams, that._loadParams);
		return that.list().reload(args);
	}
	protected canLoadPage(): boolean {
		return !this.list().isLoading();
	}

	protected _onDataLoading(list: List<any>, args: DataLoadEventArgs<any> = {}): void {
		super._onDataLoading(list, args);

		let params: LoadQueryParams = args.params || (args.params = {});
		if (params.$fetchTotal === undefined && !params.$skip) {
			// reloading is inited by an external command, request total count from server
			// NOTE: all commands of the paginator itself explicitly set the parameter `$fetchTotal`
			params.$fetchTotal = true;
		}

		if (!params.$fetchTotal) {
			// false is default value of `$fetchTotal`, remove it to make the request shorter
			params.$fetchTotal = undefined;
		}
	}

	protected _onDataLoaded(list: List<any>, args: DataLoadEventArgs<any> = {}): void {
		super._onDataLoaded(list, args);

		let that = this,
			params: LoadQueryParams = args.params || {},
			hints = args.hints || {},
			total: number,
			skip: number;
		that.hasMoreItems(that._hasNext || params.$skip > 0);

		if (hints.paging || that.options.force) {
			if (hints.total >= 0) {
				total = hints.total; // we got args.hints.total from the server (it's loading of the first page)
			} else if (params.$fetchTotal) {
				total = 0; // we requested args.hints.total from the server, but server didn't return it
			} else {
				total = that._total || 0;
			}

			skip = params.$skip || 0;
			total = Math.max(total, skip + that._top + 1);
			if (!that._hasNext) {
				// we have reached the last page, but `total` points outside the current range, correct it
				total = Math.min(total, skip + args.items.length);
			}

			that._total = total;

			// update the number of skipped items
			that.skippedItems(skip);

			// reinit menu
			that.menu = that.createMenu();
			that.menu.bindToPart(that);
			that.changed("menu");

			if (!that.options.hidePageStat) {
				that._updatePageStat(skip + 1, Math.min(that._top, args.items.length), total);
			}

		} else {
			// update the number of skipped items
			that.skippedItems(undefined);
		}
	}

	protected createMenu(): Menu {
		let that = this,
			menu = this.options.menu,
			pages: PageInfo[] = that.createPages(),
			pageItems;
		if (pages) {
			pageItems = pages.map((page: PageInfo, i: number) => {
				return {
					name: "LoadPage" + i,
					title: page.text,
					commandName: "LoadPage",
					params: {
						params: page.loadParams
					},
					// NOTE: `radio` option isn't supported by standard menu presenter, use `isDefaultAction` to simulate it
					isDefaultAction: page.isCurrent,
					disabled: !page.loadParams
				};
			});
			menu = Menu.merge(menu, { update: pageItems });
		}
		return new Menu(menu);
	}

	protected createPages(): PageInfo[] {
		let that = this;
		if (!that._total || !that._loadParams || !that._top) { return null; }

		let pages: PageInfo[] = [],
			pagesCount = Math.ceil(that._total/that._top),
			lastPage = pagesCount - 1,
			activePage = Math.floor((that._loadParams.$skip || 0)/that._top),
			N: number = 3, // number of visible pages to left and to right from an active page
			minPage = Math.min(lastPage - N, activePage) - N,
			maxPage = Math.max(N, activePage) + N;

		that["lastPage"] = pagesCount;
		// prevent events
		that["_currentPage"] = activePage + 1;

		// remove the ellipsis which replaces single page: 1 ... 3 4 5 => 1 2 3 4 5
		if (minPage < 3) { // 3 is const, don't use N
			minPage = 0;
		}
		// remove the ellipsis which replaces single page: 96 97 98 ... 100 => 96 97 98 99 100
		if (maxPage > lastPage - 3) { // 3 is const, don't use N
			maxPage = lastPage;
		}

		// fill pages
		if (minPage > 0) {
			pages.push({
				text: "1",
				loadParams: { $skip: 0 }
			}, {
				text: "..."
			});
		}
		for (let i = minPage; i <= maxPage; i++) {
			pages.push({
				text: "" + (i+1),
				isCurrent: i === activePage,
				loadParams: { $skip: that._top * i }
			});
		}
		if (maxPage < lastPage) {
			pages.push({
				text: "..."
			}, {
				text: "" + (lastPage+1),
				loadParams: { $skip: that._top * lastPage }
			});
		}

		return pages;
	}
}

ObjectListPager.mixin({
	defaultOptions: ObjectListPager.defaultOptions
});

namespace ObjectListPager {
	export interface Options extends ObjectListPaginatorBase.Options {
		hidePageStat?: boolean;
	}
}

core.ui.ObjectListPager = ObjectListPager;

export = ObjectListPager;
