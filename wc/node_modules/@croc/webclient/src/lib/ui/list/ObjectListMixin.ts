import core = require("core");
import resources = require("i18n!lib/nls/resources");
import utils = require("lib/utils");
import Menu = require("lib/ui/menu/Menu");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import ListCommonMixin = require("lib/ui/list/ListCommonMixin");
//import DomainObject = require("lib/domain/DomainObject");
import lang = core.lang;
import { DomainObject } from "lib/domain/.domain";

/*
interface ObjectListMixin extends lang.Observable {
}
*/

// Following methods are common for ObjectList and peObjectList and added to them as mixin
abstract class ObjectListMixin extends ListCommonMixin<DomainObject> {
	options: ObjectListMixin.Options;

	protected _isObjectOperable(obj: DomainObject): boolean {
		return obj && !lang.get(obj, "isRemoved") && !lang.get(obj, "isInvalid");
	}

	protected _deleteObjects(objects?: DomainObject[]): void {
		let that = this,
			activeObj = that.activeItem(),
			selection = that.selection.all();

		// #1: detect what should we delete
		if (!objects) {
			// NOTE: `editable` only exists in ObjectList
			if (that.options["editable"]) {
				// in editableList selection can contains deleted objects, fitler them out
				selection = selection.filter(that._isObjectOperable);
				// active item can be deleted as well.
				if (!that._isObjectOperable(activeObj)) {
					activeObj = null;
				}
			}
			let selectionCount = selection.length;

			if (selectionCount  === 0 && activeObj) {
				objects = [activeObj];
			} else if (selectionCount > 0 && activeObj) {
				// there are selected objects AND active - it's the most subtle case for UX
				if (selection.indexOf(activeObj) > -1) {
					// selection includes the active
					objects = selection;
				} else {
					// we couldn't determine what to delete
					objects = null;
				}
			} else if (selectionCount > 0 && !activeObj) {
				// there are only selected objects
				objects = selection;
			} else {
				// nothing to delete
				return;
			}
		}

		// now we have a set of objects to delete - `objects` (or may be not if it's unclear what to delete),
		// #2: construct a confirmation for user
		let confirmation = that.getOperationConfirmation("delete", objects, selection, activeObj);

		if (!confirmation) {
			return;
		}

		// #3: ask user
		lang.async.then(confirmation, (confirmation) => {
			if (confirmation.text) {
				ConfirmDialog.create({
					header: confirmation.header,
					text: confirmation.text,
					menu: confirmation.menu
				}).render().done(result => {
					if (result === "Selected") {
						objects = selection;
						result = "yes";
					} else if (result === "Active") {
						objects = [activeObj];
						result = "yes";
					}
					if (result === "yes") {
						that.doDeleteObjects(objects);
					}
				});
			} else if (confirmation.objects) {
				// no text, delete silently
				that.doDeleteObjects(confirmation.objects);
			}
		});
	}

	doDeleteObjects(objects?: DomainObject[]): void {
		objects = [].concat(...objects);
		this.executeDelete(objects);
	}

	protected getOperationConfirmation(op: "delete"|"unlink", objects: DomainObject[], selection: DomainObject[], activeObj: DomainObject): lang.Promisable<ObjectListMixin.ConfirmationRequest> {
		// NOTE: `editable` only exists in ObjectList
		let selectionCount = selection.length;
		let confirmationText;
		let menu;

		if (!objects) {
			// we couldn't determine what to delete, we have to ask
			if (selectionCount === 1) {
				confirmationText = this.getMessage(resources, op, "selected_or_active_one.prompt");
			} else {
				confirmationText = lang.stringFormat(this.getMessage(resources, op, "selected_or_active_many.prompt_format"), selectionCount);
			}
			menu = {items: [
				{name: "Selected",
					title: (selectionCount === 1)
						? this.getMessage(resources, op, "selected_or_active_one.confirm_selected_one")
						: this.getMessage(resources, op, "selected_or_active_one.confirm_selected_many") + " (" + selectionCount + ")"
				},
				{name: "Active", title: this.getMessage(resources, op, "selected_or_active_one.confirm_active")},
				{name: "cancel", title: resources.cancel}
			]};
		} else {
			// we determined what to delete, construct a msg depending on objects count
			if (objects.length === 1) {
				confirmationText = this.getMessage(resources, op, "one.prompt");
			} else {
				confirmationText = lang.stringFormat(
					this.getMessage(resources, op, "many.prompt_format"),
					objects.length + " " + utils.formatNumeral(objects.length, resources.words_forms.objects));
			}
		}

		let confirmation = {
			header: resources["objectList.name"],
			text: confirmationText,
			menu: menu
		};

		let optConfirm = this.options["confirm" + utils.toUpperCamel(op)];
		if (optConfirm) {
			// some people want to customize confirmation message, let them
			return optConfirm.call(this, confirmation, objects, selection, activeObj);
		}

		return confirmation;
	}

	protected abstract getMessage(resources: lang.Map<string>, op: string, mod: string): string;

	protected abstract executeDelete(objects?: DomainObject[]): void;
}

namespace ObjectListMixin {
	export interface Options extends ListCommonMixin.Options {
		confirmDelete?: <T>(confirmation: ConfirmationRequest, objects: DomainObject[], selection: DomainObject[], activeObj: DomainObject) => lang.Promisable<ConfirmationRequest>;
		confirmUnlink?: <T>(confirmation: ConfirmationRequest, objects: DomainObject[], selection: DomainObject[], activeObj: DomainObject) => lang.Promisable<ConfirmationRequest>;
	}

	export interface ConfirmationRequest {
		/**
		 * Header for ConfirmDialog
		 */
		header?: string;
		/**
		 * Text for ConfirmDialog, if empty no dialog will be shown
		 */
		text?: string;
		/**
		 * Optional menu for ConfirmDialog, be default (Yes/No)
		 */
		menu?: Menu.Options;
		/**
		 * Can contain an array of objects to delete silently (if text is empty)
		 */
		objects?: DomainObject[];
	}
}
export = ObjectListMixin;
