import core = require("core");
import Part = require("lib/ui/Part");
import View = require("lib/ui/handlebars/View");
import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import settingsTemplate = require("xhtmpl!lib/ui/templates/ObjectListSettings.hbs");
import formatters = require("lib/formatters");
import validation = require("lib/validation");
import resources = require("i18n!lib/nls/resources");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import Dialog = require("lib/ui/Dialog");
//import "vendor/twemoji/twemoji";
//import "xcss!vendor/twemoji/twemoji-awesome.css";

import lang = core.lang;

import {
	ObjectListColumnGetter,
	ObjectListColumnFormatter,
	ObjectListColumnComparer,
	ObjectListColumn,
	IList,
	IObjectList
} from ".list";
import { ObjectListState } from "./.list.types";

import Violation = validation.Violation;
import ObjectRule = validation.ObjectRule;
import OrderBy = lang.collections.OrderBy;
import OrderByData = lang.collections.OrderByData;

class ListColumnsSettings extends lang.Observable {
	static defaultOptions: ListColumnsSettings.Options = {
		ignoreRoles: {
			checkbox: true,
			reorder: true
		}
	};

	columns: ListColumnsSettings.ColumnItem[];

	/**
	 * @constructs ListColumnsSettings
	 * @extends Observable
	 */
	constructor(list: IList, options: ListColumnsSettings.Options) {
		super();

		options = lang.appendEx(options || {}, ListColumnsSettings.defaultOptions, { deep: true });

		let that = this;
		that.columns = list.columns
			.filter(col => options.ignoreRoles ? !options.ignoreRoles[col.role] : true)
			.map(col => lang.Observable.construct({
				name: col.name,
				title: col.title || col.name || "#",
				visible: !col.hidden
			}) as ListColumnsSettings.ColumnItem);

		let hasHidden = that.columns.some(col => !col.visible());
		that.groupChecked(!hasHidden);
		that.bind("change:groupChecked", that._onGroupCheckedChange, that);
	}


	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor()
	groupChecked: lang.ObservableProperty<boolean>;

	private _onGroupCheckedChange(sender: ListColumnsSettings, value: boolean): void {
		for (let col of this.columns) {
			col.visible(value);
		}
	}
}
namespace ListColumnsSettings {
	export interface Options {
		ignoreRoles?: lang.Map<boolean>;
	}

	export interface ColumnItem extends lang.Observable {
		name: lang.ObservableProperty<string>;
		title: lang.ObservableProperty<string>;
		visible: lang.ObservableProperty<boolean>;
	}
}

function defaultFormatter(v: any, col: ObjectListColumn): string {
	let text = v == null ? "" : v.toString(); // undefined == null, don't use ===
	return formatters.textAsHtml(text, col.whitespaces);
}


interface ListCommonMixin<T> extends lang.Observable {
	userSettings: core.IUserSettings;
}

/**
 * Mixin with common methods for List and peObjectList.
 */
abstract class ListCommonMixin<T> implements IObjectList<T> {
	// shared members:
	states: typeof ObjectListState;
	roleDefaults: lang.Map<ObjectListColumn | (() => ObjectListColumn)>;

	// IObjectList:
	/**
	 * @observable-property {ObjectListState}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<ObjectListState>;

	/**
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	stateMessage: lang.ObservableProperty<string>;

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	activeItem: lang.ObservableProperty<T>;

	items: ObservableCollectionView<T>;
	selection: lang.ObservableCollection<T>;
	violations: lang.ObservableCollection<Violation>;
	columns: ObjectListColumn[];
	commands: lang.Map<core.commands.ICommand>;
	options: ListCommonMixin.Options;

	/**
	 * Returns HTML of the cell
	 * @param {*} item
	 * @param {ObjectListColumn} col
	 * @returns {any}
	 */
	getCellHtml(item: T, col: ObjectListColumn): string {
		let v = col.getter ? col.getter.call(item, col) : undefined;
		if (col.html !== false && col.formatterHtml) {
			return col.formatterHtml.call(item, v, col);
		}
		let formatter = col.formatter || defaultFormatter;
		let res = formatter.call(item, v, col);

		// возвращать результат formatter'a как есть небезопасно (XSS)!
		// Т.к. разработчик мог забыть encode, а в значении свойтва содеражиться код.
		// Возвращаем html только, если задан formatterHtml, либо formatter вернул SafeHtml.

		if (col.html !== false && formatters.isHtml(res)) {
			return res.toHTML();
		}
		if (col.html) {
			return res;
		}
		if (col.role === "data" || col.role === "aux") {
			return lang.encodeHtml(res);
		}
		return res;
	}

	/**
	 * Initialize common properties: items and selection
	 * @protected
	 */
	protected _initializeProps(): void {
		let that =  this;
		that.items = new ObservableCollectionView<T>();
		that.selection = new lang.ObservableCollection<T>();
		that.violations = new lang.ObservableCollection<Violation>();

		// when removing an item, remove it from selection also
		if (!that.options.persistentSelection) {
			that.items.bind("change", (sender, ea: lang.ObservableCollectionChangeArgs<T>) => {
				if (ea && ea.removed && ea.removed.length) {
					that.selection.remove(ea.removed);
				}
			});
			// when changing `where` filter, apply it to the selection
			that.items.bind("change:where", (sender, predicate) => {
				let selected = that.selection.all().filter(predicate);
				that.selection.reset(selected);
			});
		}

		if (that.options.where) {
			that.items.where(that.options.where);
		}

		// NOTE: Option `orderBy` should be used after an initialization of `columns`.
		// This option will be used in `setupColumns`, don't use here
	}

	// optional:
	protected onColumnsChanged?(columns: ObjectListColumn[]): void;
	protected _initializeColumn?(col: ObjectListColumn|string): ObjectListColumn;

	/**
	 * Initialize columns
	 * @protected
	 * @abstract
	 */
	protected abstract _initializeColumns(): void;

	/**
	 * @param {ObjectListColumn[]} columns
	 */
	protected setupColumns(columns: ObjectListColumn[]): void {
		let that = this,
			unnamedCountersByRole = {};

		columns = that._prepareColumns(columns);

		// set #{role} as a name for unnamed columns (e.g. #checkbox, #order, #data, #data2)
		for (let col of columns) {
			if (!col.name) {
				let n = unnamedCountersByRole[col.role] || 0;
				unnamedCountersByRole[col.role] = ++n;

				col.name = "#" + col.role;
				if (n > 1) {
					col.name += n;
				}
			}
		}

		that.set("columns", columns);

		// init client sorting, orderBy should make client sorting (not server) and init orderedBy
		if (that.options.orderBy) {
			that.orderBy(that.options.orderBy);
		}

		if (that.userSettings) {
			that.userSettings.bind("init:columns", that._onColumnsInit, that);
		}
		that.bind("change:columns", that._onColumnsChanged, that);
	}

	private _onColumnsChanged(sender, columns: ObjectListColumn[]): void {
		let that = this;
		if (that.userSettings && !that.userSettings.suppressEvents) {
			let userColumns = columns.map(col => ({
				name: col.name,
				width: col.width,
				hidden: col.hidden,
				order: col.order
			}));
			that.userSettings.set("columns", userColumns);
		}
		if (that.onColumnsChanged) {
			that.onColumnsChanged(columns);
		}
	}

	private _onColumnsInit(columns: ObjectListColumn[]): void {
		let that = this;
		if (columns) {
			// if current list columns differ from cached columns from userSettings
			// then we won't restore settings
			if (that._areColumnsChanged(columns)) {
				// reset cached
				that.userSettings.set("columns", undefined);
			} else {
				// cached -> actual
				that.updateColumns(columns);
			}
		}
	}

	private _areColumnsChanged(columns: ObjectListColumn[]): boolean {
		let that = this,
			namesNew = that.columns.map(col => col.name),
			namesOld = columns.map(col => col.name);
		if (namesNew.length !== namesOld.length) { return true; }

		namesNew = lang.sort(namesNew);
		namesOld = lang.sort(namesOld);
		for (let i = 0; i < namesNew.length; i++) {
			if (namesNew[i] !== namesOld[i]) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Updates current columns with data from specified columns.
	 * @param {ObjectListColumn[]} columns
	 * @param {Object} [options]
	 * @param {Boolean} [options.onlyExisting] true: update only existing columns without adding
	 */
	updateColumns(columns: ObjectListColumn[], options?: { onlyExisting?: boolean }): void {
		let that = this,
			newColumns: ObjectListColumn[] = lang.clone(that.columns),
			onlyExisting = options && options.onlyExisting;

		// merge columns
		for (let col of columns) {
			if (!col.name) { continue; } // ignore unnamed columns

			let index = lang.findIndex(newColumns, c => c.name === col.name),
				newCol: ObjectListColumn;
			if (index >= 0) {
				newCol = lang.extend({}, newColumns[index], col);
				newColumns[index] = newCol;
			} else if (!onlyExisting) {
				newCol = that._initializeColumn ? that._initializeColumn(col) : col;
				newColumns.push(newCol);
			}
		}

		newColumns = that._prepareColumns(newColumns);
		that.set("columns", newColumns);
	}

	private _prepareColumns(columns: ObjectListColumn[]): ObjectListColumn[] {
		let that = this;
		columns = lang.sortBy(columns, col => col.order || 0);

		for (let col of columns) {
			col.role = col.role || (col.command ? "command" : "data");

			// append default values for the role
			let defaults: ObjectListColumn = lang.unlazy(that.roleDefaults[col.role]);
			col = lang.append(col, defaults);

			col.title = col.title || resources["objectList.columns." + col.role] || col.name;
			col.getter = col.getter || lang.noop; // getter is required
		}

		return columns;
	}

	/**
	 * Restore columns as they would be without applying user settings.
	 */
	protected resetColumns(): void {
		let that = this;
		if (that.userSettings) {
			that.userSettings.unbind("init:columns", null, that);
		}
		that.unbind("change:columns", null, that);

		that._initializeColumns();

		if (that.userSettings) {
			that.userSettings.set("columns", undefined);
		}

		if (that.onColumnsChanged) {
			that.onColumnsChanged(that.get("columns"));
		}
	}

	isColumnSortable(column: string|ObjectListColumn): boolean {
		return true;
	}

	private _orderedBy: OrderByData[];

	orderedBy(): OrderByData[] {
		return this._orderedBy;
	}

	protected setOrderedBy(orderBy?: OrderByData[]): void {
		let that = this;
		let _orderedBy = that._orderedBy;
		if (_orderedBy === orderBy || !_orderedBy && !orderBy) { return; }

		let changed = false;
		if (!_orderedBy !== !orderBy || _orderedBy.length !== orderBy.length) {
			changed = true;
		} else {
			for (let i = 0; i < orderBy.length; ++i) {
				let left = _orderedBy[i];
				let right = orderBy[i];
				if (left.prop !== right.prop || !left.desc !== !right.desc) {
					changed = true;
					break;
				}
			}
		}
		that._orderedBy = orderBy;
		// report to presenter to update columns sorting icons
		if (changed) {
			that.changed("columns");
		}
	}

	orderBy(columns: string|string[]|OrderByData|OrderByData[]): void {
		let parsed: OrderBy[] = this.items.parseOrderBy(columns);
		// NOTE: так как входные данные для parseOrderBy были строки, то в выходных элементах будут только
		// поля `prop` и `desc` (и не будет `getter` и `comparer`)
		let orderBy: OrderBy[] = parsed.map((item: OrderByData) => {
			let col: ObjectListColumn = lang.find(this.columns, c => c.name === item.prop);
			return !col ? item : {
				prop: col.orderByProp || col.prop,
				// don't use getter when `orderByProp` is specified
				getter: col.orderByProp ? undefined : function (): any {
					// NOTE: don't use lambda, this is another context here
					return col.getter.call(this, col);
				},
				comparer: col.comparer,
				desc: item.desc
			};
		});
		this.items.orderBy(orderBy);
		this.setOrderedBy(parsed);
	}

	/**
	 * Open Dialog for customizing columns
	 */
	protected doCustomize(): void {
		let that = this,
			dialogModel = new ListColumnsSettings(that, that.options.commandsOptions["Customize"]);

		Dialog.create({
			body: new View({
				template: settingsTemplate,
				viewModel: dialogModel
			}),
			header: resources["objectList.columnsSettings.header"],
			menu: { update: [
				{
					command: core.createCommand({
						execute: args => {
							args.dialog.close();
							that.resetColumns();
						}
					}),
					name: "Reset",
					hint: resources["objectList.columnsSettings.reset.hint"],
					title: resources["objectList.columnsSettings.reset"]
				}, {
					command: core.createCommand({
						execute: args => {
							args.dialog.close();
							that.orderBy([]);
						},
						canExecute: () => {
							let orderBy = that.items.orderBy();
							return !!(orderBy && orderBy.length);
						}
					}),
					name: "RemoveSorting",
					title: resources["objectList.columnsSettings.removeSorting"]
				}
			]}
		}).open().then((result) => {
			if (result !== "ok") { return; }

			let columns = dialogModel.columns.map(col => {
				return {
					name: col.name(),
					hidden: !col.visible()
				};
			});

			that.updateColumns(columns);
		});
	}

	protected canChangeRowHeight (): boolean {
		let presenter = (<any>this).presenter;
		if (!presenter || !presenter.dataPresenter ) {
			return false;
		}
		return this.state() === ObjectListState.loaded;
	}

	protected doIncreaseRowHeight (): void {
		let presenter = (<any>this).presenter;
		if (!presenter || !presenter.dataPresenter ) {
			return;
		}
		presenter.dataPresenter.changeRowHeight(true);
	}

	protected doDecreaseRowHeight (): void {
		let presenter = (<any>this).presenter;
		if (!presenter || !presenter.dataPresenter ) {
			return;
		}
		presenter.dataPresenter.changeRowHeight(false);
	}

	protected canCustomize(): boolean {
		return true;
	}

	/**
	 * Checks if the node can be selected
	 * @param item
	 * @returns {boolean}
	 */
	isItemSelectable(item: T): boolean {
		let that = this,
			filter = that.options.selectionFilter;
		return !!lang.coalesce(filter && filter(that, item), that._isItemSelectable(item));
	}

	/**
	 * Checks if the node can be selected by default (w/o option selectionFilter)
	 * @param item
	 * @returns {boolean}
	 */
	protected _isItemSelectable(item: T): boolean {
		return true;
	}

	/**
	 * Try to select items taking into account selectionFilter and logic from overrides (isItemSelectable)
	 * @param items Items to be selected
	 */
	setSelection(items: any[]): void {
		let that = this;

		items = items.filter(that.isItemSelectable, that);
		that.selection.reset(items);
	}

	protected doSelectAll(): void {
		// NOTE: SelectAll selects (reset) all items bypassing any filters ('where')
		this.setSelection(this.items.source().all());
	}
	protected canSelectAll(): boolean {
		// NOTE: to make accessing field observable we're doing it via `get` (with explicit firing events)
		// SelectAll available when there're not selected rows
		return this.get("selection").count() < this.get("items").source().count();
	}

	protected doSelectNone(): void {
		this.selection.clear();
	}
	protected canSelectNone(): boolean {
		return this.get("selection").count() > 0;
	}

	/**
	 * Returns an array of selected items (if any) or an array with single activeItem (if any).
	 * If there are no selected and active items, returns an empty array;
	 * @returns {Array}
	 */
	protected currentItems(): T[] {
		let that = this;

		// NOTE: use this.get("selection") instead of this.selection for triggering 'get' event
		let selection = that.get("selection");
		if (selection.count()) {
			return selection.all().filter(that.isItemSelectable, that);
		}

		let activeItem = that.activeItem();
		if (activeItem && that.isItemSelectable(activeItem)) {
			return [ activeItem ];
		}

		return [];
	}

	protected shouldValidateItems(): boolean {
		let validateItems = this.options.validateItems;
		return validateItems && validateItems !== "never";
	}

	protected shouldValidateItem(item: T): boolean {
		return false;
	}

	protected validateItem(item: T): Violation[] {
		let violations = validation.validateObjectWithProps(item),
			itemRules = this.options.itemRules;
		if (itemRules) {
			for (let rule of itemRules) {
				let error = rule.validate(item);
				if (error) {
					let violation = validation.createViolation(error, item);
					violations = validation.appendViolation(violation, violations);
				}
			}
		}
		return violations;
	}

	runItemsValidation(items?: T[]|T): Violation[] {
		if (!this.shouldValidateItems()) { return []; }

		let that = this,
			//itemArray: T[]|lang.IObservableCollection<T> = items ? lang.array(items) : that.items,
			itemArray: Pick<T[], "forEach" | "indexOf"> = items ? lang.array(items) : that.items,
			violations: Violation[] = [];

		itemArray.forEach(item => {
			if (that.shouldValidateItem(item)) {
				let itemViolations = that.validateItem(item);
				validation.appendViolation(itemViolations, violations);
			}
		});

		if (!items) {
			// validate all items - just reset violations collection
			that.violations.reset(violations);
		} else {
			// validate specified items - remove old violations with the same objects and then add new violations
			let removing: Violation[] = [];
			if (items && that.violations.count()) {
				that.violations.forEach(violation => {
					if (violation.object && itemArray.indexOf(violation.object) >= 0) {
						removing.push(violation);
					}
				});
			}
			// TODO: хорошо бы делать remove и add за одну операцию, чтобы событие change генерилось только один раз
			that.violations.remove(removing);
			that.violations.add(violations);
		}

		return violations;
	}

	abstract activate(): void;
}

/**
 * @enum {String}
 */
ListCommonMixin.prototype.states = ObjectListState;

// NOTE: getter/formatter will be used only if it's not specified in column's options (by an app dev)
ListCommonMixin.prototype.roleDefaults = {
	data: {
		getter(col: ObjectListColumn): any {
			return lang.get(this, col.prop);
		},

		formatter(v: any, col: ObjectListColumn): string | formatters.SafeHtml {
			let text;
			try {
				let propMeta = (this.getPropMeta && col.prop) ?
					this.getPropMeta(col.prop) :
					{ vt: col.vt };
				// NOTE: formatPropValue принимает FormatOptions, состоящий из vt,formatter,formatterHtml,html.
				// formatterHtml мы обработали в getCellHtml, но может быть задана одна опция html:true (и нет formatter/formatterHtml),
				// в этом случае надо использовать getDefaultFormatterHtml (внутри formatPropValue это сделать нельзя, т.к. и
				if (col.html) {
					let metaFormatter = formatters.getDefaultFormatterHtml(propMeta);
					if (lang.isFunction(metaFormatter)) {
						// явно заданный html-форматтер для свойства
						return formatters.safeHtml(metaFormatter(propMeta, v), v);
					}
				}
				text = formatters.formatPropValue(propMeta, v);
			} catch (ex) {
				// ignore any exceptions and return the result of toString() method below
			}

			if (text === undefined) {
				text = v == null ? "" : v.toString(); // undefined == null, don't use ===
			}

			// NOTE: there's no html-encoding here because it will be done later in getCellHtml
			return text;
			// WAS before 1.30: return formatters.textAsHtml(text, col.whitespaces);
		}
	},
	command: {
		formatter(v: any, col: ObjectListColumn): string {
			return "<a href='#' class='x-cmd-link' tabIndex='-1'>" + lang.encodeHtml(col.title || col.name) + "</a>";
		}
	},
	aux: {
		getter(col: ObjectListColumn): any {
			let aux: lang.Map<any> = this.aux;
			if (aux) {
				return aux[col.prop || col.name];
			}
		},
		formatter(v: any, col: ObjectListColumn): string {
			let text = formatters.formatPropValue({ vt: col.vt }, v).toString();
			return formatters.textAsHtml(text, col.whitespaces);
		}
	},
	// NOTE: core.ui.iconProvider isn't set here, so we use a factory function instead of static value
	icon: function (): ObjectListColumn {
		let iconProvider = core.ui.iconProvider;
		return !iconProvider ? undefined : {
			title: iconProvider.getIcon("picture"),
			errorHtml: iconProvider.getIcon("error", {title: resources["objectList.dataError"]}),
			loadingHtml: iconProvider.getIcon("loading", { title: resources.loading }),
			getter(): any {
				return iconProvider.getObjectIconName(this);
			},
			formatter(v: any): string {
				return iconProvider.getIcon(v);
			}
		};
	}
};


namespace ListCommonMixin {
	export interface Options extends Part.Options, PartCommandMixin.Options {
		columns?: (ObjectListColumn|string)[];
		/**
		 * @type Array|String
		 */
		orderBy?: string|string[];
		/**
		 * Function for client filtering
		 * @type Function
		 */
		where?: <T>(item: T, index?: number) => any;
		hasRowNum?: boolean;
		hasCheckboxes?: boolean;
		persistentSelection?: boolean;
		selectionFilter?: ListSelectionFilterCallback;
		validateItems?: "never" | "explicit" | "always";
		itemRules?: ObjectRule[];
	}

	export type ListSelectionFilterCallback = <T>(list: IList, item: T) => boolean;
}

export = ListCommonMixin;

/**
 * @callback ObjectListColumnGetter
 * @this {Object} List item
 * @param {ObjectListColumn} col Metadata of a column
 * @returns {*} Typed value of a column
 */

/**
 * @callback ObjectListColumnFormatter
 * @this {Object} List item
 * @param {*} v Typed value of a column (returned by 'getter' callback or 'prop' value)
 * @param {ObjectListColumn} col Metadata of a column
 * @returns {String} Formatted value of a column
 */

/**
 * @callback ObjectListColumnComparer
 * @param {*} v1 Typed value of a column for first comparing item (returned by 'getter' callback or 'prop' value)
 * @param {*} v2 Typed value of a column for second comparing item (returned by 'getter' callback or 'prop' value)
 * @returns {Number} -1 if v1 less than v2, 1 if v1 greater than v2 and 0 if the values are equal
 */

/**
 * @typedef {Object} ObjectListColumn
 * @property {String} [name]
 * @property {String} [prop]
 * @property {String} [title]
 * @property {String} [role]
 * @property {ObjectListColumnGetter} [getter]
 * @property {ObjectListColumnFormatter} [formatter]
 * @property {ObjectListColumnComparer} [comparer]
 * @property {Number} [width]
 * @property {Boolean} [hidden]
 * @property {Number} [order]
 */

