import core = require("core");
import $ = require("jquery");
import ObjectListPaginator = require("lib/ui/list/ObjectListPaginator");
import ObjectListPager = require("lib/ui/list/ObjectListPager");
import tmplMain = require("xhtmpl!lib/ui/templates/ObjectListPresenter.hbs");
import tmplTitle = require("xhtmpl!lib/ui/templates/ObjectList.title.hbs");
import tmplData = require("xhtmpl!lib/ui/templates/ObjectList.data.hbs");
import tmplFilter = require("xhtmpl!lib/ui/templates/ObjectList.filter.hbs");
import tmplHint = require("xhtmpl!lib/ui/templates/ObjectList.hint.hbs");
import tmplMenuList = require("xhtmpl!lib/ui/templates/ObjectList.menuList.hbs");
import tmplMenuRow = require("xhtmpl!lib/ui/templates/ObjectList.menuRow.hbs");
import tmplPaging = require("xhtmpl!lib/ui/templates/ObjectList.paging.hbs");
import tmplContextParts = require("xhtmpl!lib/ui/templates/ObjectList.contextParts.hbs");
import "lib/ui/ExpandablePanel"; // used in template
import "xcss!lib/ui/styles/objectList.css";

import lang = core.lang;
import { IPart } from "lib/ui/.ui";
import {
	IList,
	IObjectListPresenter,
	IObjectListPaginator,
	IObjectListDataPresenter,
	PagingOptions
} from ".list";
import Options = ObjectListPresenterBase.Options;

class ObjectListPresenterViewModel extends lang.Observable {
	options: Options;
	dataPresenter: IObjectListDataPresenter;
	paginator: IObjectListPaginator;
	templates: HandlebarsTemplateDelegate[];

	private _disposables: lang.IDisposable[];

	constructor (list: IList) {
		super();

		let  that = this;
		that.list(list);

		// Data-bind properties which depend on state().
		// NOTE: we use observable properties and binding instead of methods in presenterModel
		// to prevent redundant rerendering (see WC-996)
		that._addBinding(that.isLoading,
				list => list.state() === list.states.reloading ||
				list.state() === list.states.loadingMore);
		that._addBinding(that.isReloading, list => list.state() === list.states.reloading);
		that._addBinding(that.isLoadingMore, list => list.state() === list.states.loadingMore);
	}

	dispose (): void {
		let  that = this;
		if (that._disposables) {
			that._disposables.forEach((disposable) => {
				disposable.dispose();
			});
			that._disposables = undefined;
		}

		super.dispose();
	}

	/**
	 * @observable-property {*}
	 */
	@lang.decorators.observableAccessor()
	list: lang.ObservableProperty<IList>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isLoading: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isReloading: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isLoadingMore: lang.ObservableProperty<boolean>;

	stateSeverity (): string {
		let state = this.list().state();
		if (state === "failed") {
			return "error";
		}
		if (state === "loaded") {
			return "success";
		}
		return "info";
	}

	pendingItemsCount (): number {
		// TODO: `hasChanges` - это специфика DomainObject, но здесь элементы могут быть любого типа.
		// Надо куда-то вынести этот код.
		return this.list().get("items").all().filter(function (obj: any) {
			return lang.isFunction(obj.hasChanges) && obj.hasChanges();
		}).length;
	}

	protected _addBinding<T> (target: lang.ObservableProperty<T>, source: (list: IList) => T): void {
		let that = this,
			disposable = core.binding.databind(
			core.binding.expr(that, target),
			core.binding.expr(that.list(), function () { return source(this); }),
			{ oneway: true }
		);
		that._disposables = that._disposables || [];
		that._disposables.push(disposable);
	}
}

class ObjectListPresenterBase extends core.ui.View implements IObjectListPresenter {
	static ViewModel = ObjectListPresenterViewModel;

	static defaultOptions: Options = {
		template: tmplMain,
		unbound: true,
		Paginator: ObjectListPaginator,
		cssClass: "",
		affixMenu: true,
		//hideMenuRow: false,
		//hideMenuList: false,
		showTitle: true,
		menuRowCssClass: "x-menu-bar x-menu--contrast",
		menuListCssClass: "x-menu-bar",

		partialTemplates: {
			title: tmplTitle,
			data: tmplData,
			filter: tmplFilter,
			hint: tmplHint,
			menuList: tmplMenuList,
			menuRow: tmplMenuRow,
			paging: tmplPaging,
			contextParts: tmplContextParts
		},
		templates: ["title", "filter", "menuList", "hint", "data", "paging", "contextParts", "menuRow"]
	};

	static hostDefaultOptions: lang.Map<Options> = {
		dialog: {
			affixMenu: false,
			//affixHeader: false,
			/*gridOptions: {
				autoHeight: false
			}*/
		}
	};

	/**
	 * Dictionary: string => ObjectListPaginatorBase class.
	 * You may extend this dictionary with your own values.
	 */
	static defaultPaginators: lang.Map<lang.Constructor<IObjectListPaginator>> = {
		pages: ObjectListPager,
		throttle: ObjectListPaginator
	};

	options: Options;
	viewModel: ObjectListPresenterViewModel;
	dataPresenter: IObjectListDataPresenter;
	paginator: IObjectListPaginator;
	eventPublisher: core.IEventPublisher;

	/**
	 * @constructs ObjectListPresenterBase
	 * @extends View
	 */
	constructor(options?: Options) {
		options = ObjectListPresenterBase.mixOptions(options, ObjectListPresenterBase.defaultOptions);

		super(options);

		this.eventPublisher = core.Application.current.eventPublisher;
	}

	applyHostContext(opt?: {host: string}): core.INavigationService.NavigateOptions {
		super.applyHostContext(opt);

		if (this.dataPresenter.applyHostContext) {
			this.dataPresenter.applyHostContext(opt);
		}
		this.mixHostOptions(opt.host, ObjectListPresenterBase.hostDefaultOptions);
		return null;
	}

	/**
	 * @param {ObjectList} list
	 */
	setViewModel(list: IList): void {
		let that = this,
			presenterModel: ObjectListPresenterViewModel = that.viewModel;

		if (presenterModel) {
			presenterModel.dispose();
		}

		that._uninitChild(that.dataPresenter);
		that._initDataPresenter(list);
		that._throwIfNoDataPresenter();

		that._uninitChild(that.paginator);
		that._initPaginator(list);
		// NOTE: paginator may be not set

		presenterModel = new ObjectListPresenterViewModel(list);
		presenterModel.dataPresenter = that.dataPresenter;
		presenterModel.paginator = that.paginator;
		presenterModel.options = that.options;

		let templates = [];
		this.options.templates.forEach((name) => {
			let tmpl = this.options.partialTemplates[name];
			if (tmpl) {
				templates.push(tmpl);
			}
		});
		presenterModel.templates = templates;

		super.setViewModel(presenterModel);
	}

	unload(): void {
		let that = this;
		if (that.options.affixMenu && !that.options.hideMenuRow && that.eventPublisher) {
			that.eventPublisher.publish("ui.affix.remove_element", {
				element: $("> .x-list > .x-list-menu-row-container", that.domElement)
			});
		}
		super.unload();
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		// NOTE: viewModel is a custom object created in setViewModel, which must be disposed
		if (this.viewModel) {
			this.viewModel.dispose();
		}
		super.dispose(options);
	}

	protected doRender(domElement: JQuery|HTMLElement): void {
		let that = this;
		if (!that.viewModel) { return; }

		let list = that.viewModel.list();
		// NOTE: если мы установим hideMenuList/hideMenuRow, то это будет навсегда, до следующего rerender,
		// изменение меню не повлияет на его появление,
		// но обычно меню списка не пустое, даже если заблокированы все пункты
		// Если кому-то потребуется динамически менять меню, изначально не заданное,
		// то следует задать опции hideMenuRow/hideMenuList как false (по умолчанию undefined)
		if (that.options.hideMenuList === undefined) {
			that.options.hideMenuList = (!list.menuList || list.menuList.isEmpty()) &&
				(!list.menuListAux || list.menuListAux.isEmpty());
		}
		if (that.options.hideMenuRow === undefined) {
			that.options.hideMenuRow = (!list.menuRow || list.menuRow.isEmpty()) &&
				(!list.menuSelection || list.menuSelection.isEmpty());
		}
		super.doRender(domElement);

		if (that.options.affixMenu && !that.options.hideMenuRow && that.eventPublisher) {
			that.eventPublisher.publish("ui.affix.add_element", {
				element: $("> .x-list > .x-list-menu-row-container", that.domElement),
				controlledBy: $("> .x-list > .x-list-data-container", that.domElement),
				affixTo: "bottom"
			});
		}

		/*
		 $(domElement).on("click", ".x-list-data-container .x-cmd-link", function () {
		 // TODO: выполнять команды из menuRow как в SlickObjectListDataPresenter (реально нужно только для SimpleObjectListPresenter)
		 });
		 */
		let $domElement = that.$domElement;
		$domElement.on("click", ".x-cmd-link", function () {
			let $this = $(this),
				list = that.viewModel.list(),
				cmdName = core.commands.dataCommandName($this),
				cmdParams,
				cmd,
				menu = list.menuList,
				menuItem;

			if (cmdName) {
				cmdParams = lang.extend({},
					core.commands.dataCommandParams($this),
					{ list: list });

				menuItem = menu.getItem(cmdName);
				if (menuItem && menuItem.command) {
					menu.executeItem(menuItem, cmdParams);
					return false;
				}

				cmd = list.commands && list.commands[cmdName];
				if (cmd) {
					cmd.execute(cmdParams);
					return false;
				}
			}
		});

		// row menu hotkey handler
		$domElement.on("keyup", ".x-list-data-container", function(e: JQueryEventObject) {
			// skip navigation keyboard
			if (core.html.keyCode.isNavigationKey(e)) { return; }
			let list = that.viewModel.list();
			if (list.menuRow && list.menuRow.executeHotkey(e)) {
				return false;
			}
		});
		// list menu hotkey handler
		$domElement.on("keyup", function (e: JQueryEventObject) {
			if (core.html.keyCode.isNavigationKey(e)) { return; }
			let list = that.viewModel.list();
			// NOTE: ignore press inside paging panel
			if ($(e.target).parents(".x-list-paging").length) { return; }
			if (list.menuList && list.menuList.executeHotkey(e)) {
				return false;
			}
		});
	}

	protected _initDataPresenter(list: IList): void {
		let that = this,
			dataPresenter = that.options.dataPresenter ||
				(that.options.DataPresenter && new that.options.DataPresenter(that._dataPresenterOptions()));
		if (dataPresenter) {
			dataPresenter.setViewModel(list);
			that.registerChild(dataPresenter, {disposeOnUnload: false, keepOnUnload: true, trackStatus: true});
		}
		that.dataPresenter = dataPresenter;
	}

	protected _dataPresenterOptions() {
		let that = this,
			dataOptions = {};
		lang.forEach(that.options, function (v, name) {
			if (!ObjectListPresenterBase.defaultOptions.hasOwnProperty(name)) {
				dataOptions[name] = v;
			}
		});
		return dataOptions;
	}

	protected _throwIfNoDataPresenter(): void {
		if (!this.dataPresenter) {
			throw new Error("DataPresenter was not specified");
		}
	}

	protected _initPaginator(list: IList): void {
		let that = this,
			paging = list.options.paging,
			paginator: IObjectListPaginator,
			paginatorOptions: PagingOptions,
			Paginator;
		// NOTE: don't show a paginator when paging is explicitly turned off
		if (paging !== false) {
			paginator = that.options.paginator;
			if (!paginator) {
				paginatorOptions = that._createPaginatorOptions(paging);
				Paginator = paginatorOptions.mode ?
					ObjectListPresenterBase.defaultPaginators[paginatorOptions.mode] :
					that.options.Paginator;
				if (Paginator) {
					paginator = new Paginator(paginatorOptions);
				} else if (paginatorOptions.mode) {
					console.warn("No paginator implementation found for mode " + paginatorOptions.mode);
				}
			}

			if (paginator) {
				paginator.list(list);
				that.registerChild(paginator, {disposeOnUnload: false, keepOnUnload: true, trackStatus: false});
				// NOTE: the paginator will be auto-disposed with the presenter itself, so there is no need to unbind explicitly
				paginator.bind("change:skippedItems", that._onSkippedItemsChange, that);

				// set normalized paging options back into our list
				let opt = list.options || {};
				opt.paging = paginator.options;
			}
		}
		that.paginator = paginator;
	}

	protected _createPaginatorOptions(paging: boolean|number|PagingOptions): PagingOptions {
		if (!paging) {
			return { pageSize: 0 };
		}
		if (lang.isNumber(paging)) {
			return { pageSize: <number>paging };
		}
		if (lang.isObject(paging)) {
			return <PagingOptions>paging;
		}
		return {};
	}

	protected _onSkippedItemsChange(sender: IObjectListPaginator, value: number): void {
		let dataPresenter = this.dataPresenter;
		if (dataPresenter && dataPresenter.setNumbering) {
			dataPresenter.setNumbering(value);
		}
	}

	protected _uninitChild(part: IPart): void {
		if (part) {
			this.unregisterChild(part);
			part.dispose();
		}
	}
}

ObjectListPresenterBase.mixin({
	defaultOptions: ObjectListPresenterBase.defaultOptions,
	defaultPaginators: ObjectListPresenterBase.defaultPaginators,
	contextDefaultOptions: ObjectListPresenterBase.hostDefaultOptions
});

namespace ObjectListPresenterBase {
	export interface Options extends core.ui.View.Options {
		dataPresenter?: IObjectListDataPresenter;
		DataPresenter?: lang.Constructor<IObjectListDataPresenter>;
		paginator?: IObjectListPaginator;
		Paginator?: lang.Constructor<IObjectListPaginator>;
		// paginatorOptions?: ObjectListPaginatorBase.Options;
		affixMenu?: boolean;
		hideMenuRow?: boolean;
		hideMenuList?: boolean;
		showTitle?: boolean;
		cssClass?: string;
		menuRowCssClass?: string;
		menuListCssClass?: string;
		partialTemplates?: lang.Map<HandlebarsTemplateDelegate>;
		templates?: string[];
	}

	export type ViewModel = ObjectListPresenterViewModel;
}

core.ui.ObjectListPresenterBase = ObjectListPresenterBase;
export = ObjectListPresenterBase;
