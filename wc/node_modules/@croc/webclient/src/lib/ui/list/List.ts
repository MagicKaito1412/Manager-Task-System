import core = require("core");
import binding = require("lib/binding");
import utils = require("lib/utils");
import Component = require("lib/ui/Component");
import ListCommonMixin = require("lib/ui/list/ListCommonMixin");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import PartWithFilterMixin = require("lib/ui/PartWithFilterMixin");
import Menu = require("lib/ui/menu/Menu");
import resources = require("i18n!lib/nls/resources");

import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import {
	IObjectList, IObjectListLoader, IObjectListPresenter,
	ObjectListColumn, ObjectListLoaderResult, PagingOptions
} from ".list";
import { LoadQueryParams, IDataSource, LoadQuerySpec, LoadResponse } from "lib/interop/.interop";
import { Violation } from "lib/validation";

import lang = core.lang;
import Promise = lang.Promise;
import Application = core.Application;
import MenuOptions = Menu.Options;
import ICommand = core.commands.ICommand;
import ICommandFactory = core.commands.ICommandFactory;
import OrderByData = lang.collections.OrderByData;
import LoadOptions = List.LoadOptions;
import DataLoadEventArgs = List.DataLoadEventArgs;
import {ObjectListState} from "lib/ui/list/.list.types";

class ListLoader<T> implements IObjectListLoader<T> {
	app: Application;
	options: List.LoaderOptions;
	dataSource: IDataSource;

	private _reloadOpId: string;

	constructor(app: Application, options: List.LoaderOptions) {
		this.app = app;
		this.options = options;
		this.dataSource = options.dataSource;
	}

	load(list: IObjectList<T>, params?: LoadQueryParams): Promise<ObjectListLoaderResult<T>> {
		let that = this,
			query: LoadQuerySpec = {
				params: params
			},
			options = {
				opId: that.options.cancellable ? utils.generateGuid() : undefined,
			};

		that._reloadOpId = options.opId;

		return that.dataSource.load(query, options).then((dsResult: LoadResponse) => {
			let items = that.onMaterialize(dsResult);
			return { items: items, hints: dsResult.hints };
		}).always(() => {
			that._reloadOpId = undefined;
		});
	}

	cancel(): void {
		let that = this,
			opId = that._reloadOpId,
			ds = that.dataSource;
		if (opId && ds.cancel) {
			ds.cancel(opId);
			that._reloadOpId = undefined;
		}
	}

	protected onMaterialize(dsResult: LoadResponse): T[] {
		let that = this;
		let items = dsResult.result;

		if (that.options.onMaterialize) {
			let args = { items: items, dsResult: dsResult };
			that.options.onMaterialize.call(that, args);
			items = args.items;
		}

		return items;
	}
}
namespace ListLoader {}

class List<T> extends Component implements IObjectList<T>, ListCommonMixin<T> {
	static defaultOptions: List.Options = {
		/**
		 * @type Boolean
		 */
		filterExpanded: false,
		/**
		 * @type Boolean
		 */
		filterCollapsable: true,
		/**
		 * @type String
		 */
		expandFilterTitle: resources["objectFilter.show"],
		/**
		 * @type String
		 */
		collapseFilterTitle: resources["objectFilter.hide"],
		/**
		 * Allow multi select. For SlickGrid means adding a column with checkboxes.
		 * @type {Boolean}
		 */
		hasCheckboxes: false,
		navigateOptions: {
			dialogOptions: {
				menu: false
			}
		},
		Loader: ListLoader,
		commandsOptions: {},
		stateMessages: {
			initial: resources["objectList.state.not_loaded"],
			noData: resources["objectList.state.no_data"],
			loadFailed: resources["objectList.state.load_failed"]
		},
		userSettings: {
			props: {
				"filterExpanded": true,
				"filter": true,
				"contextParts": true,
				"rowHeight": true
			}
		}
	};

	// NOTE: see also ObjectList.defaultMenu
	static defaultMenus: List.KnownMenus = {
		// Row menu
		ListRow: { items: [] },
		// Selection menu
		Selection: { items: [
			{
				name: "Selection",
				title: resources.selection,
				html: "<span class='x-icon x-icon-select-all visible-xs'></span><span class='hidden-xs'>" + resources.selected + "</span>" +
				      " <span class='x-list-menu-selection-counter'></span>/<span class='x-list-menu-total-counter'></span>",
				items: [
					{ name: "SelectAll", title: resources.selectAll },
					{ name: "SelectNone", title: resources.selectNone }
				]
			}
		]},
		// List Menu
		List: { items: [
			{
				name: "Reload",
				title: resources.reload,
				icon: "refresh",
				isDefaultAction: true,
				order: 10
			}, {
				name: "CancelReload",
				title: resources.cancel_reload,
				icon: "stop",
				order: 11
			}
		]},
		// List Menu Aux
		ListAux: { items: [
			{
				name: "Customize",
				icon: "settings",
				title: resources.customize,
				presentation: "icon",
				order: 10
			}, {
				name: "IncreaseRowHeight",
				icon: "x-icon-menu4-outer",
				title: resources["increase_row_height"],
				presentation: "icon",
				order: 20
			}, {
				name: "DecreaseRowHeight",
				icon: "x-icon-menu4-inner",
				title: resources["decrease_row_height"],
				presentation: "icon",
				order: 21
			}
		]}
	};

	@lang.decorators.constant(List.defaultMenus)
	defaultMenus: List.KnownMenus;

	/**
	 * @enum {String}
	 */
	static events = {
		DATA_LOADING: "dataLoading",
		DATA_PREPARING: "dataPreparing",
		DATA_LOADED: "dataLoaded"
	};

	@lang.decorators.constant(List.events)
	events: typeof List.events;

	/**
	 * Additional message reporting something useful for the user
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	hintMessage: lang.ObservableProperty<string>;

	options: List.Options;
	app: Application;
	presenter: IObjectListPresenter;
	commands: lang.Map<ICommand>;
	menuList: Menu;
	menuListAux: Menu;
	menuRow: Menu;
	menuSelection: Menu;
	title: string;
	traceSource: core.diagnostics.TraceSource;
	cancellable: boolean;
	lastError: Error; 		// unused yet

	protected loader: IObjectListLoader<T>;

	/**
	 * @constructs List
	 * @extends Component
	 * @param app
	 * @param options {Object}
	 * @param options.columns {Array} Array of column descriptors
	 * @param options.columns.name {String}
	 * @param options.columns.prop {String}
	 * @param options.columns.title {String}
	 * @param options.columns.formatter {Function} [optional]
	 */
	constructor(app: Application, options?: List.Options) {
		if (!app) { throw new Error("ArgumentException: app can't be null"); }

		options = List.mixOptions(options, List.defaultOptions);
		super(options);

		let that = this;
		that.app = app;
		//that.state(that.states.initial);
		that.traceSource = new core.diagnostics.TraceSource("ui.List", that.options.traceSourceName || that.name);
		that.userSettings = core.UserSettings.create(that.options.userSettings);
		that.title = that.options.title;

		that._preinitialize();

		that._initializeColumns();

		that._initializeMenus();

		that.initPresenter();

		that.subscribeOnNavigation();
		utils.subscribeOnEvents(that, that.options, that.events);

		if (that.loader) {
			that.setInitial();
		} else {
			that.setData([]);
		}
	}

	protected tweakOptions(options: List.Options): void {
		lang.appendEx(options, {
			presenterOptions: {
				hasCheckboxes: options.hasCheckboxes,
				hasRowNum: options.hasRowNum
			}
		}, { deep: true });
		super.tweakOptions(options);
	}

	protected _preinitialize(): void {
		let that = this;

		that._initializeProps();

		that.loader = that.createLoader();
		that.cancellable = that.options.cancellable && that.loader && !!that.loader.cancel;

		that.initFilter(that.options, that.userSettings);
	}

	protected _initializeMenus(): void {
		let that = this;

		let commands = that.createCommands();
		that.commands = core.commands.unlazyCommands(commands, that);

		that.menuList = that.createListMenu();
		that._initMenu(that.menuList);

		that.menuListAux = that.createListMenuAux();
		that._initMenu(that.menuListAux);

		that.menuRow = that.createRowMenu();
		that._initMenu(that.menuRow);

		// NOTE: menuSelection will exist event without checkboxes as selection is still possible via shift-arrows/mouse
		that.menuSelection = that.createSelectionMenu();
		that._initMenu(that.menuSelection);

		if ((!that.menuSelection || that.menuSelection.isEmpty()) && (!that.menuRow || that.menuRow.isEmpty())){
			that.options.presenterOptions.affixMenu = false;
		}
	}

	protected _initMenu(menu: Menu): void {
		if (menu) {
			menu.bindToPart(this, { list: this });
		}
	}

	protected createCommands(): core.commands.ICommandLazyMap {
		let that = this,
			commands: any = {
				SelectAll: new core.commands.BoundCommand(that.doSelectAll, that.canSelectAll, that),
				SelectNone: new core.commands.BoundCommand(that.doSelectNone, that.canSelectNone, that)
			};

		if (that.loader) {
			commands.Reload = new core.commands.BoundCommand(that.doReload, that.canReload, that);
			if (that.cancellable) {
				commands.CancelReload = new core.commands.BoundCommand(that.cancelReload, that.canCancelReload, that);
			}
		}

		if (that.columns && that.columns.length) {
			commands.Customize = new core.commands.BoundCommand(that.doCustomize, that.canCustomize, that);
		}
		commands.IncreaseRowHeight = new core.commands.BoundCommand(that.doIncreaseRowHeight, that.canChangeRowHeight, that);
		commands.DecreaseRowHeight = new core.commands.BoundCommand(that.doDecreaseRowHeight, that.canChangeRowHeight, that);

		lang.extend(commands, that.options.commands);

		return commands;
	}

	protected createListMenuDefaults(): Menu.Options {
		return this.defaultMenus.List;
	}
	protected createListMenuAuxDefaults (): Menu.Options {
		return this.defaultMenus.ListAux;
	}

	protected createListMenu(): Menu {
		let that = this,
			menu = new Menu(
				that.createListMenuDefaults(),
				that.options.menuList
				//that.options.hideExportMenu && { remove: ["Export"] }
			);
		// объединяем с меню фильтра
		if (that.filter && that.filter.menu) {
			menu.mergeWith(that.filter.menu);
			that._fieldWithFilterMenu = "menuList";
		}

		if (that.cancellable) {
			let menuItem = menu.getItem("Reload");
			if (menuItem) {
				lang.append(menuItem, { hideIfDisabled: true });
			}
			menuItem = menu.getItem("CancelReload");
			if (menuItem) {
				lang.append(menuItem, { hideIfDisabled: true });
			}
		}
		return menu;
	}

	protected createListMenuAux (): Menu {
		return new Menu(
				this.createListMenuAuxDefaults(),
				this.options.menuListAux
			);
	}

	protected createRowMenuDefaults(): Menu.Options {
		return this.defaultMenus.ListRow;
	}
	protected createRowMenu(): Menu {
		return new Menu(this.createRowMenuDefaults(), this.options.menuRow);
	}

	protected createSelectionMenuDefaults(): Menu.Options {
		return this.defaultMenus.Selection;
	}
	protected createSelectionMenu(): Menu {
		return new Menu(this.createSelectionMenuDefaults(), this.options.menuSelection);
	}

	protected _initializeColumn(col: ObjectListColumn|string): ObjectListColumn {
		let column: ObjectListColumn = lang.isString(col) ? { name: <string>col } : <ObjectListColumn>col;
		if (!column.prop && column.name) {
			column.prop = column.name;
		}
		return column;
	}
	protected _initializeColumns(): void {
		let that = this,
			columns: ObjectListColumn[];
		if (that.options.columns) {
			// колонки заданы в опциях списка
			columns = that.options.columns.map(column => that._initializeColumn(column));
		} else {
			columns = [];
		}

		that.setupColumns(columns);
	}

	runValidation(): Violation[] {
		return this.runItemsValidation();
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		let that = this;

		that.state(ObjectListState.disposed);

		that.disposeFilter();

		that.items.dispose();
		that.selection.dispose();
		that.violations.dispose();

		super.dispose(options);
	}

	protected showFilterError(error: string): void {
		this.hintMessage(resources["objectList.getRestrictionsError"] + error);
	}

	protected createViewModel?(obj: T): T;

	protected createLoader(): IObjectListLoader<T> {
		let that = this,
			loader = lang.unlazy(that.options.loader, that);
		// NOTE: if loader equals to 'null' that means that the list should not have ability to load/reload (data will be set externally).
		if (loader !== undefined) {
			return loader;
		}

		// create default loader from dataSource
		let ds = that.options.dataSource;
		if (ds !== undefined) {
			return new that.options.Loader(that.app, {
				dataSource: ds,
				cancellable: that.options.cancellable,
				onMaterialize: that.options.onDataMaterialize
			});
		}
	}

	isLoading(): boolean {
		let that = this,
			state = that.state();
		return state === ObjectListState.reloading || state === ObjectListState.loadingMore;
	}

	/**
	 * The implementation of the command 'Reload'
	 * @param args
	 * @param {Object} args.params Loader parameters. If not specified, parameters from the filter are used.
	 * @returns {Promise.<DomainObject[]>}
	 */
	protected doReload(args?: LoadOptions): lang.Promise<T[]> {
		// TOTHINK: можно добавить режим persistentSelection, при котором selection будет переживать релоад...
		this.selection.clear();
		return this.reload(args);
	}

	protected canReload(): boolean {
		return !this.isLoading();
	}

	protected cancelReload(): void {
		this.loader.cancel();
	}
	protected canCancelReload(): boolean {
		return this.state() === ObjectListState.reloading;
	}

	/**
	 * @param args
	 * @param {Object} args.params Loader parameters. If not specified, parameters from the filter are used.
	 * @returns {Promise.<DomainObject[]>}
	 */
	reload(args?: LoadOptions): lang.Promise<T[]> {
		args = args || {};
		let that = this,
			// NOTE: if args.params is specified, we'll ignore current restrictions (used for paging/server sorting)
			params = lang.coalesce(args.params, that.getFilterRestrictions());
		// NOTE: null params mean there was an error during getting params
		if (params == null) { return; }

		// NOTE: Using async execution to catch any errors in one place (fail callback in the end).
		return lang.async.chain().then(() => {
			that.traceSource.time("reload");
			that.state(ObjectListState.reloading);
			that.hintMessage(undefined);

			// extend params
			if (that.options.loadParams) {
				params = lang.extend(
					params,
					lang.isFunction(that.options.loadParams) ? that.options.loadParams() : that.options.loadParams
				);
			}
			lang.extend(params, args && args.params);

			return that._load(params);
		}).then((ea: DataLoadEventArgs<T>) => {
			return that.setData(ea.items, ea.hints);
		}).fail(error => {
			that._setError(error);
		}).always(() => {
			that.traceSource.timeEnd("reload");
		}).value();
	}

	/**
	 * @param args
	 * @param {Object} args.params Loader parameters
	 * @returns {Promise.<DomainObject[]>}
	 */
	loadMore(args?: LoadOptions): lang.Promise<T[]> {
		// TOTHINK: теперь список хранит условия последней загрузки в _lastLoadParams,
		// в принципе их можно тут подставить бы (т.к. LoadMore должно быть с предыдущими условиями),
		// но сейчас они приходят из pager'a и выпилить их оттуда непросто/
		// Важно, что сам по себе метод loadMore не совсем корректный, т.к. подразумевает, что предыдущие условия будут передаваться снаружи.

		let that = this;
		if (!that.loader) {
			throw new Error("ObjectList doesn't have a loader associated with it");
		}

		// NOTE: Using async execution to catch any errors in one place (fail callback in the end).
		return lang.async.chain().then(() => {
			that.traceSource.time("loadMore");
			that.state(ObjectListState.loadingMore);
			that.hintMessage(undefined);

			return that._load(args && args.params);
		}).then((ea: DataLoadEventArgs<T>) => {
			return that.addData(ea.items, ea.hints);
		}).fail((error) => {
			that._setError(error);
		}).always(() => {
			that.traceSource.timeEnd("loadMore");
		}).value();
	}

	/**
	 * Load items with specified params via the loader
	 * @param params
	 * @returns {Promise.<DataLoadEventArgs>} Promise of DataLoadEventArgs
	 * @protected
	 */
	protected _load(params?: LoadQueryParams): lang.Promise<DataLoadEventArgs<T>> {
		let that = this,
			ea: DataLoadEventArgs<T> = {},
			promise: lang.Promise<ObjectListLoaderResult<T>>;

		ea.params = params;
		that.onDataLoading(ea);

		that.traceSource.time("loader:load");
		promise = that.loader.load(that, ea.params);

		return lang.async.then(promise, function (result: ObjectListLoaderResult<T>): DataLoadEventArgs<T> {
			that.traceSource.timeEnd("loader:load");
			if (that.state() === ObjectListState.disposed) { return; }

			ea.items = result.items;
			ea.hints = result.hints;

			that.onDataLoaded(ea);

			return ea;
		});
	}

	/**
	 * Set list's data
	 * @param {Array} items An array of items (domain objects)
	 * @param {Object} [hints]
	 * @param {String} [hints.message]
	 * @param {String} [hints.source]
	 * @returns {Array} An array of added items. May differ from input items if they are changed in onDataPreparing
	 */
	setData(items: T[], hints?: any): T[] {
		let that = this;

		if (hints && hints.message) {
			that.hintMessage(hints.message);
		}
		that.traceSource.time("setItems");
		items = that._prepareData(items, hints);
		// NOTE: см. ListCommonMixin._initializeProps, там selection синхронизируется с items,
		//	т.е. все текущие значения items удаляются из selection.
		// 	(BTW: side-effect от этого - сброс выделения при перезагрузке; даже, если результат тот же)
		//	но раз это так, то для оптимизации очистим всё сразу
		if (!that.options.persistentSelection) {
			that.selection.clear();
		}

		that.items.reset(items);
		that.activeItem(null);

		that.traceSource.timeEnd("setItems");
		that.lastError = null;
		if (!items.length) {
			that.stateMessage(that.options.stateMessages.noData);
		} else {
			that.stateMessage("");
		}
		that.state(ObjectListState.loaded);

		return items;
	}

	/**
	 * Add items to list
	 * @param {Array} items An array of items (domain objects)
	 * @param {Object} [hints]
	 * @param {String} [hints.message]
	 * @param {String} [hints.source]
	 * @returns {Array} An array of added items. May differ from input items if they are changed in onDataPreparing
	 */
	addData(items: T[], hints?: any): T[] {
		let that = this;
		if (hints && hints.message) {
			that.hintMessage(hints.message);
		}
		that.traceSource.time("addItems");
		items = that._prepareData(items, hints);
		that.items.add(items);
		that.traceSource.timeEnd("addItems");
		that.state(ObjectListState.loaded);
		return items;
	}

	/**
	 * Change list's state to initial: no items, no activeItem, initial state message
	 */
	setInitial(): void {
		let that = this;
		that.items.reset([]);
		that.selection.clear();
		that.activeItem(null);
		that.stateMessage(that.options.stateMessages.initial);
		that.state(ObjectListState.initial);
	}

	protected _prepareData(items: T[], hints?: any): T[] {
		let that = this,
			args = { items: items, hints: hints };
		that.onDataPreparing(args);
		return args.items || [];
	}

	protected _setError(error: Error): void {
		let that = this;
		if (core.eth.isCanceled(error)) {
			that.state(that.items.count() > 0 ? ObjectListState.loaded : ObjectListState.initial);
			that.hintMessage(error.message);
		} else {
			that.lastError = error;
			that.state(ObjectListState.failed);
			// TODO: show the error details (error.message)

			that.stateMessage(that.options.stateMessages.loadFailed);
			that.traceSource.error(error);
		}
	}

	/**
	 * @protected
	 * @virtual
	 * @param args
	 * @param {Array} args.items An array of loaded items (domain objects)
	 * @param {Object} [args.hints]
	 */
	protected onDataPreparing(args: DataLoadEventArgs<T>): void {
		let that = this,
			items = args.items;

		// wrap new objects if needed
		if (that.createViewModel && items) {
			args.items = items.map(obj => that.createViewModel(obj));
		}

		that.trigger(List.events.DATA_PREPARING, that, args);
	}

	/**
	 * @protected
	 * @virtual
	 * @param {DataLoadEventArgs} args
	 */
	protected onDataLoading(args: DataLoadEventArgs<T>): void {
		this.trigger(this.events.DATA_LOADING, this, args);
	}

	/**
	 * @protected
	 * @virtual
	 * @param {DataLoadEventArgs} args
	 */
	protected onDataLoaded(args: DataLoadEventArgs<T>): void {
		this.trigger(this.events.DATA_LOADED, this, args);
	}

	protected beforeRender (domElement?: JQuery|HTMLElement): void {
		let that = this;
		// auto-load data before first render
		// NOTE: don't do this in the constructor, the filter needs some time to restore its restrictions from the userSettings (see WC-1297)
		if (that.options.autoLoad && that.state() === ObjectListState.initial) {
			that.reload();
		}
		super.beforeRender(domElement);
	}

	activate(): void {
		let presenter = this.presenter;
		if (!presenter) { return; }
		if (presenter.focus) {
			presenter.focus();
		}
		if (presenter.scrollToSelf) {
			presenter.scrollToSelf();
		}
	}
}

interface List<T> extends ListCommonMixin<T>, PartCommandMixin, PartWithFilterMixin { }

// NOTE: `as any` для TS 2.4
PartCommandMixin.mixinTo(List as any);
List.mixin(ListCommonMixin);
List.mixin(PartWithFilterMixin);
List.mixin(/** @lends List.prototype */{
	defaultOptions: List.defaultOptions
});

namespace List {
	export import Loader = ListLoader;

	export interface Options extends Component.Options, ListCommonMixin.Options, PartCommandMixin.Options, PartWithFilterMixin.Options {
		title?: string;
		traceSourceName?: string;
		menuList?: MenuOptions;
		menuListAux?: MenuOptions;
		menuRow?: MenuOptions;
		menuSelection?: MenuOptions;
		stateMessages?: StateMessages;
		autoLoad?: boolean;
		loader?: IObjectListLoader<any> | ((list: List<any>) => IObjectListLoader<any>);
		Loader?: new(app: Application, options: List.LoaderOptions) => IObjectListLoader<any>;
		/**
		 * Additional params for DataSource (will be combined with filter's restrictions)
		 */
		loadParams?: LoadQueryParams | (() => LoadQueryParams);
		dataSource?: IDataSource;
		cancellable?: boolean;
		paging?: boolean|number|PagingOptions;
		onDataLoading?: <T>(sender: List<T>, args: DataLoadEventArgs<T>) => void;
		onDataLoaded?: <T>(sender: List<T>, args: DataLoadEventArgs<T>) => void;
		onDataPreparing?: <T>(sender: List<T>, args: DataLoadEventArgs<T>) => void;
		onDataMaterialize?: <T>(args: List.DataMaterializeArgs<T>) => void;
	}

	export interface LoaderOptions {
		dataSource: IDataSource;
		cancellable?: boolean;
		/**
		 * @this {ObjectListLoader} Loader instance
		 */
		onMaterialize?: <T>(this: IObjectListLoader<T>, args: List.DataMaterializeArgs<T>) => void;
	}

	export interface KnownMenus extends lang.Map<Menu.Options> {
		ListRow?: Menu.Options;
		Selection?: Menu.Options;
		List?: Menu.Options;
		ListAux?: Menu.Options;
	}

	export interface StateMessages {
		initial?: string;
		noData?: string;
		loadFailed?: string;
	}

	export interface LoadOptions {
		params?: LoadQueryParams;
	}

	export interface DataLoadEventArgs<T> {
		params?: LoadQueryParams;
		items?: T[];
		hints?: any;
	}

	export interface DataMaterializeArgs<T> {
		items: T[];
		dsResult: LoadResponse;
	}
}

core.ui.List = List;
/**
 * @deprecated Use core.ui.List component
 */
core.ui.ObjectListSimple = List;

export = List;
