import core = require("core");
import List = require("lib/ui/list/List");
import PartCommandMixin = require("lib/ui/PartCommandMixin");
import ObjectListLoader = require("lib/ui/list/ObjectListLoader");
import DataSource = require("lib/data/DataSource");
import Menu = require("lib/ui/menu/Menu");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import ViolationInfoPart = require("lib/ui/validation/ViolationInfoPart");
import PartWithFilterMixin = require("lib/ui/PartWithFilterMixin");
import ObservableCollectionView = require("lib/utils/ObservableCollectionView");
import resources = require("i18n!lib/nls/resources");
import { ContextPartComponentMixin, IContextPart } from "lib/ui/validation/ContextPartMixin";
import UnitOfWork = require("lib/domain/UnitOfWork");
import ObjectListMixin = require("lib/ui/list/ObjectListMixin");

import lang = core.lang;
import domain = require("lib/domain/.domain");
import list = require("lib/ui/list/.list");
import { LoadQueryParams, InteropError } from "lib/interop/.interop";
import ObservableCollection = lang.ObservableCollection;
import OrderBy = lang.collections.OrderBy;
import IPart = core.ui.IPart;
import IFilterPart = core.ui.IFilterPart;
import ICommand = core.commands.ICommand;
import Promise = lang.Promise;
import Application = core.Application;
import DomainObject = domain.DomainObject;
import PropertyMeta = domain.metadata.PropertyMeta;
import EntityMeta = domain.metadata.EntityMeta;
import PartCommandOptions = PartCommandMixin.PartCommandOptions;
import PartCommandResult = PartCommandMixin.PartCommandResult;
import EditorCommandOptions = PartCommandMixin.EditorCommandOptions;
import EditorCommandResult = PartCommandMixin.EditorCommandResult;
import ObjectListColumn = list.ObjectListColumn;
import IObjectListLoader = ObjectListLoader.IObjectListLoader;
import IObjectListPresenter = list.IObjectListPresenter;
import DataLoadEventArgs = ObjectList.DataLoadEventArgs;
import LoadOptions = ObjectList.LoadOptions;
import PagingOptions = ObjectList.PagingOptions;
import OrderByServer = ObjectList.OrderByServer;
import { ICommandFactory } from "lib/core.commands";

class ObjectList extends List<DomainObject> implements list.IDomainObjectList, ObjectListMixin  {
	static defaultOptions: ObjectList.Options = {
		/**
		 * @type {ObjectListColumn[]}
		 */
		columns: undefined,
		/**
		 * @type {Part|String}
		 */
		filter: undefined,
		/**
		 * Additional params for DataSource (will be combined with filter's restrictions)
		 * @type {Object|Function}
		 */
		loadParams: undefined,
		/**
		 * {String|Object} DataFacade's load policy. It can be rule name ("remoteFirst", "localFirst", "localIfOffline", "cached") or policy object (see CacheManager)
		 */
		loadPolicy: undefined, // "remoteFirst"?
		/**
		 * @type Boolean
		 */
		autoLoad: undefined,
		loader: undefined,
		Loader: ObjectListLoader,
		/**
		 * @type DataSource
		 */
		dataSource: undefined,
		/**
		 * @type Boolean
		 */
		cancellable: false,
		/**
		 * @type {Boolean|Number|Object}
		 */
		paging: undefined,
		/**
		 * @type UnitOfWork
		 */
		uow: undefined,
		/**
		 * @type Boolean
		 */
		editable: false,
		/**
		 * Allow multi select. For SlickGrid means adding a column with checkboxes.
		 * @type {Boolean}
		 */
		hasCheckboxes: true,
		/**
		 * @type Boolean
		 */
		readOnly: false,
		/**
		 * @type String
		 */
		traceSourceName: undefined,
		/**
		 * @type Boolean
		 */
		hideExportMenu: false,   // set 'true' to disable Export menu
		title: undefined,
		commands: undefined,
		commandsOptions: {
			/**
			 * Options for 'Create' command
			 * @type {Object|Function}
			 */
			Create: {
				/**
				 * Part name of editor (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of editor (see `ObjectEditor.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening editor in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 * */
				openInDialog: undefined
			},
			/**
			 * Options for 'Edit' command
			 * @type {Object|Function}
			 */
			Edit: {
				/**
				 * Part name of editor (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of editor or a callback to create it (see `ObjectEditor.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening editor in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 * */
				openInDialog: undefined,
				/**
				 * Show carousel in editor for navigating sibling objects in list
				 * @type {Boolean}
				 */
				navigateSiblings: true
			},
			/**
			 * Options for 'View' command
			 * @type {Object|Function}
			 */
			View: {
				/**
				 * Part name of viewer (by default "ObjectEditor:Type") or a callback to create it
				 * @type {String|Function}
				 */
				part: undefined,
				/**
				 * Part options of viewer or a callback to create it (see `ObjectViewer.defaultOptions`)
				 * @type {Object|Function}
				 */
				partOptions: {},
				/**
				 * true - opening viewer in Dialog, false - opening via NavigationService
				 * @type {Boolean}
				 * */
				openInDialog: undefined,
				/**
				 * Show carousel in viewer for navigating sibling objects in list
				 * @type {Boolean}
				 */
				navigateSiblings: true
			},
			/**
			 * See `ListColumnsSettings.defaultOptions`
			 * @type {Object}
			 */
			Customize: {}
		},
		onDataLoading: undefined,
		onDataLoaded: undefined,
		onDataPreparing: undefined,
		onDataMaterialize: undefined,
		stateMessages: {
			noLocalData: resources["objectList.state.no_local_data"],
		}
	};

	static defaultMenus: ObjectList.KnownMenus = {
		// Row menu
		ListRow: { items: [
			{ name: "Create", title: resources.create, hotKey: "ins" },
			{ name: "Delete", title: resources["delete"], hotKey: "del" },
			{ name: "Edit", title: resources.edit, isDefaultAction: true }
		]},
		ReadOnlyRow: { items: [
			{ name: "View", title: resources.view, isDefaultAction: true }
		]},
		// Selection menu (inherits from List)
		Selection: List.defaultMenus.Selection,
		// List Menu (inherits from List)
		List: List.defaultMenus.List,
		ListAux: List.defaultMenus.ListAux,
		EditableList: { items: [
			{
				name: "Reload",
				title: resources.reload,
				icon: "refresh",
				isDefaultAction: true,
				order: 10
			}, {
				name: "CancelReload",
				title: resources.cancel_reload,
				icon: "stop",
				order: 11
			}, {
				name: "Save",
				title: resources.save,
				html: "<span class='x-icon x-icon-save'></span><span class='hidden-xs'>" + resources.save + "</span>" +
				"<span class='x-list-menu-pendingObjects'></span>",
				icon: "save",
				order: 20
			}, {
				name: "Cancel",
				title: resources.cancel,
				icon: "undo",
				order: 30
			}
		]}
	};

	@lang.decorators.constant(ObjectList.defaultMenus)
	defaultMenus: ObjectList.KnownMenus;

	options: ObjectList.Options;
	presenter: IObjectListPresenter;
	entityType: string;
	uow: UnitOfWork;
	contextParts: ObservableCollection<IContextPart>;

	protected loader: IObjectListLoader;
	protected keepChangesOnReload: boolean;
	protected _entityType: domain.metadata.EntityMeta;
	protected _lastLoadParams: LoadQueryParams;
	protected _orderByServer: boolean;

	private _ownUow: boolean;
	protected _suppressOnObjectDetached: boolean;

	/**
	 * @constructs ObjectList
	 * @extends List
	 * @param {Application} app
	 * @param {Object} options
	 * @param {Array} options.columns Array of column descriptors
	 * @param {String} options.columns.name
	 * @param {String} options.columns.prop
	 * @param {String} options.columns.title
	 * @param {Function} [options.columns.formatter]
	 * @param {Object} options.stateMessages Overwrite state messages (key - name of state, value - message text)
	 */
	constructor(app: Application, options?: ObjectList.Options) {
		options = ObjectList.mixOptions(options, ObjectList.defaultOptions);
		super(app, options);
	}

	protected tweakOptions(options: ObjectList.Options): void {
		if (!options.validateItems) {
			options.validateItems = options.editable ? "explicit" : "never";
		}
		super.tweakOptions(options);
	}

	/**
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	saving: lang.ObservableProperty<boolean>;

	findDomainProp(column: ObjectListColumn): PropertyMeta {
		let entity: EntityMeta = this._entityType;
		if (!entity) { return; }

		return entity.props[column.prop || column.name];
	}

	protected _preinitialize(): void {
		let that = this;

		that.entityType = that.options.entityType || that.options.urlSuffix;

		// NOTE: traceSource is already created by List's constructor
		//that.traceSource = new core.diagnostics.TraceSource("ui.ObjectList", that.options.traceSourceName || that.name || that.entityType);
		that.traceSource.className = "ui.ObjectList";
		that.traceSource.name = that.options.traceSourceName || that.name || that.entityType;

		// NOTE: uow нужно создать до вызова базового метода, т.к. она используется при создании loader-а
		that.uow = that.options.uow || that.app.createUnitOfWork({ connected: true });
		that._ownUow = !that.options.uow;
		that.uow.bind("detach", that.onObjectDetached, that);
		that.keepChangesOnReload = lang.coalesce(that.options.keepChangesOnReload, !that._ownUow);

		super._preinitialize();

		that._initOrderBy();

		if (!that.entityType && that.loader) {
			that.entityType = that.loader.entityType;
		}
		that._entityType = that.app.model.meta.entities[that.entityType];
		//if (!that._entityType) { throw new Error("ObjectList.ctor:unknown entityType: " + that.entityType); }

		that.contextParts = new ObservableCollection<IContextPart>();
		that.violations.bind("change", that._onViolationsChanged, that);
	}

	protected _initOrderBy(): void {
		let that = this;
		let orderByServer: ObjectList.OrderByServer;
		let opt = that.options.orderByServer;

		if (opt === true) {
			orderByServer = { mode: "always" };
		} else if (opt === false) {
			orderByServer = { mode: "never" };
		} else if (!opt) {
			orderByServer = { mode: "auto" };
		} else if (lang.isString(opt) || lang.isArray(opt)) {
			orderByServer = { mode: "always", initial: opt };
		} else {
			orderByServer = <ObjectList.OrderByServer>opt;
		}
		if (orderByServer.initial && core.lang.isString(orderByServer.initial)) {
			orderByServer.initial = [<string>orderByServer.initial];
		}
		if (orderByServer.mode === "reloadOnly" && (!orderByServer.initial || !orderByServer.initial.length)) {
			// reloadOnly w/o initial makes no sense
			orderByServer.mode = "auto";
		}
		that.options.orderByServer = orderByServer;
		that._orderByServer = orderByServer && orderByServer.mode === "always";

		if (orderByServer && orderByServer.mode === "always") {
			// disable client orderBy for server sorting
			that.options.orderBy = undefined;
		}

		// NOTE: see ListCommonMixin.setupColumns as well
	}

	protected createLoader(): IObjectListLoader {
		let that = this,
			loader = lang.unlazy(that.options.loader, that);
		// NOTE: if loader equals to 'null' that means that the list should not have ability to load/reload (data will be set externally).
		if (loader !== undefined) {
			return loader;
		}

		let ds = that.options.dataSource || new DataSource(that.app, {
				entityType: that.entityType,
				preloads: that.options.preloads
			});
		return new that.options.Loader(that.app, {
			uow: that.uow,
			dataSource: ds,
			entityType: that.entityType,
			loadPolicy: that.options.loadPolicy,
			cancellable: that.options.cancellable,
			onMaterialize: that.options.onDataMaterialize
		});
	}

	protected createListMenuDefaults(): Menu.Options {
		let key = this.options.editable ? "EditableList" : "List";
		let menuOptions = Menu.defaultsFor(this.defaultMenus[key], key, this.entityType);
		if (this.options.hideExportMenu) {
			menuOptions = Menu.merge(menuOptions, { remove: ["Export"] });
		}
		return menuOptions;
	}
	protected createRowMenuDefaults(): Menu.Options {
		let key = this.options.readOnly ? "ReadOnlyRow" : "ListRow";
		return Menu.defaultsFor(this.defaultMenus[key], key, this.entityType);
	}
	protected createSelectionMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(this.defaultMenus.Selection, "Selection", this.entityType);
	}

	protected _initializeColumn(col: ObjectListColumn|string, initFromLoader?: boolean, initFromType?: boolean): ObjectListColumn {
		let that = this,
			column: ObjectListColumn = typeof col === "string" ? { name: col } : col;

		column.role = column.role || (column.command ? "command" : "data");

		if (column.role === "data") {
			if (initFromLoader && that.loader && that.loader.columns) {
				lang.some(that.loader.columns, col => {
					if (col.name === column.name) {
						lang.append(column, col);
						return true;
					}
				});
			}

			if (!column.getter) {
				// NOTE: если у колонки нет prop и есть getter, то предполагать prop на основе name небезопасно (WC-1399)
				column.prop = column.prop || column.name;
			}

			if (initFromType) {
				let prop: PropertyMeta = that.findDomainProp(column);
				if (prop) {
					lang.append(column, {
						name: prop.name,
						title: prop.descr,
						vt: prop.vt
					});
				}
			}
		}

		column.name = column.name || column.prop;

		return column;
	}

	private _generateColumnFromType(): ObjectListColumn[] {
		let that = this,
			columns: ObjectListColumn[] = [];
		if (!that._entityType) {
			// if we get to the generating columns from type then it MUST specified
			throw new Error("ObjectList: list's options has no entityType nor columns specified");
		}
		lang.forEach(that._entityType.props, prop => {
			if (prop.vt === "binary") { return; } // skip binaries
			let col = that._initializeColumn({
				name: prop.name,
				prop: prop.name,
				title: prop.descr,
				vt: prop.vt
			}, /*initFromLoader=*/false, /*initFromType=*/false);
			columns.push(col);
		});
		return columns;
	}

	protected _initializeColumns(): void {
		let that = this,
			columns: ObjectListColumn[];

		// NOTE: we'are not calling the base method here (in List)

		if (that.options.columns) {
			// columns were specified in the list's options
			columns = that.options.columns.map(
				col => that._initializeColumn(col, /*initFromLoader=*/true, /*initFromType=*/true));
		} else if (that.loader && that.loader.columns) {
			// columns were NOT specified in the list's options, try to take them from loader
			columns = that.loader.columns.map(
				col => that._initializeColumn(col, /*initFromLoader=*/false, /*initFromType=*/true));
		}
		if (!columns || !columns.length) {
			columns = that._generateColumnFromType();
		}

		that.setupColumns(columns);
	}

	/**
	 * @protected
	 */
	protected onColumnsChanged(): void {
		let that = this,
			menuItem = that.menuListAux.getItem("Customize");

		// update menu
		if (menuItem) {
			let hasHidden = that.columns.some(col => col.hidden);
			menuItem.cssClass = hasHidden ? "x-menu-item-badge-warning" : "";
			// notify that property 'menuList' was changed
			that.changed("menuList");
		}
	}

	/**
	 * @protected
	 * @override
	 * @returns {{Reload: BoundCommand, Edit: BoundCommand, Delete: BoundCommand, Create: BoundCommand, Save: BoundCommand, Cancel: BoundCommand}}
	 */
	protected createCommands(): core.commands.ICommandLazyMap {
		let that = this,
			commands: any = super.createCommands();

		commands.View = new core.commands.BoundCommand(that.doView, that.canView, that);

		if (!that.options.readOnly) {
			commands.Edit = new core.commands.BoundCommand(that.doEdit, that.canEdit, that);
			commands.Delete = new core.commands.BoundCommand(that.doDelete, that.canDelete, that);
			commands.DeleteSelection = new core.commands.BoundCommand(that.doDeleteSelection, that.canDeleteSelection, that);
			commands.Create = new core.commands.BoundCommand(that.doCreate, that.canCreate, that);
		}

		if (that.options.editable) {
			commands.Save = new core.commands.BoundCommand(that.doSave, that.canSave, that);
			commands.Cancel = new core.commands.BoundCommand(that.doCancel, that.canCancel, that);
		}

		lang.extend(commands, that.options.commands);

		return commands;
	}

	/*private _isObjectOperable(obj: DomainObject): boolean {
		return obj && !lang.get(obj, "isRemoved") && !lang.get(obj, "isInvalid");
	}*/

	protected doCreate(args): Promise<EditorCommandResult> {
		args = args || {};
		let that = this,
			type = args.type || that.entityType;

		return that.executePartCommand({
			part: "ObjectEditor:" + type,
			partOptions: that.options.editable ?
				{ type: type, uow: that.uow } :
				{ type: type }
		}, args, "Create").closed;
	}
	protected canCreate(): boolean {
		return this.navigationService && !!this.navigationService.navigate;
	}
	protected onBeforeCreate(createOptions: EditorCommandOptions): void {}
	protected onAfterCreate(result: EditorCommandResult, createOptions: EditorCommandOptions): void {
		let that = this,
			type = createOptions.partOptions && createOptions.partOptions.type || that.entityType;

		if (!result || !result.success || !result.object) {
			that.activate();
			return;
		}

		lang.when(result.success as Promise<void>).then(() => {
			that.onObjectCreated(type, result.object as DomainObject);
		});
	}

	/**
	 * Object creation handler.
	 * @param {String} type Type of object
	 * @param {DomainObject} obj Object (viewModel) was returned from editor
	 */
	protected onObjectCreated(type: string, obj: DomainObject): void {
		this.uow.attach(obj);
		/*
		it could make sense to reload object (was removed in WC-749):
		that._uow
			.get(type, obj.id) // if the object was create in other uow then we'll get a stub otherwise it'll the created object
		 	.load(that.objectLoadOptions)
			.load({ policy: {
		 		loadFirst: "local",
		 		allowRemote: true,
				allowLocal: true,
				shouldCache: false
			}})
			.done(function (obj) {
				that.addObject(obj);
			});
		*/
		this.addObject(obj);
	}

	protected doEdit(args: EditorCommandOptions): Promise<EditorCommandResult> {
		let that = this,
			obj = that.activeItem();

		return that.executePartCommand({
			part: "ObjectEditor:" + obj.meta.name,
			partOptions: that.options.editable ?
				{ viewModel: obj } :
				{ type: obj.meta.name, id: obj.id }
		}, args, "Edit").closed;
	}
	protected canEdit(): boolean {
		let that = this;
		return that.navigationService && that.navigationService.navigate &&
			that._isObjectOperable(that.activeItem());
	}
	protected onBeforeEdit(editOptions: EditorCommandOptions): void {
		let that = this,
			partOptions;
		if (editOptions.navigateSiblings) {
			partOptions = editOptions.partOptions = editOptions.partOptions || {};
			partOptions.navigateSiblings = that.items.all().map(item => {
				let siblingOptions = that.options.editable ?
					{ viewModel: item } :
					{ type: item.meta.name, id: item.id };
				return lang.append(siblingOptions, partOptions);
			});
		}
	}
	protected onAfterEdit(result: EditorCommandResult, editOptions: EditorCommandOptions): void {
		this.onSiblingsNavigated(result, editOptions);
		this.activate();
	}

	protected doView(args: EditorCommandOptions): Promise<EditorCommandResult> {
		let that = this,
			obj = that.activeItem();

		return that.executePartCommand({
			part: "ObjectViewer:" + obj.meta.name,
			partOptions: { viewModel: obj }
		}, args, "View").closed;
	}
	protected canView(): boolean {
		let that = this;
		return that.navigationService && that.navigationService.navigate &&
			that._isObjectOperable(that.activeItem());
	}
	protected onBeforeView(viewOptions: EditorCommandOptions): void {
		let that = this,
			partOptions;
		if (viewOptions.navigateSiblings) {
			partOptions = viewOptions.partOptions = viewOptions.partOptions || {};
			partOptions.navigateSiblings = that.items.all().map((item) => {
				return lang.append({ viewModel: item }, partOptions);
			});
		}
	}
	protected onAfterView(result: EditorCommandResult, viewOptions: EditorCommandOptions): void {
		this.onSiblingsNavigated(result, viewOptions);
		this.activate();
	}

	protected onSiblingsNavigated(result: EditorCommandResult, options: EditorCommandOptions) {
		let obj;
		if (options && options.navigateSiblings &&
			result && result.selectedId && (obj = this.items.find(item => item.id === result.selectedId))) {
			this.activeItem(obj);
		}
	}

	protected doDelete(): void {
		this._deleteObjects();
	}
	protected canDelete(): boolean {
		let that = this;
		if (!that.options.editable && that.saving()) { return false; }

		if (that._isObjectOperable(that.activeItem())) { return true; }
		let selection: ObservableCollection<DomainObject> = that.get("selection");
		return selection.count() > 0 && selection.some(that._isObjectOperable, that);
	}

	protected doDeleteSelection(): void {
		let objects = this.selection.all();
		this._deleteObjects(objects);
	}
	protected canDeleteSelection(): boolean {
		let that = this;
		if (!that.options.editable && that.saving()) { return false; }

		let selection: ObservableCollection<DomainObject> = that.get("selection");
		return selection.count() > 0 && !selection.some(obj => !that._isObjectOperable(obj));
	}

	protected executeDelete(objects?: DomainObject[]): void {
		let that = this;
		let activeObj = that.activeItem();
		objects.forEach((obj: DomainObject) => {
			that.uow.remove(obj);
			if (obj === activeObj) {
				that.activeItem(null);
			}
		});

		// NOTE: deleted objects will be removed from 'items' collection in onObjectDetached
		if (!that.options.editable) {
			that.doSave().fail(() => {
				that.uow.rollbackState();
			});
		}
	}

	protected doSave(): Promise<void> {
		return this._validateBeforeSave().then(() => {
			this._saveChanges();
		});
	}
	protected canSave(): boolean {
		return !this.saving() && this.get("uow").hasChanges();
	}

	protected _saveChanges(): Promise<any> {
		let that = this;
		that.saving(true);
		return that.uow.save({
			onError: that._onSaveError.bind(that),
			interop: {
				// NOTE: disabling suppressing publishing an event for an error (as we're passing onError)
				suppressEventOnError: false
			}
		}).always(() => {
			that.saving(false);
		});
	}

	protected _onSaveError(args: UnitOfWork.SaveErrorArgs): void {
		// TODO: надо объединить логику с редактором
		let that = this,
			error: InteropError = args.error;
		if (core.eth.isOptimisticConcurrency(error)) {
			let deleted = error.deletedObjects;
			if (deleted && deleted.length) {
				that.uow.purgeWithCascade(deleted);
				// prevent default handing in UoW._onSaveFailed as we've removed and detached all objects already
				error.deletedObjects = null;
				error.serverError.deletedObjects = null;	// todo: remove
			}
		}
		// complete save (i.e. rejecting with the error)
		args.complete();
	}

	protected doCancel(): void {
		let that = this;
		that.uow.rollbackState();
		// the list can have some violations in previous uow state, clear violations
		that.violations.clear();

	}
	protected canCancel(): boolean {
		return !this.saving() && this.get("uow").hasChanges();
	}

	protected canSelectAll(): boolean {
		let that = this;
		let paging = <PagingOptions>that.options.paging;
		if (that.options.persistentSelection &&
			paging && paging.mode && paging.mode === "pages")
		{
			return true;
		}
		return super.canSelectAll();
	}

	/*
	protected doSelectAll(): void {
		let that = this;
		NOTE: см. WC-1386 ObjectList: развитие операции "Выбрать всё" (frozen)
		let paging = <PagingOptions>that.options.paging;
		if (that.options.persistentSelection &&
			paging && paging.mode && paging.mode === "pages") {
			// Операция SelectAll для paging.mode=page + persistentSelection должна добавить в selection объекты со всех страниц.
			// Но добавить объекты в items нельзя (они не относятся к тек.странице), поэтому напрямую зовем loader.
			that.loader.load(that, that._lastLoadParams).then((result: ObjectListLoaderResult) => {
				if (result.hints && result.hints.hasNext) {
					// Even without paging params server can limit result due to its own limits.
					// This can be misleading for users as they asked for "all" but get only first N rows, add hint.
					that.hintMessage("Из-за ограничения сервера загружены и выбраны первые " + result.items.length + " записей");
				}
				let items = that._prepareData(result.items, result.hints);
				that.setSelection(items);
			});

		} else {
			that.setSelection(that.items.all());
		}
	}
	 */

	protected shouldValidateItem(item: DomainObject): boolean {
		return item.isNew() || item.isModified();
	}

	protected getCommand(cmdName: string): ICommand|ICommandFactory {
		return this.commands[cmdName];
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		let that = this;

		that.uow.unbind("detach", null, that);
		if (that._ownUow) {
			that.uow.dispose();
		}

		that._disposeParts();
		that.contextParts.dispose();

		super.dispose(options);
	}

	/**
	 * @override
	 * @param args
	 * @param {Object} args.params Loader parameters. If not specified, parameters from the filter are used.
	 * @returns {Promise.<DomainObject[]>}
	 */
	reload(args?: LoadOptions): lang.Promise<DomainObject[]> {
		let that = this;

		if (!that.loader) {
			throw new Error("ObjectList doesn't have a loader associated with it");
		}
		if (!that.keepChangesOnReload && that.uow.hasChanges()) {
			return ConfirmDialog.create({
				header: resources["objectList.reloadCaption"],
				text: resources["objectList.reloadWarning"]
			}).render().then((result) => {
				if (result === "yes") {
					that.doCancel();
					return super.reload(args);
				}
				return lang.rejected();
			});
		}

		return super.reload(args);
	}

	/**
	 * @override
	 */
	protected _load(params?: LoadQueryParams): lang.Promise<DataLoadEventArgs> {
		params = this._applyServerSort(params);
		return super._load(params);
	}

	protected _applyServerSort(params?: LoadQueryParams): LoadQueryParams {
		let that = this;
		let opt = <OrderByServer>that.options.orderByServer;
		// if server sorting and it's not reload for sort (i.e. no sorting in args)
		if ((that._orderByServer || opt.mode === "reloadOnly") && (!params || !params.$orderby)) {
			params = params || {};
			// as it's not reload for sorting, restore orderBy from previous load (to keep sorting consistent)
			if (that._lastLoadParams && that._lastLoadParams.$orderby) {
				params.$orderby = that._lastLoadParams.$orderby;
			} else  if (opt.initial) {
				// initial load - take orderBy from option
				// NOTE: do not use parseOrderByServer, as initial sort columns have nothing in common with client columns.
				params.$orderby = (<string[]>opt.initial).join(",");
			}
			// NOTE: orderByServer option will overwrite sorting in loadParams and in loader/DS
		}
		return params;
	}

	/**
	 * Set list's data
	 * @override
	 * @param {Array} items An array of items (domain objects)
	 * @param {Object} [hints]
	 * @param {String} [hints.message]
	 * @param {String} [hints.source]
	 * @returns {Array} An array of added items. May differ from input items if they are changed in onDataPreparing
	 */
	setData(items: DomainObject[], hints?: any): DomainObject[] {
		let that = this;

		if (that.keepChangesOnReload) {
			// there could be new unsaved objects in the list which will disappear on `setData`
			that.items.forEach((obj: DomainObject) => {
				if (obj.hasChanges() && items.indexOf(obj) < 0) {
					if (!items.length) {
						// server result contains no data,
						// as we're going to add unsaved object into the list
						// we should inform the user that reload returned no data
						hints = { message: resources["objectList.hint.no_data_except_unsaved"] };
					}
					items.push(obj);
				}
			});
		}

		let	itemsOld: DomainObject[];
		if (!that.options.keepAllObjects) {
			itemsOld = that.items.all();
		}

		items = super.setData(items, hints);

		// if new items aren't contained in current list items, remove them (detach) from uow,
		// but for persistentSelection we won't remove object in selection
		// NOTE: it's important to do this after reset
		if (!that.options.keepAllObjects) {
			that._suppressOnObjectDetached = true;
			try {
				for (let item of itemsOld) {
					if (items.indexOf(item) < 0 && (
						!that.options.persistentSelection || that.selection.indexOf(item) < 0)) {
						that.uow.detach(item);
					}
				}
			} finally {
				that._suppressOnObjectDetached = false;
			}
		}

		if (!items.length && hints && hints.source === "client") {
			that.stateMessage(that.options.stateMessages.noLocalData);
		}

		return items;
	}

	orderBy(columns: string|string[]): void {
		let that = this;
		if (that._orderByServer) {
			// for server sorting "orderBy" means reloading with the same params as previous results were loaded
			// plus the new order-by condition (from clicked grid's column(s))
			let args = {
				params: that._lastLoadParams
			};

			let parsed: OrderBy[] = lang.collections.parseOrderBy(columns, this.orderedBy());
			let columnsNorm = parsed.map((item: OrderBy) => {
				// item.prop это элемент из columns, найдем описание колонки для него
				let col: ObjectListColumn = lang.find(this.columns, (c: ObjectListColumn) => c.name === item.prop);
				// NOTE: если колонки нет, или у колонки нет ни orderByProp, ни prop, то сортировать нечего
				//if (!col) { return item.prop; }
				return (col && (col.orderByProp || col.prop))
					? { prop: (col.orderByProp || col.prop), desc: item.desc  } : null;
			}).filter((item) => !!item);

			// if no appropriate sorting expression was formed, there's no need for reload
			if (columnsNorm.length > 0) {
				that.setOrderedBy(columnsNorm);
				args.params.$orderby = columnsNorm.map((item) => item.prop + (item.desc ? " desc": "") ).join(",");
				// NOTE: doReload clears selection as well
				that.doReload(args);
			}
		} else {
			super.orderBy(columns);
		}
	}

	isColumnSortable(column: string|ObjectListColumn): boolean {
		if (this._orderByServer) {
			if (lang.isString(column)) {
				column = lang.find(this.columns, (c: ObjectListColumn) => c.name === column);
			}
			return !!column && !!(column.orderByProp || column.prop);
		}
		return true;
	}

	/**
	 * @protected
	 * @override
	 * @param {DataLoadEventArgs} args
	 */
	protected onDataLoaded(args: DataLoadEventArgs): void {
		let that = this;

		// keep load params but w/o paging
		// (if we need to reuse params (for reload/sorting/export) then we'll need them w/o paging args)
		that._lastLoadParams = lang.cloneEx(args.params, {except: ["$top", "$skip", "$fetchTotal"]});
		// TODO: init orderedBy

		let opt = <OrderByServer>that.options.orderByServer;
		// if paging w/mode="throttle" enabled, server returned paged data and server-sorting isn't disabled
		if (args.hints && args.hints.paging &&
			that.options.paging && (<PagingOptions>that.options.paging).mode === "throttle" &&
			opt.mode === "auto") {
			// NOTE: клиентская сортировка в режиме throttle выглядит очень плохо,
			// поэтому отключаем ее пока не загрузим все данные, см. WC-1395
			if (args.hints.hasNext) {

				if (!that._orderByServer) {
					// changing client to server sorting
					that._orderByServer = true;
					that.items.orderBy([]);
					// TODO: extract orderedBy from that._lastLoadParams or from args.hints
					that.setOrderedBy([]);
				}
			} else {
				// last portion of paged data (or full page) was loaded, now we can use client sorting again
				if (that._orderByServer) {
					// changing server to client sorting
					that._orderByServer = undefined;
					// NOTE: some columns could change their sortable attribute
					that.changed("columns");
				}
			}
		}

		super.onDataLoaded(args);
	}

	private onObjectDetached(sender, obj: DomainObject): void {
		if (obj && !this._suppressOnObjectDetached) {
			this.items.remove(obj);
		}
	}

	/**
	 * Add an object to list
	 * @protected
	 * @param obj
	 */
	protected addObject(obj: DomainObject): void {
		let that = this,
			items = that._prepareData([ obj ]);
		if (!items || !items.length) { return; }

		that.items.add(items);
		that.activeItem(items[0]);
		that.state(that.states.loaded);
		that.stateMessage("");
		window.setTimeout(() => {
			that.activate();
		});
	}

/*
	protected getResourceKey(key: string): string {
		return "objectList." + (this.options.editable ? "editable." : "") + key;
	}
*/
	protected getMessage(resources: lang.Map<string>, op: string, mod: string): string {
		if (this.options.editable) {
			let res = resources[`objectList_editable.${op}.${mod}`];
			if (res) { return res; }
		}
		return resources[`objectList.${op}.${mod}`];
	}

/*
	onQueryUnload (options) {
		let that = this,
			args = { list: that, preventingReason: undefined},
			changes;

		that.trigger(that.events.QUERY_UNLOAD, that, args);
		if (args.preventingReason) {
			return args.preventingReason;
		}

		if (!that.saving() && that.viewModel && that.viewModel.uow) {
			/!*if (!that.viewModel.uow.hasChangesSince(that._uowStateName)) {
			 return false;
			 }*!/
			changes = that.viewModel.uow.getChanges();
			if (that._hasMeaningfulChanges(changes)) {
				return that.onQueryUnloadWithChanges(options);
			}
		}
	}
*/
}

interface ObjectList extends ContextPartComponentMixin, ObjectListMixin { }

ObjectList.mixin({
	/** @type {Object} */
	defaultOptions: ObjectList.defaultOptions
});

ObjectList.mixin(ContextPartComponentMixin);
List.mixin(ObjectListMixin);

namespace ObjectList {
	export interface Options extends List.Options, ObjectListMixin.Options {
		entityType?: string;
		urlSuffix?: string;
		/**
		 * DataFacade's load policy. It can be rule name ("remoteFirst", "localFirst", "localIfOffline", "cached") or policy object (see CacheManager)
		 */
		loadPolicy?: string|any;
		loader?: IObjectListLoader|((list: ObjectList) => IObjectListLoader);
		Loader?: lang.Constructor<IObjectListLoader>;
		preloads?: string|string[];
		orderByServer?: boolean|string|string[]|ObjectList.OrderByServer;
		uow?: UnitOfWork;
		editable?: boolean;
		keepChangesOnReload?: boolean;
		readOnly?: boolean;
		hideExportMenu?: boolean;
		/**
		 * Prevent objects from detaching on reloads (if they are not in new result)
		 */
		keepAllObjects?: boolean;
		stateMessages?: StateMessages;
	}

	export interface OrderByServer {
		mode: "auto" | "always" | "never" | "reloadOnly";
		initial?: string|string[];
	}

	export interface KnownMenus extends lang.Map<Menu.Options> {
		ListRow?: Menu.Options;
		ReadOnlyRow?: Menu.Options;
		Selection?: Menu.Options;
		List?: Menu.Options;
		EditableList?: Menu.Options;
	}

	export interface StateMessages extends List.StateMessages {
		noLocalData?: string;
	}

	export import PagingOptions = list.PagingOptions;

	export import LoadOptions = List.LoadOptions;

	export interface DataLoadEventArgs extends List.DataLoadEventArgs<DomainObject> { }
}

core.ui.ObjectList = ObjectList;

export = ObjectList;

/**
 * @typedef {Object} DataLoadEventArgs
 * @description Arguments of `dataLoading` and `dataLoaded` events
 * @property {Object} [params] Parameters for the loader. Can be changed in `dataLoading`.
 * @property {Array} [items] An array of loaded items (domain objects). Can be changed in `dataLoaded`.
 * @property {Object} [hints] Hints returned by the loader. Can be changed in `dataLoaded`.
 */
