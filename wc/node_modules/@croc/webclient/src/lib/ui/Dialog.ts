import $ = require("jquery");
import core = require("core");
import View = require("lib/ui/handlebars/View");
import Menu = require("lib/ui/menu/Menu");
import utils = require("lib/utils");
import WaitingModal = require("lib/ui/WaitingModal");
import defaultTemplate = require("xhtmpl!lib/ui/templates/Dialog.hbs");
import resources = require("i18n!lib/nls/resources");
import "lib/ui/menu/MenuPresenter"; // NOTE: MenuPresenter is used inside Dialog.hbs
import "xcss!lib/ui/styles/dialog.css";
import "bootstrap";
import "jquery-ui/core"; // for $.fn.zIndex() method and :tabbable selector

import lang = core.lang;
import IPart = core.ui.IPart;
import IDialog = core.ui.IDialog;
import ICommand = core.commands.ICommand;
import INavigationService = core.INavigationService;
import Options = Dialog.Options;
import { IUserSettings} from "lib/.core";

class Dialog extends View implements IDialog {
	/**
	 * @enum {String}
	 * Names of events raised by Dialog
	 */
	static events = {
		LOAD: "load",
		CLOSING: "closing",
		CLOSED: "closed",
		DISPOSED: "disposed"
	};

	/**
	 * Default options for Dialog.
	 */
	static defaultOptions: Dialog.Options = {
		flexHeight: true,
		template: defaultTemplate,
		unbound: true,
		autoDispose: true
	};

	/**
	 * Default menu metadata
	 */
	static defaultMenu: Menu.Options = {
		items: [
			{ name: "ok", title: resources.ok, isDefaultAction: true },
			{ name: "cancel", title: resources.cancel }
		]
	};

	// prototype members: begin
	/**
	 * @enum {String}
	 * Names of events raised by Dialog (for backward compatibility)
	 */
	@lang.decorators.constant(Dialog.events)
	events: typeof Dialog.events;
	/**
	 * @observable-property {Part}
	 */
	@lang.decorators.observableAccessor()
	body: lang.ObservableProperty<IPart>;
	// prototype members: end

	options: Options;
	header: string;
	commands: lang.Map<ICommand>;
	menu: Menu;
	result: any;
	$dialog: JQuery;

	private _closeSignal: lang.Deferred<any>;
	private _hideSignal: lang.Deferred<any>;
	private _lastFocus: HTMLElement;
	private _keepAlive: boolean;
	private _suspending: boolean;
	private _closing: boolean;
	private _dialogParent: JQuery|HTMLElement;
	private _unloadOptions: core.UnloadOptions;

	/**
	 * @constructs Dialog
	 * @extends View
	 * @param {Object} options
	 * @param {String} [options.header] Dialog header text
	 * @param {Part} [options.body] A part for dialog content
	 * @param {String} [options.html] html markup for dialog content (if `body` is empty)
	 * @param {String} [options.text] plain text for dialog content (if `body` and `html` are empty)
	 * @param {String} [options.rootCssClass] CSS class for root element (with class `.modal`)
	 * @param {String} [options.dialogCssClass] CSS class for dialog element (with class `.modal-dialog`)
	 * @param {boolean} [options.flexHeight=true] Auto-change the height of dialog
	 * @param {Object} [options.commands] Object with menu commands
	 * @param {Object} [options.menu] Menu metadata (by default Dialog creates menu with 'Ok' and 'Cancel' items)
	 * @param {Function} [options.template] Template
	 * @param {Boolean} [options.unbound]
	 * @param {boolean} [options.autoDispose=true] Whether dialog should dispose part in `body`
	 * @param {Function} [options.onLoad] Callback executed on 'load' event (sender: Dialog) => void;
	 * @param {Function} [options.onClosing] Callback executed on 'closing' event (sender: Dialog, args: { result: any; cancel: boolean }) => void;
	 * @param {Function} [options.onClosed] Callback executed on 'closed' event (sender: Dialog, args: { result: any; }) => void;
	 */
	constructor(options: Options) {
		options = Dialog.mixOptions(options, Dialog.defaultOptions);
		super(options);

		this.header = this.options.header;

		this._initBody();

		this.setNavigationService(new DialogNavigationService(this, Dialog));

		this.commands = lang.extend(this.commands || {}, this.options.commands);

		this.menu = this.createMenu();
		if (this.menu) {
			// NOTE: we do not use bindToPart here as we'll assign close command for all items below
			this.menu.bindToCommands(this.commands, this);
			this.menu.acceptVisitor((item) => {
				if (!item.command) {
					// NOTE: нельзя шарить один экземпляр команды между разными пунктами меню,
					// так как их доступность (canExecute) может быть различна
					item.command = this.createCloseCommand();
				}

				// добавляем сам диалог в параметры команд меню
				item.params = lang.extend(item.params || {}, {dialog: this});
			});
		}

		if (options) {
			utils.subscribeOnEvents(this, options, this.events);
		}
	}

	protected _initBody(): void {
		let that = this,
			bodyPart = that.options.body;

		if (!bodyPart && that.options.html) {
			bodyPart = {
				render: (domElement) => {
					$(domElement).html(that.options.html);
				}
			};
		}
		if (!bodyPart && that.options.text) {
			bodyPart = {
				render: (domElement) => {
					$(domElement)
						.text(that.options.text)
						.addClass("modal-body-text");
				}
			};
		}
		if (bodyPart) {
			that.body(bodyPart);

			// initialize part' userSettings
			let app = core.Application.current,
				userSettingsStore = app && app.userSettingsStore,
				userSettings = bodyPart.userSettings;
			if (userSettingsStore && userSettings && userSettings.bind) {
				let name = userSettings.name || bodyPart.name;
				// NOTE: we're subscribing on part's UserSettings if and only if settings have name (either part's name or its own name)
				if (name) {
					userSettings.name = name;
					userSettings.bind("change", that.onPartUserSettingsChanged, that);

					// the part has named userSettings, let's initialize them
					let args: core.IUserSettings.EventArgs = { part: name, scope: userSettings.scope, region: "dialog" };
					args.bundle = userSettingsStore.load(args);
					userSettings.initialize(args.bundle);
				}
			}

			// TODO: that.registerChild(bodyPart, {disposeOnUnload: false, keepOnUnload: true});
			//that.registerChild(bodyPart);
		}
	}

	protected onPartUserSettingsChanged(userSettings: IUserSettings, bundle): void {
		let args: core.IUserSettings.EventArgs = {
			part: userSettings.name,
			bundle: bundle,
			region: "dialog",
			scope: userSettings.scope
		} ;
		core.Application.current.userSettingsStore.save(args);
	}

	/**
	 * Создает команду закрытия диалога.
	 * Такая команда используется по умолчанию, если для пункта меню не задана другая команда.
	 */
	protected createCloseCommand(): ICommand {
		return core.createCommand({
			execute: function (args) {
				args.dialog.close(args.name);
			}
		});
	}

	protected createMenu(): Menu {
		let that = this,
			menu = that.options.menu;

		if (menu === false || menu === null)
			return null;

		if (menu === true)
			menu = undefined; // will be ignored while merging
		return new Menu(that.createMenuDefaults(), menu as Menu.Options);
	}

	protected createMenuDefaults(): Menu.Options {
		return Menu.defaultsFor(Dialog.defaultMenu, "Dialog");
	}

	updateMenu (menu: Menu.Options): void {
		let that = this;
		if (that.menu) {
			that.menu.dispose();
		}
		that.options.menu = menu;
		that.menu = that.createMenu();
		if (that.menu) {
			// NOTE: we do not use bindToPart here as we'll assign close command for all items below
			that.menu.bindToCommands(that.commands, that);
		}
	}

	protected doRender(domElement: JQuery|HTMLElement): void {
		let that = this;

		that._lastFocus = <HTMLElement>document.activeElement;

		// simulate click on document to close other opened popups
		//core.$document.click();

		// NOTE: Bootstrap modal dialog:
		//	.modal-open      - body class for killing the scroll
		// 	.modal           - container to scroll within
		// 	.modal-dialog    - positioning shell for the actual modal
		// 	.modal-content   - actual modal w/ bg and corners and shit

		that.$dialog = $("<div class='modal fade' role='dialog' tabindex='-1' aria-hidden='true'>" +
				"<div class='modal-dialog'><div class='modal-content x-dialog' /></div></div>")
			.attr("aria-labelledby", that.header);
			//.stopBubbling(); // prevent bubbling of mouse and keyboard events outside of the element

		let $dialogShell = that.$dialog.find(".modal-dialog");
		let $dialogContent = $dialogShell.find(".modal-content");

		if (that.options.rootCssClass) {
			that.$dialog.addClass(that.options.rootCssClass);
		}
		if (that.options.dialogCssClass) {
			$dialogShell.addClass(that.options.dialogCssClass);
		}
		if (that.options.wide) {
			$dialogShell.addClass("modal-lg");
		}

		if (that.options.flexHeight) {
			$dialogContent.addClass("x-dialog--flex-height");
		}
		// NOTE: it's important to append _dialog to DOM before rendering.
		// Otherwise child parts can't determine they are inside dialog or not.
		that.$dialog.appendTo(domElement || document.body);

		super.doRender($dialogContent);

		if (!core.platform.isMobileDevice) {
			that.$dialog.focus();
		}

		that.$dialog.on("hide.bs.modal", e => that._onModalHide(e));

		// при закрытии возвращаем результат
		that.$dialog.on("hidden.bs.modal", e => that._onModalHidden(e));

		// после показа
		that.$dialog.on("shown.bs.modal", e => that._onModalShown(e));

		that.$dialog.modal({
			backdrop: "static",
			keyboard: false
		});
	}

	/**
	 * @deprecated WARNING! In next versions render won't return Promise. Use open method instead!
	 * @param domElement
	 * @returns {Promise}
	 */
	render(domElement?: JQuery|HTMLElement): lang.Promise<any> {
		let that = this;

		that._throwIfDisposed();
		that.beforeRender(domElement);

		if (that._closeSignal) {
			return that._closeSignal;
		}
		that._closeSignal = lang.deferred();
		that.doRender(domElement);

		// NOTE: afterRender will be called in 'shown.bs.modal' event handler
		// TODO: здесь надо вернуть Promise от события shown
		return that._closeSignal.promise();
	}

	/**
	 * Shows the dialog and wait when it will be closed
	 * @param {JQuery|HTMLElement} [domElement]
	 * @returns {lang.Promise<any>} Promise will be resolved when the dialog is closed (actually hidden)
	 */
	open(domElement?: JQuery|HTMLElement): lang.Promise<any> {
		this.render(domElement);
		return this._closeSignal.promise();
	}

	/**
	 * Hides and destroys the dialog
	 * @param [result] An result to return as resolved value of open's promise
	 * @returns {JQueryPromise<any>} Promise will be resolved when the dialog is hidden
	 */
	close(result?: any): lang.Promise<any> {
		this.result = result;
		this._unloadOptions = {reason: "close", activityContext: {}};

		// NOTE: In old browsers Modal is closed synchronously (because of animation is not supported).
		// Therefore handler _onModalHidden executes synchronously too. And this handler resets _closeSignal to
		// undefined. So we must cache _closeSignal first.
		let signal = this._closeSignal.promise();
		this._hideModal();
		return signal;
	}

	/**
	 * Hides and destroys the dialog, but doesn't resolve Promise returned from `open`. Then opens another dialog,
	 * which uses Promise from current dialog.
	 * @param {Dialog} dialog
	 * @returns {JQueryPromise<void>}
	 */
	closeAndReplace(dialog: Dialog): lang.Promise<void> {
		let that = this,
			closeTask = that._closeSignal;
		// substitute original _closeSignal
		that._closeSignal = lang.deferred();

		return that.close({}) // pass any not undefined result, otherwise returned promise will be rejected
			.always(() => {
				// Теперь текущий диалог закрыт, но promise, возвращенный его open не разрешен, т.о. вызвавший его код
				// все еще ждет. Мы же откроем новый диалог и передадим в него этот deferred (closeTask), чтобы
				// разрешить при его закрытии. Код, открывший исходный диалог, ничего не заметит.
				dialog.open();
				dialog._closeSignal = closeTask;
				// TODO: wait for ready/shown event
			});
	}

	/**
	 * Hides the dialog, but doesn't destroy it. So the dialog can be reopened later.
	 * @param result
	 * @returns {lang.Promise<any>} Promise will be resolved when the dialog is hidden
	 */
	hide(result?: any): lang.Promise<any> {
		this._keepAlive = true;
		return this.close(result);
	}

	suspend(): lang.Promise<void> {
		let that = this;
		that._keepAlive = true;
		that._suspending = true;
		that._hideSignal = lang.deferred();
		that._hideModal();
		return that._hideSignal.promise();
	}

	resume(): void {
		let that = this;
		let closeSignal = that._closeSignal;
		that._closeSignal = undefined;
		that.open(that._dialogParent);
		that._closeSignal = closeSignal;
		// TODO: здесь надо вернуть Promise от события shown (диалог показан)
	}

	dispose(options?: core.ui.Part.CloseOptions): void {
		this._hideModal();
		super.dispose(options);
		this.trigger(this.events.DISPOSED, this);
	}

	protected _hideModal(): void {
		let $dialog = this.$dialog;
		if ($dialog) {
			$dialog.modal("hide");
		}
	}

	protected _closeExternally(): void {
		let that = this;
		if (that._closing) { return; }

		that._closing = true;
		let body = that.body();
		if (body && body.queryUnload) {
			that._unloadOptions = {reason: "close", activityContext: {}};
			let reasonToStayOrDefer = body.queryUnload(that._unloadOptions);
			core.lang.async.then(reasonToStayOrDefer, reasonToStay => {
				if (!reasonToStay) {
					that._hideModal();
				}
				that._closing = undefined;
			}, () => {
				that._closing = undefined;
			});
		} else {
			that._hideModal();
			that._closing = undefined;
		}
	}

	protected _onModalShown(e: JQueryEventObject): void {
		let that = this,
			$dialog = that.$dialog;

		that.afterRender();

		that.trigger(that.events.LOAD, that);

		// устанавливаем фокус на первый элемент ввода
		if (!core.platform.isMobileDevice) {
			let $focusable = that.$dialog.find(":input:tabbable:first");
			if ($focusable.length) {
				$focusable.focus();
			}
		}

		// необработанные нажатия клавиш перенаправляем в меню
		$dialog.keyup(e => {
			if (that.menu && that.menu.executeHotkey(e)) {
				return false;
			}
		});

		// NOTE: Диалог может потерять фокус (например, из-за явного вызова blur) и тогда клавиатурные события внутри
		// диалога перестанут обрабатываться. Поэтому для обработки ESC подписываемся на document, а не на $dialog,
		// и фильтруем по активному диалогу.
		that.jqOn(core.html.$document, "keydown", e => {
			if (e.which !== core.html.keyCode.ESCAPE || $dialog[0] !== ModalManager.instance.activeModal) { return; }

			if ($dialog.find(".modal-body").has(e.target).length) {
				// фокус был внутри .modal-body - снимаем фокус, следующее нажатие ESC закроет диалог
				// NOTE: Важно оставить фокус внутри диалога, иначе клавиатурные события внутри диалога
				// перестанут обрабатываться. Поэтому фокусируем сам элемент диалога.
				$dialog.focus();
			} else {
				// фокус был за пределами .modal-body - закрываем диалог
				that._closeExternally();
			}
		});
	}

	protected _onModalHide(e: JQueryEventObject): boolean {
		let that = this,
			args = { result: that.result, cancel: false};
		that.trigger(that.events.CLOSING, that, args);
		if (args.cancel) {
			e.preventDefault();
			return false;
		}
		that.result = args.result;
		that.trigger(that.events.CLOSED, that, args);

		that.jqOff(core.html.$document, "keydown");
		return true;
	}

	protected _onModalHidden(e: JQueryEventObject): void {
		let that = this;

		super.unload();

		if (that.options.autoDispose && !that._keepAlive) {
			let bodyPart = that.body();
			if (bodyPart && bodyPart.dispose) {
				bodyPart.dispose(this._unloadOptions);
			}
			super.dispose();
		}
		that._keepAlive = undefined;

		if (that._suspending) {
			// suspending - we're going forward, backup dialog's parent to use to in 'resume' later
			that._dialogParent = that.$dialog.parent();
		}
		that.$dialog.remove();
		that.$dialog = undefined;

		let hideSignal = that._hideSignal;
		if (hideSignal) {
			hideSignal.resolve();
			that._hideSignal = undefined;
		}

		if (!that._suspending) {
			// close/hide (close w/o dispose) - we're going backward
			if (that._lastFocus && !core.platform.isMobileDevice) {
				//that._lastFocus.focus(); - doesn't work in IE8 if the element '_lastFocus' became invisible
				$(that._lastFocus).focus();
			}

			let signal = that._closeSignal;
			if (signal) {
				that._closeSignal = undefined;
				if (that.result !== undefined) {
					signal.resolve(that.result);
				} else {
					signal.reject();
				}
			}
		}
		that._suspending = undefined;

		if (core.html.$body.find(".modal:visible").length) {
			// there are other opened modals - restore class .modal-open on body
			core.html.$body.addClass("modal-open");
		}

		// NOTE: BS modal hides window scroll-bars on opening and restore them on closing,
		// so viewport size may be changed. We must notify about these changes.
		core.html.notifyDOMChanged();
	}

	static openPart(opt: {part: string|IPart, partOption?: any}): lang.Promise<any> {
		let dialog = getDialogInstance(opt);
		return dialog.open();
	}
}

namespace Dialog {
	export interface Options extends View.Options {
		/**
		 * Dialog header text
		 */
		header?: string;
		/**
		 * A part for dialog content
		 */
		body?: IPart;
		/**
		 * html markup for dialog content (if `body` is empty)
		 */
		html?: string;
		/**
		 * plain text for dialog content (if `body` and `html` are empty)
		 */
		text?: string;
		/**
		 * CSS class for root element (with class `.modal`)
		 */
		rootCssClass?: string;
		/**
		 * CSS class for dialog element (with class `.modal-dialog`)
		 */
		dialogCssClass?: string;
		/**
		 * Use wide dialog width instead of normal width (add `model-lg` class)
		 */
		wide?: boolean;
		/**
		 * Auto-change the height of dialog
		 */
		flexHeight?: boolean;
		/**
		 * Object with menu commands
		 */
		commands?: lang.Map<ICommand>;
		/**
		 * Menu metadata (by default Dialog creates menu with 'Ok' and 'Cancel' items).
		 * `false` or `null` for disabling menu. `true` for default menu.
		 */
		menu?: Menu.Options|boolean;
		/**
		 * Disables menu showing.
		 */
		hideMenu?: boolean;
		/**
		 * Whether dialog should dispose part in `body`
		 */
		autoDispose?: boolean;
		/**
		 * Show nested dialog over parent dialog
		 */
		overlay?: boolean;
		/**
		 * Do not show "close" button (cross in the upper right corner)
		 */
		noCloseButton?: boolean;

		onLoad?: (sender: Dialog) => void;
		onClosing?: (sender: Dialog, args: { result: any; cancel: boolean }) => void;
		onClosed?: (sender: Dialog, args: { result: any; }) => void;
	}
}

Dialog.mixin({
	defaultOptions: Dialog.defaultOptions,
	defaultMenu: Dialog.defaultMenu
});

interface ITransition {
	sourceDialog: Dialog;
	//targetPart: ui.IPart;
	callback: (v: any) => void;
}

function getDialogInstance(options: INavigationService.NavigateOptions, dialogClass?: lang.Constructor<Dialog>): Dialog {
	let part = getPartInstance(options);

	if (part.applyHostContext) {
		let partNavOpts = part.applyHostContext({ host: "dialog" });
		if (partNavOpts) {
			options = lang.appendEx(options, partNavOpts, { deep: true });
		}
	}

	let dialogOptions: Dialog.Options = lang.extend({ body: part }, options.dialogOptions);
	let cls = dialogClass || Dialog;

	return new cls(dialogOptions);
}

function getPartInstance(options: INavigationService.NavigateOptionsBase): IPart {
	let partOption = options.part,
		part;
	if (typeof partOption === "string") {
		part = core.createPart(partOption, options.partOptions);
	} else {
		part = partOption;
	}
	return part;
}

class DialogNavigationService implements INavigationService {
	protected _transitions: Array<ITransition> = [];

	constructor(protected dialog: Dialog, protected dialogClass: lang.Constructor<Dialog>) {
		dialog.bind(Dialog.events.DISPOSED, () => {
			this.dialog = null;
		});
	}

	navigate (options: INavigationService.NavigateOptions): lang.Promise<IPart> {
		if (!this.dialog) {
			return this._openPart(options);
		}
		if (options.part !== this.dialog.body()) {
			return this._openNested(options);
		}

		this.dialog.open();
		// TODO: wait for 'shown.bs.modal' event
		return lang.resolved(this.dialog.body());
	}

	openModal (options: INavigationService.OpenModalOptions): lang.Promise<IPart> {
		return this.navigate(options);
	}

	/**
	 * Suspend active part and activate the specified part in context of the activity.
	 * @param {Object} options
	 * @returns {Promise}
	 */
	protected _openNested (options: INavigationService.NavigateOptions): lang.Promise<IPart> {
		if (!options || !options.part) {
			throw new Error("NavigationService.navigate: options.part wasn't specified");
		}

		let that = this;
		that._transitions.push({
			sourceDialog: that.dialog,
			callback: options.onReturn || lang.noop
		});

		let dialog = that._getDialogInstance(options);
		if (dialog.options.overlay) {
			return dialog.open()
				.always((result: any) => {
					// NOTE: open's promise will be resolved when that dialog is closed (i.e. user went back)
					let tran = that._transitions.pop();
					tran.callback(result || {});
				});
		}
		else {
			return that.dialog.suspend()
				.then(() => dialog.open())
				.always((result: any) => {
					// NOTE: open's promise will be resolved when that dialog is closed (i.e. user went back)
					let tran = that._transitions.pop();
					tran.callback(result || {});
					tran.sourceDialog.resume();
				});
		}
	}

	protected _openPart(options: INavigationService.NavigateOptions): lang.Promise<any> {
		let dialog = this._getDialogInstance(options);
		return dialog.open();
	}

	close (result?: any): lang.Promise<void> {
		return this.dialog.close(result);
	}

	leave (result?: any): lang.Promise<void> {
		return this.dialog.hide(result);
	}

	replace (options: INavigationService.NavigateOptions): lang.Promise<IPart> {
		let that = this,
			dialog = that._getDialogInstance(options);
		return that.dialog.closeAndReplace(dialog).then(() => {
			// Теперь this.dialog закрыт, но promise, возвращенный его open не разрешен. Т.о. вызвавший его код все
			// еще ждет (см. _openNested). Этот promise будет разрешен при закрытии нового диалога.
			that.dialog = dialog;
			return dialog.body();
		});

/*	WAS: старая реализация по замене body: проблемы с меню и опциями
		let dialog = this.dialog,
			body = dialog.body();
		if (body) {
			dialog.unregisterChild(body);
		}
		body = this._getPartInstance(options);
		dialog.body(body);
		dialog.registerChild(body, !(options.activateOptions && options.activateOptions.keepAlive));
		body.render(dialog.$dialog.find(".modal-body"));

		return lang.resolved(body);
*/
	}

	protected _getDialogInstance(options: INavigationService.NavigateOptions): Dialog {
		return getDialogInstance(options, this.dialogClass);
	}
}

// modal element can host other overlays
core.html.overlay.targets.push(".modal");

// a service component to focus the modal with the highest z-index
class ModalManager {
	static instance: ModalManager = new ModalManager();

	private items: ModalManager.Item[] = [];

	activeModal: Element;

	add(element: Element): void {
		let $element = $(element);
		this.items.push({
			$element: $element,
			zIndex: $element.zIndex()
		});
	}
	remove(element: Element): void {
		let idx = lang.findIndex(this.items, item => item.$element[0] === element);
		if (idx >= 0) {
			this.items.splice(idx, 1);
		}
	}
	enforceFocus(): void {
		let that = this,
			item: ModalManager.Item,
			modal; // Bootstrap Modal
		if (!that.items.length) {
			that.activeModal = undefined;
			return;
		}
		// find item with the highest zIndex
		that.items = lang.sortBy(that.items, "zIndex");
		item = lang.last(that.items);
		// get Bootstrap modal
		modal = item.$element.data("bs.modal");
		if (modal) {
			modal.enforceFocus();
		}
		that.activeModal = item.$element[0];
	}
}
namespace ModalManager {
	export interface Item {
		$element: JQuery;
		zIndex: number;
	}
}

// track events from BS modals
let modalManager = ModalManager.instance;
core.html.$document
	.on("show.bs.modal", e => {
		modalManager.add(e.target);
	})
	.on("shown.bs.modal", () => {
		modalManager.enforceFocus();
	})
	.on("hide.bs.modal", e => {
		modalManager.remove(e.target);
	})
	.on("hidden.bs.modal", () => {
		modalManager.enforceFocus();
	});

core.ui.Dialog = Dialog;
export = Dialog;
