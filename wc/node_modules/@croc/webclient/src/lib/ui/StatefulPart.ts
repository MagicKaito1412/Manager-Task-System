import lang = require("lib/core.lang");
import Part = require("lib/ui/Part");
import ui = require("lib/ui/.ui");

class StatefulPart extends Part implements ui.IStatefulPart {
	/**
	 * @constructs StatefulPart
	 * @extends Part
	 */
	constructor(options?: Part.Options) {
		super(options);
	}

	/**
	 * Change part's state.
	 * If part supports states this method SHOULD be called in response of user interaction (e.g in commands).
	 * Also it's called by hosting Region/Area to apply a new state (as result of user navigation request) if the part is already activated.
	 * Implementations SHOULD NOT replace this method, instead they SHOULD implement onStateChanged.
	 * @param partOptions Part's state to be applied. State object can have arbitrary structure.
	 * @param {Object} [options]
	 * @param {Boolean} [options.disablePushState] If true there will be no "statechange" event generated,
	 * i.e. no 'pushstate' done (in terms of AppStateManager). It's being used when AppStateManager applies a new state.
	 * @returns {Boolean} true if the state was applied (event "statechange" was triggered unless disablePushState was specified), otherwise false
	 */
	changeState(partOptions: any /*Part.Options*/, options?: StatefulPart.ChangeStateOptions): boolean {
		let that = this;
		if (!that.onStateChanged) { return; }
		let newState = that.getState(partOptions),
			statesEqual = that.compareStates(newState);
		if (!statesEqual) {
			options = options || {};
			if (that.onStateChanged(newState)) {
				if (!options.disablePushState) {
					that.reportState();
				}
				return true;
			}
		}
		return false;
	}


	/**
	 * Method SHOULD be called by Part to report the fact that its state is changed.
	 * @param {Boolean} [replaceState=false]
	 * @fires StatefulPart#statechange
	 */
	reportState(replaceState?: boolean): void {
		let state = this.getState();
		/**
		 * @event StatefulPart#statechange
		 * @type {{Object, Object}}
		 * @property {Part} state.part
		 * @property {String} state._partUid part's id
		 * @property {String} [state.title] part's title
		 * @property {Object} [state.partOptions] part's state
		 * @property {Boolean} [options.replaceState]
		 */
		this.trigger("statechange", state, {replaceState: replaceState});
	}

	/**
	 * Returns part current state (if `partOptions` is not specified).
	 * Or extract part's state from part's options (if `partOptions` is specified).
	 * @param {*} [partOptions] part's options to extract part's state
	 * @returns {*}
	 */
	getState(partOptions?: Part.Options): any {
	}

	/**
	 * Compares the current part's state and the new one.
	 * @param {Object} newState A new part state
	 * @returns {Boolean} true if states are equal
	 */
	compareStates(newState: any): boolean {
		let oldState = this.getState();
		if (!oldState && !newState) {
			return true;
		}
		if ((oldState && !newState) || (!oldState && newState)) {
			return false;
		}
		return lang.isEqual(oldState, newState);
	}

	/**
	This method SHOULD be implemented by derived classes:
	 @return {boolean} true if the state was applied and the part changed its state.
	*/
	protected onStateChanged?(state?: any): boolean;
}

namespace StatefulPart {
	export import ChangeStateOptions = ui.PartChangeStateOptions;
}

export = StatefulPart;
