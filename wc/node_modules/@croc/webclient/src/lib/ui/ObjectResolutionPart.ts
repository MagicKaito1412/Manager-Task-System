import core = require("core");
import support = require("lib/domain/support");
import ObjectComparePart = require("lib/ui/ObjectComparePart");
import Menu = require("lib/ui/menu/Menu");
import CacheManager = require("lib/interop/CacheManager");
import defaultTemplate = require("xhtmpl!lib/ui/templates/ObjectResolutionPart.hbs");
import resources = require("i18n!lib/nls/resources");

import lang = core.lang;

import ICommand = core.commands.ICommand;
import Options = ObjectResolutionPart.Options;
import {LoadRule} from "lib/interop/.interop.types";

class ObjectResolutionPart extends ObjectComparePart {
	static defaultOptions: Options = {
		template: defaultTemplate
	};

	static defaultMenu: Menu.Options = {
		items: [
			{ name: "Resolve", title: resources["objectResolution.menu.save"], icon: "ok" },
			{ name: "ConfirmDeletion", title: resources["objectResolution.menu.confirmDeletion"], icon: "ok" },
			{ name: "Cancel", title: resources["objectResolution.menu.cancel"], icon: "cancel" }
		]
	};

	options: Options;
	commands: lang.Map<ICommand>;
	menu: Menu;

	/**
	 * @observable-property {Boolean}
	 */
	checkedAll: lang.ObservableProperty<boolean>;

	/**
	 * @observable-property {Boolean}
	 */
	isLocalRemoved: lang.ObservableProperty<boolean>;

	private _checking: boolean;

	/**
	 * @class ObjectResolutionPart
	 * @extends ObjectComparePart
	 * @param {Object} options
	 * @param {} options.local
	 */
	constructor(options?: Options) {
		options = ObjectResolutionPart.mixOptions(options, ObjectResolutionPart.defaultOptions);
		super(options);

		this.commands = this.createCommands();
		this.menu = this.createMenu();
		if (this.menu) {
			this.menu.bindToPart(this);
		}
	}

	protected createMenu(): Menu {
		return new Menu(ObjectResolutionPart.defaultMenu, this.options.menu);
	}

	/**
	 * @protected
	 * @returns {{Resolve: (Command), ConfirmDeletion: {Command}, Cancel: (Command)}}
	 */
	protected createCommands(): lang.Map<ICommand> {
		let that = this,
			commands: any = {};
		if (that.isLocalRemoved()) {
			commands.ConfirmDeletion = core.createCommand({
				execute: that.doConfirmDeletion.bind(that)
			});
		} else {
			commands.Resolve = core.createCommand({
				execute: that.doResolve.bind(that)
			});
		}
		commands.Cancel = core.createCommand({
			execute: that.doCancel.bind(that)
		});

		commands = core.lang.extend(commands, that.options.commands);
		return commands;
	}

	setViewModel(): void {
		let that = this,
			local,
			original,
			isLocalRemoved,
			preloads,
			deferreds = [];

		that.isLoading(true);

		// init local
		if (!that.options.local) { throw new Error("You must specify 'local' option"); }
		local = that._initLocal(that.options.local);
		isLocalRemoved = local.isRemoved() || local.isInvalid();
		if (isLocalRemoved) {
			that.hint = resources["objectResolution.info.removed"];
			that.hintSeverity = "warning";
		}
		that.isLocalRemoved(isLocalRemoved);

		// init original
		if (that.options.original) {
			original = that._initOriginal(that.options.original);
		} else {
			that._initOriginal(local.meta.name, local.id);
		}

		// load properties of server object, which are specified in local object
		preloads = Object.keys(that.options.local)
			.filter((prop) => { return local.meta.props[prop]; });
		deferreds.push(original.load({
			reload: true, // always reload original object from server to notify other UOWs about changes
			preloads: preloads,
			policy: LoadRule.remoteOnly
		}).done((loaded) => {
			that.original(loaded);
		}));

		// load all value objects of navigated properties for local object
		// NOTE: we shouldn't load navigation properties themselves, because it may overwrite
		// their current local values
		if (!that.isLocalRemoved()) {
			lang.forEach(local.meta.props, (propMeta, propName) => {
				let v = local.get(propName),
					failFilter = () => {
						// ignore any error while loading value objects (they may be new or already deleted)
						return lang.resolved();
					};
				if (v && !v.isLoaded && !v.isGhost) {
					if (!propMeta.many) {
						deferreds.push(
							local.uow.ensurePropLoaded(local, propName)
								.then(null, failFilter)
						);
					} else {
						v.all().forEach((item) => {
							deferreds.push(
								local.uow.ensureLoaded(item)
									.then(null, failFilter)
							);
						});
					}
				}
			});
		}

		lang.when.apply(lang, deferreds).done(() => {
			// everything is loaded here. Init properties.
			that._initPropsModels();

			// changing 'checkedAll' must change 'checked' for every prop and vice versa
			that.bind("change:checkedAll", that._onCheckedAllChanged, that);
			that.props().all().forEach((prop) => {
				prop.bind("change:checked", that._onCheckedPropChanged, that);
			});
		}).fail((error) => {
			// TODO: use core.diagnostics
			console.error(error);
		}).always(() => {
			that.isLoading(false);
		});
	}

	protected _onCheckedAllChanged(): void {
		let that = this;
		if (that._checking) { return; }

		that._checking = true;
		try {
			let checkedAll = that.checkedAll();
			that.props().all().forEach((prop) => {
				if (!prop.isPropEqual()) {
					prop.checked(checkedAll);
				}
			});
		} finally {
			that._checking = undefined;
		}
	}

	protected _onCheckedPropChanged(): void {
		let that = this,
			checkedAll;
		if (that._checking) { return; }

		that._checking = true;
		try {
			checkedAll = that.props().all().every((prop) => {
				return prop.checked() || prop.isPropEqual();
			});
			that.checkedAll(checkedAll);
		} finally {
			that._checking = undefined;
		}
	}

	protected doResolve(): void {
		let that = this,
			local = that.local(),
			original = that.original(),
			json = original.createJsonStub();

		that.props().all().forEach((prop) => {
			let propMeta = prop.meta,
				propName,
				v;
			if (!propMeta || prop.isPropEqual()) { return; }

			propName = propMeta.name;
			v = support.getPropRaw(prop.checked() ? local : original, propMeta);
			json[propName] = support.json.dematerializeProp(v, propMeta);
		});
		json.__metadata.ts = original.ts;

		that.navigationService.close({ changes: [ json ], resolved: true });
	}

	protected doConfirmDeletion(): void {
		let that = this,
			original = that.original(),
			json = original.createJsonStub();

		json.__metadata.isRemoved = true;
		json.__metadata.ts = original.ts;

		that.navigationService.close({ changes: [ json ], resolved: true });
	}

	protected doCancel(): void {
		this.navigationService.close();
	}
}

ObjectResolutionPart.mixin({
	// backward compatibility
	defaultOptions: ObjectResolutionPart.defaultOptions,
	defaultMenu: ObjectResolutionPart.defaultMenu,

	/**
	 * @observable-property {Boolean}
	 */
	checkedAll: lang.Observable.accessor("checkedAll"),

	/**
	 * @observable-property {Boolean}
	 */
	isLocalRemoved: lang.Observable.accessor("isLocalRemoved")
});

namespace ObjectResolutionPart {
	export interface Options extends ObjectComparePart.Options {
		menu?: Menu.Options;
		commands?: lang.Map<ICommand>;
	}
}

core.ui.ObjectResolutionPart = ObjectResolutionPart;

export = ObjectResolutionPart;
