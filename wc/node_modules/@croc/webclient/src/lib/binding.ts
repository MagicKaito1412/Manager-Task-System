/** @module "core.commands" */

import $ = require("jquery");
import lang = require("lib/core.lang");
import commands = require("lib/core.commands");
import corehtml = require("lib/core.html");

import { IDisposable } from "lib/core.lang";
import { ICommand } from "lib/core.commands";

/**
 * Bindable object.
 * @typedef {Object} Bindable
 * @property {Function} get
 * @property {Function} set
 * @property {Function} onchange
 * @property {Function} ondispose
 * @property {Function} setError
 */
export interface IBindable {
	get?(): any;
	set?(v: any): void;
	onchange?(handler: (e) => void): IDisposable;
	setError?(error: any): void;
	ondispose?(disposable: IDisposable): void;
}

/**
 * @exports binding
 * @description  Data-binding может осуществляться между специальными bindable значениями.
 * Под bindable значениям понимается любой объект, содержащий методы:
 * get()  - возвращает привязываемое значение;
 * set(v) - устанавливает привязываемое значение;
 * onchange(handler)  - подписывает обработчик на изменение значения.
 * Может возвращать объект с методом dispose(), в котором обработчик должен отписываться.
 * Этот метод будет вызван при разрыве binding-а;
 * Любой из методов может отсутствовать. Например, если нет метода onchange, то изменения значения не будут отслеживаться, т.е. binding будет "одноразовый".
 * Если, например, нет метода set, то binding будет односторонним.
*/

function executeBinding (target: IBindable, source: IBindable) {
	let sourceErrorable = typeof source.setError === "function";
	let targetErrorable = typeof target.setError === "function";

	if (sourceErrorable || targetErrorable) {
		let error = null;
		try {
			target.set(source.get());
		} catch (ex) {
			error = ex;
		}

		// устанавливаем ошибку и в источнике, и в приемнике (или сбрасываем, если ошибки нет)
		if (sourceErrorable) {
			source.setError(error);
		}
		if (targetErrorable) {
			target.setError(error);
		}
	} else {
		// in case of error it will bubble up
		target.set(source.get());
	}
}

// region databind method
function bindOneWay(target: IBindable, source: IBindable): IDisposable {
	let disposable;

	if (typeof source.onchange === "function" &&
		typeof source.get === "function" &&
		typeof target.set === "function") {
		let handler = () => {
			executeBinding(target, source);
		};

		disposable = source.onchange(handler);

		if (typeof target.ondispose === "function" &&
			disposable && typeof disposable.dispose === "function") {
			target.ondispose(disposable);
		}
	}
	return disposable;
}

/**
 * Bind two bindable objects to each other.
 * @param {Bindable} target
 * @param {Bindable} source
 * @param {Object} [options]
 * @param {Boolean} [options.oneway] if true that bind target to source only, otherwise bind source to target as well
 * @returns {{dispose:function}} disposable to break the binding
 */
export function databind(target: IBindable, source: IBindable, options?: databind.Options): IDisposable {
	options = options  || {};
	// устанавливаем начальное значение
	// В случае ошибки, исключение не будет обработано
	if (typeof target.set === "function" && typeof source.get === "function") {
		executeBinding(target, source);
	}

	let disposable1 = bindOneWay(target, source);
	let disposable2 = !options.oneway ? bindOneWay(source, target) : undefined;

	if (!disposable1 || typeof disposable1.dispose !== "function") {
		return disposable2;
	}
	if (!disposable2 || typeof disposable2.dispose !== "function") {
		return disposable1;
	}
	return {
		dispose: () => {
			disposable1.dispose();
			disposable2.dispose();
		}
	};
}
export namespace databind {
	export interface Options {
		oneway?: boolean;
	}
}

/**
 * @deprecated Use lang.support.loadingValue instead
 */
export const loading = lang.support.loadingValue;
// endregion databind method

// region html binding
function parseString(v: any): string {
	return v == null ? "" : v.toString();
}

function parseBool(v: any): boolean {
	return !!v;
}
// стандартные опции, используемые при конструировании bindable значений для html-элементов
export const htmlBindingOptions = {
	text: {
		accessor: $.fn.text,
		parse: parseString
	},
	html: {
		accessor: $.fn.html,
		parse: parseString
	},
	value: {
		event: "change",
		accessor: $.fn.val,
		parse: parseString
	},
	valueLive: {
		// TODO: также надо детектировать cut/undo/redo
		event: "keyup paste change",
		accessor: $.fn.val,
		parse: parseString,
		eventHandler: function (e) {
			if (e.type === "paste") {
				// NOTE: 'paste' event is triggered before input's value changed
				let $this = $(e.currentTarget || e.srcElement);
				let callback = function () {
					$this.change();
				};
				window.setTimeout(callback, 0);
			}
		}
	},
	disabled: {
		accessor: function (v) {
			var $this = this,
				tagName = ($this.length && $this[0].tagName),
				isForm = /(BUTTON|INPUT|OPTGROUP|OPTION|SELECT|TEXTAREA)/.test(tagName),
				tabindex;
			if (arguments.length > 0) {
				// set:
				if (v) {
					if (isForm) {
						$this.prop("disabled", true);
					} else {
						$this.addClass("disabled");
						$this.bind("click keydown keyup", false); // event handler returns false

						// store tabIndex
						tabindex = $this.attr("tabIndex");
						if (tabindex) {
							$this.data("tabIndex", tabindex);
						}
						$this.attr("tabIndex", -1);
					}
				} else {
					if (isForm) {
						$this.prop("disabled", false);
					} else {
						$this.removeClass("disabled");
						$this.unbind("click keydown keyup", false);

						// restore tabIndex
						tabindex = $this.data("tabIndex");
						if (tabindex) {
							$this.attr("tabIndex", tabindex);
							$this.removeData("tabIndex");
						} else {
							$this.removeAttr("tabIndex");
						}
					}
				}
			} else {
				// get:
				return isForm ? $this.prop("disabled") : $this.hasClass("disabled");
			}
		},
		parse: parseBool
	},
	enabled: {
		accessor: function (v) {
			if (arguments.length > 0) {
				// set:
				htmlBindingOptions.disabled.accessor.call(this, !v);
			} else {
				// get:
				return !htmlBindingOptions.disabled.accessor.call(this);
			}
		},
		parse: parseBool
	},
	readonly: {
		accessor: function (v) {
			// TODO: jQuery 3.x: remove using removeAttr, use prop("readonly", true/false)
			if (arguments.length > 0) {
				if (v) {
					// set:
					this.attr("readonly", true);
				} else {
					// get:
					this.removeAttr('readonly');
				}
			} else {
				return this.attr("readonly");
			}
		},
		parse: parseBool
	},
	visibility: {
		accessor: function (v) {
			if (arguments.length > 0) {
				// set:
				(v) ? this.show() : this.hide();
			} else {
				// get:
				// NOTE: `!this.is(":visible")` не работает, если элемент еще не отрендерен
				return this.css("display") !== "none";
			}
		},
		parse: parseBool
	},
	hidden: {
		accessor: function (v) {
			if (arguments.length > 0) {
				// set:
				(v) ? this.hide() : this.show();
			} else {
				// get:
				// NOTE: `!this.is(":visible")` не работает, если элемент еще не отрендерен
				return this.css("display") === "none";
			}
		},
		parse: parseBool
	},
	transparent: {
		accessor: function (v) {
			if (arguments.length > 0) {
				// set:
				this.css("visibility", v ? "hidden" : "");
			} else {
				// get:
				return this.css("visibility") === "hidden";
			}
		},
		parse: parseBool
	},
	checked: {
		getSpecific: function ($element) {
			if ($element[0].type === "radio") {
				return {
					eventHandler: function (e) {
						if (!$(e.target).prop("checked")) { return; }

						$("input[name='" + e.target.name + "']:not(:checked)").trigger("change", false);
					}
				};
			}
		},
		event: "change",
		accessor: function (v) {
			if (arguments.length > 0) {
				// set
				this.prop("checked", !!v);
			} else {
				// get
				return !!this.prop("checked");
			}
		},
		parse: parseBool
	},
	radioGroup: {
		event: "change",
		group: undefined,
		getSpecific: function () {
			var groupName = this.group,
				selector = "input[type='radio']";
			if (groupName) {
				selector += "[name='" + groupName +"']";
			}
			return {
				accessor: function (v) {
					if (arguments.length > 0) {
						// set (v - is a value of one of radio buttons)
						this.find(selector + "[value='" + v + "']").prop("checked", true);
					} else {
						// get
						return this.find(selector + ":checked").attr("value");
					}
				}
			};
		}
	},
	checkedNull: {
		event: "change",
		accessor: function (v) {
			if (arguments.length > 0) {
				// set
				this.prop("checked", !!v);
			} else {
				// get
				return this.prop("checked") ? true : null;
			}
		}
	},
	select: {
		event: "change",
		accessor: $.fn.val,
		parse: parseString
	},
	optionsSource: {
		accessor: function (source) {
			var html = "";
			if (source) {
				lang.forEach(source, function (value, key) {
					html += "<option value='" + lang.encodeHtml(key) + "'>" + lang.encodeHtml(value) + "</option>";
				});
				this.html(html);
			}
		}
	},
	cssClass: {
		/**
		 *
		 * @param {Object|Array|String} [value]
		 */
		accessor: function (value) {
			var that = this;
			if (arguments.length > 0) {
				// setting:
				value = value || {};
				if (lang.isArray(value)) {
					this.get(0).className = value.join(" ");
				} else if (lang.isString(value)) {
					this.get(0).className = value;
				} else {
					lang.forEach(value, function (toggle, className) {
						that.toggleClass(className, !!toggle);
					});
				}
			} else {
				// getting:
				var currentClassNames = (this.get(0).className || "").split(/\s+/);
				value = {};
				if (currentClassNames.length === 1 && currentClassNames[0] === "") {
					return value;
				}
				for (var i = 0; i < currentClassNames.length; i++) {
					value[currentClassNames[i]] = true;
				}
				return value;
			}
		}
	},
	cssClassToggle: {
		cssClass: undefined,
		getSpecific: function ($element) {
			var className = this.cssClass || $element.attr("data-cssClassToggle");
			if (className) {
				return {
					accessor: function (value) {
						if (arguments.length > 0) {
							this.toggleClass(className, value);
						}
					}
				};
			}
		}
	}
};
// отображение тэгов html-элементов на опции по умолчанию
const htmlBindingOptionsByName = {
	input: htmlBindingOptions.value,
	textarea: htmlBindingOptions.value,
	checkbox: htmlBindingOptions.checked,
	select: htmlBindingOptions.select
};

const DisposableDataKey = "x-dispose";

// shared args for "domChanged" event
const domChangedEvenArgs = {binding: true};

export function setupNodeDisposables($element: JQuery): IDisposable[] {
	let disposables = $element.data(DisposableDataKey);
	if (!disposables) {
		disposables = [];
		$element.data(DisposableDataKey, disposables);
	}
	return disposables;
}

/**
 * Create a new bindable object for a HTML element.
 * @param {HTMLElement|jQuery} el target HTMLDOME-element or jQuery-object for the binding
 * @param {String|Object} [options] Binding name or binding options (specification)
 * @param {String} [options.name] Binding name
 * @param {Function} [options.getSpecific] callback returning an `options` object for bindable - can be used for runtime customization (e.g. using of arguments in accessor function)
 * @param {Function} [options.accessor] function-accessor for setting and getting value to/from html-element
 * @param {Function} [options.parse]
 * @param {String} [options.event] event name
 * @param {Function} [options.eventHandler] An additional handler bound to the event
 * @return {Bindable}
*/
function htmlBind(el: JQuery|HTMLElement, options?: string | html.Options): IBindable {
	if (!el) { throw new Error("binding.html: element is null"); }

	let selector = $(el);

	if (!options) {
		if (selector.length) {
			// получаем опции по тэгу
			options = htmlBindingOptionsByName[selector[0].tagName.toLowerCase()];
		}
	} else if (typeof options === "string") {
		// получаем опции по имени
		options = htmlBindingOptions[options];
	} else if (options.name) {
		options = lang.append(options, htmlBindingOptions[options.name]);
	}

	// по умолчанию привязка к тексту
	if (!options) {
		options = htmlBindingOptions.text;
	}
	// make TS compiler happy:
	options = <html.Options>options;

	// может быть уточнение для конкретного элемента
	if (options.getSpecific) {
		options = <html.Options>lang.extend({}, options, options.getSpecific(selector));
	}

	let accessor = options.accessor;
	let bindable: IBindable = {};
	if (accessor) {
		bindable.get = function () {
			return accessor.call(selector);
		};
		bindable.set = function (v) {
			if (v === lang.support.loadingValue) {
				v = null;
			}
			// make TS compiler happy:
			//options = <html.Options>options;
			if ( (<html.Options>options).parse) {
				v = (<html.Options>options).parse(v);
			}
			if (v !== accessor.call(selector)) {
				accessor.call(selector, v);
				selector.trigger("domChanged", domChangedEvenArgs);
			}
		};
	}

	if (options.event) {
		let eventHandler = options.eventHandler;
		bindable.onchange = (handler) => {
			if (eventHandler) {
				let original = handler;
				handler = (e) => {
					eventHandler(e);
					original(e);
				};
			}
			selector.bind((<html.Options>options).event, handler);
			return {
				dispose: () => {
					selector.unbind((<html.Options>options).event, handler);
				}
			};
		};
	}

	bindable.ondispose = (disposable: IDisposable) => {
		let disposables = setupNodeDisposables(selector);
		disposables.push(disposable);
	};

	bindable.setError = function(error) {
		if (error && error.message) {
			error = error.message;
		}
		if (this.error !== error) {
			this.error = error;
			$(this).trigger("bindingErrorChanged", this.error);
		}
	};

	return bindable;
}
export const html = htmlBind;
export namespace html {
	/**
	 * Binding options (specification)
	 */
	export interface Options {
		/**
		 * Binding name
		 */
		name?: string;
		/**
		 * callback returning an object for bindable - can be used for runtime customization
		 * (e.g. using of arguments in accessor function).
		 */
		getSpecific?: (selector: JQuery) => html.Options;
		/**
		 * function-accessor for setting and getting value to/from html-element
		 */
		accessor?: Function;
		parse?: Function;
		event?: string;
		/**
		 * An additional handler bound to the event
		 */
		eventHandler?: Function;
		[key: string]: any;
	}
}
const oldCleanData = $.cleanData;

$.cleanData = function (elems: JQuery) {
	let el;
	for (let i = 0;	(el = elems[i]) !== undefined; i++) {
		let disposables = $.data(el, DisposableDataKey);
		//disposables = el[DisposableDataKey];
		if (disposables && disposables.length) {
			disposables.forEach((disposable) => {
				disposable.dispose();
			});
		}
	}

	oldCleanData(elems);
};
// endregion html method

// region expr binding
class BindableExpression {
	private _source: any;
	private _expr: lang.IDisposableFunction;
	private _callbacks: any[];

	/**
	 * @see `"core.lang".observableExpression`
	 * @constructs BindableExpression
	 * @article [BindableExpression](docs:bindableexpression)
	 * @param {*} source
	 * @param {*} expr
	 */
	constructor(source: any, expr: Function|string) {
		let that = this;
		that._source = source;
		that._expr = lang.observableExpression(expr, {
			onchange: () => { that.notify(); }
		});
		that._callbacks = [];

		// NOTE: после загрузки может поменяться исходный объект
		if (lang.support.isNotLoaded(that._source)) {
			that._source.load().done(function (loadedObj) {
				that._source = loadedObj;
			});
		}
	}

	dispose(): void {
		this._callbacks.length = 0;
		this._expr.dispose();
	}

	notify(): void {
		var that = this,
			args = arguments;
		that._callbacks.forEach(function (callback) {
			callback.apply(that, args);
		});
	}
	get(): any {
		return this._expr.call(this._source);
	}
	set(v: any): void {
		this._expr.call(this._source, v);
	}
	onchange(callback) {
		let that = this;
		that._callbacks.push(callback);

		return {
			dispose: function () {
				lang.arrayRemove(that._callbacks, callback);
				if (!that._callbacks.length) {
					that.dispose();
				}
			}
		};
	}
}

function exprBind(source: any, expr: Function|string): IBindable {
	return new BindableExpression(source, expr);
}

export const expr = exprBind;
export const domain = exprBind; // for backward compatibility
// endregion expr binding

export function commandBind(element: JQuery|HTMLElement, cmd: ICommand, args?: any): IDisposable {
	let onClick = function(e: JQueryEventObject) {
			if (corehtml.isExternalClick(e)) {
				return;
			}
			e.preventDefault();
			if (cmd.canExecute()) {
				let $this = $(this);
				let name = commands.dataCommandName($this) || (<any>cmd).name;
				let cmdArgs = lang.extend({},
					args,
					{ name: name },
					commands.dataCommandParams($this)
				);
				let ret = cmd.execute(cmdArgs);
				if (ret === false) { return false; }
			}
		};
	$(element).buttonClick(onClick);

	let disposable = databind(
		htmlBind(element, "enabled"),
		exprBind(cmd, "canExecute")
	);
	return {
		dispose: function () {
			$(element).unbind("click", onClick);
			disposable.dispose();
		}
	};
}
