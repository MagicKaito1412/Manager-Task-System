/** @module core */
/** @module "core.commands" */

import * as $ from "jquery";
/**
 * @type module:"core.lang"
 */
import * as lang from "lib/core.lang";
/**
 * @type module:"core.binding"
 */
import * as binding from "lib/binding";
/**
 * @type module:"core.events"
 */
import * as events from "lib/core.events";
/**
 * @type module:"core.composition"
 */
import * as composition from "lib/core.composition";
/**
 * @type module:"core.diagnostics"
 */
// NOTE: 'import *' makes diagnostics read-only, but 'require' doesn't.
// We set 'diagnostics.defaultLevel', so we can not use 'import *'.
//import * as diagnostics from "lib/core.diagnostics";
import diagnostics = require("lib/core.diagnostics");
/**
 * @type module:"core.commands"
 */
import * as commands from "lib/core.commands";
/**
 * @type module:"core.html"
 */
//import * as html from "lib/core.html";
import html = require("lib/core.html");
/**
 * @type module:"core.eth"
 */
import * as eth from "lib/core.eth";

import * as utils from "lib/utils";
import * as Part from "lib/ui/Part";
import * as StatefulPart from "lib/ui/StatefulPart";
import * as Component from "lib/ui/Component";
import * as View from "lib/ui/handlebars/View";
import * as Cookies from "vendor/cookies";
import * as resources from "i18n!lib/nls/resources";
import "vendor/modernizr";
import "vendor/history";
import "moment";
import "i18n!vendor/moment/nls/locale";

import {
	AppState, IApplication, IAppStateManager, IUserSettings, IUserSettingsStore } from ".core";
import { IPart, IDialog } from "ui/.ui";
import { IDataFacade, SystemVersionChangedEvent } from "interop/.interop";
import { IDomainModel, UnitOfWork } from "domain/.domain";
// NOTE: import types of nested namespaces
import { ui as coreui, interop as coreinterop } from "core";
import Promise = lang.Promise;
import SystemMenu = require("ui/menu/SystemMenu");

let Historyjs = <any>History;

/**
 * @exports core
 */

// reexport the most important modules
export {
	lang,
	binding,
	events,
	composition,
	diagnostics,
	commands,
	html,
	eth
};

/**
 * Global cached JQuery object for `document`.
 * @type {JQuery}
 */
export let $document: JQuery = html.$document;
/**
 * Global cached JQuery object for `window`.
 * @type {JQuery}
 */
export let $window: JQuery = html.$window;

export let nls = {
	resources: resources,

	merge: function (resourcesModule: lang.Map<string>, prefix?: string): lang.Map<string> {
		lang.forEach(resourcesModule, function (value: string, key: string): void {
			if (prefix) {
				key = prefix + key;
			}
			resources[key] = value;
		});
		return resources;
	}
};

// init namespace `ui`
/**
 * Virtual `ui` namespace where all ui components add themselves to.
 * @type {any}
 */
export let ui: typeof coreui = <any>{
	Part: Part,
	StatefulPart: StatefulPart,
	Component: Component,
	View: View
};
export namespace ui {}

// class `Application` refers to `interop`, we have to declare it
export declare let interop: typeof coreinterop;
export declare namespace interop {}

//var core = this;
lang.Class.rootNamespace = this; // core

export import createCommand = commands.createCommand;
import {isHtml, SafeHtml, safeHtml} from "lib/formatters";
export {isHtml, SafeHtml, safeHtml};

let traceSource = new diagnostics.TraceSource("core");

/*
(function (namespace, nsName) {
	var typeName,
		type,
		firstLetter;
	for (typeName in namespace) {
		firstLetter = typeName.charAt(0);
		if (firstLetter.toUpperCase() === firstLetter) {
			type = core.composition[typeName];
			type.prototype.traceSource = new core.diagnostics.TraceSource(nsName + "." + typeName);
		}
	}
}) (core.composition, "core.composition");
*/
/**
 * @typedef {Object} XConfig
 * @global
 * @property {String} apiroot Api root path ("/" or "/myapp/")
 * @property {String} root Presentation root path ("/" or "/myapp/")
 * @property {String} appName name of the application
 * @property {String} clientBase path from `root` to
 * @property {Boolean} isDebug debug mode
 * @property {String} defaultLanguage name of default language
 * @property {Object} supportedLanguages An object which fields as language names and values are language description - an object with fields `title`, `short`
 * @property {Object} modules An object with modules configurations - every field corresponds to a module and its value is a config object of the module
 * @property {Object} software An object with software description
 * @property {String} software.clientLibVersion client lib (WebClient) version
 * @property {String} software.serverLibVersion server lib (WebClient) version
 * @property {String} software.appVersion application version
 * @property {Object} security An object with security configuration
 * @property {String} security.logoutUrl An url relative to `apiroot` to log out
 */

export class SystemEvent extends lang.Observable {
	/**
	 * @deprecated Use SystemEvent.State
	 */
	static States: typeof SystemEvent.State;

	/**
	 * @deprecated Use SystemEvent.Kind
	 */
	static Kinds: typeof SystemEvent.Kind;

	kind: SystemEvent.Kind;
	uid: string;
	type: string;
	priority: string;
	message: string;
	html: string;
	severity: string;
	promise: lang.Promise<any>;
	error: Error;
	data: any;
	timestamp: Date;
	defaultAction: () => void;
	menu: any;

	/**
	 * @observable-property {SystemEventState}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<SystemEvent.State>;

	/**
	 * Always `true` to distinguish `SystemEvent` instances.
	 * @constant {Boolean}
	 */
	@lang.decorators.constant(true)
	isSystemEvent: boolean;

	/**
	 * System event. An object to represent an application-wide event. Usually it's published via `EventPublisher`.
	 * @constructs SystemEvent
	 * @memberOf module:core
	 * @extends Observable
	 * @param {Object} data
	 * @param {String} data.type
	 * @param {SystemEvent#kinds} data.kind A kind of notification: notification, process, actionRequest
	 * @param {"high"|"normal"|"low"} data.priority A priority: high, normal, low
	 * @param {String} data.message Title of notification
	 * @param {String} [data.html] Html code to use instead of plain text in message
	 * @param {"error"|"warning"|"success"|"info"} [data.severity] A severity of the notification: 'error', 'warning', 'success', 'info'
	 * @param {Promise} [data.promise] A process' promise which will resolved when the process finishes
	 * @param {Object} [data.error] Event is being created for an interop error
	 * @param {*} [data.data] Any event specific data
	 * @param {Function} [data.defaultAction]
	 * @param {Object} [data.menu]
	 */
	constructor(data: SystemEvent.Options) {
		super();
		data = data || {};
		this.type = data.type;
		this.kind = data.kind;
		this.uid = data.uid;
		this.priority = data.priority;
		if (isHtml(data.message)) {
			this.html = data.message.toHTML();
			this.message = data.message.toString();
		} else {
			this.message = data.message;
			this.html = data.html;
		}
		this.severity = data.severity;
		this.promise = data.promise;
		this.error = data.error;
		this.data = data.data;
		this.timestamp = new Date();

		this.state(SystemEvent.State.pending);

		// specifics for Notification:
		if (this.priority === undefined && (this.severity === "warning" || this.severity === "error")) {
			this.priority = "high";
		}
		// Subject to kill:
		this.defaultAction = data.defaultAction;
		/**
		 * Event menu
		 * @type {Menu}
		 */
		this.menu = null;

		if (data.menu) {
			this.menu = ui.Menu.create(data.menu);
		} else {
			this.menu = new ui.Menu();
		}
	}

	initialize(): void {	}

	/**
	 * Return formatted timestamp of the event.
	 * @return {String}
	 */
	createdFormatted(): string {
		return utils.formatDatetimeAgo(this.timestamp);
	}

	/**
	 * Return flag whether the event has a menu.
	 * @return {Boolean}
	 */
	hasMenu(): boolean {
		return this.menu && !this.menu.hidden && this.menu.items.length > 0;
	}

	//static create(data?:SystemEvent.Options):SystemEvent;
}
export namespace SystemEvent {
	export interface Options {
		/** Event type: it's the `name` passed into `EventPublisher.publish`
		 * @type {String}
		 */
		type?: string;
		/** Event kind
		 * @type {"notification"|"process"|"actionRequest"}
		 */
		kind?: SystemEvent.Kind;
		/** Event priority.
		 * @type {"high"|"normal"|"low"}
		 */
		priority?: SystemEvent.Priority;
		/** event title
		 * @type {String|SafeHtml}
		 */
		message?: string | SafeHtml;
		/** unique identifier
		 * @type {String}
		 */
		uid?: string;
		/** html of event title: html will be used instead of title where it's applicable
		 * @type {String}
		 * @deprecated use SafeHtml in message
		 */
		html?: string;
		/** event severity - importance: 'error', 'warning', 'success', 'info'
		 * @type {"error"|"warning"|"success"|"info"}
		 */
		severity?: SystemEvent.Severity;
		/** A `Promise` object for process-event - the notification will be closed where the promise is resolved
		 * @type {jQuery.Promise}
		 */
		promise?: lang.Promise<any>;
		/** Error object in case when the event represents an interop error
		 * @type {Object}
		 */
		error?: any;
		/** Any event specific data
		 * @type {*}
		 */
		data?: any;
		defaultAction?: any;
		menu?: any;
	}

	export const State = {
		/**
		 * Event was created.
		 */
		pending: "pending" as "pending",
		/**
		 * Event was shown to the user.
		 */
		active: "active" as "active",
		/**
		 * Event was archived.
		 */
		archived: "archived" as "archived"
	};
	export type State = (typeof State)[keyof typeof State];

	export const Kind = {
		notification: "notification" as "notification",
		process: "process" as "process",
		actionRequest: "actionRequest" as "actionRequest"
	};
	export type Kind = (typeof Kind)[keyof typeof Kind];

	export const Priority = {
		high: "high" as "high",
		normal: "normal" as "normal",
		low: "low" as "low"
	};
	export type Priority = (typeof Priority)[keyof typeof Priority];

	export const Severity = {
		error: "error" as "error",
		warning: "warning" as "warning",
		success: "success" as "success",
		info: "info" as "info"
	};
	export type Severity = (typeof Severity)[keyof typeof Severity];
}
SystemEvent.mixin({
	states: SystemEvent.State,
	kinds: SystemEvent.Kind
});
SystemEvent.States = SystemEvent.State;
SystemEvent.Kinds = SystemEvent.Kind;

export class Platform extends lang.Observable {
	defaultLanguage: string;
	modernizr: ModernizrStatic;
	scrollbarWidth: number;
	supportTouch: boolean;
	isMobileDevice: boolean;
	features: {
		resizeOnZoom?: boolean
	};
	limits: {
		queryStringMaxLen: number;
	};
	browser: {
		ie?: { version?: number; };
		iemobile?: { version?: number; };
		webkit?: { version?: number; };
		firefox?: { version?: number; };
	};
	os: {
		android?: {
			version?: number;
		};
		mac?: {};
	};
	$metaViewport: JQuery;
	private _userscalableRegex: RegExp;
	private _maxscaleRegex: RegExp;
	private _printing: boolean;

	/**
	 * @constructs Platform
	 * @extends Observable
	 * @memberOf! module:core
	 * @param {XConfig} config
	 */
	constructor (config: XConfig) {
		super();
		let that = this;

		Cookies.defaults.path = config.root;
		that.modernizr = Modernizr;

		// Установим текущий язык
		let language = Cookies.get("X-Lang") || (config.require && config.require.locale);

		// NOTE: navigator.language - это язык интерфейса браузера, использовать его неочень правильно
		// navigator.userLanguage есть только в IE, зависит от текущих региональных настроек ("en-us", "ru")
		that.defaultLanguage = navigator ? (navigator["userLanguage"] || navigator.language): "en";
		// для "en-us" оставим только "en":
		let re = /(\w+)-\w+/i;
		if (re.test(that.defaultLanguage)) {
			that.defaultLanguage = re.exec(that.defaultLanguage)[1];
		}
		if (!language ) {
			language = that.defaultLanguage || "en";
		}
		that.language(language);
		traceSource.info("current language: " + language);

		that.bind("change:language", (sender, value) => {
			Cookies.set("X-Lang", value, {path: config.root});
			window.location.reload();
		});

		that.animation(true);
		that.bind("change:animation", function (sender, value) {
			$.fx.off = !value;
		});

		// TODO: Нам надо знать не просто мобильное ли устройство, а:
		// 		основной метод ввода: физическая клава или тач (чтобы выбирать контролы соответствующие)
		//		(NOTE: в Win8 может быть и тач и мышь одновременно!)
		//		быстродействие: тормозное или нормальное (чтобы отключать что-нибудь лишнее)
		//		скорость сети: нормальная или GPRS-like (чтобы оптимизировать что-нибудь)
		that.supportTouch = that.isTouchDevice();
		that.isMobileDevice = screen.width <= 480;
		if (navigator && !that.isMobileDevice) {
			that.isMobileDevice = navigator.userAgent.match(/Android|iPad|iPhone|iPod|Mobile|iemobile|windows (ce|phone)|blackberry|BB10|kindle|bada|psp|palm|phone|opera m(ob|in)i|maemo|meego.+mobile|symbian|xda/i) != null;
			if (!that.isMobileDevice)
				// that's bad idea: MS Surface is ARMS-based but it's mostly 'desktop' than 'mobile'
				that.isMobileDevice = navigator.platform.match(/armv\d*/i) != null;
		}
		traceSource.debug("isMobileDevice: " + that.isMobileDevice);

		// if mobile device doesn't support CSS3 Transitions then disable all jQ-animations
		// NOTE: we're using jQuery.animate-enhanced which extends jQuery.animate() to automatically use CSS3 transformations
		if (that.isMobileDevice && !that.modernizr.csstransitions) {
			traceSource.warn("csstransitions isn't supported, disabling jQ-animations");
			that.animation(false);
		}

		that.limits = {
			queryStringMaxLen: 2048 // default limit of IIS
		};

		that.browser = {};
		that.os = {};
		if (navigator) {
			// detect browser
			let uaMatch;
			let userAgent = navigator.userAgent;
			if (userAgent.indexOf("MSIE") > -1) {
				if (uaMatch = /IEMobile\/([\d.]+)/.exec(userAgent)) {
					// "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 920)"
					// "Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; SAMSUNG; SGH-i917)"
					// "Mozilla/4.0 (compatible; MSIE 7.0; Windows Phone OS 7.0; Trident/3.1; IEMobile/7.0; LG; GW910)"
					that.browser.iemobile = { version: parseFloat(uaMatch[1]) };
				} else if (uaMatch = /MSIE ([0-9]+[.0-9]*)/.exec(userAgent)) {
					// NOTE: признак MSIE присуствует во всех версиях userAgent для IE вплоть до версии 10 включительно.
					that.browser.ie = { version: parseFloat(uaMatch[1]) };
				}
			} else if (uaMatch = /AppleWebKit\/([\d.]+)/.exec(userAgent)) {
				// Chrome: "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.72 Safari/537.36"
				// Edge: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586"
				that.browser.webkit = {
					version: parseFloat(uaMatch[1])
				};
			} else if (uaMatch = /Firefox\/([\d.]+)/.exec(userAgent)) {
				// "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0"
				that.browser.firefox = {
					version: parseFloat(uaMatch[1])
				};
			}

			// detect os/platform/device
			if (userAgent.indexOf("Android") > -1) {
				uaMatch = /Android\s([\d.]{3})/i.exec(userAgent);
				that.os.android = {};
				// NOTE: Firefox for Android doesn't report Android version
				if (uaMatch) {
					that.os.android.version = parseFloat(uaMatch[1])
				}
			} else if (userAgent.indexOf("Mac OS") > -1) {
				that.os.mac = {};
			}
		}

		// print events handlers
		var beforePrint = function() {
			that.printing(true);
		};
		var afterPrint = function() {
			// ugly hack: In Chrome there will be no beforePrint ever,
			// so we're simulating changing property for 'change' event to fire
			that._printing = true;
			that.printing(false);
		};
		// detect printing
		if (window.matchMedia) {
			var mediaQueryList = window.matchMedia("print");
			mediaQueryList.addListener(function(mql) {
				if (mql.matches) {
					beforePrint();
				} else {
					afterPrint();
				}
			});
		} else {
			window.onbeforeprint = beforePrint;
			window.onafterprint = afterPrint;
		}

		that.$metaViewport = $("meta[name=viewport]");
		that._userscalableRegex = /user-scalable\s*=\s*[0,no]/i;
		that._maxscaleRegex = /maximum-scale=1.0/i;

		that._initFeatures();
	}

	/**
	 * @observable-property {Boolean}
	 */
	printing: lang.ObservableProperty<boolean>;
	/**
	 * @observable-property {String}
	 */
	language: lang.ObservableProperty<string>;
	/**
	 * @observable-property {Boolean}
	 */
	animation: lang.ObservableProperty<boolean>;

	_initFeatures (): void {
		let that = this,
			resizeOnZoom;

		if (that.isMobileDevice) {
			if (that.browser.webkit) {
				// 537 - webkit version with guaranteed working 'resize on zoom' feature
				resizeOnZoom = that.browser.webkit.version >= 537;
			} else if (that.browser.iemobile) {
				resizeOnZoom = that.browser.iemobile.version >= 10;
			} else {
				resizeOnZoom = false;
			}
		} else {
			resizeOnZoom = true;
		}
		that.features = {resizeOnZoom: resizeOnZoom};
	}

	isTouchDevice (): boolean {
		return !!('ontouchstart' in window) 	// works on most browsers
				|| (window.navigator && window.navigator.msMaxTouchPoints > 0); // IE10
	}

	getUserScalable (): boolean {
		let that = this;

		if (!that.isMobileDevice) { return true; }

		if (that.os.android && that.os.android.version) {
			// Android 2.2: viewport meta tag does not seem to be supported at all.
			// http://stackoverflow.com/questions/11345896/full-webpage-and-disabled-zoom-viewport-meta-tag-for-all-mobile-browsers/12270403#12270403
			if (that.os.android.version <= 2.2){
				return true;
			}
		}
		var viewportContent = that.$metaViewport.attr("content");
		if (viewportContent.indexOf("user-scalable") > -1) {
			return !that._userscalableRegex.test(viewportContent);
		}
		return !(that._maxscaleRegex.test(viewportContent));
	}

	/**
	 * Set meta tag 'viewport' values minimum-scale/maximum-scale. Setting them to "1.0" disables user zooming in mobile browsers.
	 * @param {String} [minScale="1.0"]
	 * @param {String} [maxScale="1.0"]
	 */
	setUserScalable (minScale: string, maxScale: string): void {
		if (!minScale || !maxScale) {
			minScale = "1.0";
			maxScale = "1.0";
		}

		var content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";
		if (minScale === maxScale) {
			content = content  + ", user-scalable=0";
		}
		this.$metaViewport.attr("content", content);
	}

	localize (resource: string|lang.Map<string>): string {
		if (!resource) { return <any>resource; }
		if (lang.isString(resource)) { return resource; }
		if (lang.isObject(resource)) {
			let language = this.language();
			if (resource.hasOwnProperty(language)) {
				return resource[language];
			}
			return resource[this.defaultLanguage];
		}
		return <any>resource;
	}

	measureScrollbar (): number {
		if (this.scrollbarWidth == null) {
			let scrollDiv = document.createElement("div");
			scrollDiv.className = "modal-scrollbar-measure";
			html.$body.append(scrollDiv);
			this.scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
			html.$body[0].removeChild(scrollDiv);
		}
		return this.scrollbarWidth;
	}
}
Platform.mixin({
	/**
	 * @observable-property {Boolean}
	 */
	printing: lang.Observable.accessor("printing"),
	/**
	 * @observable-property {String}
	 */
	language: lang.Observable.accessor("language"),
	/**
	 * @observable-property {Boolean}
	 */
	animation: lang.Observable.accessor("animation")

});
/**
 * Global instance of {Platform}. Available as `core.platform`.
 * @type {Platform}
 */
export const platform = new Platform(xconfig);

html.isMobileDevice = platform.isMobileDevice;

/**
 * Global wrapper for `window.localStorage` available as `core.localStorage`.
 * @type {Object}
 */
export const localStorage = {
	prefix: "",
	impl: window.localStorage,

	setItem: function (key: string, value: string): void {
		this.impl.setItem(this.prefix + key, value);
	},
	getItem: function (key: string): string {
		return this.impl.getItem(this.prefix + key);
	},
	removeItem: function (key: string): void {
		this.impl.removeItem(this.prefix + key);
	},

	// TODO: clear, length, key (with prefix)

	setObject: function (key: string, value: any): void {
		this.impl.setItem(this.prefix + key, JSON.stringify(value));
	},
	getObject: function (key: string): any {
		let value = this.impl.getItem(this.prefix + key);
		if (value) {
			try { value = JSON.parse(value); } catch (e) { }
			return value;
		}
		return null;
	},

	// NOTE: iterator should not add or remove keys in storage
	forEach: function (iterator: (val: any, key: string, ctx: any) => boolean|void, thisArg?: void): boolean {
		let that = this,
			func = function (): boolean {
				iterator.apply(this, arguments);
				return false;
			};
		return that.some(func, thisArg);
	},
	some: function (iterator: (val: any, key: string, ctx: any) => boolean|void, thisArg?: any): boolean {
		let that = this,
			l = this.impl.length,
			i,
			key,
			value;

		for (i = 0; i < l; i++) {
			key = this.impl.key(i);
			if (key && (!that.prefix || lang.stringStartsWith(key, that.prefix))) {
				value = this.impl.getItem(key);
				if (value) {
					try { value = JSON.parse(value); } catch (e) { }
				}
				if (that.prefix) { key = key.slice(that.prefix.length);	} // remove key prefix
				if (iterator.call(thisArg, value, key, that)) { return true; }
			}
		}
		return false;
	},

	setupPrefix: function (prefix: string): void {
		if (prefix && prefix.charAt(prefix.length - 1) !== "/") { prefix += "/"; }
		this.prefix = prefix;
	}
};
/**
 * Global wrapper for `core.localStorage` for working with application settings. It implements hierarchy of settings (bundle -> value).
 * @type {Object}
 */
export const settings = {
	store: localStorage,
	prefix: "settings",

	_getStoreKey: function (key: string): string {
		return this.prefix + "." + key;
	},
	getItem: function (fqname: string): string {
		let that = this,
			idx = fqname.indexOf("."),
			bundleName,
			bundle;
		if (idx > 0) {
			bundleName = fqname.slice(0, idx);
			bundle = that.getBundle(bundleName);
			if (bundle) {
				fqname = fqname.slice(idx + 1);
				return lang.nested(bundle, fqname);
			}
			return undefined;
		}
		return that.store.getItem(that._getStoreKey(fqname));
	},
	setItem: function(fqname: string, value: string): void {
		let that = this,
			idx = fqname.indexOf("."),
			bundleName,
			bundle,
			lastIdx,
			propName;

		if (idx > 0) {
			bundleName = fqname.slice(0, idx);
			bundle = that.getBundle(bundleName);
			if (!bundle) {
				bundle = {};
			}
			fqname = fqname.slice(idx + 1);
			lastIdx = fqname.lastIndexOf(".");
			if (lastIdx < 0) {
				// only one "." (e.g. "MyPart.SomeParam")
				bundle[fqname] = value;
			} else {
				// e.g. if fqname="MyPart.SomeGroup1.SubGroup2.SomeParam"
				propName = fqname.slice(lastIdx + 1);	// propName = "SomeParam"
				fqname = fqname.slice(0, lastIdx);		// fqname = "SomeGroup1.SubGroup2"
				let objValue = bundle;
				lang.forEach(fqname.split("."), (propName) => {
					if (!objValue.hasOwnProperty(propName))
						objValue = objValue[propName] = {};
					else
						objValue = objValue[propName];
				});
				objValue[propName] = value;
			}
			that.setBundle(bundleName, bundle);
		} else {
			value === undefined || value === null
				? that.store.removeItem(that._getStoreKey(fqname))
				: that.store.setItem(that._getStoreKey(fqname), value);
		}
	},

	/**
	 * @param {String} name
	 * @return {Object}
	 */
	getBundle: function (name: string): any {
		return this.store.getObject(this._getStoreKey(name));
	},
	/**
	 * @param {String} name
	 * @param {Object} bundle
	 */
	setBundle: function (name: string, bundle: Object): void {
		let that = this;
		if (!bundle) {
			that.store.removeItem(that._getStoreKey(name));
		} else {
			lang.traverseObject(bundle, function (name: string, value: any, path: string[], owner: Object, isObject: boolean): void {
				if (!isObject) {
					// remove empty primitive value
					if (value === "" || value === null || value === undefined) {
						delete owner[name];
					}
				} else {
					// remove empty object value
					if (lang.isEmptyObject(value)) {
						delete owner[name];
					}
				}
			}, {visitObjects: true, visitValues: true});
			if (lang.isEmptyObject(bundle)) {
				that.store.removeItem(that._getStoreKey(name));
			} else {
				that.store.setObject(that._getStoreKey(name), bundle);
			}
		}
	},

	clear: function (bundleName?: string): void {
		let that = this,
			test = bundleName ? that._getStoreKey(bundleName) : that.prefix,
			toDelete = [];
		that.store.forEach((value, key) => {
			if (lang.stringStartsWith(key, test)) {
				toDelete.push(key);
			}
		}, that);
		lang.forEach(toDelete, (key) => {
			that.store.removeItem(key);
		});
	},

	getBundleNames: function(): string[] {
		let that = this,
			names = [];
		that.store.forEach((value, key) => {
			let idx = key.indexOf(that.prefix);
			if (idx === 0) {
				names.push(key.slice(that.prefix.length + 1));
			}
		}, that);
		return names;
	}
};

/**
 *
 */
export class UserSettings extends lang.Observable implements IUserSettings {
	private __values: lang.Map<any>;
	private _propsOverrides: IUserSettings.PropsMap;
	private _initialized: boolean;

	suppressEvents: boolean;
	name: string;
	scope: UserSettings.Scope;

	/**
	 * @constructs UserSettings
	 * @extends Observable
	 * @memberOf! module:core
	 * @params {Object} [options] map with prop names and booleans where`false` means to ignore the property in bindToProp/attach
	 */
	constructor(options?: UserSettings.Options) {
		super();
		let that = this;
		that.__values = {};
		if (options) {
			that._propsOverrides = options.props;
			that.name = options.name;
			that.scope = options.scope;
		}
	}

	/**
	 * Change a property. Triggers "change" event with all values.
	 * @param {String} name
	 * @param value
	 */
	set(name: string, value: any): void {
		this.__values[name] = value;
		this.trigger("change", this, this.__values);
	}

	initialize(json: Object): void {
		let that = this;
		that.__values = json || {};
		that._initialized = true;

		if (json) {
			that.suppressEvents = true;
			try {
				lang.forEach(json, (value, name) => {
					if (that._propsOverrides && that._propsOverrides[name] === false) { return; }

					that.trigger("init:" + name, value);
				});
			} finally {
				that.suppressEvents = false;
			}
		}
	}

	/**
	 * Bind the instance to a property of an Observable object.
	 * On the property change we'll fire "change" event with all values.
	 * @param {Observable} owner
	 * @param {String} propName
	 */
	bindToProp(owner: lang.Observable, propName: string): void {
		let that = this;

		if (that._propsOverrides && that._propsOverrides[propName] === false) { return; }

		// prop -> settings (saving)
		owner.bind("change:" + propName, (sender, value) => {
			if (!that.suppressEvents) {
				that.set(propName, value);
			}
		});
		// settings -> prop (loading)
		that.bind("init:" + propName, (value) => {
			try {
				lang.set(owner, propName, value);
			} catch (e) {
				traceSource.warn("UserSettings: failed init for '" + propName + "': " + e + ". See the next error");
				console.error(e);
				lang.set(owner, propName, undefined);
			}
		});
		// binding after initialization
		if (that._initialized) {
			let value = that.__values[propName];
			if (value !== undefined) {
				try {
					lang.set(owner, propName, value);
				} catch (e) {
					traceSource.warn("UserSettings: failed init for '" + propName + "': " + e + ". See the next error");
					console.error(e);
					lang.set(owner, propName, undefined);
				}
			}
		}
	}

	/**
	 * Attach a nested part settings.
	 * @param {String} name name of nested part, will be used as setting name
	 * @param {UserSettings} nested
	 */
	attach(name: string, nested: IUserSettings): void {
		if (!nested) { return; }

		let that = this;
		let propOverride = that._propsOverrides && that._propsOverrides[name];

		if (propOverride === false) {
			return;
		} else if (lang.isObject(propOverride)) {
			nested.applyOverrides(propOverride as IUserSettings.PropsMap);
		}

		nested.bind("change", (sender, values) => {
			that.set(name, values);
		});
		that.bind("init:" + name, (values) => {
			nested.initialize(values);
		});
		// attaching after initialization
		if (that._initialized) {
			let values = that.__values[name];
			if (values) {
				nested.initialize(values);
			}
		}
	}

	applyOverrides(props: IUserSettings.PropsMap): void {
		this._propsOverrides  = lang.extendEx(this._propsOverrides || {}, props, {exact: true});
	}

	/**
	 * Attach settings store to the nested region.
	 * @param {String} name name of nested region, will be used as setting name
	 * @param {Region} region
	 */
	attachToRegion(name: string, region: composition.Region): void {
		let that = this;
		region.bind("usersettings.change", (sender, args: UserSettings.EventArgs) => {
			let regionValues = that.__values[name] || {};
			regionValues[args.part] = args.bundle;
			that.set(name, regionValues);
		});
		region.bind("usersettings.request", (sender, args: UserSettings.EventArgs) => {
			let regionValues = that.__values[name];
			if (regionValues) {
				args.bundle = regionValues[args.part];
			}
		});
	}

	getValues(): Object {
		return this.__values;
	}

	get(name: string): any {
		return this.__values[name];
	}

	/*bindAll(owner: lang.Observable): void {
		if (this._propsOverrides) {
			lang.forEach(this._propsOverrides, (enabled, propName) => {
				let field = this[propName];
				if (field && field.userSettings) {
					this.attach(propName, field.userSettings);
				} else {
					this.bindToProp(owner, propName);
				}
			});
		}
	}*/

	static create(options?: false | UserSettings.Options): IUserSettings {
		if (options === false)
			return null;

		return new UserSettings(options);
	}
}
export namespace UserSettings {
	export interface Options extends IUserSettings.Options { }
	export import PropsMap = IUserSettings.PropsMap;
	export import Scope = IUserSettings.Scope;
	export import EventArgs = IUserSettings.EventArgs;
}

export class UserSettingsStore extends lang.Observable implements IUserSettingsStore {
	bundleName: string;
	settings;

	/**
	 * @constructs UserSettingsStore
	 * @extends Observable
	 * @memberOf! module:core
	 */
	constructor (settings) {
		super();
		this.bundleName = "ui.userSettings";
		this.settings = settings;
	}

	/**
	 * Save part's user settings.
	 * @method
	 * @async-debounce throttle=100
	 * @param {Object} args
	 * @param {String} args.area area name
	 * @param {String} args.region region name
	 * @param {String} args.part part name
	 * @param {Object} args.bundle settings object
	 */
	@lang.decorators.constant(lang.debounce("_save", 100, "_saveTimer"))
	save: (args: UserSettings.EventArgs) => void;

	/**
	 * Save part's user settings.
	 * @param {Object} args
	 * @param {String} args.area
	 * @param {String} args.region
	 * @param {String} args.part
	 * @param {Object} args.bundle
	 */
	protected _save(args: UserSettings.EventArgs): void {
		let bundle = this.settings.getBundle(this.bundleName) || {};
		bundle[this._getKey(args.area, args.region, args.part, args.scope)] = args.bundle;
		this.settings.setBundle(this.bundleName, bundle);
	}

	/**
	 * Return user settings for part-in-region-in-area
	 * @param {Object} args
	 * @param {String} args.area Area name
	 * @param {String} args.region Region name
	 * @param {String} args.part Part name
	 * @returns {*}
	 */
	load(args: UserSettings.EventArgs): any {
		let bundle = this.settings.getBundle(this.bundleName);
		if (bundle) {
			return bundle[this._getKey(args.area, args.region, args.part, args.scope)];
		}
	}

	protected _getKey(area: string, region: string, part: string, scope: UserSettings.Scope): string {
		if (scope === "global")
			return part;
		return (area || "index") + "." + region + "." + part;
	}

	/**
	 * Remove user settings of all parts.
	 */
	clearAll(): void {
		this.settings.clear("ui.userSettings");
	}
}

/*
core.di = {
	importResolver: function (obj) {
		if (obj.imports) {
			lang.forEach(obj.imports, function (value, contract) {
				var impl = core.di.contracts[contract],
					accessor;
				if (impl) {
					impl = core.di._getInstance(impl);
					if (lang.isString(value)) {
						accessor = obj[value];
						if (lang.isString(accessor)) {
							obj[accessor] = impl;
						} else if (lang.isFunction(accessor)) {
							obj[accessor].call(obj, impl);
						}
					} else if (lang.isFunction(value)) {
						value.call(obj, impl);
					}
				}
			});

		}
	},
	defineContract: function (contract, impl) {
		core.di.contracts[contract] = impl;
	},
	_getInstance: function (impl) {
		return impl;
	},
	contracts: {}
};
lang.Class.importResolver = core.di.importResolver;
*/

let _moduleFactories: lang.Map<AppModuleFactoryFn> = {};

/**
 * @callback ModuleInitializer
 * @param {Application} app Application
 * @param {Object} options Module options
 * */

export interface IAppModule {
	initialize?: (app: Application) => void;
	handlers?: lang.Map<Function>;
}

export interface AppModuleFactoryFn {
	(app: Application, options?: any): void | IAppModule;
}

export function createModule (factoryFn: AppModuleFactoryFn): void
export function createModule (factoryFn: AppModuleFactoryFn, options: {modulesRegistry: lang.Map<AppModuleFactoryFn>}): void
export function createModule (moduleName: string, factoryFn: AppModuleFactoryFn): void
export function createModule (moduleName: string, factoryFn: AppModuleFactoryFn, options: {modulesRegistry: lang.Map<AppModuleFactoryFn>}): void
/**
 * Register a callback to be called on Application initialization.
 * Callback MAY return an object. If so then the object will be treated as a module.
 * The module MAY contain `initialize` method (which will be called immediately) and `handlers` field.
 * An object in `handlers` field is treated as map: field name is a Pub/Sub event name, its value is a callback.
 * @param {String} [moduleName] Optional module name.
 * @param {ModuleInitializer} factoryFn
 * @param {Object} [options]
 * @param {Object} [options.registry] Modules registry to use instead of global one (used by default)
 */
export function createModule (...args): void {
	let moduleName,
		callback,
		options,
		registry = _moduleFactories,
		fnIdx = 0;
	if (lang.isString(arguments[0])) {
		moduleName = arguments[0];
		fnIdx = 1;
	}
	callback = arguments[fnIdx];
	if (!callback) {
		throw "core.createModule: module callback function wasn't specified";
	}
	options = arguments[fnIdx+1];
	if (options && options.modulesRegistry) {
		registry = options.modulesRegistry;
	}
	if (!moduleName) {
		moduleName = "module-" + Object.keys(registry).length;
	} else if (registry[moduleName]) {
		moduleName = "module-" + moduleName + "-" + Object.keys(registry).length;
	}
	registry[moduleName] = (app, options) => {
		return callback(app, options);
	};
}


/**
 * @callback AreaModuleInitializer
 * @param {Application} app Application
 * @param {Area} area
 * @param {Object} options Module options
 */
export interface AppAreaModuleFactoryFn {
	(app: Application, area: composition.Area, options?: Object): any;
}

export function createAreaModule (factoryFn: AppAreaModuleFactoryFn): void
export function createAreaModule (factoryFn: AppAreaModuleFactoryFn, options: {modulesRegistry: lang.Map<AppModuleFactoryFn>}): void
export function createAreaModule (areaName: string, factoryFn: AppAreaModuleFactoryFn): void
export function createAreaModule (areaName: string, factoryFn: AppAreaModuleFactoryFn, options: {modulesRegistry: lang.Map<AppModuleFactoryFn>}): void
/**
 * Registers callback to be called on Application initialization.
 * Callback MAY return an object. If so then the object will be treated as a module.
 * @param {String} [areaName] Area name. If you need to register callback for a default area just omit this parameter
 * @param {AreaModuleInitializer} factoryFn A callback to be called on `initialized` event fired of the specified area
 * @param {Object} [options]
 * @param {Object} [options.registry] Modules registry to use instead of global one (used by default)
 */
export function createAreaModule (...args): void {
	let areaName = "",
		callback,
		moduleName,
		options,
		registry = _moduleFactories,
		fnIdx = 0;

	if (lang.isString(arguments[0])) {
		areaName = arguments[0];
		fnIdx = 1;
	}
	callback = arguments[fnIdx];
	if (!callback) { throw "core.createAreaModule: module callback function wasn't specified"; }

	options = arguments[fnIdx+1];
	if (options && options.modulesRegistry) {
		registry = options.modulesRegistry;
	}

	moduleName = areaName || "area-default";
	if (registry[moduleName]) {
		if (areaName) {
			moduleName = "area-" + areaName;
			if (registry[moduleName]) {
	moduleName = "module-" + areaName + "-" + Object.keys(registry).length;
			}
		} else {
			moduleName = "module-area-default-" + Object.keys(registry).length;
		}
	}
	registry[moduleName] = function (app: Application, options?: Object): void {
		let area = app.areaManager.getArea(areaName);
		if (!area) {
			// if the area doesn't exists allow Application to create it ad hoc
			area = app.onUnknownArea(areaName);
		}
		if (!area) { throw new Error("core.createAreaModule: area with name'" + areaName + "' doesn't exist"); }
		area.bind("initialized", () => {
			// TODO: here we don't support module-objects
			callback(app, area, options);
		});
	};
}

export interface ApplyStateOptions {
	start?: boolean;
	disablePushState?: boolean;
	fullSwitch?: boolean;
	doNotTouchAppState?: boolean;
}

export class AppStateManager extends lang.Observable implements IAppStateManager {
	/**
	 * Defaults for AppStateManager
	 * @type {Object}
	 * @property {String} defaultArea - name of default area in url ("index")
	 * @property {String} defaultState - name of default state in url ("default")
	 * @property {String} displayRoot - name of UI root url segment ("display")
	 * @property {String} goRoot - name of "go" url segment ("go")
	 */
	static defaultOptions: AppStateManager.Options = {
		defaultArea: "index",
		defaultState: "default",
		displayRoot: "display",
		goRoot: "go",
		execRoot: "exec"
	};
	options: AppStateManager.Options;
	app: Application;
	started: boolean;
	root: string;
	traceSource: diagnostics.TraceSource;
	private _pushing: boolean;
	private _startTimer: number;
	private _reRoutePattern: RegExp;
	/**
	 * Base title for the application (will the used for all areas/states)
	 * @observable-property {String}
	 */
	@lang.decorators.observableAccessor()
	baseTitle: lang.ObservableProperty<string>;

	/**
	 * @constructs AppStateManager
	 * @extends Observable
	 * @memberOf module:core
	 * @article [Navigation](docs:navigation)
	 * @param {Application} app
	 * @param {Object} [options]
	 */
	constructor (app: Application, options?: AppStateManager.Options) {
		super();
		let that = this;
		that.options = lang.appendEx(options || {}, AppStateManager.defaultOptions, { deep: true });
		that.app = app;
		that._pushing = false;	// this is ugly hack to prevent reacting on 'statechange' event on pushstate call
		that.started = false;
		that.traceSource = new diagnostics.TraceSource("core.AppStateManager");
		that.root = app.config.root || "/";
		that._reRoutePattern = new RegExp("^" + utils.combinePaths(that.root, "/(" + that.options.displayRoot + "|" + that.options.goRoot + "|" + that.options.execRoot + ")")
			.replace("/", "\/") + "\/([^/?]*)(?:\/([^/?]*)(?:\/([^?]*))?)?");

		that.baseTitle(Historyjs.options.initialTitle || document.title);
		that.bind("change:baseTitle", () => {
			let state = Historyjs.getState(/*friendly=*/true, /*create=*/true);
			state.title = that.getPageTitle(state.data);
			Historyjs.setTitle(state);
		});
		if (!app.config.disableHistory) {
			Historyjs.Adapter.bind(window, "statechange", () => {
				let starting = !that.started,
					state,
					task;
				if (that._startTimer) {
					window.clearTimeout(that._startTimer);
					that._startTimer = undefined;
				}
				that.started = true;
				if (!that._pushing) {
					// NOTE: фактически событие "statechange" генерируется когда юзер жмет back/forward в браузере
					// и если кто-то сделает History.pushState (минуя наш метод pushState)
					// Также событие генерируется при старте приложения в HTML4 браузерах, если url содержит хеш (см. метод start)

					that.traceSource.debug("window.statechange raised");
					state = Historyjs.getState(/*friendly=*/true, /*create=*/true);
					// NOTE: on back/forward the browser already changed url by itself,
					// so it makes no sense to ask components to compose an AppState and push it via pushState (as it'd do by default)
					// So here we're specifically disabling pushing state (doNotTouchAppState=true)
					// It also prevents replacing current url with an url restored
					task = that._applyState(state, {disablePushState: true, start: starting, doNotTouchAppState: true});

					if (task) {
						task.then( () => {
							let appState = state.data,
								url = appState && appState.url ? appState.url : that._getClientUrl(state);
							that.app.eventPublisher.publish("app.statechange", {state: appState, url: url});
						}, () => {
							// applying state was rejected, return previous state
							let idx = Historyjs.getCurrentIndex();
							if (idx > 0) {
								state = Historyjs.getStateByIndex(idx - 1);
								that.pushState(state.data);
							}
						});
					}
				}
			});
		}
	}

	protected _getClientUrl (state: HistoryState): string {
		// NOTE: getRootUrl return "/" ending, but we don't need it
		// WAS: ранее использовался hashedUrl
		return state.cleanUrl
			? state.cleanUrl.slice(Historyjs.getRootUrl().length - 1)
			: "/";
	}

	protected _parseRoute (route: string, ignoreUnknown: boolean): AppState {
		let that = this,
			//pattern_query = /^([^?\[]*)(?:\[([^\[]*)\])?(?:\?(.*))?$/,
			pattern_query = /\?([^#]*)/,
			result = that._reRoutePattern.exec(route),
			data,
			area, areaState, part;

		if (result) {
			// NOTE: result[0] - full url, result[1] - first part (display/go)
			if (result[1] === that.options.displayRoot) {
				// url like: display/
				area = result[2] || "";
				areaState = result[3] || "";
				part = result[4] || "";
			} else if (result[1] === that.options.goRoot) {
				// url like: go/
				area = "";
				areaState = "";
				part = result[2] || "";
			} else if (!ignoreUnknown && result[1] === that.options.execRoot) {
				// url like: exec/
				data = {
					command: {
						name: result[2]
					},
					route: that.removeRootFromUrl(route) || ""
				};
				// query string (parameters):
				result = pattern_query.exec(route);
				if (result) {
					if (result[1]) {
						data.command.args = utils.parseUriParams(result[1]);
					}
				}
				return data;
			}
			data = {
				area: area,
				areaState: { name: areaState },
				regionState: {
					part: part,
					title: "",
					partOptions: {}
				},
				route: that.removeRootFromUrl(route) || ""
			};
			if (data.route[data.route.length - 1] === "?") {
				data.route = data.route.slice(0, data.route.length - 1);
			}
			if (data.area === that.options.defaultArea) {
				data.area = "";
			}
			if (data.areaState.name === that.options.defaultState) {
				data.areaState.name = "";
			}
			// query string (parameters):
			result = pattern_query.exec(route);
			if (result) {
				if (result[1]) {
					data.regionState.partOptions = utils.parseUriParams(result[1]);
				}
			}
		} else {
			// check for root url ("", "/", "/app/", "/app"), optionally with query
			route = that.removeRootFromUrl(route);
			if (!route)
				return {};
			result = pattern_query.exec(route);
			if (result && result[1]) {
				// default app state but with query params
				data = {
					area: "",
					areaState: { name: "" },
					regionState: {
						part: "",
						title: "",
						partOptions: utils.parseUriParams(result[1])
					},
					route: route
				};
			} else if (!ignoreUnknown) {
				return that.onUnknownRoute(route);
			}
		}
		return data || {};
	}

	protected removeRootFromUrl(url: string): string {
		if (this.root === "/" && url && url[0] === "/") {
			return url.substring(1);
		}
		if (this.root && this.root.length > 1) {
			// not server root, but folder ("/app")
			if (url.indexOf(this.root) === 0) {
				return url.substring(this.root.length);
			}
			// NOTE: this.root has "/" at the end, but route could be without "/"
			let rootNoSlash = this.root.substring(0, this.root.length - 1);
			if (url.indexOf(rootNoSlash) === 0) {
				return url.substring(rootNoSlash.length);
			}
		}
		return url;
	}

	/**
	 * This method can be overridden for processing url custom commands.
	 * A custom command is a term in url "/term"..
	 * The method can return:
	 * 	- a `AppState` object to push (the simplest case is `{}` - go to app root).
	 *  - a Promise of `AppState` object
	 *  - empty (null/undefined) - do nothing, implementation should make pushState on its own
	 * @param {String} cmdName
	 * @param {String} route
	 * @param {Object} [cmdArgs]
	 * @returns {AppState}
	 */
	protected onCommand(cmdName: string, route: string, cmdArgs?: any): lang.Promisable<AppState> {
		// For implementers:
		// 	Here you can process custom command (cmdName) and return a new AppState where to go
		// 	or return null to stop processing the route (you should change App state on your own)
		return {};
	}

	/**
	 * This method can be overridden for processing custom url.
	 * Returning an empty object means "go to root".
	 * Custom app logic can override and process any custom url. In this case it should return null.
	 * @param {String} route
	 * @returns {AppState}
	 */
	protected onUnknownRoute(route: string): AppState {
		// For implementers:
		// 	empty object means "go to root".
		// 	Custom app logic can override and process any custom url. In this case it should return null
		return {};
	}

	start (): void {
		//if (this.app.config.disableHistory) { return; }
		let that = this,
			state = Historyjs.getState(true, true),
			isHistoryApiSupported = !Historyjs.emulated.pushState;

		if (that.started) { return; }

		if (that.traceSource.enabled("debug")) {
			that.traceSource.debug("[AppStateManager] start with state=" + JSON.stringify(state));
		}

		let extraPath = document.location.pathname.slice(that.app.config.root.length);
		// NOTE: "/ajax" and "/ajax/" are the same paths
		if (!isHistoryApiSupported && extraPath.length > 1 && !lang.stringStartsWith(extraPath, that.options.displayRoot + "/report/")) {
			// in HTML4 browser if path doesn't equal app root that means that the current url went from a HTML5 browser.
			// So we need to cut off this extra path as otherwise it'll stay forever.
			// e.g. "http://localhost/xfw3-ajax/display/index/groups" should become "http://localhost/xfw3-ajax/#display/index/groups"
			Historyjs.clearQueue();
			Historyjs.clearAllIntervals();
			document.location.href = utils.combinePaths(Historyjs.getRootUrl(), that.app.config.root) + "#" + extraPath + document.location.search;
			return;
		} else if (isHistoryApiSupported && lang.stringStartsWith(document.location.hash, "#" + that.options.displayRoot )) {
			// in HTML5 browser if path contains hash (#display) that means that the current url went from a HTML4 browser.
			// e.g. "http://localhost/xfw3-ajax/#display/index/groups" should become "http://localhost/xfw3-ajax/display/index/groups"
			Historyjs.clearQueue();
			Historyjs.clearAllIntervals();
			document.location.href = utils.combinePaths(Historyjs.getRootUrl(), that.app.config.root) + document.location.hash.slice(1);
			return;
		}

		// NOTE: in HTML4 browsers here we have "hashed" state (not normalized),
		// so it shouldn't be used. But in HTML4 browsers there will be 'statechange' event later (if url has hash)
		// And in its handler we'll get normalized state.
		// So we're ignoring state for HTML4 browsers if it's not empty (has some hash):
		// i.e.: if (HTML5 or not-hashed-url)
		// Unfortunately detecting "empty" state isn't easy. History.js can return "hashed" for root url -
		// e.g. cleanUrl="http://example.org/myapp/", but hashedUrl="http://example.org/myapp/?&_suid=13..95"
		// Also as state here isn't normalized so any hashed url will be cleanUrl ("http://localhost/ajax/#display/index/groups")
		if (isHistoryApiSupported || (state.hashedUrl === state.cleanUrl && state.cleanUrl.indexOf("#") < 0)) {
			that.started = true;
			Historyjs.setTitle(state);
			that._applyState(state, {disablePushState: true, start: true});
		} else {
			// Here we hope that 'statechange' will fire shortly
			// but we can be wrong (History.js is buggy), so schedule a timer to guarantee the app started
			that._startTimer = window.setTimeout( () => {
				that._startTimer = undefined;
				if (that.started) { return; }

				let state = Historyjs.getState(true, true);
				that.traceSource.warn("[AppStateManager] start: state was treated as non-empty but 'statechange' event hasn't fired, url=" + state.url);
				that.started = true;
				Historyjs.setTitle(state);
				that._applyState(state, {disablePushState: true, start: true});
			}, 2000);
		}
	}

	protected _getStateTitle (state: AppState): string {
		return (state.regionState ? state.regionState.title : null) || (state.areaState ? state.areaState.title : null) || null;
	}

	getPageTitle (state: AppState): string {
		let that = this,
			title = that._getStateTitle(state);
		title = (title ? title + " - " : "") + that.baseTitle();
		return title;
	}

	/**
	 * Update current browser url, serializing specified state into the url
	 * @param {AppState} state Current application state
	 * @param {Object} options
	 * @param {Boolean} [options.replaceState] Pass true if you want to replace the current url with the new one without adding record into browser history.
	 * @param {Boolean} [options.freezeUrl] do not change URL while pushing the new AppState
	 */
	pushState (state: AppState, options?: {replaceState?: boolean; freezeUrl?: boolean;} ): void {
		if (this.app.config.disableHistory) { return; }
		if (!this.started) { return; }
		if (!state) { throw new Error("AppStateManager.pushState: state should not be null"); }

		let that = this,
			title = that.getPageTitle(state),
			url;
		options = options || {};
		if (options.freezeUrl) {
			let curState = Historyjs.getState(/*friendly*/true, /*create*/true);
			// NOTE: a trick: put current state into special field which is analyzed in 'start' method
			// i.e. on page reload AppStateManager will use state from _reloadState, but on 'backward' in browser
			// new ('state') state will be used.
			if (curState.data) {
				state._reloadState = curState.data._reloadState || curState.data;
			}
			url = that._getClientUrl(curState);
		} else if (state.url) {
			url = state.url;
		} else {
			url = that.getStateUrl(state);
		}
		state.url = url;

		if (that.traceSource.enabled("debug")) {
			that.traceSource.debug("pushState: mode=" +
				(options.freezeUrl ? "pushWithFreeze" :
				options.replaceState ? "replaceState" : "pushState") +
				", url=" + url + ", state=" + JSON.stringify(state) + ", title=" + title);
		}

		// NOTE: History.pushState/replaceState manually fires 'statechange' event
		// but we don't want it when pushing state - that's because we're setting the _pushing flag.
		that._pushing = true;
		try {
//				if (options.removePrevious) {
//					TODO: так не работает, т.к. back асинхронный
//					Historyjs.back(false);
//					Historyjs.replaceState(state, title, url, /*queue*/true)
//				} else {
//				}
			options.replaceState
				? Historyjs.replaceState(state, title, url, /*queue*/false)
				: Historyjs.pushState(state, title, url, /*queue*/false);
		}
		catch (e) {
			console.log(e);
		}
		finally {
			that._pushing = false;
		}

		that.app.eventPublisher.publish("app.statechange", {state: state, url: url});
	}

	/**
	 * Replace current browser url, serializing specified state into the url
	 * @param {AppState} state Current application state
	 */
	replaceState (state: AppState): void {
		this.pushState(state, {replaceState: true});
	}

	/**
	 * Switch current state of application without deactivating current area state if it's same as the new one.
	 * @param {AppState} state A new application state
	 * @returns {Promise}
	 */
	applyState (state: AppState): Promise<void> {
		return this._applyState({data: state}, {disablePushState: false});
	}

	/**
	 * Switch current state of application. Also change the browser URL.
	 * It makes 'full switch', i.e. deactivate current area state even if it's the same in the new state.
	 * @param {AppState} state A new application state
	 * @returns {Promise}
	 */
	switchState (state: AppState): Promise<void> {
		return this._applyState({data: state}, {fullSwitch: true, disablePushState: false});
	}

	/**
	 * @param state
	 * @param options
	 * @returns {JQueryPromise}
	 * @private
	 */
	private _applyState (state: {data: AppState}| HistoryState, options: ApplyStateOptions): Promise<void> {
		let that = this,
			appState: AppState,
			route;
		if (that.traceSource.enabled("debug")) {
			that.traceSource.debug("[AppStateManager] _applyState: enter with state: " + JSON.stringify(state));
		}
		if (!state.data || lang.isEmptyObject(state.data)) {
			route = that._getClientUrl(<HistoryState>state);
			that.traceSource.debug("[AppStateManager] _applyState: parsed route from state: " + route);
			appState = that._parseRoute(route, false);
			// state restored from Url will not contain title - we need to get them
		} else {
			appState = state.data || {};
			// NOTE: the state from state.data could be loaded from cache (as result of page refresh),
			// and it may not relate to current url (in route). If this happens it will be processed in Area.activateState

			if (appState._reloadState && options && options.start) {
				appState = appState._reloadState;
			}
		}
		that.traceSource.debug(() => { return "[AppStateManager] _applyState: applying appState: " + JSON.stringify(state); });
		if (appState === null) {
			// NOTE: appState === null means that it was not parsed in parseRoute,
			// but it was processed in onUnknownRoute (otherwise it'd be equal {})
			return null;
		}
		if (appState.command) {
			return that._execUrlCommand(appState, options);
		}
		return that._applyAppState(appState, options);
	}

	protected _execUrlCommand(appState: AppState, options: ApplyStateOptions): Promise<void> {
		let that = this;
		let res = that.onCommand(appState.command.name, appState.route, appState.command.args);
		if (lang.isPromise(res)) {
			return res.then((res) => {
				if (res) {
					//that.pushState(res, {replaceState: true});
					return that._applyAppState(res, options);
				}
			});
		} else {
			if (res) {
				//that.pushState(res, {replaceState: true});
				return that._applyAppState(res, options);
			}
			return lang.resolved();
		}
	}

	private _applyAppState (state: AppState, options: ApplyStateOptions): Promise<void> {
		var that = this,
			areaManager = that.app.areaManager,
			stateName = "",
			area,
			areaName = "",
			areaState;

		if (state) {
			areaName = state.area;
			stateName = (state.areaState ? state.areaState.name : "");
			areaState = {
				name: stateName,
				regionState: state.regionState
			};
		}
		// options.state = state;
		if (that.app.config.isDebug) {
			return areaManager.activateState(areaName, areaState, options);
		} else {
			try {
				return areaManager.activateState(areaName, areaState, options);
			} catch (e) {
				// if something bad happened fallback to root state
				that.traceSource.log(e.message);
				// TODO: why "start"?
				that.app.eventPublisher.publish("app.start.fail",
					SystemEvent.create({
						kind: SystemEvent.Kind.notification,
						message: "Application navigation error: " + e.message,
						severity: "warning",
						priority: "high"
					})
				);
				// we failed to activate a state or part in some area (we're sure that the area exists),
				// fallback to its default state (and cut off part)
				// TODO: NOTE: we could keep part name for the case if it's correct but only state is incorrect
				area = areaManager.getArea(areaName);
				if (area) {
					stateName = area.getDefaultState();
				} else {
					areaName = "";
					stateName = "";
				}
				return areaManager.activateState(areaName, stateName);
			}
		}
	}

	getAreaUrl (areaName: string): string {
		return this.getAreaStateUrl(areaName, null);
	}

	getAreaStateUrl (areaName: string, stateName: string): string {
		var that = this,
			url;
		areaName = areaName || that.options.defaultArea;
		stateName =  stateName || that.options.defaultState;
		if (stateName !== that.options.defaultState) {
			url = "/" + that.options.displayRoot + "/" + areaName + "/" + encodeURIComponent(stateName) ;
		} else if (areaName !== that.options.defaultArea) {
			url = "/" + that.options.displayRoot + "/" + areaName;
		} else {
			url = "/";
		}
		if (that.root.charAt(that.root.length - 1) === "/") {
			url = url.slice(1);
		}
		url = that.root + url;
		return url;
	}

	getStateUrl (state: AppState): string {
		var that = this,
			url = "",
			regionUrl = "",
			query = "",
			areaName,
			stateName;
		/*
			/
			/display/index/
			/display/index/state1
			/display/index/default/mypart1
			/display/area1
			/display/area1/default/mypart1
			/display/area1/state1/mypart1
			/display/area1/state1/mypart1?partArg1=value1
			/display/area1/state1?partArg1=value1
			/?partArg1=value1
		 */
		if (state.regionState) {
			if (!state.isDefaultPart && state.regionState.part) {
				if (typeof state.regionState.part === "string") {
					regionUrl = <string>state.regionState.part;
				} else {
					regionUrl = (<IPart>state.regionState.part).name;
				}
			}
			// TODO: allow part to customize its options presentation in url
			if (state.regionState.partOptions) {
				query = utils.buildUriParams(state.regionState.partOptions);
				if (query) {
					query = "?" + query;
				}
			}
			if (regionUrl) {
				url = "/" + regionUrl;
			}
			if (query) {
				url += query;
			}
		}
		areaName = state.area || that.options.defaultArea || null;
		stateName =  (state.areaState ? (state.areaState.isDefault ? null : state.areaState.name) : null)
			|| that.options.defaultState;
		if (url || (stateName !== that.options.defaultState)) {
			url = "/display/" + areaName + "/" + encodeURIComponent(stateName) + url;
		} else if (areaName !== that.options.defaultArea) {
			url = "/display/" + areaName;
		} else {
			url = "/";
		}
		if (that.root.charAt(that.root.length - 1) === "/") {
			url = url.slice(1);
		}
		return that.root + url;
	}

	/**
	 * Return current application state
	 * @returns {AppState}
	 */
	getCurrentState(): AppState {
		let state = Historyjs.getState(/*friendly*/true, /*create*/false),
			appState: AppState;
		if (!state || !state.data || lang.isEmptyObject(state.data)) {
			let route = this._getClientUrl(Historyjs.getState(/*friendly*/true, /*create*/true));
			appState = this._parseRoute(route, true);
		} else {
			appState = state.data;
		}
		return appState;
		/* БЫЛО ТАК (почему?):
		var route = this._getClientUrl(Historyjs.getState(true, true));
		return this._parseRoute(route);
		*/
	}

	getPreviousState(): AppState {
		let idx = Historyjs.getCurrentIndex(),
			state;
		if (idx > 0) {
			state = Historyjs.getStateByIndex(idx-1);
			if (state) {
				return state.data;
			}
		}
	}

	/*simulateBack: function () {
		var that = this;
		that._pushing = true;
		//Historyjs.back();
		Historyjs.back(false);
		that._pushing = false;
	}*/
}
namespace AppStateManager {
	export interface Options {
		defaultArea: string;
		defaultState: string;
		displayRoot: string;
		goRoot: string;
		execRoot: string;
	}
}
AppStateManager.mixin({
	defaultOptions: AppStateManager.defaultOptions
});

export class Application implements IApplication {
	static defaultOptions: Application.Options = {
		EventPublisher: events.EventPublisher,
		AreaManager: composition.AreaManager,
		StateManager: AppStateManager,
		UserSettingsStore: UserSettingsStore,
	};
	static current: Application;
	config: XConfig;
	options: Application.Options;
	/**
	 * Domain model of Application.
	 * @type {IDomainModel} */
	model: IDomainModel;
	/**
	 * Data Facade
	 * @type {DataFacade} */
	dataFacade: IDataFacade;
	rootElement: HTMLElement;
	$rootElement: JQuery;
	initContainerElement: JQuery;
	/**
	 * Global publish/subscriber.
	 * @type {EventPublisher} */
	eventPublisher: events.EventPublisher;
	/**
	 * Manager all areas.
	 * @type {AreaManager} */
	areaManager: composition.AreaManager;
	/**
	 * Manage application state via URL.
	 * @type {AppStateManager} */
	stateManager: AppStateManager;
	/**
	 * Store of parts settings.
	 * @type {UserSettingsStore} */
	userSettingsStore: UserSettingsStore;
	sysMenu: SystemMenu;

	/**
	 * @constructs Application
	 * @memberOf module:core
	 * @param {XConfig} config XConfig object placed on the page on the server
	 * @param {Object} [options]
	 * @param {String|Function} [options.template] Template of the application page for client-side rendering
	 * @param {Boolean} options.ignoreModules If specified then Application won't use modules registry on its initialization
	 * @param {Object} options.modulesRegistry
	 */
	constructor (config: XConfig, options?: Application.Options) {
		let that = this;

		that.options = lang.appendEx(options || {}, Application.defaultOptions, { deep: true });
		// set up global static singleton instance
		Application.current = that;

		that.config = config || { root: "/"};
		that.config.root = that.config.root || "/";
		that.config.apiroot = that.config.apiroot || that.config.root;

		if (that.config.root === "/" && location.hostname === "localhost") {
			// it's a local dev app, like "localhost:21267/"
			localStorage.setupPrefix(that.config.appName);
		} else {
			localStorage.setupPrefix(that.config.root);
		}

		let diagLevel = settings.getItem(diagnostics.defaultLevelKey);
		if (diagLevel !== undefined) {
			diagnostics.setDefaultLevel(diagLevel);
		}

		that.createComponents();

		let dataFacade = that.options.dataFacade;
		if (!lang.isPromise(dataFacade)) {
			that.dataFacade = dataFacade;
		}
	}

	protected createComponents(): void {
		let that = this;

		// events.EventPublisher)();
		that.eventPublisher = new that.options.EventPublisher();
		let compositionSettings = settings.getBundle("composition");
		//new composition.AreaManager(that, compositionSettings && compositionSettings.debug ? { debug: compositionSettings.debug } : null);
		that.areaManager = new that.options.AreaManager(that, compositionSettings && compositionSettings.debug ? { debug: compositionSettings.debug } : null);
		//new AppStateManager(that);
		that.stateManager = new that.options.StateManager(that);
		// new UserSettingsStore
		that.userSettingsStore = new that.options.UserSettingsStore(settings);
	}

	/** @deprecated use Application.State */
	static States: typeof Application.State;

	/** @deprecated use Application.State */
	states: typeof Application.State;

	preinitialize (): void {}

	/**
	 * Initialization state. It happens after all modules initialized.
	 * @return {Promise} If implementation returns a promise then next stage (post-initialization) will be postponed till it resolved.
	 */
	initialize (): void|Promise<void> {}

	/**
	 * Post-initialization stage (latest). It happens after AppStateManager applied current state from url.
	 * Publishes pub/sub "app.start" event.
	 */
	postinitialize (): void {
		this.stateManager.start();
		this.eventPublisher.start();
	}

	/**
	 * @param {Object} [options]
	 * @param {boolean} [options.connected] Subscribe on DataFacade's 'update' event
	 * @returns {UnitOfWork}
	 */
	createUnitOfWork (options?: UnitOfWork.Options): UnitOfWork {
		let model = this.model;
		return new model.UnitOfWork(this.dataFacade, options);
	}

	/**
	 * Initialize the application: initialize areas and its regions from markup, initialize modules, start AppStateManager
	 * @param {jQuery|HTMLElement} rootElement
	 */
	run (rootElement?: JQuery|HTMLElement): Promise<void> {
		return this._run(rootElement).fail(e => {
			this._onStateChanged(Application.States.failed, e);
		});
	}

	@lang.decorators.asyncSafe
	protected _run (rootElement?: JQuery|HTMLElement): Promise<void> {
		let that = this;

		if (!that.dataFacade) {
			return lang.async.then(that.createDataFacade(), dataFacade => {
				that.dataFacade = dataFacade;
				return that._run1(rootElement);
			});
		}

		return that._run1(rootElement);
	}

	@lang.decorators.asyncSafe
	protected _run1 (rootElement?: JQuery|HTMLElement): Promise<void> {
		let that = this;

		that.eventPublisher.subscribe("interop.server_version_changed", (ev: SystemVersionChangedEvent) => {
			if (ev.args && ev.args.newVersion) {
				that.updateAppVersion(ev.args.newVersion);
			}
		});

		// Initialize root element
		if (!rootElement) {
			rootElement = $(".x-app-root");
			if ((<any>rootElement).length === 0) {
				rootElement = document.body;
			}
		} else if ((<any>rootElement).length === 0) {
			throw new Error("Application.run: rootElement cannot be an empty array");
		}
		if ((<any>rootElement).length) {
			rootElement = rootElement[0];
		}
		that.rootElement = <HTMLElement>rootElement;
		that.$rootElement = $(rootElement);

		// Initialize container for app state reporting
		that.initContainerElement = that.$rootElement.find(".x-app-init-container");
		if (that.initContainerElement.length) {
			that.initContainerElement = that.initContainerElement.clone();
		}

		// Initialize dataFacade
		let dataFacade = that.dataFacade;
		if (dataFacade && !dataFacade.eventPublisher) {
			dataFacade.setEventPublisher(that.eventPublisher);
		}

		that.preinitialize();

		if (that.options.template) {
			new View({template: that.options.template, viewModel: that}).render(that.rootElement);
		}
		// Initialize Areas
		that._initAreas();

		// Initialize app modules
		that._initModules();

		let initTask = that.initialize();

		$window.bind("beforeunload", () => {
			if ($("body").hasClass("modal-open")) {
				$(".modal").remove();
				$(".modal-backdrop").remove();
			}

			lang.forEach(that.areaManager.getAreas(), (area: composition.Area) => {
				area.regionManager.unloadAll({suppressUI: true, reason: "windowUnload"});

				that._onStateChanged("unloading");
			});
		});

		return lang.async.then(initTask, lang.async.wrap(() => {
			that._onStateChanged("initialized");

			that.postinitialize();

			that._onStateChanged("started");
		}));
	}

	createDataFacade(): IDataFacade|Promise<IDataFacade> {
		let that = this,
			dataFacade = that.options.dataFacade;
		if (dataFacade) {
			// option `dataFacade` is specified - return it
			return dataFacade;
		}

		if (interop) {
			const DataFacade = interop.DataFacade;
			const BackendInterop = interop.BackendInterop;
			if (DataFacade && BackendInterop) {
				return DataFacade.create(BackendInterop.create(that.config), that.eventPublisher);
			}
		}
	}

	/**
	 * @param {String} state
	 * @param {Error} [error]
	 * @private
	 */
	protected _onStateChanged (state: Application.State, error?: any): void{
		let that = this,
			args = {state: state, error: undefined};

		if (state === "failed") {
			args.error = error;
			if (error) {
				console.error(error);
				if (error.stack) {
					console.debug(error.stack);
				}
			} else {
				console.error("Application initialization error");
			}
		}

		that.onAppStateChanged(args);
	}

	/**
	 * Create Area objects from DOM markup and add them to the areaManager.
	 * @private
	 */
	protected _initAreas (): void {
		let that = this,
			areasContainer: JQuery = that.$rootElement.find(".x-areas-container"),
			defaultAreaName,
			$areas: JQuery;
		areasContainer = areasContainer.length ? areasContainer : that.$rootElement;
		// set up parent element for all areas
		that.areaManager.areasContainer = areasContainer;

		$areas = areasContainer.filter(".x-area").add(".x-area", areasContainer.get(0));
		if ($areas.length > 0) {
			$areas.each(function(): void {
				let areaName = $(this).attr("data-area") || this.id,
					options = lang.parseJsonString($(this).attr("data-area-options")) || {},
					area = that.areaManager.createArea(areaName, this, options);
				if (!areaName || options.isDefault) {
					if (defaultAreaName !== undefined) {
						throw new Error("core.Application.run: found several unnamed areas but only one is permitted");
					}
					defaultAreaName = areaName || "";
				}
			});
			if (defaultAreaName === undefined) {
				defaultAreaName = that.areaManager.getAreas()[0].name || "";
			}
		} else {
			// no areas found in markup, let's create a default area
			let area = that.onUnknownArea("");
			defaultAreaName = area.name || "";
		}
		that.areaManager.setDefaultArea(defaultAreaName);
	}

	/**
	 * Initialize app modules registered via `core.createAppModule` and `core.createAreaModule` methods.
	 * @private
	 */
	protected _initModules (): void {
		let that = this;
		if (!that.options.ignoreModules) {
			let registry = that.options.modulesRegistry || _moduleFactories;
			lang.forEach(registry, (moduleFactory: AppModuleFactoryFn, name: string) => {
				let moduleOptions;
				if (that.config && that.config.modules) {
					moduleOptions = that.config.modules[name];
				}
				let moduleVar = moduleFactory(that, moduleOptions);
				// NOTE: `module` can be a callback or an object with `initialize` method
				if (moduleVar) {
					let module = <IAppModule>moduleVar;
					if (module.initialize) {
						module.initialize(that);
					}
					// Events Auto-Wiring
					if (module.handlers) {
						lang.forEach(module.handlers, function(handler: string|Function, eventName: string): void {
							if (lang.isString(handler)) {
								if (!module.hasOwnProperty(<string>handler)) {
									throw new Error("Application.run: can't find handler '" + handler + "' of event '" + eventName + "'");
								}
								handler = module[<string>handler];
							}
							that.eventPublisher.subscribe(eventName, (<Function>handler).bind(module));
						});
					}
				}
			});
		}
	}

	/**
	 * Register part factory.
	 * @param {String} partName Name of the part. It will be used to create part via createPart method.
	 * @param {Function} creator
	 */
	registerPart (partName: string, creator: (options?: any) => IPart): void {
		registerPart(partName, creator);
	}

	/**
	 * Create a part instance.
	 * @param {String} partName Name of the part
	 * @param {Object} [options] Options to pass to part's constructor
	 * @returns {Part}
	 */
	createPart (partName: string, options?: any): IPart {
		return createPart(partName, options);
	}

	/**
	 * Creates a dialog
	 * @param {Object} [options] Options to pass to dialog's constructor
	 * @returns {Dialog}
	 */
	createDialog(options: any): IDialog {
		return ui.Dialog.create(options);
	}

	/**
	 * Return all registered parts names.
	 * @returns {String[]}
	 */
	getAllPartNames (): string[] {
		return Object.keys(_partFactories);
	}

	updateAppVersion (ver: string): void {
		this.config.software = this.config.software || { appVersion: undefined };
		this.config.software.appVersion = ver;
	}

	protected onAppStateChanged (args: Application.StateChangedArgs): void {
		let that = this;
		switch (args.state) {
			case "loading":
				that.onLoading();
				break;
			case "failed":
				that.onFailed(args.error);
				break;
			case "initialized":
				that.onInitialized();
				break;
			case "started":
				that.onStarted();
				break;
			case "unloading":
				that.onUnloading();
				break;
		}
	}

	protected onLoading (): void {
		let that = this;
		$(that.rootElement).empty();
		if (that.initContainerElement) {
			that.initContainerElement.appendTo(that.rootElement);
		}
	}

	protected onUnloading (): void {
		$(".x-app-init-container").remove();
		$(this.rootElement).empty();
		this.eventPublisher.publish("app.unload");
	}

	protected onInitialized (): void {
		$(".x-app-init-container").remove();
		$(this.rootElement).show();
	}

	protected onStarted (): void {}

	protected onFailed (error: Error): void {
		let that = this,
			$root = $(that.rootElement || ".x-app-root"),
			message = resources["application_init_failed"] + "...";
		if ($root.length === 0) {
			$root = $("body");
		}
		$root.empty().show().addClass("x-app-root--failed");

		let $container = $("<div class='x-app-init-container'></div>").appendTo($root);
		$("<h2 class='x-app-init-message'><div class='x-app-init-message-smile'>:(</div>" + message + "</h2>").appendTo($container);
		// if (that.config.isDebug) { // show the error somewhere }
		console.warn(error);
	}

	onUnknownArea (areaName: string): composition.Area {
		let that = this,
			area = that.areaManager.createArea(areaName);
		area.regionManager.createRegion("main", {navigable: true});
		return area;
	}
}
export namespace Application {
	export interface Options {
		template?: HandlebarsTemplateDelegate;
		modulesRegistry?: lang.Map<AppModuleFactoryFn>;
		ignoreModules?: boolean;
		dataFacade?: IDataFacade|lang.Promise<IDataFacade>;
		EventPublisher?: {new (): events.EventPublisher};
		AreaManager?: {new (app: IApplication, options?: composition.AreaManager.Options): composition.AreaManager};
		StateManager?: {new (app: IApplication, options?: AppStateManager.Options): AppStateManager};
		UserSettingsStore?: {new (settings): UserSettingsStore};
	}

	export const State = {
		loading: "loading" as "loading",
		initialized: "initialized" as "initialized" ,
		started: "started" as "started" ,
		failed: "failed" as "failed",
		unloading: "unloading" as "unloading"
	};
	export type State = (typeof State)[keyof typeof State];

	export interface StateChangedArgs {
		state: Application.State;
		error?: Error;
	}
}
// backward compatibility:
Application.prototype.states = Application.State;
Application.States = Application.State;

let _partFactories = {};
/**
 * Register a part factory.
 * @param {String} partName Part name
 * @param {Function} creator Function to be called when part creation requested (see core.createPart)
 */
export function registerPart(partName: string, creator: (options?: any) => IPart): void {
	if (!creator) {
		throw new Error("core.registerPart: part '" + partName + "' has no factory method");
	}
	_partFactories[partName] = creator;
}

/**
 * Create an instance of part
 * @param {String} partName name of the part
 * @param {Object} [options] parameters of part's constructor
 * @returns {Part}
 */
export function createPart(partName: string, options?: any): IPart {
	let i = 1,
		ctor = _partFactories[partName],
		names,
		name;

	if (!ctor) {
		names = partName.split(":");
		for (; i < names.length; i++) {
			name = names.slice(0, names.length - i).join(":");
			ctor = _partFactories[name];
			if (ctor) {
				(options || (options = {})).urlSuffix = names.slice(-i).join(":");
				break;
			}
		}
	} else {
		// there's a factory for {partName} name, but to keep things consistent add urlSuffix as well
		let idx = partName.indexOf(":");
		if (idx > 0) {
			(options || (options = {})).urlSuffix = partName.substring(idx + 1);
		}
	}
	if (!ctor) {
		throw eth.unknownPart(partName);
	}

	let part = ctor(options);
	if (!part) {
		throw new Error("core.createPart: factory method of part '" + partName + "' didn't return a part instance");
	}
	part.name = partName;

	return part;
}

View.Handlebars.registerHelper("part", function () {
	let options = arguments[arguments.length - 1],
		markup = new View.ChildViewMarkup(options),
		hash = options.hash,
		partName = hash.name,
		className = hash["class"],
		viewModel = hash.hasOwnProperty("viewModel") ? hash.viewModel : this,
		partArgs: any[],
		partOptions,
		partFactory;

	if (arguments.length > 1) {
		// pass all args except the last one (which is options) into part's ctor
		partArgs = lang.concatExceptLast.apply(null, arguments);
	} else {
		// Old style: take part's arguments from helper's hash
		partOptions = markup.getHash();
		// But we have some reserved properties which cannot be used as part's arguments (name, class, viewModel):
		delete partOptions.name;
		delete partOptions["class"];
		delete partOptions.viewModel;
		utils.parseObject(partOptions);

		partArgs = [ partOptions ];
	}

	partFactory = function () {
		let part;
		if (className) {
			partArgs.unshift(null, className); // `core` is used as `rootNamespace` by default
			part = lang.Class.create.apply(null, partArgs);
			part.name = partName || part.name;
		} else if (partName) {
			partArgs.unshift(partName);
			part = createPart.apply(null, partArgs);
		}

		if (!part) {
			throw new Error("Can't create part. You should specify option 'class' or 'name'.");
		}

		if (viewModel && part.setViewModel) {
			part.setViewModel(viewModel);
		}
		return part;
	};

	markup.registerPendingChild(partFactory);
	return markup.getHtml();
});

/**
 * @deprecated Use 'part' helper
 */
View.Handlebars.registerHelper("view", View.Handlebars.helpers["part"]);

View.Handlebars.registerHelper("xconfig", function (name) {
	let value = Application.current.config[name] || "";
	return new View.Handlebars.SafeString(lang.encodeHtml(value));
});

View.Handlebars.registerHelper("res", function (name) {
	let value = resources[name];
	return new View.Handlebars.SafeString(value);
});

View.Handlebars.registerHelper("if-feature", function (name, options) {
	// TODO add core.platform.features?
	if (platform.modernizr[name]) {
		return options.fn(this);
	} else {
		return options.inverse(this);
	}
});

ui.getWaitingIconClass = function (size) {
	let cssClass = "x-icon x-icon-waiting x-icon-anim-rotating";
	if (size) {
		cssClass += " x-icon-" + size;
	}
	return cssClass;
};
if (!platform.modernizr.cssanimations) {
	// if css3 animations isn't supported (i.e. IE <= 9),
	// then there should be classes 'x-img-waiting-*' available from common.ie.css
	ui.getWaitingIconClass = function (size) {
		return "x-img-waiting-" + (size || 16);
	};
}

View.Handlebars.registerHelper("waiting-icon", function (options) {
	let size = options.hash.size || 48,
		cssClass = options.hash.cssClass,
		html = "<div class='" + ui.getWaitingIconClass(size) + (cssClass ? (" " + cssClass) : "") + "'></div>";
	return new View.Handlebars.SafeString(html);
});

/**
 * Handlebars-helper "waiting-large".
 */
View.Handlebars.registerHelper("waiting-large", function (options) {
	let hash = options && options.hash,
		text = hash && (hash.res && resources[hash.res] || hash.text) || resources["loading"],
		html = "<div class='x-waiting-container x-waiting-container-large'>" +
			"<div class='" + ui.getWaitingIconClass(48) + "'></div>" +
			"<h4>" + lang.encodeHtml(text) + "</h4>" +
			"</div>";
	return new View.Handlebars.SafeString(html);
});

View.Handlebars.registerHelper("bootstrap-severity-class", function (severity, options) {
	let bsSeverity = severity || "info";
	// change our "error" to bootstrap "danger"
	bsSeverity === "error" && (bsSeverity = "danger");
	return new View.Handlebars.SafeString((options.hash.prefix || "label") + "-" + bsSeverity);
});


//severity-icon
View.Handlebars.registerHelper("severity-icon", function (severity) {
	let icoClass;
	let color;
	switch (severity) {
		case "critical":
		case "error":
			icoClass = "x-icon-warning-triangle2";
			color = "#d9534f";
			break;
		case "warning":
			icoClass = "x-icon-warning";
			color = "#f0ad4e";
			break;
		case "success":
			icoClass = "x-icon-ok";
			color = "#5cb85c";
			break;
		default :
			icoClass = "x-icon-info2";
			color = "#5bc0de";
			break;
	}
	return new View.Handlebars.SafeString("<span class='x-icon " + icoClass + "' style='color: " + color + "'></span>");
});

View.Handlebars.registerHelper("notification-icon", function () {
	let that = this,
		icoClass,
		color = "grey";
	if (!that.kind || that.kind === SystemEvent.Kind.notification) {
		/*
		NOTE: colors was got from bootstrap variables:
			@brand-primary:         #428bca;
			@brand-success:         #5cb85c;
			@brand-info:            #5bc0de;
			@brand-warning:         #f0ad4e;
			@brand-danger:          #d9534f;
		 */
		switch (that.severity) {
			case "error":
				icoClass = "x-icon-warning-triangle2";
				color = "#d9534f";
				break;
			case "warning":
				icoClass = "x-icon-warning";
				color = "#f0ad4e";
				break;
			case "success":
				icoClass = "x-icon-ok";
				color = "#5cb85c";
				break;
			default :
				icoClass = "x-icon-info2";
				color = "#5bc0de";
				break;
		}
		if (that.state() === "archived") {
			color = "grey";
		}
	} else if (that.kind === "process") {
		icoClass = "x-icon-lightning";
		color = "#428bca";
	}

	return new View.Handlebars.SafeString("<span class='x-icon " + icoClass + "' style='color: " + color + "'></span>");
});

View.Handlebars.registerHelper("mailto", function (address) {
	/* USAGE: {{mailto "address@example.com"}} */
	return new View.Handlebars.SafeString(
		"<a href='mailto:" + address + "' onclick='window.preventWindowUnload()'>" + address + "</a>"
	);
});

function clientLinkBind(target: View.HelperTarget, appState: AppState, $root: JQuery) {
	let app = Application.current;
	if (!app) {
		console.warn("clientLinkBind: no Application found");
		return;
	}

	let $element = View.findElement(target, $root);
	if ($element.is("a")) {
		$element.attr("href", app.stateManager.getStateUrl(appState));
	}

	let cmd = commands.createCommand({
		execute: args => {
			app.stateManager.applyState(args.appState);
		}
	});
	binding.commandBind($element, cmd, {appState: appState});
}
View.Handlebars.registerHelper("link", function(context: any, options: View.HelperOptions) {
	if (arguments.length === 1) {
		options = context;
		context = null;
	}
	let markup = new View.HelperMarkup(options);
	/*
	 USAGE:
	 <a {{link part="UserInfo" area="admin" areaState="users" partOptions=(object type="User")}}>Go to</a>
	 * */
	let hash = <any>markup.getHash();
	let appState: AppState = {
		area: hash.area,
		areaState: {
			name: hash.areaState
		},
		regionState: {
			part: hash.part,
			partOptions: hash.partOptions
		}
	};
	View.addCallback(options.data, clientLinkBind, [markup.target, appState]);
	if (arguments.length === 1) {
		return markup.getHtml();
	}
	return new View.Handlebars.SafeString("<a " + markup.getHtml().toString() + ">" + context + "</a>");
});
