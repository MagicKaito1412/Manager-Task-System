import lang = require("lib/core.lang");

/**
 * @exports "core.diagnostics"
 */

export enum levels {
	off = 0,
	error = 1,
	warn = 2,
	info = 3,
	trace = 4,
	debug = 5
}

/**
 * Global registry of class->level mappings
 * @private
 */
const _traceSources: lang.Map<levels> = {};

export let defaultLevel  = levels.trace;

export const defaultLevelKey = "diagnostics.tracing.defaultLevel";

export function setSourceLevel(className: string, level: string|levels): void {
	if (lang.isString(level)) {
		level = levels[level];
	}
	_traceSources[className] = <levels>level;
}

export function setDefaultLevel(level: levels|string|number): void {
	let lv;
	if (level !== undefined) {
		lv = lang.isString(level) ? levels[level] : level;
		defaultLevel = lv;
	}
}

export function getSourceLevel(className: string): levels {
	return lang.coalesce(_traceSources[className], defaultLevel);
}

export class TraceSource {
	className: string;
	name: string;
	private _level: levels;

	/**
	 * @constructs TraceSource
	 * @param {String} [className] class/category name of the source
	 * @param {String} [name] name of the instance (to distinguish several sources of the same class)
	 */
	constructor(className: string, name?: string) {
		let that = this;
		that.className = className || "";
		that.name = name;
		_traceSources[className] || (_traceSources[className] = undefined);
	}

	enabled(level: string|levels): boolean {
		// debug (5) -> trace (4) -> info (3) -> warn (2) -> error (1) -> off (0)
		let that = this;
		if (lang.isString(level)) {
			level = levels[level];
		}
		if (that._level !== undefined) {
			return (level <= that._level);
		}
		if (!that.className) {
			return false;
		}
		// lookup in the global registry
		return (level <= getSourceLevel(that.className));
	}

	_writeIf (level: levels, methodName: string, originalArgs): void {
		let that = this,
			console = window.console,
			args,
			method;
		if (console && that.enabled(level)) {
			method = console[methodName] || console.log;
			if (method) {
				if (originalArgs.length === 1 && lang.isFunction(originalArgs[0])) {
					args = [originalArgs[0]()];
				} else {
					args = originalArgs;
				}
				if (args.length > 0 && lang.isString(args[0])) {
					args[0] = that.className + (that.name ? "[" + that.name + "]" : "") + ": " + args[0];
				} else  {
					console.log(methodName + ": " + that.className + (that.name ? "[" + that.name + "]" : "") + " - see the following message:");
				}
				method.apply(console, args);
			}
		}
	}

	setLevel(level: levels): void {
		this._level = level;
	}

	log(...args): void {
		this._writeIf(levels.trace, "log", args);
	}

	debug(...args): void {
		this._writeIf(levels.debug, "debug", args);
	}

	info(...args): void {
		this._writeIf(levels.info, "info", args);
	}

	warn(...args): void {
		this._writeIf(levels.warn, "warn", args);
	}

	error(...args): void {
		this._writeIf(levels.error, "error", args);
	}

	time(...args): void {
		this._writeIf(levels.debug, "time", args);
	}

	timeEnd(...args): void {
		this._writeIf(levels.debug, "timeEnd", args);
	}
}
