import lang = require("lib/core.lang");
import binding = require("lib/binding");

class Filter extends lang.Observable {
	protected _restrictions: lang.ObservableDictionary;
	protected _disposes: lang.Map<lang.IDisposable>;

	/**
	 * @class Filter
	 * @extends Observable
	 * @param items
	 */
	constructor(items) {
		super();
		let that = this;

		that._disposes = {};
		that._restrictions = new lang.ObservableDictionary();

		items && that.addRange(items);

		that._restrictions.bind("itemChange", that._onRestrictionsChange, that);
		that._restrictions.bind("itemsChange", that._onRestrictionsChange, that);
	}

	protected _onRestrictionsChange(sender, args) {
		this.trigger("change", this, args);
	}

	set(map): void {
		this._restrictions.reset(map);
	}

	add(name, expr): void {
		var that = this,
			bindable,
			v;

		// TODO так себе проверка на bindable
		(bindable = (expr && (
			lang.isFunction(expr.onchange) ||
			lang.isFunction(expr.set) ||
			lang.isFunction(expr.get)))
		) || (v = expr);

		(typeof expr === "function") && (v = expr());
		that._restrictions.add(name, v);
		bindable && (that._disposes[name] = binding.databind(binding.domain(that._restrictions, name), expr));
	}

	addRange(items): void {
		lang.forEach(items, (val: any, name: string) => {
			this.add(name, val);
		});
	}

	remove(name: string): void {
		let that = this,
			d = that._disposes[name];
		if (lang.isDisposable(d)) {
			d.dispose();
			delete that._disposes[name];
		}
		that._restrictions.remove(name);
	}

	clear(): void {
		this._clearDisposes();
		this._restrictions.clear();
	}

	protected _clearDisposes() {
		lang.forEach(this._disposes, (d) => {
			if (lang.isDisposable(d)) {
				d.dispose();
			}
		});
	}

	dispose(): void {
		var that = this;
		that._clearDisposes();
		that._restrictions.unbind("itemChange", null, that);
		that._restrictions.unbind("itemsChange", null, that);
		that._restrictions.dispose();
	}

	toJson() {
		return this._restrictions.all();
	}
}

export = Filter;