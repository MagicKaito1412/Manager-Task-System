import lang = require("lib/core.lang");
import resources = require("i18n!lib/nls/resources");
import moment = require("moment");
import utils = require("lib/utils");

import { metadata } from "lib/domain/.domain";
import PropertyMeta = metadata.PropertyMeta;
import EnumMeta = metadata.EnumMeta;
import ValueType = metadata.ValueType;

export interface SafeHtml {
	toHTML(): string;
}
class SafeHtmlImpl implements SafeHtml {
	protected text: string;
	protected html: string;

	/**
	 * @constructs SafeHtml
	 * @param {String} html
	 * @param {String} text
	 * @constructor
	 */
	constructor (html: string, text: string) {
		this.text = text;
		this.html = html;
	}

	/**
	 * Get html text.
	 * Handlebars also checks method `toHTML` to detect SafeString object.
	 * So class `SafeHtml` can be used in Handlebars templates to present HTML.
	 * @returns {string}
	 */
	toHTML(): string {
		return "" + this.html;
	}

	/**
	 * Get text with stripped out html.
	 * @returns {string}
	 */
	toString(): string {
		return "" + (this.text !== undefined ? this.text : lang.htmlText(this.html));
	}
}

export interface FormatOptions {
	vt?: ValueType;
	formatter?: (v: any) => string | SafeHtml;
	formatterHtml?: (v: any) => string;
	formatterName?: string;
	html?: boolean;
}

export type IPropFormatter = (propMeta: FormatOptions, value: any) => string;

/**
 * Returns default function-formatter for prop metadata.
 * @param {Object} propMeta a property metadata
 * @return {Function} A function that accepts two arguments (propMeta,value) and return a formatted string (`fn(propMeta, value):string`)
 */
export function getDefaultFormatter(propMeta: FormatOptions): IPropFormatter {
	switch (propMeta.vt) {
		case "ui1":
		case "i2":
		case "i4":
		case "i8":
		case "float":
		case "double":
		case "decimal":
			return number;
		case "date":
		case "time":
		case "dateTime":
		case "timeTz":
		case "dateTimeTz":
			return dateTime;
		case "boolean":
			return boolean;
		case "enum":
			return enumeration;
		case "timeSpan":
			return timeSpan;
	}
}
export function getDefaultFormatterHtml(propMeta: FormatOptions): IPropFormatter {
	if (propMeta.vt === "smallBin") {
		return binaryAsHtmlImage;
	}
}
export function binaryAsHtmlImage(propMeta: PropertyMeta, value: any): string {
	if (propMeta["contentType"] === "image") {
		let dataUrl = "data:image;base64," + value;
		return "<img src='" + dataUrl  + "'>";
	}
}

export function enumeration(propMeta: PropertyMeta, value: any): string {
	return (<EnumMeta>propMeta.ref).formatValue(value);
}

export let defaultFormats = {
	// localized moment's formats, see http://momentjs.com/docs/#/displaying/format/
	"date": "L",
	"time": "LT",
	"dateTime": "L LT",
	"timeTz": "LT Z",
	"dateTimeTz": "L LT Z",
	"timeSpan": "dhm"
};

export function dateTime(propMeta: PropertyMeta, value: any): string {
	if (value) {
		let format = propMeta.format || defaultFormats[propMeta.vt];
		value = moment(value).format(format);
	}
	return value;
}

export function boolean(propMeta: PropertyMeta, value: any): string {
	if (value == null) { return ""; }
	return value ? resources.yes : resources.no;
}

export function timeSpan(propMeta: PropertyMeta, value: any): string {
	let formatted = value,
		parsed,
		unit;

	parsed = utils.splitDuration(value, propMeta.format || defaultFormats[propMeta.vt]);
	if (parsed) {
		formatted = "";
		for (unit in parsed) {
			if (parsed.hasOwnProperty(unit)) {
				formatted += parsed[unit] + resources["timeSpan." + unit] + " ";
			}
		}
	}

	return formatted;
}

export function number(propMeta: PropertyMeta, value: any): string {
	// NOTE: у Number.toString есть параметр radix, поэтому явно вызываем toString без параметром,
	// чтобы случайно не передать в formatPropValue значение formatterName,
	// кроме того вызов Number.toString.call(2, "") сломается в IE8
	return value ? value.toString() : value;
}

/**
 * Format arbitrary object's property value.
 * @param {Object} propMeta metadata of the prop
 * @param {*} propValue property value to format
 * @return {String} formatted property value
 */
export function formatPropValue(propMeta: FormatOptions, propValue: any): string | SafeHtml {
	if (propValue == null) { return ""; }
	if (!propMeta) { return "" + propValue; }

	// NOTE: during model initialization default formatters were set for all properties (see domain.js:postprocessEntity)
	let formatter = propMeta.formatter;
	if (lang.isFunction(formatter)) {
		return formatter(propValue);
	}
	// NOTE: в propMeta.formatter должно быть тоже самое, что возвращает  getDefaultFormatter
	// 	(только обернутое в функцию для подставления метаданных свойства),
	//	но на случай, если нас вызывают не для метасвойства типа, а, например, для редактора кастомного свойства,
	// 	получим форматтер еще раз (по типу свойства vt)
	let metaFormatter = getDefaultFormatter(propMeta);
	if (lang.isFunction(metaFormatter)) {
		return metaFormatter(propMeta, propValue);
	}
	if (propMeta.html) {
		metaFormatter = getDefaultFormatterHtml(propMeta);
		if (lang.isFunction(metaFormatter)) {
			// явно заданна опция html - используем дефолтный html0форматтер для свойства,
			// html-форматтер возвратает html-текст, но результате метода formatPropValue воспринимается как текст,
			// который надо энкодить (unsafe), поэтому обернем его в safeHtml.
			return safeHtml(metaFormatter(propMeta, propValue));
		}
	}

	return propValue.toString(propMeta.formatterName || propMeta.formatter);
}

/**
 * Format prop value as HTML using html-formatters (from propMeta or default for vartype).
 * Important: you can use this function without additional html encoding (e.g. {{{formatPropHtml}}} in template)
 * as it encode all prop values if there's no html-formatter specified.
 * If there's a html-formatter then there will be no html-encoding - it's totally up to the formatter.
 * @param {Object} propMeta
 * @param {any} propValue
 * @returns {string}
 */
export function formatPropHtml(propMeta: FormatOptions, propValue: any): string {
	if (!propMeta || propValue == null) {
		return "";
	}
	if (propMeta.html === false) {
		// html-форматирование явно отключено
		return lang.encodeHtml(formatPropValue(propMeta, propValue).toString());
	}
	let formatterHtml = propMeta.formatterHtml;
	if (lang.isFunction(formatterHtml)) {
		// явно заданный html-форматтер для свойства
		return formatterHtml(propValue);
	}
	let metaFormatter = getDefaultFormatterHtml(propMeta);
	if (lang.isFunction(metaFormatter)) {
		// явно заданный html-форматтер для свойства
		return metaFormatter(propMeta, propValue);
	}
	// иначе используем текстовое представление
	// Т.к. данная функция возвращает html, то логично, что она может использоваться
	// в шаблоне без дополнительно html-энкодинга: {{{formatPropHtml}}}
	// Но, если мы выводим значение string/text свойств, то это очень опасно,
	// т.к. содержимое может быть html-кодом - имеем XSS.
	// Поэтому, при отсутствии явного html-форматтера, содержимое свойства мы явно энкодим.
	// Исключение составляет случай, если текст-форматтер вернул SafeHtml
	let val = formatPropValue(propMeta, propValue);
	if (!val) { return ""; }
	if (isHtml(val)) {
		return val.toHTML();
	}
	return textAsHtml(val.toString());
}

export function isHtml(str: any): str is SafeHtml {
	return !!(str && str.toHTML);
}

export function safeHtml(html: string, text?: string): SafeHtml {
	return new SafeHtmlImpl(html, text);
}

/**
 * Format a string for displaying as html. This includes encoding all special symbols ('<', '>') and
 * converting some symbols into html entities (space - &nbps, '&' - &amp;).
 * @param {String} text
 * @param {Boolean} whitespaces - encode spaces as &nbsp;
 * @returns {string}
 */
export function textAsHtml(text: string, whitespaces?: boolean): string {
	text = lang.encodeHtml(text, whitespaces);
	// TODO: iconize emoji (or something else)
	//if (col.iconizeEmoji)
	//	return twemoji.parse(text, {size: 16});
	return text;
}
