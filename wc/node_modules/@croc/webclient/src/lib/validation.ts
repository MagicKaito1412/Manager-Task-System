import lang = require("lib/core.lang");
import utils = require("lib/utils");
import formatters = require("lib/formatters");
import datetimes = require("lib/utils/datetimes");
import moment = require("moment");
import Big = require("big");
import resources = require("i18n!lib/nls/resources");

import { IDomainObject, metadata } from "lib/domain/.domain";
import ValueType = metadata.ValueType;
import PropertyMetaRuntime = metadata.PropertyMetaRuntime;
import PropertyMetaBase = metadata.PropertyMetaBase;
import EnumMeta = metadata.EnumMeta;
import SafeHtml = formatters.SafeHtml;
import PropertyMeta = metadata.PropertyMeta;


// -------------------------- PARSERS -----------------------------------------

export interface ParseResult {
	parsedValue?: any;
	errorMsg?: any;
}

export interface Parser {
	tryParse(propMeta: PropertyMetaBase, v: any, skipValidation?: boolean): ParseResult;
}

export interface NumberParser extends Parser {
	minValue: number;
	maxValue: number;
}
export interface BigNumberParser extends Parser {
	minValue: Big;
	maxValue: Big;
	minValueUnsafe?: Number;
	maxValueUnsafe?: Number;
}
interface AnyParser extends Parser {
	[key: string]: any;
}

function checkNumberRange(v: number, minValue: number, maxValue: number): ParseResult {
	if (minValue !== undefined && v < minValue) {
		return {
			errorMsg: formatters.safeHtml(
				resources["validation.minValue"] + "<nobr>" + utils.formatNumber(minValue) + "</nobr>"
			)
		};
	}
	if (maxValue !== undefined && v > maxValue) {
		return {
			errorMsg: formatters.safeHtml(
				resources["validation.maxValue"] + "<nobr>" + utils.formatNumber(maxValue) + "</nobr>"
			)
		};
	}
}
function checkBigNumberRange(v: Big, minValue: Big, maxValue: Big): ParseResult {
	if (minValue !== undefined && v.lt(minValue)) {
		return {
			errorMsg: formatters.safeHtml(
				resources["validation.minValue"] + "<nobr>" + utils.formatNumber(minValue.toString()) + "</nobr>"
			)
		};
	}
	if (maxValue !== undefined && v.gt(maxValue)) {
		return {
			errorMsg: formatters.safeHtml(
				resources["validation.maxValue"] + "<nobr>" + utils.formatNumber(maxValue.toString()) + "</nobr>"
			)
		};
	}
}
/**
 * Number comparer supporting Number and Big.
 */
export let NumberComparer = {
	lt: function(l: number|Big|string, r: number|Big|string): boolean {
		if (lang.isNumber(l) && lang.isNumber(r)) {
			return l < r;
		}
		else if (l instanceof Big && r instanceof Big) {
			return l.lt(r);
		}
		// strings? parse them
		return new Big(l).lt(r);
	},
	lte: function(l: number|Big|string, r: number|Big|string): boolean {
		if (lang.isNumber(l) && lang.isNumber(r)) {
			return l <= r;
		}
		else if (l instanceof Big && r instanceof Big) {
			return l.lte(r);
		}
		// strings? parse them
		return new Big(l).lte(r);
	},
	gt: function(l: number|Big|string, r: number|Big|string): boolean {
		if (lang.isNumber(l) && lang.isNumber(r)) {
			return l > r;
		}
		else if (l instanceof Big && r instanceof Big) {
			return l.gt(r);
		}
		// strings? parse them
		return new Big(l).gt(r);

	},
	gte: function(l: number|Big|string, r: number|Big|string): boolean {
		if (lang.isNumber(l) && lang.isNumber(r)) {
			return l >= r;
		}
		else if (l instanceof Big && r instanceof Big) {
			return l.gte(r);
		}
		// strings? parse them
		return new Big(l).gte(r);
	}
};

function tryParseFloat(v: any, minValue: number, maxValue: number, skipValidation?: boolean): ParseResult {
	let parsed: number = v === "" ? null : parseFloat(v);
	if (isNaN(parsed)) {
		return { errorMsg: resources["validation.number"] };
	}

	let res: ParseResult = { parsedValue: parsed };
	if (res.parsedValue && !skipValidation) {
		// it's an integer, check its range
		res = checkNumberRange(res.parsedValue, minValue, maxValue) || res;
	}
	return res;
}

function tryParseInteger(v: any, minValue: number, maxValue: number, skipValidation?: boolean): ParseResult {
	// NOTE parseInt can change value: "1.2" => 1, "1A" => 1, "A" => NaN,
	let parsed: number = v === "" ? null : parseInt(v, 10);
	if (!isFinite(parsed)) {
		// i.e. if Nan, Infinity, -Infinity
		return { errorMsg: resources["validation.integer"] };
	}

	let res: ParseResult = { parsedValue: parsed };
	if (res.parsedValue && !skipValidation) {
		// it's an integer, check its range
		res = checkNumberRange(res.parsedValue, minValue, maxValue) || res;
	}
	return res;
}

function tryParseBigInteger(v: any, minValue: Big, maxValue: Big, skipValidation?: boolean): ParseResult {
	let parsed: Big;
	if (v instanceof Big) {
		parsed = v;
	} else {
		try {
			// TODO: получается, мы для i8 всегда создаем Big,
			// возможно нужна опция, которая бы говорила "создавать Big только для больших значений"
			parsed = new Big(v);
		} catch (ex) {
			return { errorMsg: resources["validation.number"] };
		}
	}
	let res;
	if (!skipValidation) {
		res = checkBigNumberRange(parsed, minValue, maxValue);
	}
	return res || { parsedValue: parsed };
}

function tryParseDecimal(v: any, minValue: Big, maxValue: Big, skipValidation?: boolean): ParseResult {
	let parsed: Big;
	if (v instanceof Big) {
		parsed = v;
	} else {
		try {
			// TODO: получается, мы для i8 всегда создаем Big,
			// возможно нужна опция, которая бы говорила "создавать Big только для больших значений"
			parsed = new Big(v);
		} catch (ex) {
			return { errorMsg: resources["validation.number"] };
		}
	}
	let res;
	if (!skipValidation) {
		res = checkBigNumberRange(parsed, minValue, maxValue);
	}
	return res || { parsedValue: parsed };
}

const parserDateTime: Parser = {
	tryParse: function (propMeta: PropertyMetaBase, v: any): ParseResult {
		let vt = propMeta.vt;
		try {
			let parsed: Date;
			if (lang.isDate(v) && isFinite(v.valueOf())) {
				parsed = v;
			} else if (lang.isString(v)) {
				parsed = datetimes.parseISOString(v, /*isGlobalTime*/ vt === "timeTz" || vt === "dateTimeTz");
			} else if (lang.isNumber(v)) {
				parsed = new Date(v);
			}

			if (parsed && isFinite(parsed.valueOf())) {
				if (vt === "time") {
					parsed = new Date(1900, 0, 1, parsed.getHours(), parsed.getMinutes(), parsed.getSeconds(), parsed.getMilliseconds());
				} else if (vt === "timeTz") {
					// при отбрасывании даты меняется зона, скорректируем время на эту разницу
					let offsetDelta = (parsed.getTimezoneOffset() - new Date(1900, 0, 1).getTimezoneOffset());
					if (offsetDelta !== 0) {
						let hours = parsed.getHours(),
							minutes = parsed.getMinutes();
						minutes = minutes + (offsetDelta % 60);
						hours = hours + (offsetDelta - offsetDelta % 60) / 60;
						parsed = new Date(1900, 0, 1, hours, minutes, parsed.getSeconds(), parsed.getMilliseconds());
					} else {
						parsed = new Date(1900, 0, 1, parsed.getHours(), parsed.getMinutes(), parsed.getSeconds(), parsed.getMilliseconds());
					}
				} else if (vt === "date") {
					parsed = new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
				}
				return {
					parsedValue: parsed
				};
			}
			return { errorMsg: resources["validation.dateTime"] };
		} catch (e) {
			// TODO
			return { errorMsg: resources["validation.dateTimeFormat"] };
		}
	}
};

const parserEnum: Parser = {
	tryParse: function (propMeta: PropertyMetaRuntime, v: any, skipValidation: boolean): ParseResult {
		let result: ParseResult = {},
			parsed = 0,
			canParse: boolean,
			enumMeta = propMeta["ref"] as EnumMeta,
			members = enumMeta.members,
			valueParser = getParser(enumMeta.vt || "i4"),
			// TODO: TS2345: Argument of type 'EnumMeta' is not assignable to parameter of type 'PropertyMeta'.
			parsedVal = valueParser.tryParse(enumMeta as any, v, skipValidation);

		if (!parsedVal.errorMsg) {
			result.parsedValue = parsedVal.parsedValue;
		} else if (lang.coalesce(propMeta["flags"], enumMeta.flags)) {
			canParse = (typeof v === "string") && v.trim().split(",").every(function (vName) {
					vName = vName.trim();
					if (members.hasOwnProperty(vName)) {
						parsed = parsed | members[vName].value;
						return true;
					}
					return false;
				});
			if (canParse) {
				result.parsedValue = parsed;
			} else {
				result.errorMsg = "Can't parse value '" + v + "' for flags '" + propMeta.name + "'";
			}
		} else {
			if (typeof v === "string") {
				let member = members[v];
				if (!member) {
					member = lang.find(members, m => m.descr === v);
				}
				if (member) {
					result.parsedValue = member.value;
				}
			}
			if (!result.hasOwnProperty("parsedValue")) {
				result.errorMsg = "Can't parse value '" + v + "' for enum '" + propMeta.name + "'";
			}
		}
		return result;
	}
};

const parserString: Parser = {
	tryParse: function (propMeta: PropertyMetaBase, v: any): ParseResult {
		if (v == null) {
			// null|undefined - return undefined (or any other falsy value) to use original value
			return;
		}
		if (!lang.isString(v)) {
			v = v.toString();
		}
		return {
			parsedValue: v ? v.trim() : ""
		};
	}
};

const parserTimespan: Parser = {
	tryParse: function (propMeta: PropertyMetaBase, v: any): ParseResult {
		// TimeSpan value can be in the following formats:
		// * number (double) - milliseconds
		// * .NET System.TimeSpan:  "[ws][-]{ d | [d.]hh:mm[:ss[.ff]] }[ws]"
		// * ISO_8601 (XSD duration): "PnYnMnDTnHnMnS" (https://en.wikipedia.org/wiki/ISO_8601#Time_intervals)
		// NOTE: .NET-сервер возвращает number.
		let duration: moment.Duration;
		//duration = moment.duration(v);

		if (lang.isNumber(v)) {
			// NOTE: we need Number parsing (not Big) but without min/max
			return tryParseInteger(v, undefined, undefined);
			// if Big support needed: return parsers.i8.tryParse(propMeta, v);
		} else if (lang.isString(v)) {
			duration = moment.duration(v);
			// TODO: нет признак о том, что значение было распаршено (типа moment.isValid)
		} else if (moment.isDuration(v)) {
			duration = v;
		} else {
			return { errorMsg: resources["validation.timeSpan"] };
		}

		// Now we have a Duration object, normalize it as milliseconds from "zero date" (1900-01-01)
		// NOTE: moment add mutates the object, so we have to construct base dates ("zero") every time
		v = moment("1900-01-01").add(duration).diff(moment("1900-01-01"));

		return {
			parsedValue: v
		};
	}
};

export interface ParserMap {
	[vt: string]: AnyParser;
	ui1?: NumberParser;
	i2?: NumberParser;
	i4?: NumberParser;
	i8?: BigNumberParser;
	float?: NumberParser;
	double?: NumberParser;
	decimal?: BigNumberParser;
	date?: Parser;
	time?: Parser;
	dateTime?: Parser;
	timeTz?: Parser;
	dateTimeTz?: Parser;
	string?: Parser;
	text?: Parser;
	boolean?: Parser;
	uuid?: Parser;
	timeSpan?: Parser;
	"enum"?: Parser;
}

/**
 * Property value parsers.
 */
export const parsers: ParserMap = {
	ui1: {
		minValue: 0,
		maxValue: 255,
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseInteger(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	i2: {
		minValue: -32768,
		maxValue: 32767,
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseInteger(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	i4: {
		minValue: -2147483648,
		maxValue: 2147483647,
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseInteger(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	i8: {
		minValue: new Big("-9223372036854775808"),
		maxValue: new Big("9223372036854775807"),
		minValueUnsafe: -9223372036854775808,
		maxValueUnsafe: 9223372036854775807,
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			if (propMeta.useNumber) {
				// отключена поддержка Big - всегда Number, может быть потеря точности
				return tryParseInteger(v, this.minValueUnsafe, this.maxValueUnsafe, skipValidation);
			}
			return tryParseBigInteger(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	float: {
		minValue: -3.40282347E+38,
		maxValue: 3.40282347E+38,
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseFloat(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	double: {
		minValue: -1.7976931348623157E+308, // same as -Number.MAX_VALUE (not Number.MIN_VALUE 5e-324!)
		maxValue: 1.7976931348623157E+308,	// same as Number.MAX_VALUE
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseFloat(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	decimal: {
		minValue: new Big("-79228162514264337593543950335"),
		maxValue: new Big("79228162514264337593543950335"),
		minValueUnsafe: -79228162514264337593543950335,
		maxValueUnsafe: 79228162514264337593543950335,
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			if (propMeta.useNumber) {
				// отключена поддержка Big - всегда Number, может быть потеря точности
				return tryParseFloat(v, this.minValueUnsafe, this.maxValueUnsafe, skipValidation);
			}
			return tryParseDecimal(v, this.minValue, this.maxValue, skipValidation);
		}
	},
	/**
	 * @deprecated
	 */
	integer: {
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseInteger(v, this.minValue, this.maxValue, skipValidation);
		},
		message: resources["validation.integer"]
	} as AnyParser,
	/**
	 * @deprecated
	 */
	number: {
		tryParse(propMeta: PropertyMetaBase, v: any, skipValidation: boolean): ParseResult {
			return tryParseFloat(v, this.minValue, this.maxValue, skipValidation);
		},
		message: resources["validation.number"]
	},
	date: parserDateTime,
	time: parserDateTime,
	dateTime: parserDateTime,
	timeTz: parserDateTime,
	dateTimeTz: parserDateTime,
	"enum": parserEnum,
	/**
	 * @deprecated Use 'enum' member
	 */
	enumeration: parserEnum, // backward compatibility
	string: parserString,
	text: parserString,
	boolean: {
		tryParse(propMeta: PropertyMetaBase, v: any): ParseResult {
			if (v === false || v === 0 || v === "0" || v === "false") {
				// false, 0, "0", "false"
				return { parsedValue: false };
			} else if (!v) {
				// "", null, undefined, NaN etc.
				return { parsedValue: null };
			}
			// everything else (including " ")
			return { parsedValue: true };
		}
	},
	uuid: {
		tryParse(propMeta: PropertyMetaBase, v: any): ParseResult {
			if (utils.isGuid(v)) {
				return { parsedValue: v };
			}
		}
	},
	timeSpan: parserTimespan
};

/**
 * Returns parser for VarType
 * @param {String} vt Primitive property type
 */
export function getParser(vt: ValueType): Parser {
	return parsers[vt];
}

// backward compatibility
parsers["getParser"] = getParser as any;


// -------------------------- FACETS ------------------------------------------

export interface Violation {
	error?: string|SafeHtml;
	props?: string[];
	object?: any;
	severity?: ViolationSeverity;
	description?: string;
	/**
	 * Name of rule which generates this violation
	 */
	rule?: string;
}
export type ViolationSeverity = "critical" | "error" | "warning" | "info";

export interface Rule {
	name?: string;
	validate(v: any, propMeta: PropertyMetaRuntime): Violation|string;
}

export interface RuleFormatting extends Rule {
	/**
	 * Formats an error message. Can be used in 'validate" method.
	 * @param message
	 * @param propMeta
	 */
	format(message: string, propMeta: PropertyMetaRuntime): string;
}

export interface RuleMap extends lang.Map<Rule> {
	nullable?: Rule;
}

export interface ObjectRule {
	validate(v: any): Violation|string;
}

function parseDateFacet(propMeta: PropertyMetaRuntime, facetName: string): any {
	let val = propMeta[facetName],
		parseResult = getParser(propMeta.vt).tryParse(propMeta, val, false);
	if (parseResult) {
		if (parseResult.errorMsg) {
			throw new Error("Incorrect '" + facetName + "' facet definition for prop '" + propMeta.name + "'. " + parseResult.errorMsg);
		}
		if (parseResult.parsedValue !== undefined) {
			val = parseResult.parsedValue;
		}
	}
	return val;
}

function formatDateTime(date: any, propMeta: PropertyMetaRuntime): string {
	return formatters.formatPropValue(propMeta, new Date(date)).toString();
}

function format(message: string, propMeta: PropertyMetaRuntime): string {
	return (propMeta.descr || propMeta.name)+ ": " + message;
}

/**
 * Property facets
 */
export const facets: RuleMap = {
	maxLen: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (v && v.length > propMeta.maxLen) {
				let message = resources["validation.maxLen"] + propMeta.maxLen;
				return this.format(message, propMeta);
			}
		}
	},
	minLen: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (v && v.length < propMeta.minLen) {
				let message = resources["validation.minLen"] + propMeta.minLen;
				return this.format(message, propMeta);
			}
		}
	},
	minValue: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (v != null && propMeta.minValue != null) {
				// v < propMeta.minValue
				if (NumberComparer.lt(v, propMeta.minValue)) {
					let message = resources["validation.minValue"] + propMeta.minValue;
					return this.format(message, propMeta);
				}
			}
		}
	},
	maxValue: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (v != null && propMeta.maxValue != null) {
				// v > propMeta.maxValue
				if (NumberComparer.gt(v, propMeta.maxValue)) {
					let message = resources["validation.maxValue"] + propMeta.maxValue;
					return this.format(message, propMeta);
				}
			}
		}
	},
	range: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			let range = propMeta.range;
			if (range && v != null) {
				if (!lang.isArray(range) || range.length !== 2) {
					throw new Error("Incorrect 'range' facet definition for prop " + propMeta.name + ": expected two-value array");
				}
				let minValue = range[0],
					maxValue = range[1];
				// if (v < minValue || v > maxValue)
				if (NumberComparer.lt(v, minValue) || NumberComparer.gt(v, maxValue)) {
					let message = resources["validation.range"] + "[" + minValue + "; " + maxValue + "] " +
						resources["validation.inclusive"];
					return this.format(message, propMeta);
				}
			}
		}
	},
	pattern: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (propMeta.pattern) {
				let pattern = /^\/(.*)\/(.*)/.exec(propMeta.pattern);
				if (!pattern) {
					throw new Error("Incorrect 'pattern' facet definition for prop " + propMeta.name + ": expected /pattern/modifiers");
				}
				let regexp = RegExp.apply(undefined, pattern.slice(1));
				if (v && !regexp.test(v)) {
					let message = propMeta.patternMsg || resources["validation.pattern"] + "'" + propMeta.pattern + "'";
					return this.format(message, propMeta);
				}
			}
		}
	},
	minInclusive: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (propMeta.minInclusive) {
				let minInclusive = parseDateFacet(propMeta, "minInclusive");
				if (v && v < minInclusive) {
					let message = resources["validation.minInclusive"] +
						formatDateTime(minInclusive, propMeta) + resources["validation.inclusive"];
					return this.format(message, propMeta);
				}
			}
		}
	},
	maxInclusive: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (propMeta.maxInclusive) {
				let maxInclusive = parseDateFacet(propMeta, "maxInclusive");
				if (v && v > maxInclusive) {
					let message = resources["validation.maxInclusive"] +
						formatDateTime(maxInclusive, propMeta) + resources["validation.inclusive"];
					return this.format(message, propMeta);
				}
			}
		}
	},
	minExclusive: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (propMeta.minExclusive) {
				let minExclusive = parseDateFacet(propMeta, "minExclusive");
				if (v && v <= minExclusive) {
					let message = resources["validation.minExclusive"] + formatDateTime(minExclusive, propMeta);
					return this.format(message, propMeta);
				}
			}
		}
	},
	maxExclusive: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (propMeta.maxExclusive) {
				let maxExclusive = parseDateFacet(propMeta, "maxExclusive");
				if (v && v >= maxExclusive) {
					let message = resources["validation.maxExclusive"] + formatDateTime(maxExclusive, propMeta);
					return this.format(message, propMeta);
				}
			}
		}
	},
	totalDigits: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (v && propMeta.totalDigits != null) {
				if (v.toString().replace(/[,.\s]/g, "").length > propMeta.totalDigits) {
					let message = resources["validation.totalDigits"] + propMeta.totalDigits;
					return this.format(message, propMeta);
				}
			}
		}
	},
	fractionDigits: {
		validate(v: any, propMeta: PropertyMetaRuntime): string {
			if (v && propMeta.fractionDigits != null) {
				let fractionDigits = propMeta.fractionDigits,
					parts = v.toString().split(".");
				if (parts.length > 1 && parts[1].length > fractionDigits) {
					let message = resources["validation.fractionDigits"] + propMeta.fractionDigits;
					return this.format(message, propMeta);
				}
			}
		}
	},
	"enum": {
		validate(v: any, propMeta: PropertyMeta): string {
			if (v === null || v === undefined) {
				return;
			}

			let enumMeta = propMeta.ref as EnumMeta,
				members = enumMeta.members,
				flags = lang.coalesce(propMeta["flags"], enumMeta.flags);
			if (flags) {
				let fullMask = enumMeta.fullMask;
				if (!fullMask) {
					// flags was set for prop not enum, we have to evaluate fullMask
					fullMask = 0;
					lang.forEach(members, function (member) {
						fullMask = fullMask | member.value;
					});
				}
				if (typeof v === "number" && ((v & fullMask) === v)) {
					return;
				}
			} else {
				if ((typeof v === "number" || typeof v === "string") &&
					lang.some(members, (member) => {
						return member.value === v;
					})) {
					return;
				} else if (typeof v === "string" && members.hasOwnProperty(v)) {
					return;
				}
			}
			let message = resources["validation.enum"] + "'" + enumMeta.descr + "'";
			return this.format(message, propMeta);
		}
	},
	nullable: {
		validate(v: any, propMeta: PropertyMetaBase): string {
			if (!propMeta.nullable && (v === null || v === undefined || v === "")) {
				return this.format(resources["validation.nullable"], propMeta);
			}
		}
	}
};
// Post-initialize facets implementations - add names & format method
lang.forEach(facets, (facet: RuleFormatting, name: string) => {
	facet.name = name;
	facet.format = format;
	// NOTE: emit 'format' method in every rule to be able to override it later.
});

export function shouldValidateProp(viewModel: any, propMeta: PropertyMetaRuntime): boolean {
	return propMeta.rules && propMeta.rules.length || !propMeta.nullable ||
		viewModel["validate" + utils.toUpperCamel(propMeta.name)];
}

/**
 * Validate an object property
 * @param {Object} viewModel Owner of the property
 * @param {String|Object} prop Property metadata or name
 */
export function validateProp(viewModel: any, prop: PropertyMetaRuntime|string): Violation {
	let propMeta: PropertyMetaRuntime = lang.isString(prop) && viewModel.meta ? viewModel.meta.props[prop] : prop;
	if (!propMeta.name) { return null; }
	if (!shouldValidateProp(viewModel, propMeta)) { return null; }

	let propValue = lang.get(viewModel, propMeta.name);

	// facets' rules & custom rules:
	let rules: RuleMap = {};
	//	1. combine
	if (propMeta.rules && propMeta.rules.length) {
		for (let i = 0; i < propMeta.rules.length; i++) {
			let rule = propMeta.rules[i];
			rules[rule.name || ("custom-rule" + i)] = rule;
		}
	}

	if (propMeta.nullable) {
		rules.nullable = undefined;
	} else if (/*!propMeta.nullable &&*/ !rules.nullable) {
		rules.nullable = facets.nullable;
	}

	// 	2. execute rules
	//  execute not-null rule first
	if (rules.nullable) {
		let violation = executeRule(rules.nullable, viewModel, propValue, propMeta);
		if (violation) {
			return violation;
		}
	}
	let ruleNames = Object.keys(rules);
	for (let i = 0; i < ruleNames.length; i++) {
		if (ruleNames[i] !== "nullable") {
			let rule = rules[ruleNames[i]];
			let violation = executeRule(rule, viewModel, propValue, propMeta);
			if (violation) {
				return violation;
			}
		}
	}

	// custom validateProp methods:
	let validateFn = "validate" + utils.toUpperCamel(propMeta.name);
	if (viewModel[validateFn]) {
		let error = viewModel[validateFn](propValue, propMeta);
		if (error) {
			return createViolation(error, viewModel, propMeta);
		}
	}
}
function executeRule(rule: Rule, viewModel: any, propValue: any, propMeta: PropertyMetaRuntime): Violation {
	if (rule) {
		let error = rule.validate(propValue, propMeta);
		if (error) {
			let violation = createViolation(error, viewModel, propMeta);
			if (rule.name) {
				violation.rule = rule.name;
			}
			return violation;
		}
	}
}

export function createViolation(error: string|SafeHtml|Violation, object?: any, prop?: PropertyMetaRuntime|string): Violation {
	if (!error) { return; }

	let violation: Violation = (lang.isString(error) || formatters.isHtml(error)) ? { error: error } : error;

	if (object) {
		violation.object = object;
	}

	if (prop) {
		let propName: string = lang.isString(prop) ? prop : prop.name;
		if (propName && (!violation.props || violation.props.length === 0)) {
			violation.props = [propName];
		}

		let readOnly: boolean = !lang.isString(prop) && prop.readOnly;
		if (readOnly) {
			violation.severity = "warning";
		}
	}

	return violation;
}

export function validateObjectProps(viewModel: IDomainObject|any): Violation[] {
	let props: lang.Map<PropertyMetaRuntime> = viewModel.meta && viewModel.meta.props;
	if (!props) { return; }

	let violations: Violation[];
	lang.forEach(props, propMeta => {
		let violation = validateProp(viewModel, propMeta);
		if (violation) {
			violations = violations || [];
			violations.push(violation);
		}
	});
	return violations;
}

/**
 * Join several violations descriptions.
 * @param {Array|Object|String} appendix Array of violation, single violation object or just error message
 * @param {Array} [violations] Optional array of violations to join with
 * @return {Array} Array of violations (or undefined if objViol and violations both are undefined)
 */
export function appendViolation(appendix: Violation[]|Violation|string, violations?: Violation[]): Violation[] {
	if (appendix) {
		violations = violations || [];
		let appendixArray = lang.array<Violation|string>(appendix);
		for (let obj of appendixArray) {
			let viol: Violation = lang.isString(obj) ? { error: obj } : obj;
			violations.push(viol);
		}
	}
	return violations;
}

/**
 * Validate object: execute type's and object's rules and validate method.
 * @param {Object} viewModel
 */
export function validateObject(viewModel: IDomainObject|any): Violation[] {
	let rules: ObjectRule[],
		violations: Violation[];

	if (viewModel.meta && (rules = viewModel.meta.rules)) {
		for (let rule of rules) {
			let viol = rule.validate(viewModel);
			if (viol) {
				violations = appendViolation(viol, violations);
			}
		}
	}
	if (viewModel.validate) {
		let viol = viewModel.validate();
		if (viol) {
			violations = appendViolation(viol, violations);
		}
	}
	if (violations && violations.length > 0) {
		for (let viol of violations) {
			viol.object = viewModel;
		}
	}

	return violations;
}

export function validateObjectWithProps(object): Violation[] {
	let violations1 = validateObjectProps(object),
		violations2 = validateObject(object);
	return appendViolation(violations2, violations1);
}