/** @module "core.commands" */

import lang = require("lib/core.lang");
import Menu = require("lib/ui/menu/Menu");

export interface ICommand {
	canExecute(): boolean;
	execute(...args: any[]): any;
}
export interface ICommandSpec {
	canExecute?: (() => boolean) | boolean;
	execute?: (...args: any[]) => any;
	name?: string;
	params?: any;
}
export interface IBoundCommandSpec extends ICommandSpec {
	canExecute?: () => boolean;
}
export interface ICommandFactory extends lang.Factory<ICommand> {}

export interface ICommandMap extends lang.Map<ICommand> {}

export interface ICommandLazyMap extends lang.Map<lang.Lazy<ICommand>> {}

export interface CommandArgs {
	name?: string;
	result?: any;
}

export class Command extends lang.Observable implements ICommand {
	name: string;
	params: any;
	/**
	 * @constructs Command
	 * @extends Observable
	 */
	constructor () {
		super();
	}

	// canExecute(): boolean;
	// canExecute(v: boolean): void;
	// execute(...args);
	// canExecute: lang.ObservableProperty<boolean>;
	// execute: (...args: any[]) => any;

	protected _prepareExecuteArgs(args: any[]): CommandArgs[] {
		let params = lang.extend({name: this.name}, this.params);
		if (args.length > 0) {
			args[0] = lang.extend(params, args[0]);
		} else if (this.params) {
			args = [params];
		}
		return args;
	}

	protected _enrichWithResult(args: CommandArgs[], result): CommandArgs[] {
		if (result === undefined) {
			return args;
		}
		if (args.length > 0) {
			args[0].result = result;
		} else {
			args = [{result: result}];
		}
		return args;
	}
}
export interface Command {
	canExecute(): boolean;
	canExecute(v: boolean): void;
	execute(...args: any[]): any;
}
export namespace Command {
}

export function createCommand(execute: executeFn): Command;
export function createCommand(execute: executeFn, canExecute: canExecuteFn): Command;
export function createCommand(spec: ICommandSpec): Command;
/**
 * Creates a new command.
 * @param {Object|Function} spec A command specification (object with execute/canExecute) or `execute` method (then 2nd arg can be `canExecute`)
 * @param {Function|Boolean} spec.canExecute
 * @param {Function} spec.execute
 * @param {Function} [canExecute]
 * @returns {Command}
 */
export function createCommand(spec: ICommandSpec|executeFn, canExecute?: canExecuteFn): Command {
	let cmd =  new Command(),
		cmdSpec: ICommandSpec;

	if (lang.isFunction(spec)) {
		cmdSpec = { execute: spec };

		if (arguments.length === 2) {
			cmdSpec.canExecute = canExecute;
		}
	} else {
		cmdSpec = spec;
	}

	lang.extend(cmd, cmdSpec);

	if (!cmdSpec.hasOwnProperty("canExecute")) {
		cmd.declareProp("canExecute", true);
	}
	else if (typeof cmdSpec.canExecute !== "function") {
		cmd.declareProp("canExecute", cmdSpec.canExecute);
	}
	// NOTE: else cmd.canExecute is a function taken from cmdSpec

	if (!cmd.execute) {
		// cmdSpec didn't contain 'execute' method
		cmd.execute = function(...args) {
			args = this._prepareExecuteArgs(args);
			this.trigger.apply(this, ["executed"].concat(args));
		};
	} else {
		let executeMethod = cmd.execute;
		// replace execute method with binded to command instance function and our additional logic:
		//  - inject additional command' params (from params field) into execute arguments (
		cmd.execute = function(...args) {
			let that = this,
				res;
			if (!that.canExecute()) { return; }
			args = that._prepareExecuteArgs(args);
			res = executeMethod.apply(that, args);
			args = that._enrichWithResult(args, res);
			that.trigger.apply(that, ["executed"].concat(args));
			return res;
		};
	}

	return cmd;
}
interface executeFn {
	(v: any): any;
}
interface canExecuteFn {
	(): boolean;
}

function canExecuteTrue(): boolean {
	return true;
}

export class BoundCommand extends Command {
	private _execute: executeFn;
	private _canExecute: canExecuteFn;

	constructor (execute: executeFn, ctx: Object);
	constructor (execute: executeFn, canExecute: canExecuteFn, ctx: Object);
	constructor (spec: IBoundCommandSpec, ctx: Object);
	/**
	 * @constructs BoundCommand
	 * @extends Command
	 * @param {Object} spec
	 * @param {*} ctx
	 */
	constructor (spec: IBoundCommandSpec|executeFn, ctx: Object|canExecuteFn) {
		super();

		let that = this,
			cmdSpec: IBoundCommandSpec;

		if (lang.isFunction(spec)) {
			cmdSpec = { execute: spec };

			if (arguments.length >= 3) {
				cmdSpec.canExecute = <canExecuteFn>ctx;
				ctx = arguments[2];
			}
		} else {
			cmdSpec = spec;
		}

		cmdSpec = cmdSpec || {};
		that._canExecute = cmdSpec.canExecute || canExecuteTrue;
		that._execute = cmdSpec.execute || lang.noop;

		lang.append(that, cmdSpec);
		that.context(ctx || that);
	}

	private _context: any;
	/**
	 * @observable-property {BoundCommand#context}
	 * @description Command context
	 */
	@lang.decorators.observableAccessor()
	context: lang.ObservableProperty<any>;

	/**
	 * @override
	 * @returns {boolean}
	 */
	canExecute(): boolean {
		let that = this,
			ret = !!that._canExecute.apply(that.context(), arguments);
		// trick: if somebody wants to explicitly notify about changing 'canExecute', he can call:
		//   cmd.trigger("change", cmd, { prop: "canExecute" });
		//that.trigger("get", that, { prop: "canExecute", value: ret});
		return ret;
	}

	/**
	 * @override
	 * @returns {*}
	 */
	execute(...args: any[]): any {
		let that = this,
			ret;

		// NOTE: use that._context instead of that.context() to prevent observers notification
		if (!that._canExecute.call(that._context)) { return; }

		args = that._prepareExecuteArgs(args);
		ret = that._execute.apply(that.context(), args);
		args = that._enrichWithResult(args, ret);
		that.trigger.apply(that, ["executed"].concat(args));
		return ret;
	}
}


export function createBoundCommand(execute: executeFn, ctx: Object): BoundCommand;
export function createBoundCommand(execute: executeFn, canExecute: canExecuteFn, ctx: Object): BoundCommand;
export function createBoundCommand(spec: IBoundCommandSpec, ctx: Object): BoundCommand;

/**
 * Creates a new bound command.
 * @param {Object} cmdSpec
 * @param {Function|Boolean} cmdSpec.canExecute
 * @param {Function} cmdSpec.execute
 * @param {Observable} [ctx]
 * @returns {Command}
 */
export function createBoundCommand(): BoundCommand {
	return BoundCommand.create.apply(BoundCommand, arguments);
}

/**
 * Gets name of a command from the attribute 'data-command-name' (or 'data-cmd-name')
 * @param $element jQuery set
 * @returns {String}
 * @static
 */
export function dataCommandName($element: JQuery): string {
	return $element.attr("data-command-name") || $element.attr("data-cmd-name");
}

/**
 * Gets parameters for a command from the attribute 'data-command-params' (or 'data-cmd-params')
 * @param $element jQuery set
 * @returns {Object}
 * @static
 */
export function dataCommandParams($element: JQuery): any {
	let cmdParamsHtml = $element.attr("data-command-params") || $element.attr("data-cmd-params"),
		cmdParams;
	if (cmdParamsHtml && lang.isString(cmdParamsHtml)) {
		cmdParams = lang.parseJsonString(cmdParamsHtml);
	}
	return cmdParams || {};
}

/**
 * Extracts command name/params from HTMLElement and executes menu item for the command.
 * @param $element
 * @param {Menu} menu
 * @param {Object} [args]
 * @return {boolean} true if a command was executed
 */
export function tryToExecuteHtmlCommand($element: JQuery, menu: Menu, args?: any): boolean {
	let cmdName = dataCommandName($element),
		cmdParams,
		menuItem;

	if (cmdName) {
		cmdParams = lang.extend({},
			dataCommandParams($element),
			args);

		menuItem = menu.getItem(cmdName);
		if (menuItem && menuItem.command) {
			menu.executeItem(menuItem, cmdParams);
			return true;
		}
		return false;
	}
}

/**
 * Creates commands instances if they are specified as factory functions.
 * @param {ICommandLazyMap} commands
 * @param ctx
 * @returns {ICommandMap}
 */
export function unlazyCommands(commands: ICommandLazyMap, ctx?: any): ICommandMap {
	lang.forEach(commands, (command: lang.Lazy<ICommand>, name) => {
		commands[name] = lang.unlazy(command, ctx);
	});
	return commands as ICommandMap;
}
