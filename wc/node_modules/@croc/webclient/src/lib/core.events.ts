import * as lang from "lib/core.lang";
import * as diagnostics from "lib/core.diagnostics";

import { AppEvent, AppEventArgs, IEventPublisher } from ".core";
import IDisposable = lang.IDisposable;

export class EventPublisher extends lang.CoreClass implements IEventPublisher {
	traceSource: diagnostics.TraceSource;
	private _events: lang.Observable;
	private _deferredEvents: AppEvent[];
	private _isDeferred: boolean;

	/**
	 * Event publisher.
	 * Initially publisher is frozen - all published events arn't processed and postponed till `start` method called.
	 * @constucts EventPublisher
	 * @memberOf module:"core.events"
	 */
	constructor () {
		super();
		this._events = new lang.Observable();
		/** @type TraceSource */
		this.traceSource = new diagnostics.TraceSource("core.EventPublisher");
		this._isDeferred = true;
	}

	/**
	 * @deprecated Use `subscribe` method
	 */
	getEvent(eventName) {
		var that = this;
		return {
			subscribe: function (handler) {
				return that.subscribe(eventName, handler);
			}
		};
	}

	/**
	 * Subscribe the handler on the event.
	 * @param {String} eventName Name of app event
	 * @param {Function} handler Callback which will be called on the event publishing. Callback should expect argument of type AppEvent.
	 * @returns {Object} Disposable object to unsubscribe
	 */
	subscribe(eventName: string, handler: (event: AppEvent) => void): IDisposable {
		// wrap the handler to collect all handled events on publishing
		return this._events.subscribe(eventName, function (event: AppEvent, handledEvents: AppEvent[]) {
			// NOTE: create a shallow copy of the event for every handler
			var handlerEvent = lang.clone(event);
			handler.call(this, handlerEvent);
			handledEvents.push(handlerEvent);
		});
	}

	/**
	 * Subscribe the handler on all events.
	 * @param {Function} handler Callback which will be called on any event publishing.
	 * @returns {Object} Disposable object to unsubscribe
	 */
	subscribeAll(handler: (event: AppEvent) => void): IDisposable {
		return this.subscribe("*", handler);
	}

	/**
	 * Publish event with its data.
	 * The event processing will be postponed if start method wasn't called.
	 * @param {String} eventName Name of app event
	 * @param {Object|SystemEvent} [eventArgs] Data for the event. Subscribed callbacks get it via AppEvent.args field.
	 * @param {Function} [eventArgs.defaultAction] Callback to be called if there're no any subscribers.
	 * @param {Function} [eventArgs.initialize]
	 */
	publish(eventName: string, eventArgs?: AppEventArgs): void {
		var that = this,
			event: AppEvent = {
				eventName: eventName,
				args: eventArgs,
				processed: true
			},
			handledEvents: AppEvent[] = [],
			processed: boolean;

		if (that._isDeferred) {
			// Application initialization hasn't finished yet, postpone the event
			if (!that._deferredEvents) {
				that._deferredEvents = [];
			}
			that._deferredEvents.push(event);
			return;
		}

		if (eventArgs && lang.isFunction(eventArgs.initialize)) {
			eventArgs.initialize();
		}
		that._events.trigger(eventName, event, handledEvents);
		that._events.trigger("*", event, handledEvents);

		that.traceSource.debug("Published '" + eventName + "' event");
		// execute default callback if the event wasn't processed
		if (eventArgs && eventArgs.defaultAction) {
			processed = handledEvents.some(function (ev) { return ev.processed; });
			if (!processed) {
				eventArgs.defaultAction();
				that.traceSource.debug("Event '" + eventName + "' wasn't processed by subscribers and its defaultAction was executed");
			}
		}
	}

	/**
	 * Start processing postponed (published earlier) events.
	 * Also publishes "app.start" event.
	 */
	start(): void {
		var that = this;
		that._isDeferred = false;
		if (that._deferredEvents) {
			that._deferredEvents.forEach(function (event) {
				that.publish(event.eventName, event.args);
			});
			that._deferredEvents = undefined;
		}
		that.publish("app.start");
	}
}
