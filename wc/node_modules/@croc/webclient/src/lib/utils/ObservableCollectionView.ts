import lang = require("lib/core.lang");

import OrderBy = lang.collections.OrderBy;
import OrderByOrString = lang.collections.OrderByOrString;
import OrderByData = lang.collections.OrderByData;
import WhereCallback = ObservableCollectionView.WhereCallback;

class ObservableCollectionView<T> extends lang.Observable implements lang.IObservableCollection<T> {
	private _source: lang.IObservableCollection<T>;
	private _sourceOwned: boolean;
	private _comparer: (x: any, y: any) => number;
	private _orderBy: OrderBy[];
	private _where: (item: T, index?: number) => boolean;
	private _items: T[];


	/**
	 * Wrapping collection that supports filtering and ordering of the source collection.
	 * @constructs ObservableCollectionView
	 * @extends Observable
	 * @param {Array|ObservableCollection} source
	 */
	constructor(source?: T[]|lang.IObservableCollection<T>) {
		super();

		if (source) {
			this._setSource(source);
		} else if (!arguments.length) {
			// если источник не передан, то создаем пустой
			this._setSource([]);
		}
	}

	dispose(): void {
		super.dispose();
		this._clearSource();
	}

	source(): lang.IObservableCollection<T>;
	source(value: T[]|lang.IObservableCollection<T>): void;
	/**
	 * Source collection
	 * @param value
	 * @return {*}
	 */
	source(value?: T[]|lang.IObservableCollection<T>) {
		let that = this;
		if (arguments.length) {
			that._clearSource();
			if (value) {
				that._setSource(value);
			}
			that.trigger("change", that, {});
		} else {
			that.trigger("get", that, { prop: "source", value: that._source });
			return that._source;
		}
	}

	orderBy(): OrderBy[];
	orderBy(orderBy: OrderByOrString|OrderByOrString[]): void;
	/**
	 * Gets or sets an expression for ordering
	 * @param {String|Array} [orderBy]
	 * @returns {Array|undefined}
	 */
	orderBy(orderBy?: OrderByOrString|OrderByOrString[]) {
		let that = this;
		if (arguments.length) {
			that._items = undefined; // сбросим кэш
			let parsed: OrderBy[] = that.parseOrderBy(orderBy);
			that._comparer = lang.collections.createComparer(parsed);
			ObservableCollectionView._set(that, "orderBy", parsed);
			that.trigger("change", that, {});
		} else {
			return ObservableCollectionView._get(that, "orderBy");
		}
	}

	parseOrderBy(orderBy: OrderByOrString|OrderByOrString[]): OrderBy[] {
		return lang.collections.parseOrderBy(orderBy, this._orderBy);
	}

	/**
	 * @deprecated use `lang.collections.parseOrderBy` instead
	 * @param orderBy
	 * @param oldOrderBy
	 * @return {any}
	 */
	static parseOrderBy(orderBy: OrderByOrString|OrderByOrString[], oldOrderBy?: OrderByData[]): OrderBy[] {
		return lang.collections.parseOrderBy(orderBy, oldOrderBy);
	}

	where(): WhereCallback<T>;
	where(filter: WhereCallback<T>): void;
	/**
	 * Gets or sets filtering function
	 * @param {Function} [filter]
	 * @returns {Function|undefined}
	 */
	where(filter?: WhereCallback<T>) {
		let that = this;
		if (arguments.length) {
			that._items = undefined; // сбросим кэш
			ObservableCollectionView._set(that, "where", filter);
			that.trigger("change", that, {});
		} else {
			return ObservableCollectionView._get(that, "where");
		}
	}

	all(): T[] {
		let that = this,
			ret: T[] = that._resultItems();
		ret.forEach((item, i) => {
			that.trigger("get", that, { prop: i.toString(), value: item });
		});
		that.trigger("get", that, { prop: "all", value: ret });
		return ret;
	}
	get(i: number|string): T {
		let that = this,
			ret = that._resultItems()[<number>i];
		that.trigger("get", that, { prop: i.toString(), value: ret });
		return ret;
	}
	count(): number {
		let that = this,
			ret = that._resultItems().length;
		that.trigger("get", that, { prop: "count", value: ret });
		return ret;
	}
	indexOf(item: T): number {
		return this._resultItems().indexOf(item);
	}
	add(item: T|T[]): void {
		this._throwIfNoSource();
		this._source.add(item);
	}
	remove(item: T|T[]): void {
		this._throwIfNoSource();
		this._source.remove(item);
	}
	move(indexFrom: number, indexTo: number): void {
		let that = this;
		that._throwIfNoSource();
		if (that._comparer) {
			throw new Error("Перемещение элементов с заданным порядком невозможно");
		}
		if (that._where) {
			indexFrom = that._source.indexOf(that.get(indexFrom));
			indexTo = that._source.indexOf(that.get(indexTo));
		}
		that._source.move(indexFrom, indexTo);
	}
	clear(): void {
		this._items = undefined; // сбросим кэш
		if (this._source) {
			this._source.clear();
		}
	}
	reset(items: T|T[]): void {
		this._throwIfNoSource();
		// сбросим кэш, т.к. полагаться на возникновение "change" при reset мы не можем
		// (если коллекция не изменилась, то события не будет)
		if (this._comparer || this._where) {
			this._items = undefined;
		}
		this._source.reset(items);
	}
	toggle(item: T): void {
		this._throwIfNoSource();
		this._source.toggle(item);
	}
	forEach(iterator: (item: T, index: number, array: T[]) => void, context?: any): void {
		return this._resultItems().forEach(iterator, context);
	}
	find(predicate: (item: T, index: number) => boolean, context?: any): T {
		return lang.find(this._resultItems(), predicate, context);
	}

	private _throwIfNoSource(): void {
		if (!this._source) {
			throw new Error("Не задана коллекция-источник");
		}
	}

	/**
	 * Returns filtered and sorted array of items
	 */
	private _resultItems(): T[] {
		// TOTHINK: сделать этот метод ObservableExpression, тогда можно будет отслеживать изменения во вложенных
		// объектах (сейчас отслеживаются изменения только непосредственно в элементах коллекции)

		let that = this,
			items: T[] = that._items;
		if (!items) {
			if (!that._source) {
				items = [];
			} else {
				items = that._source.all();
			}
			if (that._where) {
				items = items.filter(that._where);
			}
			if (that._comparer) {
				items = lang.sort(items, that._comparer);
			}
			that._items = items;
		}
		return items;
	}

	private _setSource(source: T[]|lang.IObservableCollection<T>): void {
		let that = this;
		if (!lang.ObservableCollection.isObservableCollection(source)) {
			// TODO: по идее в этом случае не обязательно создавать внутреннюю ObservableCollection и
			// синхронизироваться с ней. Можно было бы работать напрямую с массивом source, но это была бы
			// отдельная ветка кода.
			that._source = new lang.ObservableCollection<T>(source);
			that._sourceOwned = true;
		} else {
			that._source = source; // source is already ObservableCollection
			that._sourceOwned = false;
		}

		that._source.bind("change", that._onSourceChange, that);
		that._source.bind("itemChange", that._onSourceItemChange, that);
	}

	private _clearSource(): void {
		let that = this;

		that._items = undefined; // сбросим кэш

		if (that._source) {
			that._source.unbind("change", null, that);
			that._source.unbind("itemChange", null, that);

			if (that._sourceOwned && (<any>that._source).dispose) {
				(<any>that._source).dispose();
			}

			that._sourceOwned = undefined;
			that._source = undefined;
		}
	}

	/**
	 * Проверяет, что элемент находится на своем месте в упорядоченном массиве
	 * @param item
	 * @return {Boolean}
	 */
	private _isItemOrderCorrect(item: T): boolean {
		let items = this._items,
			comparer = this._comparer,
			i = items.indexOf(item);
		// NOTE: indexOf - затратная операция (O(n)), хорошо бы сюда передавать уже известный индекс элемента.
		// Для этого нужно ввести индексы измененных элементов в аргументах события itemChange у ObservableCollection.
		return i < 0 ||
			(i === 0 || comparer(items[i - 1], item) <= 0) &&
			(i === items.length - 1 || comparer(items[i + 1], item) >= 0);
	}

	/**
	 * Проверяет, что элемент не изменил своего членства в коллекции
	 * @param item
	 * @returns {boolean}
	 */
	private _isItemMembershipCorrect(item: T): boolean {
		var oldMembership = this._items.indexOf(item) >= 0,
			newMembership = !!this._where(item);
		return oldMembership === newMembership;
	}

	private _onSourceChange(sender, args: lang.ObservableCollectionChangeArgs<T>): void {
		let that = this;
		that._items = undefined; // сбросим кэш

		// filter added and removed arrays
		if (that._where && args) {
			args = lang.clone(args);
			if (args.added) {
				args.added = args.added.filter(that._where);
			}
			if (args.removed) {
				args.removed = args.removed.filter(that._where);
			}
		}
		// re-trigger event
		that.trigger("change", that, args);
	}

	private _onSourceItemChange(sender, args: lang.ObservableCollectionItemChangeArgs<T>) {
		let that = this;
		if (that._items && args && args.changed) {
			// проверим, что:
			// - каждый измененный элемент не изменил своего членства в коллекции
			//   (т.е. если элемент был в коллекции, то он в ней и остался; если элемент не принадлежал коллекции,
			//   то он в нее не добавился)
			// - каждый измененный элемент остается на своем месте в упорядоченной коллекции
			let changed =
				(that._where && !args.changed.every(that._isItemMembershipCorrect, that)) ||
				(that._comparer && !args.changed.every(that._isItemOrderCorrect, that));
			if (changed) {
				that._items = undefined; // сбросим кэш
				that.trigger("change", that, {});
				return;
			}
		}

		// just re-trigger event
		that.trigger("itemChange", that, args);
	}
}

namespace ObservableCollectionView {
/*
	export interface OrderByData {
		prop?: string;
		desc?: boolean;
	}
	export interface OrderBy {
		prop?: string;
		desc?: boolean;
		getter?: () => any;
		comparer?: (x: any, y: any) => number;
	}

	export type OrderByOrString = OrderBy|string;
*/

	export interface WhereCallback<T> {
		(item: T, index?: number): any;
	}
}

export = ObservableCollectionView;

