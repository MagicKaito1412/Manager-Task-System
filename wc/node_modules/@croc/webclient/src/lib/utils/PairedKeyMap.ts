import lang = require("lib/core.lang");

/**
 * Словарь с составным ключом {key1, key2}
 */
class PairedKeyMap<T> {
	private _values: lang.Map<lang.Map<T>>;

	constructor() {
		this._values = {};
	}
	get(key1: string, key2: string, defaultValue?: T): T {
		var values1 = this._values[key1] || (this._values[key1] = {});
		return values1[key2] || (values1[key2] = defaultValue);
	}
	set(key1: string, key2: string, value: T): void {
		var values1 = this._values[key1] || (this._values[key1] = {});
		values1[key2] = value;
	}
	find(key1: string, key2: string): T {
		var values1 = this._values[key1];
		return values1 && values1[key2];
	}
	select(key1: string): T[] {
		var values1 = this._values[key1];
		return values1 ? Object.keys(values1).map(function (key2) { return values1[key2]; }) : [];
	}
	remove(key1: string, key2: string): boolean {
		var values1 = this._values[key1];
		if (values1 && values1.hasOwnProperty(key2)) {
			delete values1[key2];
			if (lang.isEmptyObject(values1)) {
				delete this._values[key1];
			}
			return true;
		}
		return false;
	}
	forEach(callback: (item: T, key1: string, key2: string) => void, context?): void {
		lang.forEach(this._values, function (values1, key1) {
			lang.forEach(values1, function (value2, key2) {
				callback.call(context, value2, key1, key2);
			});
		});
	}
	some(callback: (item: T, key1: string, key2: string) => boolean, context?): boolean {
		return lang.some(this._values, function (values1, key1) {
			return lang.some(values1, function (value2, key2) {
				return callback.call(context, value2, key1, key2);
			});
		});
	}
	all(): T[] {
		var result = [];
		this.forEach(function (value) {
			result.push(value);
		});
		return result;
	}
}

export = PairedKeyMap;
