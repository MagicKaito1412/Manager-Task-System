import lang = require("lib/core.lang");
import diagnostics = require("lib/core.diagnostics");
import * as interop from "lib/interop/.interop";
import DataStoreBase = require("lib/data/DataStoreBase");
import { Deferred } from "lib/core.lang";

const traceSource = new diagnostics.TraceSource("interop.DataSynchronizer");

class DataSynchronizer extends lang.Observable {

	static defaultOptions = {
		defaultInterval: 500,
		maxInterval: 10000
	};

	private cancellationRequested: boolean;
	private _store: DataStoreBase;
	private _scheduled: number;
	private _pingOnlyScheduled: number;
	private _attempts: number;
	private _pendingSync: boolean;
	private maxInterval: number;
	private defaultInterval: number;
	private _interval: number;
	private _intervalStep: number;
	private _saveAction: (objects: interop.DomainObjectData[], options?: interop.SaveOptions) => lang.Promise<any>;
	private _pingAction: () =>  lang.Promise<DataSynchronizer.PingResult>;
	private _pingFn: () => void;
	private _pingOnlyFn: () => void;
	private _syncFn: () => void;

	/**
	 * @observable-property {DataSynchronizer.State}
	 */
	@lang.decorators.observableAccessor()
	state: lang.ObservableProperty<DataSynchronizer.State>;

	/**
	 * @constructs DataSynchronizer
	 * @extends Observable
	 * @param {DataStoreBase} dataStore
	 * @param {{save:Function, ping: Function}} options
	 */
	constructor(dataStore: DataStoreBase, options: DataSynchronizer.Options) {
		if (!dataStore)
			throw new Error("DataSynchronizer.ctor: dataStore should be specified");
		if (!options || !options.save || !options.ping)
			throw new Error("DataSynchronizer.ctor: interop with 'ping' and 'save' actions should be specified");

		super();
		this._store = dataStore;
		this.state(DataSynchronizer.State.Idle);
		this._scheduled = undefined;

		this.maxInterval = DataSynchronizer.defaultOptions.maxInterval;
		this.defaultInterval = DataSynchronizer.defaultOptions.defaultInterval;
		this._clearStats();

		this._saveAction = options.save;
		this._pingAction = options.ping;
		this._pingFn = this._ping.bind(this);
		this._pingOnlyFn = this._pingOnly.bind(this);
		this._syncFn = this._sync.bind(this);
	}

	isSynchronizing(): boolean {
		return this.state() === DataSynchronizer.State.Synchronizing;
	}

	isScheduledOrSynchronizing(): boolean {
		return this._scheduled !== undefined || this.state() === DataSynchronizer.State.Synchronizing;
	}

	protected _clearStats(): void {
		let that = this;
		that._attempts = 0;
		that._interval = that.defaultInterval;
		that._intervalStep = that.defaultInterval;
	}

	setIdle(): void {
		let that = this;
		/*isSynchronizing = that.isSynchronizing() && that._scheduled;*/
		that.state(DataSynchronizer.State.Idle);
		/*if (isSynchronizing) {
		 that._scheduled = false;
		 that.scheduleSync(false);
		 }*/
		if (that._pendingSync) {
			that._pendingSync = false;
			that.scheduleSync(false);
		}
	}

	/**
	 * Schedules synchronization.
	 * @param {Boolean} pingOnly if true then first call will be 'ping' and only if it succeeded then continue to save
	 * @returns {boolean} true if a task was schedule otherwise false
	 */
	scheduleSync(pingOnly: boolean): boolean {
		let that = this;
		// cancel cancellation
		that.cancellationRequested = false;
		if (that.isSynchronizing() || that._scheduled) {
			that._pendingSync = true;
			traceSource.debug("scheduleSync was ignored as it's already scheduled or synchronizing is in progress");
			return false;
		}
		if (that._attempts > 5) {
			if (that._interval <= that.maxInterval) {
				that._interval = that._interval + that._intervalStep;
			}
		}
		traceSource.debug("scheduleSync scheduled, pingOnly=" + pingOnly + ", interval=" + that._interval);
		that._scheduled = window.setTimeout(pingOnly ? that._pingFn : that._syncFn, that._interval);
		return true;
	}

	protected _ping(): void {
		let that = this;
		that._scheduled = undefined;
		if (that._cancelIfRequested()) {
			return;
		}
		that.state(DataSynchronizer.State.Synchronizing);
		that._attempts++;
		that._pingAction()
			.done((result: DataSynchronizer.PingResult) => {
				that.state(DataSynchronizer.State.Idle);
				if (that._cancelIfRequested()) {
					return;
				}
				if (result.serverOnline) {
					that._clearStats();
					that._sync();
				} else {
					that.scheduleSync(true);
				}
			});
	}

	protected _sync(): void {
		let that = this;
		that._scheduled = undefined;
		if (that.isSynchronizing()) {
			// scheduled timer fired, but previous synchronization hasn't finished yet.
			return;
		}
		that.state(DataSynchronizer.State.Synchronizing);
		that._store.getChanges().done((objects: interop.DomainObjectData[]) => {
			if (lang.isEmpty(objects)) {
				that._clearStats();
				that.setIdle();
				that._onSyncSuccess(null, null, /*suppressEvent*/true);
				return;
			}
			that._attempts++;
			that._saveAction(objects, { sync: true })
				.done((response) => {
					that._onSaveDone(objects, response, /*isSuccess*/true);
				})
				.fail((response) => {
					that._onSaveDone(objects, response, /*isSuccess*/false);
				});
		});
	}

	protected _onSaveDone(objects: interop.DomainObjectData[], response, isSuccess: boolean): void {
		let that = this,
			syncFailures = [];

		that._clearStats();

		if (response && response.error) {
			let syncResult = <interop.SaveInteropError>response;
			// single object/group failed
			if (syncResult.httpStatus) {
				syncResult.error.httpStatus = syncResult.httpStatus;
			}
			syncFailures.push({
				error: syncResult.error,
				result: response,
				objects: [].concat(objects)
			});
			objects = [];
		} else if (response && response.results) {
			// several groups were being save,
			// request may failed partially or completely, or succeeded (if there're no SaveResponse with error)
			let syncResult = <interop.AggregateSaveResponse>response;
			lang.forEach(syncResult.results, (result: interop.SaveResponse) => {
				if (!result.ids && response.results.length > 1) {
					traceSource.warn("Incorrect server response: AggregateSaveResponse contains more than 1 group but a group has no ids field");
				}
				if (result.error) {
					// a group saving failed with an error
					let failure = {
						error: result.error,
						result: result,
						objects
					};
					if (response.httpStatus) {
						failure.error.httpStatus = response.httpStatus;
					}
					/*if (!result.ids && response.results.length === 1) {
						failure.objects = [].concat(objects);
						objects = [];
					}*/
					if (result.ids) {
						failure.objects = [];
						lang.forEach(result.ids, (id) => {
							let obj = lang.find(objects, (o) => {
								return (o.id === id.id) && o.__metadata && o.__metadata.type === id.type;
							});
							if (obj) {
								failure.objects.push(obj);
								// remove from original objects those ones which failed to save
								lang.arrayRemove(objects, obj);
							}
						});
					} else if (response.results.length === 1) {
						// the single group failed - all objects are source of the failure
						failure.objects = [].concat(objects);
						objects = [];
					} else {
						// и что делать? групп >1, но в текущей нет ids
					}
					syncFailures.push(failure);
				}
			});
		} else if (!isSuccess) {
			// request failed with an exception
			return that._onSyncError([{
				objects: objects,
				error: response.serverError || response,
				result: response
			}]);
		}

		// NOTE: now `objects` contains only successfully saved original objects
		if (syncFailures.length > 0) {
			// some failed..
			if (objects.length > 0) {
				// and some succeeded, we should commit succeeded
				that._onSyncSuccess(objects, response, /*suppressEvent=*/true);
			}
			// ... and publish error for failed
			that._onSyncError(syncFailures);
		} else {
			// all succeeded
			that.setIdle();
			that._onSyncSuccess(objects, response);
		}
	}

	protected _onSyncSuccess(objects: interop.DomainObjectData[], response, suppressEvent?: boolean): void {
		this.trigger("sync.success", { changes: objects, response: response, suppressEvent: suppressEvent });
	}

	protected _onSyncError(failures: DataSynchronizer.SyncFailture[]): void {
		let defer = lang.Deferred();

		defer.done(() => {
			this.setIdle();
		});

		this.trigger("sync.error", { failures: failures, defer: defer });
	}

	/**
	 * Cancel all activity (scheduled timers and synchronization in progress)
	 */
	cancel(): void {
		let that = this;
		traceSource.debug("cancellation requested");
		that.cancellationRequested = true;
		if (that._pingOnlyScheduled !== undefined) {
			window.clearTimeout(that._pingOnlyScheduled);
		}
		if (that._scheduled !== undefined) {
			window.clearTimeout(that._scheduled);
		}
	}

	protected _cancelIfRequested(): boolean {
		let that = this;
		if (that.cancellationRequested) {
			that.cancellationRequested = false;
			that.state(DataSynchronizer.State.Idle);
			that._clearStats();
			return true;
		}
		return false;
	}

	schedulePing(): void {
		let that = this;
		// cancel cancellation
		that.cancellationRequested = false;
		// NOTE: here we have a separate flag for timer threshold - _pingOnlyScheduled, then in scheduleSync (_scheduled)
		if (that.isScheduledOrSynchronizing() || that._pingOnlyScheduled !== undefined) {
			traceSource.debug("schedulePing was ignored as it's already scheduled or synchronizing is in progress");
			return;
		}
		if (that._attempts > 5) {
			if (that._interval <= that.maxInterval) {
				that._interval = that._interval + that._intervalStep;
			}
		}
		that._pingOnlyScheduled = window.setTimeout(that._pingOnlyFn, that._interval);
	}

	protected _pingOnly(): void {
		let that = this;
		// NOTE: we're not changing state to 'synchronizing' because we don't want to prevent synchronization
		that._pingOnlyScheduled = undefined;
		that._attempts++;
		that._pingAction()
			.done((result: DataSynchronizer.PingResult) => {
				that.state(DataSynchronizer.State.Idle);
				if (result.serverOnline) {
					that._clearStats();
				}
			});
	}
}

// backward compatibility
DataSynchronizer.mixin({
	states: DataSynchronizer.State
});

namespace DataSynchronizer {
	export interface Options {
		save: (objects: interop.DomainObjectData[], options?: interop.SaveOptions) => lang.Promise<any>;
		ping: () => lang.Promise<PingResult>;
	}
	export interface PingResult {
		networkOnline: boolean;
		serverOnline: boolean;
	}
	export const State = {
		Idle: "idle" as "idle",
		Synchronizing: "synchronizing" as "synchronizing"
	};
	export type State = (typeof State)[keyof typeof State];

	export interface SyncSuccessEventArgs {
		changes: interop.DomainObjectData[];
		response: any;	// TODO
		suppressEvent?: boolean;
	}
	export interface SyncFailture {
		objects: interop.DomainObjectData[]; //
		error: interop.ExceptionData;	//response.serverError || response,
		result: interop.SaveResponse;
	}
	export interface SyncFailtureEventArgs {
		failures: SyncFailture[];
		defer: Deferred<void>;
	}
}
export = DataSynchronizer;

