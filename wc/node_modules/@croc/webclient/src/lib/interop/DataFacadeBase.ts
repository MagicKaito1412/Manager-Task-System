import * as core from "core";
import * as resources from "i18n!lib/nls/resources";

import {
	DomainObjectData,
	SavedObjectData,
	ExceptionData,
	InteropError,
	AjaxSettings,
	AjaxOptions,
	LoadQuery,
	LoadResponse,
	LoadOptions,
	SaveOptions,
	SaveResponse,
	IBackendInterop,
	DataUpdateEventArgs,
	SystemVersionChangedEventArgs,
	ObjectIdentity
} from ".interop";

import IEventPublisher = core.IEventPublisher;
import SystemEvent = core.SystemEvent;
import SystemEventData = core.SystemEvent.Options;
import Deferred = core.lang.Deferred;
import Promise = core.lang.Promise;

/**
 * Load data.
 * @function load
 * @memberOf DataFacadeBase.prototype
 * @param {Object} query query JSON-object
 * @param {Object|String} query.source name of source or JSON-object to load from
 * @param {String} query.source.type entityType when loading objects
 * @param {String} [query.source.id] objectId when loading a single object
 * @param {String} [query.source.propName] name of navigation property
 * @param {String} [query.type] entityType name of loading objects
 * @param {String} [query.preloads] array of property names or property chains
 * @param {Object} [query.params] query parameters
 * @param {Object} options
 * @param {String} [options.opId] cancellation operation id
 * @returns {Promise}
 */

abstract class DataFacadeBase extends core.lang.Observable {
	// TODO:
	_interop: IBackendInterop;

	eventPublisher: IEventPublisher;

	/**
	 * @constructs DataFacadeBase
	 * @extends Observable
	 * @param {BackendInterop} interop
	 * @param {EventPublisher} [eventPublisher]
	 */
	constructor(interop: IBackendInterop, eventPublisher?: IEventPublisher) {
		super();

		let that = this;
		if (!interop) {
			throw new Error("DataFacade.constructor: interop is null");
		}

		/** @type BackendInterop */
		that._interop = interop;
		if (interop.bind) {
			interop.bind("server_version_changed", that._onServerVersionChanged, that);
		}

		if (eventPublisher) {
			that.setEventPublisher(eventPublisher);
		}
	}

	setEventPublisher(eventPublisher: IEventPublisher): void {
		this.eventPublisher = eventPublisher;
	}

	protected _publishEvent(eventName: string, eventArgs?: core.AppEventArgs): void {
		let eventPublisher = this.eventPublisher;
		if (eventPublisher) {
			eventPublisher.publish(eventName, eventArgs);
		}
	}

	/**
	 * @param query
	 * @protected
	 */
	protected _normalizeQuery(query: LoadQuery): LoadQuery {
/*
		if (!query.source && query.type)
			query.source = query.type;
*/
		return query;
	}

	/**
	 * Load objects from server via BackendInterop and publish event.
	 * @param {Object} query
	 * @param {Object} options
	 * @returns {Promise}
	 * @protected
	 */
	protected _load(query: LoadQuery, options: LoadOptions): Promise<any> {
		let that = this,
			promise = that._interop.load(query, options);

		if (!options.suppressProcessEvent) {
			that._publishEvent("interop.load", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.process,
				priority: "normal",
				message: resources.loading,
				promise: promise
			}));
		}
		return promise;
	}

	/**
	 * Call server via Ajax
	 * @param {Object|String|Function} ajaxSettings Ajax settings as for jQuery.ajax()
	 * @param {Object} [options] additional options
	 * @param {Boolean} [options.suppressEventOnError=false] do not publish pub/sub event on an error
	 * @param {Boolean} [options.suppressAutoLogin=false] do not make auto login in case of a 401 response
	 * @param {Boolean} [options.suppressCacheBreakthrough=false] do not add timestamp into query string for GET-request
	 * @param {Object} [options.processEvent] data of notification event (kind=process) to override default
	 * @param {Boolean} [options.suppressProcessEvent=false] do not publish pub/sub event for process
	 * @return {*}
	 */
	ajax(ajaxSettings: AjaxSettings|string|(() => AjaxSettings), options?: AjaxOptions): Promise<any> {
		let that = this,
			settings: AjaxSettings,
			eventData: SystemEventData,
			promise: Promise<any>;

		if (core.lang.isString(ajaxSettings)) {
			settings = { url: ajaxSettings};
		} else if (core.lang.isFunction(ajaxSettings)) {
			settings = ajaxSettings();
		} else {
			settings = ajaxSettings;
		}
		options = options || {};

		promise = this._interop.ajax(settings, options)
			.done(() => {
				that._onAjaxSuccess(settings, options);
			}).fail((error) => {
				that._onAjaxFail(error, settings, options);
			});

		if (!options.suppressProcessEvent) {
			eventData = core.lang.extend({
				priority: "normal",
				message: options.fileDownload ? resources["interop.downloading_file"] :
					(settings.type === "POST" ? resources["interop.sending_data"] : resources.loading)
			}, options.processEvent, {
				kind: core.SystemEvent.Kind.process,
				promise: promise
			});
			that._publishEvent("interop.ajax", core.SystemEvent.create(eventData));
		}

		return promise;
	}

	protected _onAjaxSuccess(settings: AjaxSettings, options: AjaxOptions): void {

	}
	protected _onAjaxFail(error: InteropError, settings: AjaxSettings, options: AjaxOptions): void {
		let action = (error && error.action || "ajax");
		this._handleInteropError(action, error, options);
	}

	/**
	 * Cancel operation with id equals to opId.
	 * @param {String} opId
	 * @param {Object} [options]
	 * @param {Boolean} [options.clientOnly] do not call server controller (api/cancel)
	 * @returns {Promise}
	 */
	cancel(opId: string, options?: { clientOnly?: boolean }): Promise<any> {
		let that = this,
			settings: AjaxSettings = {
				url: "api/_cancel?$opId=" + opId,
				type: "POST"
			};
		options = options || {};
		that._interop.cancel(opId);
		if (!options.clientOnly) {
			return that._interop.ajax(settings);
		}
	}

	beginBatch(): void {
		if (this._interop.beginBatch)
			this._interop.beginBatch();
	}

	completeBatch(): void {
		if (this._interop.completeBatch)
			this._interop.completeBatch();
	}

	/**
	 *
	 * @param {Array} objects domain objects in json-form (dto)
	 * @param {Object} [options]
	 * @param {String} [reason] "load" or "save" (default)
	 * @protected
	 * @fires DataFacadeBase#update
	 */
	protected _triggerUpdate(objects: SavedObjectData[], options?: { caller?: any }, reason?: string): void {
		if (!objects || !objects.length) { return; }

		let that = this,
			args: DataUpdateEventArgs = {
				objects: objects,
				caller: options ? options.caller : null,
				reason: reason || "save"
			};

		// TODO: TOTHINK: м.б. надо асинхронно через window.setTimeout?
		/**
		 * Objects change.
		 * @event DataFacadeBase#update
		 * @type {Object}
		 * @property {Array} objects Domain objects in json-form (dto)
		 * @property {*} caller An object which called DataFacade.save method
		 * @property {String} reason A reason of updating objects: "save" or "load"
		 */
		that.trigger("update", that, args);
	}

	/**
	 * Handler to call on any error during remote save.
	 * @param {Array} objects Json objects were being saved
	 * @param {Object} error An error object got from BackendInterop.save
	 * @param {Object} options Save options - the same as DataFacade.save
	 * @param {jQuery.Deferred} defer Deferred to reject with normalized error
	 * @protected
	 */
	protected _onRemoteSaveError(objects: DomainObjectData[], error: any, options: SaveOptions, defer: Deferred<any>): void {
		let that = this,
			event: SystemEvent;

		// save operation can return json result (not exception) with 'error' field of type exception
		if (error.error && error.error.$isException) {
			error = that.errorFromJson(error.error);
		}
		options = options || {};

		if (!options.suppressEventOnError) {
			event = that.createSaveErrorEvent(error, options, objects);
			if (event) {
				that._publishEvent("interop.save.error", event);
			}
		}
		if (defer) {
			defer.reject(error);
		}

		// interop error contains a list of obsolete deleted objects
		if (core.eth.isOptimisticConcurrency(error)) {
			let deletedObjects = error.deletedObjects;
			if (deletedObjects) {
				that._triggerUpdateObsolete(deletedObjects, options);
			}
		}
	}

	protected _triggerUpdateObsolete(objects: ObjectIdentity[], options?: { caller?: any }): void {
		if (!objects || !objects.length) { return; }

		let that = this,
			args: DataUpdateEventArgs = {
				objects: null,
				deletedObjects: objects,
				caller: options ? options.caller : null,
				reason: "save"
			};
		window.setTimeout(() => {
			that.trigger("update", that, args);
		});
	}

	/**
	 * Create a SystemEvent for save error.
	 * @param {Object} error An error object got from BackendInterop.save
	 * @param {Object} options Save options - the same as DataFacade.save
	 * @param {Array<DomainObjectData>} objects Json objects were being saved
	 * @returns {SystemEvent}
	 */
	createSaveErrorEvent(error: InteropError, options: SaveOptions, objects: DomainObjectData[]): SystemEvent {
		let event = this.createInteropErrorEvent("save", error);
		event.message = resources["interop.save.failed"] + ". " + event.message;
		event.priority = "high";
		// TODO: добавить операции Retry/Cancel, см. ObjectList.createAsyncSaveErrorEvent, надо вынести оттуда, чтобы также использовалось по умолчанию в дереве и любых других контекстах

		return event;
	}

	/**
	 * Create a SystemEvent for save success.
	 * @param {Object} response Server response
	 * @returns {SystemEvent}
	 */
	createSaveSuccessEvent(response: SaveResponse): SystemEvent {
		if (response && response.error) {
			// success but with warning
			return new core.SystemEvent({
				kind: core.SystemEvent.Kinds.notification,
				priority: "normal",
				severity: "warning",
				message: resources["interop.save.success_with_warning"] + ": " + response.error.message
			});
		}
		return new core.SystemEvent({
			kind: core.SystemEvent.Kinds.notification,
			priority: "low",
			severity: "success",
			message: resources["interop.save.success"]
		});
	}

	protected _handleInteropError(action: string, error: Error, options: AjaxOptions): void {
		let that = this;
		if (!options || !options.suppressEventOnError) {
			that._publishEvent("interop.error", that.createInteropErrorEvent(action, error));
		}
	}

	/**
	 * Create a SystemEvent for a general interop error
	 * @param {String} action Executed action ("save", "load", "ajax" and so on)
	 * @param {Object} error An error from the server parsed with BackendInterop.tryParseException
	 * @return {SystemEvent}
	 */
	createInteropErrorEvent(action: string, error: InteropError): SystemEvent {
		let menu;
		if (error && error.serverError && this._interop.config.isDebug) {
			menu = core.ui.Menu.create({ items: [{
				name: "Debug",
				command: core.createCommand({
					execute: function () {
						let errorText = JSON.stringify(error.serverError, null, 2).replace(/\\r\\n/g, "\n").replace(/\\\\/g, "\\");
						core.ui.Dialog.create({
							header: "Server error debug info",
							menu: { remove: ["cancel"]},
							html: "<pre class='x-modal-error-info'>" + core.lang.encodeHtml(errorText) + "</pre>"
						}).render();
						return false;
					}
				})
			}]});
		}
		return core.SystemEvent.create({
			kind: core.SystemEvent.Kind.notification,
			priority: "normal",
			severity: (error && error.hasUserDescription) ? "warning" : "error",
			message: (error && error.message)
				? error.message
				: resources["interop.error.default"],
			error: error,
			menu: menu
		});
	}

	createServerVersionChangedEvent(data: any): SystemEvent {
		return core.SystemEvent.create({
			kind: core.SystemEvent.Kind.actionRequest,
			// TODO: может priority="max"?
			message: core.safeHtml(
				resources["interop.server_version_changed.html"],
				resources["interop.server_version_changed"]),
			severity: "warning",
			uid: "interop.server_version_changed",
			data: data,
			menu: { hidden: true,
				items: [{
					name: "Reload",
					title: resources["reload"],
					command: core.createCommand({
						execute: function () {
							/*if (window.applicationCache) {
							 window.applicationCache.swapCache()
							}*/
							window.location.reload();
						}
					})
				}
				// TODO: команда "Игнорировать"/"Отложить" (возможно настраиваемая) ?
				// или например в зависимости от разности версии: 1.0.0 => 2.0.0 не игнорируемая, 1.1.0 => 1.2.0 игнорируемая
			]}
		});
	}

	protected _onServerVersionChanged(args?: SystemVersionChangedEventArgs): void {
		if (!args || args.oldVersion) {
			this._publishEvent(
				"interop.server_version_changed",
				this.createServerVersionChangedEvent(
					args ? {
						// for backward compatibility:
						version: args.newVersion,
						newVersion: args.newVersion,
						oldVersion: args.oldVersion
					} : {
						oldVersion: -1
					})
			);
		}
	}

	protected _objectsFromResponse(response: LoadResponse, query: LoadQuery): DomainObjectData[] {
		if (!response) { return []; }

		let result: DomainObjectData[], more: DomainObjectData[];
		// substitute __metadata.type from query.type
		result = [].concat(response.result || []).filter((obj: DomainObjectData) => {
			// TOTHINK: should we substitute id from query.source.id?
			if (!obj || !obj.id) { return false; }

			// TODO: почему бы не взять сначала obj.__metadata.type?
			if (query.type) {
				obj.__metadata = core.lang.append(obj.__metadata || {}, { type: query.type });
				return true;
			}

			return !!(obj.__metadata && obj.__metadata.type);
		});
		// NOTE: query.type isn't suitable for objects in 'more'
		more = [].concat(response.more || []).filter((obj: DomainObjectData) => {
			return !!(obj && obj.id && obj.__metadata && obj.__metadata.type);
		});
		return result.concat(more);
	}

	/**
	 * Updates `objects` with data from server response (`response`).
	 * @param {Array} objects Objects were being saved
	 * @param {Object} response Response from DomainController
	 * @param {Boolean} [repeated] Whether objects were already updated from another response
	 * @protected
	 */
	protected _updateSaved(objects: SavedObjectData[], response?: SaveResponse, repeated?: boolean): void {
		let processedObjects: core.lang.Map<boolean> = {};
		objects.forEach((obj: SavedObjectData) => {
			let newId: string,
				updatedObj: DomainObjectData;

			if (!repeated) {
				obj.__metadata.ts = obj.__metadata.ts + 1 || 1;
				delete obj.__metadata.isNew;
			}

			// try to find newId
			if (response && response.newIds && response.newIds.length) {
				response.newIds.some(function (o) {
					if (o.id === obj.id && o.type === obj.__metadata.type) {
						newId = o.newId;
						return true;
					}
					return false;
				});
			}

			// try to find updatedObj with new values of properties
			if (response && response.updatedObjects && response.updatedObjects.length) {
				for (let i = 0; i < response.updatedObjects.length; i++) {
					let o = response.updatedObjects[i];
					if (o.id === (newId || obj.id) && o.__metadata.type === obj.__metadata.type) {
						updatedObj = o;
						// memorize the fact that we've processed the object
						processedObjects[i] = true;
						break;
					}
				}
			}

			// set __newValues
			if (newId) {
				obj.__newValues = { id: newId };
			}
			if (updatedObj) {
				obj.__newValues = obj.__newValues || {};
				// copy all values from updatedObj except __metadata and id
				core.lang.forEach(updatedObj, (v, name) => {
					if (name === "__metadata") {
						if (updatedObj.__metadata.ts) {
							obj.__metadata.ts = updatedObj.__metadata.ts;
						}
					} else if (name !== "id") {
						obj.__newValues[name] = v;
					}
				});
			}

			// delete resourceId for binary properties values
			core.lang.forEach(obj, (v, name) => {
				if (v && v.$value === "LobPropValue") {
					obj.__newValues = obj.__newValues || {};
					v = core.lang.clone(v);
					delete v.resourceId;
					obj.__newValues[name] = v;
				}
			});
		});
		if (response && response.updatedObjects && response.updatedObjects.length) {
			// now process objects in 'updatedObjects' which were not sent from the client (absent in 'objects')
			// BUT they should be updated as well
			core.lang.forEach(response.updatedObjects, (obj, index) => {
				if (processedObjects[index]) { return; }
				let newObj = <any>obj;
				newObj.__newValues = newObj.__newValues || {};
				// NOTE: if object data from response contains ts (newObj.__metadata.ts) then
				//	it will normally be used in DataStore.commit to update object in store
				//	But if it doesn't then we need to put a kind of command to say DataStore to increment ts
				//	(we don't known ts's actual value).
				if (!newObj.__metadata.ts) {
					newObj.__newValues.__incrementTs = true;
				}

				objects.push(newObj);
			});
		}
	}

	protected _updateFromNewValues(objects: SavedObjectData[]): void {
		objects.forEach(function (obj) {
			if (obj.__newValues) {
				// WAS:
				//if (obj.__newValues.__aux) {
				//	obj.__aux = core.lang.extend(obj.__aux || {}, obj.__newValues.__aux);
				//	delete obj.__newValues.__aux;
				//}
				//core.lang.extend(obj, obj.__newValues);
				core.lang.forEach(obj.__newValues, function (v, name) {
					if (name === "id" || name === "__incrementTs") { return; }
					if (name === "__aux") {
						obj.__aux = core.lang.extend(obj.__aux || {}, v);
						return;
					}
					obj[name] = v;
				});
			}
		});
	}

	errorFromJson(exceptionJson: ExceptionData): InteropError {
		return this._interop.tryParseException(exceptionJson);
	}

/*
	handleAjaxError(jqXhr, textStatus, options?: AjaxOptions) {
		let error = this._interop.handleError(jqXhr, textStatus);
		this._handleInteropError("ajax", error, options);
	}
*/
}

export = DataFacadeBase;
