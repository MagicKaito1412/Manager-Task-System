import core = require("core");
import DataFacadeBase = require("lib/interop/DataFacadeBase");
import DataSynchronizer = require("lib/interop/DataSynchronizer");
import CacheManager = require("lib/interop/CacheManager");
import diagnostics = require("lib/core.diagnostics");
import resources = require("i18n!lib/nls/resources");
import Menu = require("lib/ui/menu/Menu");
import ConfirmDialog = require("lib/ui/ConfirmDialog");
import ObjectEditor = require("lib/ui/editor/ObjectEditor");
import DataStoreBase = require("lib/data/DataStoreBase");

import {
	DomainObjectData,
	SavedObjectData,
	ExceptionData,
	InteropError,
	AjaxSettings,
	AjaxOptions,
	LoadQuery,
	LoadResponse,
	LoadOptions,
	SaveOptions,
	SaveResponse,
	IBackendInterop,
	CheckConnectionResult as CheckConnectionResultBase,
	LoadPolicy, LoadPolicyRule, LoadQuerySource
} from ".interop";
import { LoadRule, SaveMode, SaveTarget } from "lib/interop/.interop.types";

import lang = core.lang;
import IEventPublisher = core.IEventPublisher;
import SystemEvent = core.SystemEvent;
import SystemEventData = core.SystemEvent.Options;
import Deferred = lang.Deferred;
import Promise = lang.Promise;

class DataFacadeSmart extends DataFacadeBase {

	/**
	 * @type {Object}
	 * @property {Number} checkConnectionTimeout
	 * @property {Boolean} forceLoadUnsync Add non-synchronized objects to a result of loading
	 * @property {Boolean} allowGoOffline Allow adding "GoOffline" command into all interop error notifications.
	 * @property {Function} DataSynchronizer Class of DataSynchronizer implementation
	 * @property {Function} CacheManager Class for CacheManager implementation
	 * @property {CacheManager} cacheManager cacheManager instance
	 * @property {LoadRule} loadRule A default load rule for cacheManager
	 */
	static defaultOptions: DataFacadeSmart.Options = {
		saveMode: "smart",
		checkConnectionTimeout: 1000,
		forceLoadUnsync: false,
		allowGoOffline: true,
		supportNetworkRealtimeEvents: true,
		DataSynchronizer: DataSynchronizer,
		CacheManager: CacheManager,
		cacheManager: undefined,
		loadRule: undefined
	};
	options: DataFacadeSmart.Options;
	protected _supportNetworkRealtimeEvents: boolean;
	protected _cacheManager: CacheManager;
	private _synchronizr: DataSynchronizer;
	private _store: DataStoreBase;
	private _lastCheckCon: number;

	/**
	 * @class DataFacadeSmart
	 * @extends DataFacadeBase
	 * @param {BackendInterop} interop
	 * @param {EventPublisher} eventPublisher
	 * @param {DataStoreBase} dataStore
	 * @param {Object} options Additional options
	 * @param {CacheManager} options.cacheManager
	 * @param {Function} options.DataSynchronizer
	 * @param {"remoteFirst"|"localFirst"|"localIfOffline"|"cached"|"remoteOnly"|"localOnly"} options.loadRule
	 * @param {Boolean} options.supportNetworkRealtimeEvents
	 * @param {"smart"|"offline"|"remoteOnly"} options.saveMode Saving mode: smart, offline, online (by default 'smart'), see property saveMode
	 */
	constructor (interop: IBackendInterop, eventPublisher: IEventPublisher, dataStore: DataStoreBase, options: DataFacadeSmart.Options) {

		super(interop, eventPublisher);
		if (!dataStore) {
			throw new Error("DataFacade.ctor: DataStore should be specified");
		}

		this.options  = lang.appendEx(options || {}, DataFacadeSmart.defaultOptions, { deep: true });

		this._initDataStore(dataStore);

		// Do we support real-time network events (online/offline)? - unfortunately Modernizr unable to detect them
		this._supportNetworkRealtimeEvents = this.options.supportNetworkRealtimeEvents;

		this.manuallyDisconnected(!!core.settings.getItem("DataFacade.manuallyDisconnected"));

		this.saveMode(this.options.saveMode);
		this.networkOnline(true);
		this.serverOnline(true);

		this._updateSaveTarget(/*doSchedule=*/true);

		this._cacheManager = this._createCacheManager();

		if (interop.bind) {
			interop.bind("offline", () => {
				this.traceSource.debug("DataFacade gets 'offline' event from interop");
				// network has disappeared, we're offline for sure
				this.networkOnline(false);
				this.serverOnline(false);
				if (this.saveMode() !== SaveMode.remoteOnly) {
					this.saveTarget(SaveTarget.local);
				}
			});
			interop.bind("online", () => {
				this.traceSource.debug("DataFacade gets 'online' event from interop");
				// network has appeared,
				// it means only that network is available, server MAY be still offline, but we care about this only in 'smart' mode
				this.networkOnline(true);
				if (!this.manuallyDisconnected() && this.saveMode() === SaveMode.smart) {
					// NOTE: after network restored we need to restore online/serverOnline statuses
					this.checkConnection().then(() => {
						this._scheduleSyncIfNeeded();
					});
				}
			});
		}

		if (interop.checkAppCache) {
			interop.checkAppCache((result) => {
				if (result === "updateready") {
					this._onServerVersionChanged();
				}

				if (result !== "uncached") {
					let isObsolete = (result === "obsolete");
					this.checkConnection().then((result) => {
						if (isObsolete && !result.serverOnline) {
							this._publishEvent("interop.appcache_obsolete_warning", core.SystemEvent.create({
								kind: core.SystemEvent.Kind.notification,
								priority: "high",
								message: resources["interop.appcache_obsolete_warning"],
								severity: "warning"
							}));
						}
					});
				}
			});
		}

		this.bind("change:manuallyDisconnected", (sender, v) => {
			if (!v) {
				// NOTE: after manuallyDisconnected changed from true to false we need to restore online/serverOnline statuses
				this.checkConnection().then(() => {
					this._scheduleSyncIfNeeded();
				});
			} else {
				if (this.saveMode() !== SaveMode.remoteOnly) {
					this.saveTarget(SaveTarget.local);
				}
				this._synchronizr.cancel();
			}
			core.settings.setItem("DataFacade.manuallyDisconnected", v);
		});

		this.bind("change:saveMode", () => {
			this._updateSaveTarget();
		});
	}

	setEventPublisher(eventPublisher: IEventPublisher): void {
		super.setEventPublisher(eventPublisher);

		eventPublisher.subscribe("interop.sync.retry", (ev) => {
			this._onSyncRetry(ev.args);
		});
		eventPublisher.subscribe("interop.sync.cancel", (ev) => {
			this._onSyncCancel(ev.args);
		});
	}

	/**
	 * Current saving mode
	 * @observable-property {DataFacadeSmart#saveModes}
	 */
	@lang.decorators.observableAccessor()
	saveMode: lang.ObservableProperty<SaveMode>;

	/**
	 * Network is accessible on the device. If true, serverOnline MAY be true or false.
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	networkOnline: lang.ObservableProperty<boolean>;

	/**
	 * Server was accessible on last check. If true then networkOnline MUST be true.
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	serverOnline: lang.ObservableProperty<boolean>;

	/**
	 * Where to save data.
	 * @observable-property {DataFacadeSmart#saveTargets}
	 */
	@lang.decorators.observableAccessor()
	saveTarget: lang.ObservableProperty<SaveTarget>;

	/**
	 * If true then DataFacade will not try to call the server at all.
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	manuallyDisconnected: lang.ObservableProperty<boolean>;

	/**
	 * DataSynchronizer is synchronizing offline changes.
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isSynchronizing: lang.ObservableProperty<boolean>;

	/**
	 * An error occurred during offline changes synchronization and DataFacade's waiting for its processing completes.
	 * @observable-property {Boolean}
	 */
	@lang.decorators.observableAccessor({init: false})
	isSyncErrorProcessing: lang.ObservableProperty<boolean>;

	traceSource: diagnostics.TraceSource = new diagnostics.TraceSource("interop.DataFacade");

	protected _initDataStore (dataStore: DataStoreBase): void {
		let that = this;

		that._onStoreRawError = lang.debounce(that._onStoreRawError, 100);

		if (lang.isPromise(dataStore)) {
			dataStore.then((dataStore) => {
				that._initDataStore2(dataStore);
				that._updateSaveTarget(/*doSchedule=*/true);
			});
		} else {
			that._initDataStore2(dataStore);
		}
	}

	protected _initDataStore2 (dataStore: DataStoreBase): void {
		let that = this;
		that._store = dataStore;
		that._store.bind("error", that._onStoreRawError, that);
		that._synchronizr = that._createDataSynchronizer(dataStore);
		dataStore.test();
	}

	protected _createDataSynchronizer (dataStore: DataStoreBase): DataSynchronizer {
		let that = this;
		let synchronizer = new that.options.DataSynchronizer(dataStore, {
			save: that._interop.save.bind(that._interop),
			ping: that.checkConnection.bind(that)
		});
		synchronizer.bind("sync.success", that._onStoreSynced, that);
		synchronizer.bind("sync.error", that._onStoreSyncError, that);
		synchronizer.bind("change:state", (sender, value) => {
			that.isSynchronizing(value === DataSynchronizer.State.Synchronizing);
		});
		return synchronizer;
	}

	protected _getDefaultLoadRule (): LoadRule {
		let rule = this.options.loadRule;
		if (!rule) {
			switch (this.saveMode()) {
				case SaveMode.smart:
					rule =  LoadRule.localIfOffline;
					break;
				case SaveMode.remoteOnly:
					rule =  LoadRule.remoteFirst;
					break;
				default:
					rule =  LoadRule.cached;
					break;
			}
		}
		return rule;
	}

	protected _createCacheManager (): CacheManager {
		let that = this;
		return that.options.cacheManager ||
			new that.options.CacheManager({defaultRule: that._getDefaultLoadRule()});
	}

	protected _updateSaveTarget (doSchedule?: boolean): void {
		let that = this;

		switch (that.saveMode()) {
			case SaveMode.smart:
				if (!that.manuallyDisconnected() && that.serverOnline()) {
					if (!that._store) {
						// Initial initialization while DataStore isn't ready yet
						that.saveTarget(SaveTarget.remoteFirst);
						break;
					}
					lang.when(that._store.hasChanges())
						.done((hasChanges: boolean) => {
							// TODO: может здесь вызвать checkConnection если serverOnline=false ?
							that.saveTarget(hasChanges ? SaveTarget.local : SaveTarget.remoteFirst);
							if (doSchedule && hasChanges) {
								that._scheduleSyncIfNeeded();
							}
						})
						.fail(() => {
							that.saveTarget(SaveTarget.remoteFirst);
						});
				} else {
					that.saveTarget(SaveTarget.local);
				}
				break;
			case SaveMode.offline:
				that.saveTarget(SaveTarget.local);
				if (doSchedule) {
					that._scheduleSyncIfNeeded();
				}
				break;
			case SaveMode.remoteOnly:
				that.saveTarget(SaveTarget.remoteOnly);
				break;
		}
	}

	dispose (): void {
		this._store.unbind("error", null, this);
		this._synchronizr.cancel();
	}

	ajax(ajaxSettings: AjaxSettings|string|(() => AjaxSettings), options?: AjaxOptions): Promise<any> {
		// TODO: ajax resposes caching: if (options.cachable) {}
		if (this.manuallyDisconnected()) {
			let error: InteropError = new Error(resources["interop.server_unavailable"]);
			error.serverOffline = true;
			this._handleInteropError("ajax", error, options);
			return lang.rejected(error);
		}
		return super.ajax(ajaxSettings, options);
	}

	protected _onAjaxSuccess(settings: AjaxSettings, options: AjaxOptions): void {
		this.serverOnline(true);
	}

	protected _onAjaxFail(error: InteropError, settings: AjaxSettings, options: AjaxOptions): void {
		super._onAjaxFail(error, settings, options);
		if (error.serverOffline) {
			this.serverOnline(false);
		}
	}

	protected _normalizeResponse (response: LoadResponse): LoadResponse {
		response = response || {};
		response.hints = response.hints || {};
		return response;
	}

	protected _addResponseHint (response: LoadResponse, fieldName: string, fieldValue: any): LoadResponse {
		response = this._normalizeResponse(response);
		response.hints[fieldName] = fieldValue;
		return response;
	}

	protected _localResponse (response: LoadResponse, policies): LoadResponse {
		response = this._normalizeResponse(response);
		response.hints.source = "client";
		if (policies.onlinePolicy && policies.onlinePolicy.loadFirst !== policies.policy.loadFirst) {
			response.hints.message = resources["interop.hint.returned_local_data_due_to_server_offline"];
		}
		return response;
	}

	protected _serverResponse (response: LoadResponse): LoadResponse {
		response = this._normalizeResponse(response);
		response.hints.source = "server";
		return response;
	}

	protected _serverErrorResponse (response: LoadResponse, error: InteropError): LoadResponse {
		response = this._normalizeResponse(response);
		lang.extend(response.hints, {
			message: resources["interop.hint.returned_local_data_due_to_server_error"],
			source: "client",
			error: error
		});
		return response;
	}

	/**
	 * Load data.
	 * @param {Object} query query JSON-object
	 * @param {Object|String} query.source name of source or JSON-object to load from
	 * @param {String} query.source.type entityType when loading objects
	 * @param {String} [query.source.id] objectId when loading a single object
	 * @param {String} [query.source.propName] name of navigation property
	 * @param {String} [query.type] entityType name of loading objects
	 * @param {String} [query.preloads] array of property names or property chains
	 * @param {Object} [query.params] query parameters
	 * @param {Object} options
	 * @param {String} [options.opId] cancellation operation id
	 * @param {String|Object} [options.policy] explicit policy (if specified it will override CacheManager's rule)
	 * @returns {*}
	 */
	load (query: LoadQuery, options?: LoadOptions): Promise<LoadResponse> {
		let that = this;
		options = options || {};
		query = that._normalizeQuery(query);
		let policies = that._getLoadPolicy(query, options);
		let policy = options.policy = policies.policy;
		let defer = lang.Deferred();
		if (policy.loadFirst === "remote") {
			that.loadRemotely(query, options)
				.done((response) => {
					defer.resolve(that._serverResponse(response));
				})
				.fail((error) => {
					if (that._isUnrecoverableError(error)) {
						// Bad Data: the request illegal and should not be repeated!
						defer.reject(error);
					} else {
						if (that.serverOnline()) {
							// Remote load failed but serverOnline=true, we should update it.
							// But we cannot be sure about what kind of error we got from loadRemotely
							// It could mean something different than server inaccessibility error
							if (that._isServerInaccessibilityError(error)) {
								that.serverOnline(false);
								that._schedulePing();
							}
						}

						if (policy.allowLocal) {
							// TODO: здесь нюанс - мы получили какую-то ошибку и скрываем ее, если данные найдутся локально
							// Это может быть не то, что мы хотели, возвращая ошибку с сервера.
							that.loadLocally(query, options)
								.done((response) => {
									if (!response || !response.found) {
										defer.reject(error);
									} else if (response) {
										// found something locally, we have to ignore maxAge as server load failed anyway
										defer.resolve(that._serverErrorResponse(response, error));
										// as we're going to return cached data and an error occurred, let's show a warning to user
										that._handleInteropError("load", error, options);
									}
								})
								.fail((error) => {
									// it isn't a normal situation
									defer.reject(error);
								});
						} else {
							defer.reject(error);
						}
					}
				});
		} else {	// i.e. policy.loadFirst === "local"
			that.loadLocally(query, options)
				.done((response) => {
					let maxAge = lang.coalesce(policy.maxAge, policies.onlinePolicy && policies.onlinePolicy.maxAge);
					if (!response || !response.found) {
						if (policy.allowRemote && that.serverOnline()) {
							that.loadRemotely(query, options)
								.done((response: LoadResponse ) => {
									defer.resolve(that._serverResponse(response));
								})
								.fail((error: InteropError) => {
									if (that._isServerInaccessibilityError(error)) {
										that.serverOnline(false);
										that._schedulePing();
									}
									defer.reject(error);
								});
						} else {
							// NOTE: actually we're returning empty result ({found:false})
							defer.resolve(that._localResponse(response, policies));
						}
						if (!that.serverOnline()) {
							that._schedulePing();
						}
					} else if (lang.isNumber(maxAge) || response.found === "unsync") {
						// NOTE: response.found can be true, false or "unsync". Last value means that the cached
						// result was not found, but the response contains unsynchronized objects only.

						// found locally but we should check cache age
						if (lang.isNumber(response.age) && response.age <= maxAge) {
							// TODO: проверить, что полученные объкты содержат все свойства, загружаемые по умолчанию (скалярные без lazyLoad)
							defer.resolve(that._localResponse(response, policies));
						} else {
							// local data is outdated (or contains only unsynchronized objects), we should load remotely
							// BUT if we're offline or an error occurred, then the data will be used anyway
							if (policy.allowRemote && that.serverOnline()) {
								that.loadRemotely(query, options)
									.done((response: LoadResponse) => {
										defer.resolve(that._serverResponse(response));
									})
									.fail((error) => {
										if (that._isUnrecoverableError(error)) {
											defer.reject(error);
										} else {
											if (that._isServerInaccessibilityError(error)) {
												that.serverOnline(false);
												that._schedulePing();
											}
											// as we're going to return cached data and an error occurred, let's show warning to user
											that._handleInteropError("load", error, options);

											defer.resolve(that._serverErrorResponse(response, error));
										}
									});
							} else {
								that._schedulePing();
								response = that._localResponse(response, policies);
								response.hints.message = resources["interop.hint.returned_local_data_due_to_server_offline"];
								defer.resolve(response);
							}
						}
					} else {
						// i.e. response.found=true
						// TODO: проверить, что полученные объкты содержат все свойства, загружаемые по умолчанию (скалярные без lazyLoad)
						if (!that.serverOnline()) {
							that._schedulePing();
						}
						defer.resolve(that._localResponse(response, policies));
					}
				})
				.fail((error) => {
					// it isn't a normal situation

					if (policy.allowRemote && that.serverOnline()) {
						that.loadRemotely(query, options)
							.done((response: LoadResponse) => {
								defer.resolve(that._serverResponse(response));
							})
							.fail((error) => {
								if (that._isServerInaccessibilityError(error)) {
									that.serverOnline(false);
									that._schedulePing();
								}
								defer.reject(error);
							});
					} else {
						defer.reject(error);
					}
					if (!that.serverOnline()) {
						that._schedulePing();
					}
				});
		}
		defer.fail((error) => {
			that._handleInteropError("load", error, options);
		});
		return defer.promise();
	}

	/**
	 * Calculates load policy
	 * @param query
	 * @param options
	 * @returns {{policy: Object, onlinePolicy: Object}}
	 * @private
	 */
	protected _getLoadPolicy (query: LoadQuery, options?: LoadOptions): {policy: LoadPolicy, onlinePolicy: LoadPolicy}{
		let that = this;
		let onlinePolicy: LoadPolicy;

		let policy = options.policy || that._cacheManager.getLoadPolicy(query, options);

		if (!policy || !(<any>policy).loadFirst) {
			// 'policy' is not a full policy (LoadPolicy), it's a rule (LoadRule/LoadPolicyRule).
			//	It can be a rule name or an object with a rule name:
			let rule: LoadRule;
			if (lang.isString(policy)) {
				rule = LoadRule[policy];
			} else {
				rule = LoadRule[(<LoadPolicyRule>policy).rule];
			}
			// normalize rule name to enum:
			if (!rule) {
				// probably we encountered an incorrect CacheManager implementation:
				// it didn't return nor a policy nor a rule.
				rule = that._getDefaultLoadRule();
			}
			// Now 'rule' is a value of LoadRule

			// TODO: remove AlwaysRemote/AlwaysLocal in 0.11 version
			if (rule === LoadRule.remoteFirst) {
				policy = {
					loadFirst: "remote",
					allowRemote: true,
					allowLocal: true,
					shouldCache: false
				};
			} else if (rule === LoadRule.localFirst) {
				policy = {
					loadFirst: "local",
					allowRemote: true,
					allowLocal: true,
					shouldCache: true
				};
			} else if (rule === LoadRule.localIfOffline) {
				policy = {
					loadFirst: that.serverOnline() ? "remote" : "local",
					allowRemote: true,
					allowLocal: true,
					shouldCache: true
				};
				onlinePolicy = {
					loadFirst: "remote",
					allowRemote: true,
					allowLocal: true,
					shouldCache: true
				};
			} else if (rule === LoadRule.cached) {
				policy = {
					loadFirst: "local",
					allowRemote: true,
					allowLocal: true,
					shouldCache: true,
					maxAge: (<LoadPolicyRule>policy).maxAge
				};
			} else if (rule === LoadRule.remoteOnly) {
				policy = {
					loadFirst: "remote",
					allowRemote: true,
					allowLocal: false,
					shouldCache: false
				};
			} else if (rule === LoadRule.localOnly) {
				policy = {
					loadFirst: "local",
					allowRemote: false,
					allowLocal: true,
					shouldCache: false
				};
			}
		}

		if (that.manuallyDisconnected()) {
			onlinePolicy = onlinePolicy || <LoadPolicy>policy;
			policy = {
				loadFirst: "local",
				allowRemote: false,
				allowLocal: true,
				shouldCache: false
			};
		}

		return {
			policy: <LoadPolicy>policy,
			onlinePolicy: onlinePolicy
		};
	}

	loadRemotely (query: LoadQuery, options: LoadOptions): Promise<LoadResponse> {
		let that = this,
			response: LoadResponse,
			objects,
			policy: LoadPolicy = (options && <LoadPolicy>options.policy);

		// NOTE: maybe we should pass options to backendInterop.load?
		return that._load(query, options)
			.then((r) => {
				response = r;
				that.serverOnline(true);

				// don't cache anything from custom route
				if (query.route) {
					return true;
				}

				// cache data in the store
				objects = that._objectsFromResponse(response, query);
				return lang.when(
						policy.allowLocal && objects && objects.length &&
						that._store.cache(objects, { actualize: true, skipMissing: !policy.shouldCache})
					)
					.then(() => {
						if (policy.shouldCache) {
							return that._store.cacheQuery(query, response);
						}
					})
					.then(() => {
						return true;
					}, () => {
						// NOTE: ignore any errors while caching
						return lang.resolved();
					});
			})
			.then(() => {
				// уведомляем об обновлении данных
				if (objects && objects.length) {
					that._triggerUpdate(objects, options, "load");
				}
				return response;
			});
	}

	loadLocally (query: LoadQuery, options: LoadOptions): Promise<DataStoreBase.LoadResponse> {
		options = options || {};

		let that = this,
			forceLoadUnsync = lang.coalesce(options.forceLoadUnsync, that.options.forceLoadUnsync),
			deferredQuery = that._store.query(query),
			deferredSelect;

		if (!forceLoadUnsync || !query.type || (<LoadQuerySource>query.source).id || (<LoadQuerySource>query.source).propName) {
			return deferredQuery;
		}

		deferredSelect = that._store.select({
			type: query.type,
			hasChanges: true, // select only changed objects
			isRemoved: false  // not removed objects
		});
		return lang.when(deferredQuery, deferredSelect)
			.then((response: DataStoreBase.LoadResponse, changed: DomainObjectData[]) => {
				if (changed && changed.length) {
					// found non-synchronized objects
					changed.forEach((obj) => {
						// NOTE: hasUnsyncChanges is used in DomainObject.fromJson overridden module-security
						(<any>obj.__metadata).hasUnsyncChanges = true;
					});

					if (response.found) {
						if (lang.isArray(response.result)) {
							// add non-synchronized to response
							// TODO: use DomainObjectMap. But we need domain model for this.
							let ids = {};
							response.result.forEach((obj) => {
								ids[obj.id] = obj;
							});
							changed.forEach((obj) => {
								let found = ids[obj.id];
								if (found) {
									// NOTE: hasUnsyncChanges is used in DomainObject.fromJson overridden module-security
									(<any>found.__metadata).hasUnsyncChanges = true;
								} else {
									response.result.push(obj);
								}
							});
						} else {
							// response found in cache but it's empty
							response.result = changed;
						}
					} else {
						// return only non-synchonized objects
						response = {
							found: "unsync", // response contains unsynchronized objects only
							result: changed
						};
					}
				}

				return response;
			});
	}

	/**
	 * Run server connection checking.
	 * @param {Object} options
	 * @param {Boolean} [options.suppressSaveTargetUpdate=false]
	 * @returns {Promise} Promise will be revolved (never rejected) into object {networkOnline: boolean, serverOnline: boolean, notificationPublished: boolean}
	 */
	checkConnection (options?: {suppressSaveTargetUpdate: boolean}): Promise<DataFacadeSmart.CheckConnectionResult> {
		let that = this;
		if (!that._interop.checkConnection) {
			that.networkOnline(true);
			that.serverOnline(true);
			if (that.saveMode() !== SaveMode.remoteOnly) {
				that.saveTarget(SaveTarget.local);
			}
			return lang.resolved({networkOnline: true, serverOnline: true});
		}
		// threshold
		if (that._lastCheckCon && Date.now() - that._lastCheckCon < that.options.checkConnectionTimeout) {
			return lang.resolved({
				networkOnline: that.networkOnline(),
				serverOnline: that.serverOnline()
			});
		}
		// NOTE:
		return that._interop.checkConnection("POST")
			.then((result: DataFacadeSmart.CheckConnectionResult) => {
				that._lastCheckCon = Date.now();
				if (that.traceSource.enabled("debug")) {
					that.traceSource.debug(() => { return "checkConnection: " + JSON.stringify(result); });
				}

				let networkOnline = result.networkOnline,
					serverOnline = result.serverOnline;
				if (serverOnline && !networkOnline) {
					that.traceSource.warn("BackendIntreop.checkConnection returns inconsistent values: serverOnline is true, but networkOnline is false");
					networkOnline = true;
				}
				if (that.serverOnline() && !serverOnline) {
					result.notificationPublished = true;
					that._publishEvent("interop.offline", core.SystemEvent.create({
						kind: core.SystemEvent.Kind.notification,
						priority: "normal",
						message: resources["interop.offline"]
					}));
				} else if (that.serverOnline() === false && serverOnline) {
					result.notificationPublished = true;
					that._publishEvent("interop.online", core.SystemEvent.create({
						kind: core.SystemEvent.Kind.notification,
						priority: "normal",
						message: resources["interop.online"]
					}));
				}
				that.networkOnline(networkOnline);
				that.serverOnline(serverOnline);
				if (!options || !options.suppressSaveTargetUpdate) {
					// now update 'saveTarget' property, it depends on current saveMode
					if (that.saveMode() === SaveMode.smart) {
						let curMode = that.saveTarget();
						if (curMode === undefined) {
							// NOTE: we're here from constructor, checkConnection/updateSaveTarget are called concurrently
							that.saveTarget(serverOnline ? SaveTarget.remoteFirst : SaveTarget.local);
						} else if (!serverOnline) {
							that.saveTarget(SaveTarget.local);
						} else if (curMode === SaveTarget.local && serverOnline) {
							// In smart mode if there's no changes we should change saveTarget to "remoteFirst"
							that._updateSaveTarget();
						}
					}
				}
				return result;
			});
	}

	protected _schedulePing (): void {
		let that = this;
		if (that.manuallyDisconnected()) {
			return;
		}
		if (!that.networkOnline() && that._supportNetworkRealtimeEvents) {
			return;
		}
		// schedule ping if and only if DataSynchronizer isn't synchronizing any changes
		if (!that._synchronizr.isScheduledOrSynchronizing()) {
			that._synchronizr.schedulePing();
			that.traceSource.debug("DataFacade scheduled ping");
		}
	}

	/**
	 * Save objects.
	 * @param {Array} objects domain objects in json-form (dto)
	 * @param {Object} options Options
	 * @param {Object} options.policy
	 * @param {String} options.policy.target Where to save, see `DataFacadeSmart.saveTargets`
	 * @param {Boolean} options.policy.shouldCache Whether to cache saved object locally or not
	 * @param {String|Array} [options.hints] hints for save operation (passed to the server)
	 * @param {Boolean} options.suppressAutoLogin
	 * @param {Boolean} [options.suppressEventOnError=false] Suppress event publishing on an error
	 * @param {Boolean} [options.suppressEventOnSuccess=false] Suppress event publishing on success
	 * @param {Boolean} [options.suppressProcessEvent=false] Suppress progress event publishing
	 * @return {Promise} object for async operation of saving
	 */
	save(objects: DomainObjectData[], options?: SaveOptions): lang.Promise<SavedObjectData[]> {
		let defer: JQueryDeferred<SavedObjectData[]> = lang.Deferred();
		options = options || {};
		if (options.policy && options.policy.target) {
			if (!SaveTarget[options.policy.target]) {
				// some illegal value was supplied, ignore it
				options.policy.target = this.saveTarget();
			}
		} else {
			options.policy = lang.extend({}, options.policy, {target: this.saveTarget()});
		}
		if (options.policy.target === SaveTarget.local) {
			this._saveLocally(objects, options, defer);
		} else {
			this._saveRemotely(objects, options, defer);
		}
		return defer.promise();
	}

	/**
	 * Save objects into local store.
	 * @param {Array} objects domain objects in json-form (dto)
	 * @param {Object} options options for interop
	 * @param {Boolean} options.suppressAutoLogin
	 * @param {Boolean} options.suppressEventOnSuccess
	 * @param {Boolean} options.suppressEventOnError
	 * @param {jQuery.Deferred} defer
	 */
	protected _saveLocally (objects: DomainObjectData[], options: SaveOptions, defer: lang.Deferred<DomainObjectData[]>): void {
		let that = this;

		that.saveTarget(SaveTarget.local);

		that._store.save(objects)
			.done(() => {
				that._onLocalSaveDone(objects, options);
				defer.resolve(objects);
				that._scheduleSyncIfNeeded();
			})
			.fail((error) => {
				defer.reject(error);
			});
	}

	protected _scheduleSyncIfNeeded (): boolean {
		let that = this;
		if (that.manuallyDisconnected()) {
			return;
		}
		if (!that.networkOnline() && that._supportNetworkRealtimeEvents) {
			return;
		}
		// NOTE: if server isn't accessible we should NOT eat network bandwidth by sending all changes each time,
		// instead we'll continue to "ping" server
		let res = that._synchronizr.scheduleSync(/*pingOnly=*/!that.serverOnline());
		that.traceSource.debug("DataFacade scheduled synchronization, serverOnline=" + that.serverOnline());
		return res;
	}

	/**
	 * Continuation on successful save into local store.
	 * @param {Array} objects domain objects in json-form (dto)
	 * @param {Object} options options for interop
	 * @param {Boolean} options.suppressAutoLogin
	 * @param {Boolean} options.suppressEventOnSuccess
	 * @param {Boolean} options.suppressEventOnError
	 */
	protected _onLocalSaveDone (objects: DomainObjectData[], options: SaveOptions): void {
		let that = this;

		// update ts in objects
		that._updateSaved(objects);
		// notify all about data change
		that._triggerUpdate(objects, options);

		if (!options || !options.suppressEventOnSuccess) {
			that._publishEvent("interop.save.success.local", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.notification,
				priority: "low",
				severity: "success",
				message: resources["interop.save.success.local"]
			}));
		}
	}

	protected _saveRemotely (objects: DomainObjectData[], options: SaveOptions, deferred: lang.Deferred<DomainObjectData[]>): void {
		let that = this;

		let promise = that._interop.save(objects, options)
			.done((response) => {
				that._onRemoteSaveDone(objects, options, response);
				deferred.resolve(objects);
			})
			.fail((error) => {
				if (that._isUnrecoverableError(error) || options.policy.target === SaveTarget.remoteOnly) {
					that._onRemoteSaveError(objects, error, options, deferred);
				} else {
					// the error can be a result of server inaccessibility
					that.checkConnection({suppressSaveTargetUpdate: true})
						.done((result) => {
							if (result.serverOnline) {
								// TODO: here we can check for error details to go offline automatically
								// or we can prompt user to decide whether go offline or not.
								that._onRemoteSaveError(objects, error, options, deferred);
							} else {
								that._saveLocally(objects, options, deferred);
							}
						});
				}
			});

		if (!options.suppressProcessEvent) {
			that._publishEvent("interop.save", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.process,
				priority: "normal",
				message: resources.saving,
				promise: promise
			}));
		}
	}

	/**
	 * Continuation on successful save to the server.
	 * @param {Array} objects domain objects in json-form (dto)
	 * @param {Object} options options for interop
	 * @param {Boolean} options.suppressAutoLogin
	 * @param {Boolean} options.suppressEventOnSuccess
	 * @param {Boolean} options.suppressEventOnError
	 * @param {Object} response server response
	 * @param {Object} response.error
	 * @param {Array} response.ids array of objects identities which saving was failed
	 * @param {Object} response.newIdentityMap TODO
	 * @param {Array} response.originalObjects
	 * @param {Array} response.updatedObjects
	 */
	_onRemoteSaveDone (objects: DomainObjectData[], options: SaveOptions, response): void {
		let that = this;

		that.networkOnline(true);
		that.serverOnline(true);

		// update ts in objects
		that._updateSaved(objects, response);

		that._store.commit(objects).done(() => {
			// NOTE: _updateFromNewValues must be executed after store.commit(), because
			// old values are used in DataStore.
			that._updateFromNewValues(objects);
			// TODO: почему мы здесь не передаем caller в опциях как в "connected" DataFacade?
			that._triggerUpdate(objects, options);

			if (!options.suppressEventOnSuccess) {
				that._publishEvent("interop.save.success", that.createSaveSuccessEvent(response));
			}
		});
	}

	/**
	 * Create a SystemEvent for save error.
	 * @param {Object} error An error object got from BackendInterop.save
	 * @param {Object} options Save options - the same as DataFacade.save
	 * @param {Array<DomainObject>} objects Json objects were being saved
	 * @returns {SystemEvent}
	 */
	createSaveErrorEvent(error: InteropError, options: SaveOptions, objects: DomainObjectData[]): SystemEvent {
		// NOTE: base createSaveErrorEvent will call createInteropErrorEvent
		let evn = super.createSaveErrorEvent(error, options, objects);
		if (this.saveTarget() === SaveTarget.remoteOnly) {
			evn.menu.removeItem("GoOffline");
		} else {
			// TODO: может здесь надо как в createInteropErrorEvent проверять:
			//if (that.options.allowGoOffline && !that._isUnrecoverableError(error)) {
			//	that._addGoOfflineMenuItem(evn);
			//}
			// ensure event's menu has "GoOffline" item
			this._addGoOfflineMenuItem(evn);

			/* it was before 0.15:
			menu = { items: [
				{
					name: "SaveLocally",
					title: resources["interop.saveLocally"],
					command: core.createCommand({
						execute: function () {
							that._saveLocally(objects, options, defer);
						}
					})
				}
			]};
			// NOTE: remove "GoOffline" command as both "SaveLocally" and "GoOffline" commands can puzzle user
			evn.menu.removeItem("GoOffline");
			evn.menu.mergeWith(menu);
			*/
		}
		return evn;
	}

	createInteropErrorEvent(action: string, error: InteropError): SystemEvent {
		let that = this;
		let evn = DataFacadeBase.prototype.createInteropErrorEvent.call(that, action, error);
		// If the error is not a result of data/request itself (i.e. not "UnrecoverableError"),
		// then we'll add menu item "GoOffline"
		if (that.options.allowGoOffline && !that.manuallyDisconnected() && !that._isUnrecoverableError(error)) {
			that._addGoOfflineMenuItem(evn);
		}
		return evn;
	}

	protected _addGoOfflineMenuItem(sysEvent: SystemEvent): void {
		let menu: Menu.Options = {
			items: [{
				name: "GoOffline",
				title: resources["interop.go_offline"],
				hint: resources["interop.go_offline_hint"],
				icon: "offline",
				command: core.createCommand({
					execute: () => {
						this.manuallyDisconnected(true);
						this._publishEvent("interop.went_offline", core.SystemEvent.create({
							kind: core.SystemEvent.Kind.notification,
							priority: "normal",
							message: resources["interop.went_offline"]
						}));
					}
				})
			}]
		};
		if (sysEvent.menu) {
			sysEvent.menu.mergeWith(menu);
		} else {
			sysEvent.menu = Menu.create(menu);
		}
	}

	protected _onStoreSynced (syncResult: DataSynchronizer.SyncSuccessEventArgs): void {
		let that = this,
			changes = syncResult.changes,
			response = syncResult.response,
			hasChanges = !lang.isEmpty(changes),
			defer;

		that.networkOnline(true);
		that.serverOnline(true);

		if (hasChanges) {
			// update saved object from new values
			// NOTE: response can be SaveResponse or AggregateSaveResponse
			if (response && lang.isArray(response.results)) {
				response.results.forEach((result, i) => {
					that._updateSaved(changes, result, /*repeated*/i > 0);
				});
			} else {
				that._updateSaved(changes, response);
			}

			defer = that._store.commit(changes);
		}

		lang.async.done(defer, () => {
			if (that.saveMode() === SaveMode.smart) {
				that._updateSaveTarget();
			}

			// raise 'update' event with updated values
			if (hasChanges) {
				that._updateFromNewValues(changes);
				that._triggerUpdate(changes);
			}

			if (!syncResult.suppressEvent) {
				that._publishEvent("interop.sync.success", core.SystemEvent.create({
					kind: core.SystemEvent.Kind.notification,
					priority: "normal",
					severity: "success",
					message: resources["interop.sync.changes_synced"]
				}));
			}

			that.traceSource.debug("Offline changes synchronized");
		});
	}

	protected _onSyncRetry (syncResult: DataSynchronizer.SyncFailtureEventArgs): void {
		if (syncResult.defer) {
			syncResult.defer.resolve();
		}
		this._scheduleSyncIfNeeded();
	}

	protected _onSyncCancel (syncResult: DataSynchronizer.SyncFailtureEventArgs): void {
		let that = this;
		if (syncResult.defer) {
			syncResult.defer.resolve();
		}
		let changes = [];
		syncResult.failures.forEach((failure) => {
			changes = changes.concat(failure.objects);
		});
		that._store.rollback(changes).then((rollbacked: DomainObjectData[]) => {
			let updated = [],
				tasks = [];
			lang.forEach(rollbacked, (obj: DomainObjectData) => {
				if (!obj.__metadata.isRemoved) {
					// reload object
					let policy: LoadPolicy = {
						loadFirst: "local",
						allowRemote: true,
						allowLocal: true,
						shouldCache: true
						// TODO: maxAge: loadPolicy.maxAge
					};
					// successful load will cause firing 'update' event
					tasks.push(
						that.load({
							source: {type: obj.__metadata.type, id: obj.id},
							type: obj.__metadata.type
						}, {policy: policy})
							.then((response: DataStoreBase.LoadResponse) => {
								if (response && response.age) {
									// data loaded from local cache, therefore 'update' event didn't fire
									// (as it only fires on remote load)
									updated.push(response.result);
								}
							})
					);
				} else {
					updated.push(obj);
				}
			});
			if (tasks.length > 0) {
				lang.whenAll(tasks).then(() => {
					that._triggerUpdate(updated);
				});
			} else if (updated.length > 0) {
				that._triggerUpdate(updated);
			}

			// After we made store.rollback there should be no pending changes in store,
			// so in smart mode we should go online
			if (that.saveMode() === SaveMode.smart) {
				that._updateSaveTarget();
			}
		});
	}

	/**
	 * Handles 'sync.error' event from DataSynchronizer.
	 * Important: the method should signal on syncResult.defer in ALL cases.
	 * @param syncResult
	 * @param {Array} syncResult.failures Array of errors (with at least one item), where error object is {objects:[], error:{}}
	 * @param {jQuery.Deferred} syncResult.defer
	 * @protected
	 */
	protected _onStoreSyncError (syncResult: DataSynchronizer.SyncFailtureEventArgs): void {
		let that = this;
		that.traceSource.debug("An error occurred during offline changes synchronization.");
		let failures = syncResult.failures;
		let firstError: InteropError;
		failures.forEach((failure) => {
			if (failure.error && failure.error.$isException) {
				failure.error = that.errorFromJson(failure.error);
				if (!firstError) {
					firstError = <InteropError>failure.error;
				}
			}
		});
		that.isSyncErrorProcessing(true);
		if (syncResult.defer) {
			syncResult.defer.always(() => {
				that.isSyncErrorProcessing(false);
			});
		}

		if (that._isUnrecoverableError(firstError)) {
			that._onStoreSyncUnrecoverableError(syncResult);
		} else if (that._isServerInaccessibilityError(firstError)) {
			that.serverOnline(false);
			if (syncResult.defer) {
				syncResult.defer.resolve();
			}
			that._scheduleSyncIfNeeded();
		} else {
			that.checkConnection()
				.then((result) => {
					if (!result.serverOnline || !result.networkOnline) {
						if (syncResult.defer) {
							syncResult.defer.resolve();
						}
						that._scheduleSyncIfNeeded();
					} else {
						that._onStoreSyncUnrecoverableError(syncResult);
					}
				});
		}
	}

	protected _isUnrecoverableError (error: InteropError): boolean {
		return core.eth.isUnrecoverableError(error);
	}

	protected _isServerInaccessibilityError (error: InteropError): boolean {
		if (error && error.serverOffline) {
			return true;
		}
		return !this.networkOnline() && this._supportNetworkRealtimeEvents;
	}

	/**
	 * Handles unrecoverable synchronization errors.
	 * @param syncResult SyncResult from DataSynchronizer
	 * @param {Array} syncResult.failures Array of errors (with at least one item), where error object is {objects:[], error:{}}
	 * @param {jQuery.Deferred} syncResult.defer
	 * @protected
	 */
	protected _onStoreSyncUnrecoverableError (syncResult: DataSynchronizer.SyncFailtureEventArgs): void {
		let event = this.createSyncErrorEvent(syncResult);
		this._publishEvent("interop.sync.error", event);
	}

	createSyncErrorEvent (syncResult: DataSynchronizer.SyncFailtureEventArgs): SystemEvent {
		let that = this,
			failures = syncResult.failures,
			firstError = failures[0].error,
			message = failures.length === 1	?
				resources["interop.sync.error"] + (firstError.message ? ": " + firstError.message: "") : resources["interop.sync.error.many"] + firstError.message,
			menu: Menu.Options = { items: [
				{
					name: "Retry",
					title: resources["interop.sync.retry"],
					command: core.createCommand({
						execute: () => {
							that._publishEvent("interop.sync.retry", syncResult);
						}
					})
				}, {
					name: "Cancel",
					title: resources["interop.sync.cancel"],
					command: core.createCommand({
						execute: () => {
							that._publishEvent("interop.sync.cancel", syncResult);
						}
					})
				}
			]};
		if (that.options.allowGoOffline && !that.manuallyDisconnected() /*&& !that._isUnrecoverableError(firstError)*/) {
			menu.items.push({
				name: "GoOffline",
				title: resources["interop.go_offline"],
				icon: "offline",
				command: core.createCommand({
					execute: () => {
						that.manuallyDisconnected(true);
						if (syncResult.defer) {
							syncResult.defer.resolve();
						}
						that._publishEvent("interop.went_offline", core.SystemEvent.create({
							kind: core.SystemEvent.Kind.notification,
							priority: "normal",
							message: resources["interop.went_offline"]
						}));
					}
				})
			});
		}

		return core.SystemEvent.create({
			kind: core.SystemEvent.Kind.actionRequest,
			data: syncResult,
			severity: firstError.hasUserDescription ? "warning" : "error",
			message: message,
			menu: menu
		});
	}

	/**
	 * Handles 'error' event from DataStore.
	 * @param {Error} error
	 * @protected
	 */
	protected _onStoreRawError (error: Error): void {
		let that = this;
		that.traceSource.warn("store access error: " + error.message);
		that._publishEvent("interop.store.error.raw", core.SystemEvent.create({
			kind: core.SystemEvent.Kind.actionRequest,
			severity: "error",
			error: error,
			uid: "store:" + (error.name || error.message),
			message: core.safeHtml(
				lang.encodeHtml(error.message) + "<br/>" + resources["interop.store.error.raw.html"],
				error.message),
			menu: {
				hidden: true,
				items: [{
						name: "Recreate",
						command: new core.commands.BoundCommand(that._recreateStore, that)
					}
				]
			}
		}));
	}

	/**
	 * Recreate DataStore with user prompt.
	 * @protected
	 */
	protected _recreateStore (): Promise<void> {
		let that = this;
		return ConfirmDialog.create({
				header: resources["interop.store.recreate.header"],
				text: resources["interop.store.recreate.prompt"]
			})
			.render().then((result) => {
				if (result === "yes") {
					return that._store.recreate().then(() => {
						that._publishEvent("interop.store.error", core.SystemEvent.create({
							kind: core.SystemEvent.Kind.notification,
							priority: "normal",
							severity: "success",
							message: resources["interop.store.recreate.success"]
						}));
					});
				}
			});
	}
}
// backward compatibility
DataFacadeSmart.mixin({
	saveModes: SaveMode,
	saveTargets: SaveTarget
});

namespace DataFacadeSmart {
	export interface Options {
		cacheManager?: CacheManager;
		CacheManager?: new(options: CacheManager.Options) => CacheManager;
		DataSynchronizer?: new(dataStore: DataStoreBase, options: DataSynchronizer.Options) => DataSynchronizer;
		loadRule?: LoadRule;
		saveMode?: SaveMode;
		allowGoOffline?: boolean;
		supportNetworkRealtimeEvents?: boolean;
		checkConnectionTimeout?: number;
		forceLoadUnsync?: boolean;
	}
	export interface CheckConnectionResult extends CheckConnectionResultBase {
		notificationPublished?: boolean;
	}
}


core.interop = core.interop || <any>{};
core.interop.DataFacadeSmart = DataFacadeSmart;

export = DataFacadeSmart;
