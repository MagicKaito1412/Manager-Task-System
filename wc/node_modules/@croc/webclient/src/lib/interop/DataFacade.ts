import core = require("core");
import DataFacadeBase = require("lib/interop/DataFacadeBase");
import resources = require("i18n!lib/nls/resources");

import interop = require(".interop");
import IDataFacade = interop.IDataFacade;
import IBackendInterop = interop.IBackendInterop;
import DomainObjectData = interop.DomainObjectData;
import SavedObjectData = interop.SavedObjectData;
import LoadQuery = interop.LoadQuery;
import LoadResponse = interop.LoadResponse;
import LoadOptions = interop.LoadOptions;
import SaveOptions = interop.SaveOptions;
import SaveResponse = interop.SaveResponse;
import IEventPublisher = core.IEventPublisher;
import SystemEvent = core.SystemEvent;
import Promise = core.lang.Promise;
import { InteropError } from "lib/interop/.interop";

class DataFacade extends DataFacadeBase implements IDataFacade {
	/**
	 * @constructs DataFacade
	 * @extends DataFacadeBase
	 * @param {BackendInterop} interop
	 * @param {EventPublisher} [eventPublisher]
	 */
	constructor(interop: IBackendInterop, eventPublisher?: IEventPublisher) {
		super(interop, eventPublisher);
	}

	load(query: LoadQuery, options?: LoadOptions): Promise<LoadResponse> {
		let that = this;
		options = options || {};
		query = that._normalizeQuery(query);
		return that._load(query, options)
			.done((response: LoadResponse) => {
				if (!response) { return; }
				// уведомляем об обновлении данных
				let objects = that._objectsFromResponse(response, query);
				if (objects && objects.length) {
					that._triggerUpdate(objects, options, "load");
				}
			})
			.fail((error) => {
				that._handleInteropError("load", error, options);
			});
	}

	/**
	 * Save objects.
	 * @param {Array} objects domain objects in json-form (dto)
	 * @param {Object} options Options
	 * @param {*} [options.caller]
	 * @param {String|Array} [options.hints] hints for passing to the server
	 * @param {Boolean} [options.suppressEventOnError=false] Suppress event publishing on an error
	 * @param {Boolean} [options.suppressEventOnSuccess=false] Suppress event publishing on success
	 * @param {Boolean} [options.suppressProcessEvent=false] Suppress progress event publishing
	 * @return {Promise} object for async operation of saving
	 */
	save(objects: DomainObjectData[], options?: SaveOptions): Promise<SavedObjectData[]> {
		let that = this,
			deferredOut: JQueryDeferred<SavedObjectData[]> = core.lang.Deferred();

		options = options || {};
		let promise = that._interop.save(objects, options)
			.done((response: SaveResponse) => {
				that._onSaveDone(objects, options, response);
				deferredOut.resolve(objects);
			})
			.fail((error: InteropError) => {
				that._onRemoteSaveError(objects, error, options, deferredOut);
			});

		if (!options.suppressProcessEvent) {
			that._publishEvent("interop.save", core.SystemEvent.create({
				kind: core.SystemEvent.Kind.process,
				priority: "normal",
				message: resources.saving,
				promise: promise
			}));
		}

		return deferredOut.promise();
	}

	protected _onSaveDone(objects: DomainObjectData[], options: SaveOptions, response: SaveResponse): void {
		let that = this;

		that._updateSaved(<SavedObjectData[]>objects, response);
		that._updateFromNewValues(<SavedObjectData[]>objects);

		// уведомляем об изменении данных
		that._triggerUpdate(objects, options);

		if (!options.suppressEventOnSuccess) {
			that._publishEvent("interop.save.success", that.createSaveSuccessEvent(response));
		}
	}
}

core.interop = core.interop || <any>{};
core.interop.DataFacade = DataFacade;

export = DataFacade;
