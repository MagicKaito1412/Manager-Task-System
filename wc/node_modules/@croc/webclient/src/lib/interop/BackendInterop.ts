import $ = require("jquery");
import core = require("core");
import utils = require("lib/utils");
import resources = require("i18n!lib/nls/resources");
import "vendor/jquery.fileDownload";

import {
	IBackendInterop,
	CheckConnectionResult,
	DomainObjectData,
	SavedObjectData,
	ExceptionData,
	AjaxSettings,
	AjaxOptions,
	LoadQuerySource,
	LoadQuery,
	LoadOptions,
	SaveOptions,
	SystemVersionChangedEventArgs,
	ObjectIdentity,
	BusinessLogicException as IBusinessLogicException,
	OptimisticConcurrencyException as IOptimisticConcurrencyException,
	InteropError as IInteropError
} from ".interop";
import { Violation, ViolationSeverity } from "lib/validation";

import Deferred = core.lang.Deferred;
import Promise = core.lang.Promise;
import {AppCacheState} from "lib/interop/.interop.types";

type BatchItem = {
	ajaxSettings: AjaxSettings;
	options: AjaxOptions;
	defer: Deferred<any>;
};

/**
 * @type {TraceSource}
 */
let traceSource = new core.diagnostics.TraceSource("interop.backend");

class BackendInterop extends core.lang.Observable implements IBackendInterop {
	config: XConfig;
	apiUrlPrefix: string;
	clientVersion: string;
	serverVersion: string;
	preventCaching: boolean;
	traceSource: core.diagnostics.TraceSource;
	protected batching: number;
	protected batch: BatchItem[];
	private _operations: core.lang.Map<Deferred<any>>;

	/**
	 * @constructs BackendInterop
	 * @extends Observable
	 * @param {XConfig} xconfig
	 */
	constructor(xconfig?: XConfig) {
		super();

		this.config = xconfig || { root: ""};
		this.apiUrlPrefix = "api/";	// v1/
		this.clientVersion = xconfig && xconfig.software ? xconfig.software.clientLibVersion : undefined;
		this.serverVersion = null;
		this.preventCaching = true;
		this.traceSource = traceSource;
		this.batching = 0;
		this._operations = {};

		core.$window.on("online", this._onAppOnline.bind(this));
		core.$window.on("offline", this._onAppOffline.bind(this));
	}

	HEADER_SERVER_VER: string;

	checkAppCache(cb: (appCacheState: AppCacheState) => void): void {
		let that = this,
			appCache = window.applicationCache,
			hooks;
		if (appCache) {
			/*
			 0 	UNCACHED 	Has not been cached
			 1 	IDLE 	Has finished updating, or otherwise doing nothing
			 2 	CHECKING 	Seeing if the manifest has changed
			 3 	DOWNLOADING 	Any file in the manifest is being downloaded
			 4 	UPDATEREADY 	The manifest has been changed
			 5 	OBSOLETE 	The cache is obsolete
			 */
			if (appCache.status === appCache.UNCACHED) {
				cb("uncached");
			} else {
				// There's appCache in use.
				// There could be events had fired before BackendInterop was created (we hooked them in bootloader.js)
				// NOTE: we cannot rely on applicationCache.status, it can report incorrect status, so we rely on events
				hooks = (<any>appCache).hooks; // hooks field is added by bootloader
				if (hooks) {
					if (hooks.error) {
						cb("error");
						return;
					}
					if (hooks.cached) {
						cb("cached");
						return;
					}
					if (hooks.noupdate) {
						cb("noupdate");
						return;
					}
					if (hooks.updateready ) {
						cb("updateready");
						return;
					}
					if (hooks.obsolete ) {
						cb("obsolete");
						return;
					}
				}
				if (appCache.status === appCache.OBSOLETE) {
					cb("obsolete");
				} else if (appCache.status === appCache.UPDATEREADY) {
					cb("updateready");
				} else if (appCache.status === appCache.IDLE) {
					cb("noupdate");
				} else {
					// CHECKING/DOWNLOADING in progress
					appCache.onerror = () => {
						cb("error");
					};
					appCache.onobsolete = () => {
						cb("obsolete");
					};
					appCache.onupdateready = () => {
						cb("updateready");
					};
					appCache.oncached = () => {
						cb("cached");
					};
					appCache.onnoupdate = () => {
						cb("noupdate");
					};
/*                  TODO: report progress?
					appCache.onprogress = function () {

					};
*/
				}
			}
		}
	}

	filterServerResponse(jqXHR: JQueryXHR): void {
		let that = this,
			srvVer: string,
			args: SystemVersionChangedEventArgs;
		srvVer = jqXHR.getResponseHeader(that.HEADER_SERVER_VER);
		if (srvVer && that.serverVersion !== srvVer) {
			args = {
				oldVersion: that.serverVersion,
				newVersion: srvVer
			};
			that.serverVersion = srvVer;
			that.trigger("server_version_changed", args);
		}
	}

	protected _onAppOnline(e): void {
		this.traceSource.info("online");
		this.trigger("online", null);
	}
	protected _onAppOffline(e): void {
		this.traceSource.info("offline");
		this.trigger("offline", null);
	}

	beginBatch(): void {
		let that = this;
		if (!that.batching) {
			that.batch = [];
		}
		that.batching++;
	}

	protected _addBatchItem(ajaxSettings: AjaxSettings, options: AjaxOptions): Promise<any> {
		let defer = core.lang.Deferred();
		this.batch.push({ ajaxSettings: ajaxSettings, options: options, defer: defer });
		return defer.promise();
	}

	completeBatch(): void {
		let that = this,
			batch: BatchItem[];
		that.batching--;
		if (!that.batching) {
			batch = that.batch;
			for (let request of batch) {
				that._fixAjaxSettings(request.ajaxSettings, request.options);
				that._executeAjax(request.ajaxSettings, request.defer);
			}
			that.batch = null;
		}
	}

	_executeAjax(ajaxSettings: AjaxSettings, defer: Deferred<any>, repeating?: boolean): Promise<any> {
		let that = this;
		return that._executeAjaxSuccess(ajaxSettings, defer, repeating)
			.fail((jqXhr, textStatus) => {
				let error = that.handleError(jqXhr, textStatus);
				that.traceSource.info("Ajax request to " + ajaxSettings.url + " failed: " + JSON.stringify(error));
				if (defer) {
					defer.reject(error);
				}
			});
	}

	protected _executeAjaxSuccess(
		ajaxSettings: AjaxSettings, defer: Deferred<any>, repeating?: boolean): Promise<any>
	{
		let that = this;
		that.traceSource.debug("Sending a " + ajaxSettings.type + " ajax request " + ajaxSettings.url);
		return $.ajax(ajaxSettings)
			.done((data: any, status: string, jqXHR: JQueryXHR) => {
				that.filterServerResponse(jqXHR);
				if (defer) {
					defer.resolve(data);
				}
			});
	}

	ajax(ajaxSettings: AjaxSettings, options?: AjaxOptions): Promise<any> {
		let that = this,
			defer: Deferred<any> = core.lang.Deferred();
		options = options || {};
		that._fixAjaxSettings(ajaxSettings, options);
		if (options.fileDownload) {
			that._downloadFile(ajaxSettings, options, defer);
		} else {
			that._executeAjax(ajaxSettings, defer, !!options.suppressAutoLogin);
			if (options.opId) {
				that._operations[options.opId] = defer;
				defer.always(() => {
					delete that._operations[options.opId];
				});
			}
		}
		return defer.promise();
	}

	protected _downloadFile(ajaxSettings: AjaxSettings, options: AjaxOptions, deferred: Deferred<void>): void {
		let that = this,
			url = ajaxSettings.url,
			headers = "";
		if (options.contentType) {
			headers = "Accept=" + options.contentType + ";";
		}
		let cookieName = "fileDownload-" + utils.generateGuid();
		headers += "X-FileDownload=" + cookieName;
		if (url.indexOf("?") > -1) {
			url += "&";
			} else {
			url += "?";
			}
		url += ("$headers=" + encodeURIComponent(headers));

		that.traceSource.debug("Downloading file from " + url);
		$.fileDownload(url, {
			data: ajaxSettings.data,
			cookieName: cookieName,
			httpMethod: ajaxSettings.type,
			successCallback: function (): void {
				that.traceSource.debug("File from " + url + " successfully downloaded");
				deferred.resolve();
			},
			failCallback: function (response: string): void {
				let responseJson = response ? JSON.parse(response) : null,
					message = (responseJson && responseJson.message) || "",
					error = new InteropError(message);
				error.serverError = responseJson;
				error.action = "downloadFile";
				that.traceSource.warn("Error during downloading a file from " + url + ": " + response);
				deferred.reject(error);
			}
		});
	}

	protected _fixAjaxSettings(settings: AjaxSettings, options: AjaxOptions): void {
		let that = this,
			url: string,
			urlDelimiter: string,
			urlLen: number;
		options = options || {};

		if (!settings.url) {
			console.error("BackendInterop: no url was specified for ajax");
		}
		url = that.normalizeUrl(settings.url);
		if (that.preventCaching && !options.suppressCacheBreakthrough && settings.type !== "POST") {
			urlDelimiter = url.indexOf("?") < 0 ? "?" : "&";
			url += urlDelimiter + "tm=" + Date.now();
		}
		url = encodeURI(url);
		settings.url = url;

		if (options.opId) {
			if (!settings.data) {
				settings.data = {};
			}
			settings.data.$opId = options.opId;
		}

		if (settings.data) {
			core.lang.forEach(settings.data, (v: any, key: string) => {
				if (v && core.lang.isPlainObject(v)) {
					// NOTE: if we pass an object in data to jQuery, it'll serialize it into query string as
					// "{key}[prop_1][prop_1_1]={value of v.prop_1.prop_1_1}"
					// As it's hard to parse on the server, we're preventing this by manually serializing into json
					settings.data[key] = JSON.stringify(v);
				}
			});
		}

		if (that.clientVersion) {
			settings.headers = {
				"x-client-ver": that.clientVersion
			};
		}

		if (!options.fileDownload) {
			if (options.contentType) {
				settings.accepts = { "*": options.contentType};
			} else {
				if (core.lang.stringStartsWith(url, that.config.apiroot + "api/")) {
					// for api ajax calls setup Accept header as "application/json" by default
					settings.accepts = core.lang.extend({ "*": "application/json"}, settings.accepts);
				}
			}
		}

		if (!settings.type && options.supportsGetPost) {
			// calculate url length
			urlLen = url.length;
			core.lang.forEach(settings.data, (v: any, key: string) => {
				if (v && core.lang.isArray(v)) {
					// every array item will be passed as separate parameter: &key[]=value1&key[]=value2
					// after encoding: &key%5B%5D=value1&key%5B%5D=value2
					let keyLength = encodeURIComponent(key).length + 8; // +2 for "%5B%5D", +1 for "&", +1 for "="
					urlLen += (keyLength * v.length);
					v.forEach((i) => {
						urlLen += (i != null ? encodeURIComponent(i).length : 0);
					});
				} else {
					urlLen += encodeURIComponent(key).length;
					urlLen += (v != null ? encodeURIComponent(v).length : 0) + 2; // 2 is for "&" and "=" in `&key=value`
				}
			});
			// choose HTTP method depending on the length of URL
			settings.type = urlLen <= core.platform.limits.queryStringMaxLen ? "GET" : "POST";
		}
	}

	cancel(opId: string): void {
		if (!opId) { return; }
		let defer = this._operations[opId];
		if (defer) {
			defer.reject(core.eth.canceled());
		}
	}

	normalizeUrl(url: string): string {
		let root = this.config.apiroot;
		if (root && url) {
			// если это не абсолютный url и он не начинается с корня сайта "/myapp/" или "/", то добавим корень сайта в начало
			// т.е. "http://example.com/myapp" и "/myapp" не трогаем, а "api/load" станет "/myapp/api/load" (или "/api")
			if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0 && url.indexOf(root) !== 0) {
				url = utils.combinePaths(root, url);
			}
		}
		return url;
	}

	/**
	 * Load objects by query.
	 * @param {Object} query query JSON-object
	 * @param {Object|String} query.source name of source to load from, or its specification
	 * @param {String} query.source.type Name of the source (e.g. EntityType or DataSource name)
	 * @param {String} [query.source.id] objectId when loading a single object
	 * @param {String} [query.source.propName] name of navigation property
	 * @param {String} [query.type] entityType name of loading objects
	 * @param {String} [query.preloads] array of property names or property chains
	 * @param {Object} [query.params] query parameters
	 * @param {Object} options
	 * @param {String} [options.opId] cancellation operation id
	 * @param {Boolean} [options.suppressAutoLogin=false]
	 * @param {String} [options.contentType] MIME content type of the response (e.g. "application/vnd.ms-excel")
	 * @param {Boolean} [options.fileDownload=false] Return result as a file, it makes the browser to open "Save as" dialog
	 * @returns {Promise} object for async operation. Continuations arguments:
	 *      - done: data - array of domain objects in json-form
	 *      - fail: error - json object with parsed server error.
	 */
	load(query: LoadQuery, options?: LoadOptions): Promise<any> {
		let that = this,
			source: LoadQuerySource|string = query.source,
			preloads: string|string[] = query.preloads,
			url: string,
			data: any = {},
			ajaxSettings;

		if (!source) {
			throw new Error("BackendInterop.load: query.source must be specified");
		}

		options = options || {};
		if (options.supportsGetPost === undefined) {
			options.supportsGetPost = true; // supports GET and POST by default
		}

		url = that.apiUrlPrefix;
		if (query.route) {
			url += query.route;
		}
		if (core.lang.last(url) !== "/") {
			url += "/";
		}

		if (typeof source === "string") {
			url += source;
		} else {
			url += source.type;
			if (source.id) {
				url += ("(" + source.id + ")");
				if (source.propName) {
					url += "/" + source.propName;
				}
			}
		}

		// preloads
		if (preloads) {
			data.$expand = typeof preloads === "string" ? preloads : preloads.join(",");
		}

		// parameters
		if (query.params) {
			core.lang.extend(data, query.params);
		}

		ajaxSettings = {
			url: url,
			data: data
		};
		return that.batching && !options.fileDownload ?
				that._addBatchItem(ajaxSettings, options) :
				that.ajax(ajaxSettings, options);
	}

	/**
	 * Save objects.
	 * @param objects domain objects in json-form (dto)
	 * @param {Object} options
	 * @param {Boolean} [options.sync=false] flag for synchronization mode (just add special argument to query string)
	 * @param {String|Array} [options.hints] hints for passing to the server
	 * @return {jQuery.promise} object for async operation of saving
	*/
	save(objects: DomainObjectData[], options?: SaveOptions): Promise<any> {
		let that = this,
			hints,
			queryStr = "",
			ajaxSettings: AjaxSettings;

		options = options || {};
		if (options.sync) {
			queryStr += "?$sync=1";
		}
		if (options.hints) {
			hints = options.hints;
			if (core.lang.isArray(hints)) {
				hints = hints.join(",");
			}
			if (queryStr) { queryStr += "&"; } else { queryStr += "?"; }
			queryStr = queryStr + "$hints=" + hints;
		}

		ajaxSettings = {
			url: that.apiUrlPrefix + "_store" + queryStr,
			data: JSON.stringify(objects)
		};
		ajaxSettings.type = "POST";
		ajaxSettings.contentType = "application/json";
		ajaxSettings.processData = false;

		return that.ajax(ajaxSettings, {});
	}

	checkConnection(httpMethod?: string): Promise<CheckConnectionResult> {
		let that = this,
			defer = core.lang.Deferred<CheckConnectionResult>(),
			ajaxSettings: AjaxSettings;

		try {
			if (navigator && !navigator.onLine) {
				defer.resolve({networkOnline: false, serverOnline: false});
			} else {
				// Browser thinks it's online, let's check actual server connectivity
				ajaxSettings = { url: that.apiUrlPrefix + "ping"};
				if (httpMethod) {
					ajaxSettings.type = httpMethod;
				}
				that.ajax(ajaxSettings).then(() => {
					defer.resolve({networkOnline: true, serverOnline: true});
				}, () => {
					defer.resolve({networkOnline: true, serverOnline: false});
				});
			}
		} catch (error) {
			that.traceSource.error("BackendInterop.checkConnection error: " + error.meesage);
			that.traceSource.error(error);
			defer.resolve({networkOnline: false, serverOnline: false});    // TOTHINK: ?
		}
		return defer.promise();
	}

	protected _isException(json: ExceptionData): boolean {
		return json && json.$isException;
	}

	handleError(jqXhr: JQueryXHR, textStatus: string): InteropError|any {
		let that = this,
			status: number = jqXhr.status,
			contentType: string = jqXhr.getResponseHeader("Content-Type") || "",
			responseJson: any,
			exception: ExceptionData,
			message: string,
			serverOffline: boolean,
			result: any;

		if (core.lang.isObject(jqXhr.responseText)) {
			responseJson = jqXhr.responseText;
		} else if (contentType.indexOf("application/json") > -1) {
			responseJson = jqXhr.responseText ? JSON.parse(jqXhr.responseText) : null;
		} else if (contentType.indexOf("text/html") > -1) {
			let re = /<meta\s*name="x-custom-error"/im;
			if (re.test(jqXhr.responseText)) {
				// we've got custom html-response with an error
				let matches = /<body>([\s\S]*)<\/body>/im.exec(jqXhr.responseText);
				if (matches && matches.length === 2) {
					let html = matches[1];
					if (html) {
						let tmp = document.createElement("DIV");
						tmp.innerHTML = html;
						message = tmp.textContent||tmp.innerText;
					}
				}
			}
		}
		// NOTE: responseJson can be a json-object of exception, GroupSaveResult or something else
		// In general we except:
		// - an exception (has message and $isException fields)
		// - some object with error field containing an exception
		// - any other object - in this case we can't parse and understand result and return Error object.
		// Important: In all cases we'll add the following fields into returning object: message, httpStatus

		// Try to extract the error message:
		//	- firstly try to get message from exception
		if (responseJson) {
			// try to extract exception object
			if (that._isException(responseJson)) {
				exception = responseJson;
				responseJson = null;
			} else if (that._isException(responseJson.error)) {
				// NOTE: support a special case: a JSON with 'error' field
				exception = responseJson.error;
				delete responseJson.error;
			}

			// try to extract message from exception/json result
			if (exception) {
				message = exception.message;
			} else if (responseJson.message) {
				message = responseJson.message;
			} else if (responseJson.error && responseJson.error.message) {
				message = responseJson.error.message;
			}
		}
		//	- otherwise pickup default message basing on httpStatus
		if (!message) {
			if (status === 404 || status === 503) {
				if (jqXhr.getResponseHeader("Connection") === "close") {
					message = resources["interop.server_unavailable"];
					serverOffline = true;
				} else {
					message = resources["interop.resource_or_page_not_found"];
				}
			} else if (status >= 500) {
				message = resources["interop.server_critical_error"];
			} else if (status > 0) {
				message = resources["interop.server_interaction_error"];
			} else {
				// status=0 means:
				//	- TCP connection was closed but no http response returned (e.g. due to firewall)
				//  - connection was aborted by XHR (XHR.abort), it could be aborted by jQuery due to timeout
				//	- connection was aborted by browser (e.g. due to DNS error or some other network errors)
				//	- for a GET-request the server returns 301/302/304/307 (redirects) with cross-origin Location
				// Except connection was aborted by XHR we treat status=0 as "server inaccessibility"
				message = textStatus === "timeout"
					? resources["interop.server_interaction_timeout"]
					: resources["interop.server_unavailable"];
				serverOffline = textStatus !== "abort";
			}
		}

		// if responseJson is an exception then convert it into Error object,
		// otherwise we left it to client code
		if (exception) {
			// the response is an exception
			result = that.tryParseException(exception);
			result = core.lang.appendEx(result, responseJson, {deep: false});
		} else if (responseJson) {
			// the response is some json but not an exception
			result = responseJson;
		} else {
			// we couldn't parse response as json at all
			result = new Error(message);
			result.serverResponse = jqXhr.responseText;
		}

		if (result && !result.message) {
			result.message = message;
		}
		// serverOffline
		result.serverOffline = result.serverOffline || serverOffline || undefined;
		if (exception) {
			exception.serverOffline = result.serverOffline;
		}
		// httpStatus
		if (result.httpStatus === undefined) {
			result.httpStatus = status;
			if (exception && exception.httpStatus === undefined) {
				exception.httpStatus = status;
			}
		}

		return result;
	}

	exceptionHandlers: core.lang.Map<(exceptionJson: ExceptionData) => InteropError>;

	/**
	 * Parses json-object of an error from the server.
	 * @param {Object} exceptionJson Error from the server
	 * @param {Boolean} exceptionJson.containsUserDescription
	 * @param {String} exceptionJson.$className Server exception type name
	 * @return {Error}
	 */
	tryParseException(exceptionJson: ExceptionData): InteropError {
		// TODO: support exceptions chains via 'innerException' property
		let handler: (exceptionJson: ExceptionData) => InteropError;
		let error: InteropError;
		if (exceptionJson.$className) {
			handler = this.exceptionHandlers[exceptionJson.$className];
			if (handler) {
				error = handler(exceptionJson);
			} else if (exceptionJson.$parentClasses && exceptionJson.$parentClasses.length) {
				// find handlers for base (parent) type of the exception
				for (let i = 0; i < exceptionJson.$parentClasses.length; i++) {
					let className = exceptionJson.$parentClasses[i];
					handler = this.exceptionHandlers[className];
					if (handler) {
						error = handler(exceptionJson);
					}
				}
			}
			if (!error) {
				error = new InteropError(exceptionJson.message);
			}
			// copy common props:
			error.serverError = exceptionJson;
			error.hasUserDescription = !!exceptionJson.containsUserDescription || !!exceptionJson.hasUserDescription;
			if (exceptionJson.httpStatus) {
				error.httpStatus = exceptionJson.httpStatus;
			}
			// TODO: хорошо бы ввести некую идентификацию типов ошибок, не привязанную к типам исключений
			error.$className = exceptionJson.$className;
		}
		return error;
	}
}

BackendInterop.mixin({
	HEADER_SERVER_VER: "x-ver",

	appCacheStates: AppCacheState,

	exceptionHandlers: {
		"XBusinessLogicException": function(exceptionJson: any): BusinessLogicException {
			let error = new BusinessLogicException(exceptionJson.message);
			if (exceptionJson.violations) {
				let violations = [];
				for (let i = 0; i < exceptionJson.violations.length; i++) {
					let srvVio = exceptionJson.violations[i];
					if (srvVio.items && srvVio.items.length) {
						violations.push({
							error: srvVio.message || exceptionJson.message,
							props: [utils.toLowerCamel(srvVio.items[0].propertyName)],
							object: srvVio.items[0].identity,
							severity: srvVio.ignorable ? "warning" : "error", // or critical?
							description: srvVio.description,
							rule: srvVio.ruleId
						});
					}
				}
				error.violations = violations;
			}
			return error;
		},

		"XOptimisticConcurrencyException": function(exceptionJson: any): OptimisticConcurrencyException {
			let obsolete = exceptionJson.obsoleteObjects,
				deleted = exceptionJson.deletedObjects,
				message;
			if (obsolete && deleted) {
				if (deleted.length > 0 && obsolete.length === 0) {
					message = resources["interop.error.OptimisticConcurrency.deleted"];
				} else if (obsolete.length > 0 && deleted.length === 0) {
					message = resources["interop.error.OptimisticConcurrency.changed"];
				}
			}
			message = message || resources["interop.error.OptimisticConcurrency"];
			let error = new OptimisticConcurrencyException(message);
			error.obsoleteObjects = obsolete;
			error.deletedObjects = deleted;
			return error;
		}
		/*			NOTE: кажется логичным трактовать недоступность СУБД как "недоступность сервера",
		 однако это имеет побочные эффекты: при синхронизации, которая падает с XStorageInaccessibilityException,
		 меняется состояние на serverOnline=false, потом делает ping, который успешен,
		 и состояние меняется обратно serverOnline=true.
		 В этоге постоянно отображается множество нотификаций "Восстановлена связь с сервером".

		 "XStorageInaccessibilityException": function (responseJson, error) {
		 error.serverOffline = true;
		 //responseJson.message = resources["interop.error.StorageInaccessibility"];
		 }
		 */
	}
});

namespace BackendInterop {
}

class BusinessLogicException extends Error implements IBusinessLogicException {
	violations: Violation[];
}

class InteropError extends Error implements IInteropError {
	action: string;
	serverError: any;
	serverResponse: any;
	hasUserDescription: boolean;
	$className: string;
	serverOffline: boolean;
	httpStatus: number;

	constructor(message: string) {
		super();
		this.name = "InteropError";
		this.message = message;
	}
}

class OptimisticConcurrencyException extends InteropError implements IOptimisticConcurrencyException {
	obsoleteObjects: ObjectIdentity[];
	deletedObjects: ObjectIdentity[];

	constructor(message: string) {
		super(message);
		this.name = "OptimisticConcurrencyError";
	}
}

core.interop = core.interop || <any>{};
core.interop.BackendInterop = BackendInterop;

export = BackendInterop;
