import lang = require("lib/core.lang");
import support = require("./support");

import domain = require(".domain");
import IDomainObject = domain.IDomainObject;
import DomainObject = domain.DomainObject;
import UnitOfWork = domain.UnitOfWork;
import LoadOptions = domain.LoadOptions;
import EntityMeta = domain.metadata.EntityMeta;

class NotLoadedObject extends lang.Observable implements IDomainObject {
	/**
	 * @constant {Boolean}
	 */
	@lang.decorators.constant(true)
	isGhost: boolean;

	/**
	 * @constant {Boolean}
	 */
	@lang.decorators.constant(false)
	isLoaded: boolean;

	meta: EntityMeta;
	id: string;
	uow: UnitOfWork;

	private _deferredLoad: lang.Promise<DomainObject>;

	/**
	 * Representation of a not-loaded domain object with known identity.
	 * @constructs NotLoadedObject
	 * @extends Observable
	 * @param meta
	 * @param id
	 */
	constructor(meta: EntityMeta, id: string) {
		super();
		this.meta = meta;
		this.id = id;
	}

	load(options?: LoadOptions): lang.Promise<DomainObject> {
		let that = this,
			deferred = that._deferredLoad;

		// NOTE: Previous loading is already in progress - we can return it if no options are specified.
		// But if there are some options, we should load again with these options.
		if (deferred && lang.isEmpty(options)) {
			return deferred;
		}

		support.throwIfDetached(that);

		// NOTE: wait until the previous loading is completed,
		// maybe after it we will not have to call DataFacade at all.
		return lang.async.then(deferred, () => {
			return that._doLoad(options);
		});
	}

	protected _doLoad(options?: LoadOptions): lang.Promise<DomainObject> {
		let that = this;
		return that._deferredLoad = that.uow.ensureLoaded(that, options)
			.always(() => { that._deferredLoad = undefined; });
	}

	toString(): string {
		let that = this;
		return that.meta.descr + " (" + that.meta.name + ") (id: " + that.id + ")";
	}
}

export = NotLoadedObject;
