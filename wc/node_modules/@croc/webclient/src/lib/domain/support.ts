import lang = require("lib/core.lang");
import datetimes = require("lib/utils/datetimes");
import utils = require("lib/utils");
import formatters = require("lib/formatters");
import moment = require("moment");
import Big = require("big");
import resources = require("i18n!lib/nls/resources");

import domain = require(".domain");
import internals = require(".internals");
import IDomainObject = domain.IDomainObject;
import DomainObject = domain.DomainObject;
import DomainObjectInternal = internals.DomainObjectInternal;
import DomainObjectUndoState = domain.DomainObject.UndoState;
import DomainObjectLocalState = domain.DomainObject.LocalState;
import UnitOfWork = domain.UnitOfWork;
import UnitOfWorkInternal = internals.UnitOfWorkInternal;
import EntityNameTerm = domain.EntityNameTerm;
import EntityMeta = domain.metadata.EntityMeta;
import PropertyMeta = domain.metadata.PropertyMeta;
import NotifyOptions = domain.NotifyOptions;
import GetPropOptions = domain.GetPropOptions;
import SetPropOptions = domain.SetPropOptions;

export interface IEventNotifier {
	trigger(ctx: any, name: string, ...args): void;
	resume(): void;
}

export interface NotifyRawOptions extends NotifyOptions {
	notifier?: IEventNotifier;
}

export interface SetPropRawOptions extends SetPropOptions, NotifyRawOptions {
	/**
	 * Index of the state in undo stack where current value will be copied to. If not specified, the last (top) state will be used.
	 * Ignored if option 'norollback' or 'original' is specified.
	 */
	undoIndex?: number;
}

/**
 * Возвращает имя класса.
 * @param type - наименовнаие типа {string}
 *             - функция-класс доменного объекта
 *             - json-объект метаописателя типа
 */
export function typeNameOf(type: EntityNameTerm): string {
	return typeof type === "string"	?
		<string>type :
		typeof type === "function" ?
			(<lang.Constructor<DomainObject>>type).prototype.meta.name :
			(<any>type).name;
}

/**
 * Возвращает идентификатор объекта
 * @param {String|DomainObject} obj Cтрока или доменный объект
 */
export function objectIdOf(obj: string|IDomainObject): string {
	//return obj ? (obj.id || obj) : obj;
	return lang.isObject(obj) ? (<IDomainObject>obj).id : <string>obj;
}

/**
 * Return meta properties of model that reference to the specified type.
 */
export function propRefsTo(targetEntityInfo: EntityMeta): PropertyMeta[] {
	let model = targetEntityInfo.model,
		refs: PropertyMeta[] = [];
	lang.forEach(model.entities, (entityInfo: EntityMeta) => {
		// TOTHINK: why entityInfo.declared, not entityInfo.props?
		lang.forEach(entityInfo.declared, (propInfo: PropertyMeta) => {
			if (propInfo.vt === "object") {
				if (targetEntityInfo.base) {
					for (let typeMeta = targetEntityInfo; typeMeta; typeMeta = typeMeta.base) {
						if (propInfo.ref  === typeMeta) {
							refs.push(propInfo);
							break;
						}
					}
				} else if (propInfo.ref === targetEntityInfo) {
					refs.push(propInfo);
				}
			}
			/*if (propInfo.vt === "object" && propInfo.ref === targetEntityInfo) {
				refs.push(propInfo);
			}*/
		});
	});
	return refs;
}

/**
 * Выбрасывает исключение, если у объекта не установлено свойство uow
 */
export function throwIfDetached(obj: IDomainObject): void {
	if (!obj.uow) {
		throw new Error("This operation with detached object isn't allowed");
	}
}

export function notifyPropChanged(
	obj: DomainObject, propName: string, propValue, oldValue, options?: NotifyRawOptions): void;
/**
 * Уведомляет об изменении свойства, генерируя соответствующие события
 * @param {DomainObject} obj
 * @param {string} propName
 * @param propValue
 * @param oldValue
 * @param options
 * @param {ChangeBatchNotifier} [options.notifier] - батч событий
 */
export function notifyPropChanged(
	obj: DomainObjectInternal, propName: string, propValue, oldValue, options?: SetPropRawOptions/*NotifyRawOptions*/): void
{
	if (options && options.suppressEvents) { return; }

	let sender: DomainObject = obj._sender || obj,
		notifier: IEventNotifier = options && options.notifier,
		args: lang.ObservableChangeArgs = {
			prop: propName,
			value: propValue,
			oldValue: oldValue,
			reason: "change"
		};
	if (options) {
		if (options.original) {
			args.reason = "load";
		} else if (options.norollback) {
			args.reason = "set";
		}
	}
	if (notifier) {
		notifier.trigger(obj, "change:" + propName, sender, propValue, oldValue);
		notifier.trigger(obj, "change", sender, args);
	} else {
		obj.trigger("change:" + propName, sender, propValue, oldValue);
		obj.trigger("change", sender, args);
	}
}

export function notifyPropSet(
	obj: DomainObject, propName: string, propValue, oldValue, options?: NotifyRawOptions): void;
/**
 * Уведомляет об установке значения свойства, генерируя соответствующие события
 * @param {DomainObject} obj
 * @param {string} propName
 * @param propValue
 * @param oldValue
 * @param {Object} options
 * @param {ChangeBatchNotifier} [options.notifier] - батч событий
 */
export function notifyPropSet(
	obj: DomainObjectInternal, propName: string, propValue, oldValue, options?: NotifyRawOptions): void
{
	if (options && options.suppressEvents) { return; }

	var sender: DomainObject = obj._sender || obj,
		notifier: IEventNotifier = options && options.notifier,
		args: lang.ObservableSetArgs = {prop: propName, value: propValue, oldValue: oldValue};

	if (notifier) {
		notifier.trigger(obj, "set", sender, args);
	} else {
		obj.trigger("set", sender, args);
	}
}

export function notifyPropGet(
	obj: DomainObject, propName: string, propValue, options?: NotifyRawOptions): void;
/**
 * Уведомляет об получении значения свойства, генерируя соответствующие события
 * @param {DomainObject} obj
 * @param {string} propName
 * @param propValue
 * @param options
 * @param {ChangeBatchNotifier} [options.notifier] - батч событий
 */
export function notifyPropGet(
	obj: DomainObjectInternal, propName: string, propValue, options: NotifyRawOptions): void
{
	if (options && options.suppressEvents) { return; }

	var sender: DomainObject = obj._sender || obj,
		notifier: IEventNotifier = options && options.notifier,
		args: lang.ObservableGetArgs = {prop: propName, value: propValue};

	if (notifier) {
		notifier.trigger(obj, "get", sender, args);
	} else {
		obj.trigger("get", sender, args);
	}
}

export function getPropRaw(obj: DomainObject, propMeta: PropertyMeta, options?: GetPropOptions): any;
/**
 * Возвращает "грязное" значение свойства (без дополнительных проверок и оборачиваний)
 * @param {DomainObject} obj доменный объект
 * @param propMeta метаданные свойства - json-объект
 * @param options
 */
export function getPropRaw(obj: DomainObjectInternal, propMeta: PropertyMeta, options: GetPropOptions = {}): any {
	let propName: string = propMeta.name;
	if (options.original) {
		let undoState: DomainObjectUndoState  = lang.find(obj._undostack, state => state.values.hasOwnProperty(propName));
		if (undoState) {
			return undoState.values[propName];
		}
	}
	return obj._propValues[propMeta.name];
}

export function setPropRaw(
	obj: DomainObject, propMeta: PropertyMeta, propValue, options?: SetPropRawOptions): void;
/**
 * Устанавливает "грязное" значение свойства (без дополнительных проверок и оборачиваний)
 * @param {DomainObject} obj доменный объект
 * @param propMeta метаданные свойства - json-объект
 * @param propValue значение свойства
 * @param {Object} options опции - json-объект с полями:
 * @param {Boolean} options.original - устанавливается оригинальное значение свойства. если свойство не менялось, то устанавливается текущее значение с опцией norollback
 * @param {Boolean} options.norollback - выполняется начальная установка свойства - значения НЕ копируются в коллекцию оригинальных значений
 * @param {Boolean} options.suppressEvents do not fire events ("set", "change")
 */
export function setPropRaw(
	obj: DomainObjectInternal, propMeta: PropertyMeta, propValue: any, options: SetPropRawOptions = {}): void
{
	if (propValue === undefined && !options.norollback) {
		// NOTE: Установка undefined означает, что свойство пытаются сделать не загруженным. Зачем?
		// Скорее всего, это результат какой-то ошибки. См. WC-1484.
		// Исключение - когда задан флаг norollback. Значит, выполняется DomainObject#rollbackState
		// или DomainObject#remove или что-то подобное.

		console.warn("Setting the domain property to 'undefined' is not allowed. Undefined was replaced by null.");
		propValue = null;
	}

	let propName: string = propMeta.name;
	if (options.original) {
		// NOTE: Оригинальное значение содержится в первом состоянии, где свойство менялось первый раз (if any).
		// Поищем его и в случае удачи заменим в нем значение.
		let undoState = lang.find(obj._undostack, state => state.values.hasOwnProperty(propName));
		if (undoState) {
			undoState.values[propName] = propValue;
			return;
		}
	}

	let norollback = options.norollback || options.original,
		oldValue = obj._propValues[propName],
		valueChanged: boolean = !lang.isEqual(propValue, oldValue),
		propWrapper = obj._propWrappers[propName],
		originalValues: lang.Map<any>;

	if (!norollback && valueChanged && propValue !== undefined &&
		oldValue && oldValue.$value === "NotAuthorizedPropValue") {
		throw errors.createNotAuthorized();
	}

	if (valueChanged && !norollback) {
		let undoState = options.undoIndex >= 0 && obj._undostack[options.undoIndex] || states.topUndoState(obj);
		originalValues = undoState.values;
		if (!originalValues.hasOwnProperty(propName)) {
			originalValues[propName] = oldValue;
		} /* See WC-1250:
		else if (lang.isEqual(originalValues[propName],propValue)) {
			let newState: DomainObjectLocalState;
			delete originalValues[propName];
			// check whatever undoState's values is empty
			newState = obj.localStates.normal;
			for (let key in originalValues) {
				if (originalValues.hasOwnProperty(key)) {
					// not empty
					newState = obj.localStates.modified;
					break;
				}
			}
		}*/

		setLocalState(obj, obj.localStates.modified, options, undoState);
	}

	if (propValue !== undefined) {
		obj._propValues[propName] = propValue;
	} else {
		delete obj._propValues[propName];
	}

	// dispose prop wrapper if it's changed
	if (propWrapper) {
		let wrapperChanged = propMeta.vt === "object" ?
			(propValue !== undefined ? propWrapper.isGhost : !propWrapper.isGhost) :
			valueChanged;
		if (wrapperChanged) {
			if (typeof propWrapper.dispose === "function") {
				propWrapper.dispose();
			}
			delete obj._propWrappers[propName];
		}
	}

	if (valueChanged) {
		notifyPropChanged(obj, propName, propValue, oldValue, options);
	}
	notifyPropSet(obj, propName, propValue, oldValue, options);
}

/**
 * Remove id from opposite property without synchronization.
 * @param {DomainObject} obj
 * @param {PropertyMeta} propMeta
 * @param {String} id
 * @param {SetPropRawOptions} options
 */
export function removeFromOppositeNavProp(
	obj: DomainObject, propMeta: PropertyMeta, id: string, options?: SetPropRawOptions): void
{
	let uow = <UnitOfWorkInternal>obj.uow;
	if (propMeta.opposite) {
		let refObj: DomainObject = uow.find(propMeta.ref.name, id);
		if (refObj) {
			removeFromNavProp(refObj, propMeta.opposite, obj.id, options, /*noSync*/true);
		} else {
			// object isn't loaded yet
			uow._objects.pendingRemove(propMeta.opposite, id, obj.id, options);
		}
	}
}
export function addToOppositeNavProp(obj: DomainObject, propMeta: PropertyMeta, id: string, options?: SetPropRawOptions): void {
	let uow = <UnitOfWorkInternal>obj.uow;
	if (propMeta.opposite) {
		let refObj = uow.find(propMeta.ref.name, id);
		if (refObj) {
			addToNavProp(refObj, propMeta.opposite, obj.id, options, /*noSync*/ true);
		} else {
			// object isn't loaded yet
			uow._objects.pendingAdd(propMeta.opposite, id, obj.id, options);
		}
	}
}

/**
 * Добавляет id к значению навигируемого свойства (для массивных) или замещает значение свойства (для скалярных).
 * Синхронизирует обратное свойство.
 * @param {DomainObject} obj исходный доменный объект, свойство которого модифицируется
 * @param {object} propMeta метаданные модифицируемого свойства объекта obj
 * @param {string|DomainObject} v идентификатор или объект, добавляемый к свойству
 * @param {object} [options]
 * @param {boolean} [noSync] не синхронизировать обратное свойство
 */
export function addToNavProp(
	obj: DomainObject, propMeta: PropertyMeta, v: string|IDomainObject,
	options?: SetPropRawOptions, noSync?: boolean): void
{
	var id: string = objectIdOf(v),
		uow = <UnitOfWorkInternal>obj.uow,
		value: any,
		changed: boolean;

	// изменяем само свойство
	value = getPropRaw(obj, propMeta, options);
	if (value && value.$value === "NotAuthorizedPropValue") {
		return;
	}

	if (!propMeta.many) {
		// NOTE: устанавливаем значение, только если старое значение отличается от нового
		// (в том числе, если старое было не загружено)
		if (value !== id) {
			setPropRaw(obj, propMeta, id, options);
			changed = true;

			// удаляем объект из старого обратного свойства
			// NOTE: делаем это независимо от флага noSync. В данном случае noSync должна препятствовать
			// повторному добавлению объекта в новое обратное свойство, но не удалению
			if (propMeta.opposite && uow && value) {
				removeFromOppositeNavProp(obj, propMeta, value, options);
			}
		}
	} else {
		if (value === undefined) {
			// свойство не загружено
			if (uow) {
				uow._objects.pendingAdd(propMeta, obj.id, id, options);
				changed = true;
			}
		} else {
			if (value === null) {
				// свойство пустое
				value = [];
			}
			if (value.indexOf(id) < 0) {
				// NOTE: перед модификацией массива его нужно обязательно клонировать,
				// иначе изменится также текущее значение свойства и затем уже измененное значение попадет
				// в коллекцию оригинальных значений
				value = value.concat(id); // NOT: value.push(id)
				setPropRaw(obj, propMeta, value, options);
				changed = true;
			}
		}
	}

	// изменяем обратное свойство
	if (changed && !noSync && propMeta.opposite && uow) {
		addToOppositeNavProp(obj, propMeta, id, options);
	}
}

/**
 * Удаляет id из значения навигируемого свойства. Синхронизирует обратное свойство.
 * @param {DomainObject} obj исходный доменный объект, свойство которого модифицируется
 * @param propMeta метаданные модифицируемого свойства объекта obj
 * @param {string} v идентификатор, удаляемый из свойства
 * @param {Object} [options]
 * @param {boolean} [noSync] - не синхронизировать обратное свойство
 */
export function removeFromNavProp(
	obj: DomainObject, propMeta: PropertyMeta, v: string|IDomainObject,
	options?: SetPropRawOptions, noSync?: boolean): void
{
	var id: string = objectIdOf(v),
		uow = <UnitOfWorkInternal>obj.uow,
		value: any,
		i: number,
		changed: boolean;

	// get current value
	value = getPropRaw(obj, propMeta, options);
	if (value && value.$value === "NotAuthorizedPropValue") {
		return;
	}

	if (value === undefined) {
		// property isn's loaded
		if (uow) {
			uow._objects.pendingRemove(propMeta, obj.id, id, options);
			changed = true;
		}
	} else {
		if (!propMeta.many) {
			// NOTE: update to null if and only if the old value equals to removing value (id)
			if (value === id) {
				setPropRaw(obj, propMeta, null, options);
				changed = true;
			}
		} else {
			// NOTE: check if removing value is in current value array
			if (value !== null && (i = value.indexOf(id)) >= 0) {
				// NOTE: перед модификацией массива его нужно обязательно клонировать,
				// иначе изменится также текущее значение свойства и затем уже измененное значение попадет
				// в коллекцию оригинальных значений
				value = value.slice();
				value.splice(i, 1);
				if (!value.length) {
					value = null;
				}
				setPropRaw(obj, propMeta, value, options);
				changed = true;
			}
		}
	}

	// update opposite property
	if (changed && !noSync && propMeta.opposite && uow) {
		removeFromOppositeNavProp(obj, propMeta, id, options);
	}
}

//	function getEmptyNotNullValueForPropType(vt) {
//		switch (vt) {
//			case "boolean":
//				return false;
//		}
//		return null;
//	}

/**
 * Returns initial value of the property
 * @param {Object} propMeta
 * @return {*}
 */
export function getInit(propMeta: PropertyMeta): any {
	let initValue = propMeta.init;
	if (typeof initValue === "string") {
		initValue = initFacets.getTypeInitFacet(initValue, propMeta);
	}
	if (typeof initValue === "function") {
		initValue = initValue(propMeta);
	}
	// если значения по умолчанию нет, то проставим null, чтобы отличать от незагруженных свойств
	if (initValue === undefined) {
		initValue = null;
		// Before 0.13 WAS: propMeta.nullable ?	null : getEmptyNotNullValueForPropType(propMeta.vt);
	}

	return initValue;
}

export function setLocalState(
	obj: DomainObject, value: DomainObjectLocalState,
	options?: SetPropOptions, undoState?: DomainObjectUndoState): void;
/**
 * Устанавливает "состояние" объекта.
 * @param {DomainObject} obj Целевой объект.
 * @param {Number} value Значение.
 * @param {Object} [options] Опции. Необязательный параметр.
 * @param {Object} [undoState] Предыдущее состояние в стеке отката. Необязательный параметр, используется для оптимизации.
 */
export function setLocalState(
	obj: DomainObjectInternal, value: DomainObjectLocalState,
	options?: SetPropOptions, undoState?: DomainObjectUndoState): void
{
	let old = obj._localState;

	if (!options || !options.norollback) {
		if (!undoState) {
			undoState = states.topUndoState(obj);
		}
		undoState.localState = Math.max(value, undoState.localState);
		value = Math.max(value, old);
	}

	if (value !== old) {
		obj._localState = value;
		notifyPropChanged(obj, "localState", value, old, options);
	}
}

export let errors = {
	createObjectNotFound: function (typeName: string, id: string) {
		return new Error(resources["object_not_found"]);
	},
	createNotAuthorized: function () {
		return new Error(resources["not_authrozied"]);
	}
};

export function findObjectByIdentity(objects: DomainObject[], typeName: string, id: string): DomainObject;
export function findObjectByIdentity(objects: IDomainObject[], typeName: string, id: string): IDomainObject;
/**
 * Search for an object in array by its type and id. Take into account inheritence
 * @param {Array} objects
 * @param {String} typeName
 * @param {String} id
 */
export function findObjectByIdentity(
	objects: IDomainObject[], typeName: string, id: string): IDomainObject
{
	return lang.find(objects, (obj) => {
		if (obj.id !== id) {
			return false;
		}

		let typeMeta;
		for (typeMeta = obj.meta; typeMeta; typeMeta = typeMeta.base) {
			if (typeMeta.name === typeName) {
				return true;
			}
		}
		return false;
	});
}

function topUndoState<T>(target: { _undostack: T[] }): T;
function topUndoState<T>(target: any): T;
function topUndoState<T>(target): T {
	return lang.last<T>(target._undostack);
}

export let states = {
	/**
	 Возвращает последнее состояние в стеке отката объекта
	 */
	topUndoState: topUndoState,
	/**
	 Возвращает индекс состояния по его имени в стеке отката объекта
	 */
	getUndoStateIndex: function<T extends { name: string }>(target, stateName?: string): number {
		let undostack: T[] = target._undostack,
			stateIndex: number;
		if (stateName === undefined) {
			stateIndex = undostack.length - 1;
		} else {
			for (let i = 0; i < undostack.length; i++) {
				if (undostack[i].name === stateName) {
					stateIndex = i;
					break;
				}
			}
		}
		return stateIndex;
	},
	/**
	 Удаляет состояние из стека отката объекта
	 */
	removeUndoState: function<T>(target, stateIndex: number, stateFactory: (name: string) => T): void {
		let undostack: T[] = target._undostack;
		undostack.splice(stateIndex, 1);

		if (!undostack.length) {
			undostack.push(stateFactory(""));
		}
	}
};

export interface LobPropValueDto {
	size?: number;
	fileName?: string;
	mimeType?: string;
	/**
	 * Specified for local (unsaved) value after value chosen and before it uploaded onto server.
	 */
	pendingUpload?: boolean;
	/**
	 * Specified for local (unsaved) value but uploaded onto server
	 */
	resourceId?: string;
}
export class LobPropValue implements LobPropValueDto {
	size: number;
	fileName: string;
	/**
	 * Specified for local (unsaved) value after value chosen and before it uploaded onto server.
	 */
	pendingUpload?: boolean;
	/**
	 * Specified for local (unsaved) value but uploaded onto server
	 */
	resourceId?: string;
	mimeType?: string;

	/**
	 * @constructs LobPropValue
	 * @param {Object} dto
	 */
	constructor(dto: LobPropValueDto) {
		lang.extend(this, dto);
	}

	toString(): string {
		let that = this,
			size = utils.formatSize(that.size);

		if (that.fileName) {
			return that.fileName + (size ? " (" + size + ")" : "");
		}
		return size;
	}

	toJson(): any {
		let that = this,
			ret = {$value: "LobPropValue"};
		lang.forEach(that, (v: any, key: string) => {
			if (that.hasOwnProperty(key) && !lang.isFunction(v)) {
				ret[key] = v;
			}
		});
		return ret;
	}
}

export let values = {
	NotAuthorizedPropValue: {
		isNotAuthorized: true,
		toString: function (): string {
			return resources["not_authorized"];
		},
		is: function (value: any): boolean {
			return value && (value.isNotAuthorized || value.$value === "NotAuthorizedPropValue");
		},
		toJson: function (): Object {
			return {$value: "NotAuthorizedPropValue"};
		}
	},
	LobPropValue: LobPropValue
};

export let json = {
	materializeProp: function (v: any, propMeta: PropertyMeta): any {
		if (lang.isString(v)) {
			if (propMeta.vt === "dateTime" || propMeta.vt === "date" || propMeta.vt === "time") {
				return datetimes.parseISOString(v, /*isGlobalTime*/false);
			}
			if (propMeta.vt === "dateTimeTz" || propMeta.vt === "timeTz") {
				return datetimes.parseISOString(v, /*isGlobalTime*/true);
			}
		}
		return v;
	},
	/**
	 * Convert domain prop value for json
	 * @param v
	 * @param propMeta
	 * @returns {any}
	 */
	dematerializeProp: function (v: any, propMeta: PropertyMeta): any {
		if (lang.isDate(v)) {
			if (propMeta.vt === "dateTime" || propMeta.vt === "date" || propMeta.vt === "time") {
				return datetimes.toISOString(v, /*isGlobalTime*/false);
			}
			if (propMeta.vt === "dateTimeTz" || propMeta.vt === "timeTz") {
				return datetimes.toISOString(v, /*isGlobalTime*/true);
			}
		}
		if (v instanceof Big) {
			if (propMeta.vt === "i8") {
				return v.toFixed();
			} else {
				// Big should be used only for i8, but just in case
				return v.toString();
			}
		}
		return v;
	}
};

type ChangeBatchEventArgs = any[];
type ChangeBatchItem = {
	ctx: any;
	events: ChangeBatchEventArgs[];
};
export class ChangeBatchNotifier implements IEventNotifier {
	private _batch: ChangeBatchItem[];

	/**
	 * Collect 'change', 'change:{prop}' and 'set' events and trigger them in a batch
	 * @constructs ChangeBatchNotifier
	 */
	constructor() {
		this._batch = []; // TODO: use DomainObjectMap
	}

	/**
	 * A replacement for NavigationPropBase trigger method.
	 * Instead of events generating it collect events arguments till 'resume' method called.
	 * @param {Object} ctx An object which generates event
	 * @param {String} name Event name
	 * @param {Object} sender Event sender (can differ from ctx)
	 * @param {Object} data event's arguments
	 */
	trigger(ctx: lang.IEventful, name: string, sender, data): void {
		// NOTE: 'change:{prop}' is always triggered with 'change' event. We can handle 'change' event only.
		if (lang.stringStartsWith(name, "change:")) {
			return;
		}

		// we don't collect any events except of 'change' and 'set'
		let args: ChangeBatchEventArgs = [];
		for (let i = 1; i < arguments.length; i++) { args [i-1] = arguments[i]; }
		if (name !== "set" && name !== "change") {
			ctx.trigger.apply(ctx, args);
			return;
		}

		// get delayed events for specified context
		let events = this._getEvents(ctx);
		// find event args with the same name, sender and property name
		let prevArgs = lang.find(events, (ea: ChangeBatchEventArgs) => {
			return ea[0] === name && ea[1] === sender &&
				ea[2] && ea[2].prop && data && data.prop && ea[2].prop === data.prop;
		});
		if (!prevArgs) {
			events.push(args);
		} else {
			prevArgs[2].value = data.value;
		}
	}

	/**
	 * Completes batch and generates all collected events.
	 */
	resume(): void {
		this._batch.forEach((item: ChangeBatchItem) => {
			lang.forEach(item.events, (args: ChangeBatchEventArgs) => {
				// trigger 'change' and 'set' events
				item.ctx.trigger.apply(item.ctx, args);
				// trigger 'change:{prop}' event together with 'change'
				if (args[0] === "change" && args[2] && args[2].prop && args[2].hasOwnProperty("value")) {
					item.ctx.trigger(
						"change:" + args[2].prop, //eventName
						args[1], //sender
						args[2].value, //value
						args[2].oldValue // oldValue
					);
				}
			});
		});
		this._batch.length = 0;
	}

	/**
	 * Returns an array of arguments of 'trigger' method called for specified context
	 * @param ctx
	 * @returns {Array}
	 * @private
	 */
	_getEvents(ctx): ChangeBatchEventArgs[] {
		var that = this,
			triggers: ChangeBatchItem = lang.find(that._batch, v => v.ctx === ctx);
		if (!triggers) {
			triggers = {ctx: ctx, events: []};
			that._batch.push(triggers);
		}
		return triggers.events;
	}
}

export let initFacets = {
	getTypeInitFacet: function (initFacet: string, propMeta: PropertyMeta) {
		switch (propMeta.vt) {
			case "date":
			case "time":
			case "dateTime":
			case "timeTz":
			case "dateTimeTz":
				initFacet = initFacets.dateTime[initFacet];
				break;
		}
		return initFacet;
	},

	dateTime: {
		now: function (propMeta: PropertyMeta) {
			let format = propMeta.format ? propMeta.format : formatters.defaultFormats[propMeta.vt];
			let formatter = formatters.getDefaultFormatter(propMeta);
			return moment(formatter(propMeta, new Date()), format).toDate();
		}
	}
};
