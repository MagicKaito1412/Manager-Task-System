import lang = require("lib/core.lang");
import support = require("./support");
import DomainObject = require("./DomainObject");
import DomainObjectRegistry = require("./DomainObjectRegistry");
import eth = require("lib/core.eth");

import domain= require(".domain");
import internals = require(".internals");
import interop = require("lib/interop/.interop");
import IDomainObject = domain.IDomainObject;
import IDomainModel = domain.IDomainModel;
import IDataFacade = interop.IDataFacade;
import DomainObjectData = interop.DomainObjectData;
import SavedObjectData = interop.SavedObjectData;
import LoadQuery = interop.LoadQuery;
import LoadResponse = interop.LoadResponse;
import ObjectIdentity = interop.ObjectIdentity;
import DataUpdateEventArgs = interop.DataUpdateEventArgs;
import DomainObjectInternal = internals.DomainObjectInternal;
import DomainObjectLocalState = DomainObject.LocalState;
import EntityNameTerm = domain.EntityNameTerm;
import TypedNameTerm = domain.TypedNameTerm;
import PropertyMeta = domain.metadata.PropertyMeta;
import ReferenceToObject = domain.ReferenceToObject;
import ChangeOptions = domain.ChangeOptions;
import SetPropOptions = domain.SetPropOptions;
import ToJsonOptions = domain.ToJsonOptions;
import FromJsonOptions = domain.FromJsonOptions;
import LoadOptions = domain.LoadOptions;
import SaveOptions = UnitOfWork.SaveOptions;
import SaveResult = UnitOfWork.SaveResult;

/**
 * Creates an instance of domain object or a ghost
 * @callback CreateInstanceCallback
 * @param {Object} model
 * @param {String} typeName
 * @param {String} [id]
 * @returns {Object}
 */

class UnitOfWork extends lang.Observable {
	model: IDomainModel;

	protected _dataFacade: IDataFacade;
	protected _objects: DomainObjectRegistry;

	/**
	 * Unit of work
	 * @constructs UnitOfWork
	 * @extends Observable
	 * @param {Object} model
	 * @param {DataFacadeBase} dataFacade
	 * @param {Object} [options]
	 * @param {boolean} [options.connected] Subscribe on DataFacade's 'update' event
	 */
	constructor(model: IDomainModel, dataFacade: IDataFacade, options?: UnitOfWork.Options) {
		super();

		let that = this;
		that.model = model;
		that._objects = new DomainObjectRegistry(model, that);
		/**
		 * @type {DataFacadeBase}
		 * @private
		 */
		that._dataFacade = dataFacade;
		if (options && options.connected && lang.Observable.isObservable(that._dataFacade)) {
			that._dataFacade.bind("update", that._onDataUpdate, that);
		}
	}

	/**
	 * Don't handle 'update' event from DataFacade
	 */
	isolated: boolean;

	/**
	 * Observable read-only property. It signals that there are some changed objects (new, deleted or modified) in UoW.
	 * @observable-getter {Boolean}
	 */
	hasChanges: lang.ObservableGetter<boolean>;

	dispose(): void {
		let that = this;

		// unbind
		if (lang.Observable.isObservable(that._dataFacade)) {
			that._dataFacade.unbind("update", null, that);
		}

		// dispose all objects
		that._objects.forEach(function (obj) {
			obj.dispose();
		});

		super.dispose();
	}

	all(): DomainObject[] {
		return <DomainObject[]>this._objects.all().filter(function (obj) {
			return !obj.isGhost;
		});
	}
	forEach(callback: (obj: DomainObject) => void, context?): void {
		return this._objects.forEach(function (obj) {
			if (!obj.isGhost) {
				callback.call(context, obj);
			}
		});
	}

	attach(obj: IDomainObject, options?: ChangeOptions): IDomainObject {
		let that = this;
		if (obj.uow && obj.uow === that) {
			return obj;
		}
		let obj2 = <DomainObjectInternal>obj;
		if (obj2._localState === DomainObjectLocalState.invalid) {
			throw new Error("UnitOfWork.attach: cannot attach invalid object");
		}
		if (obj.uow) {
			obj.uow.detach(obj);
		}
		that._objects.add(obj, options);
		if (!obj.isGhost) {
			obj.bind("change:localState", that._onObjectChanged, that);
			if ((<DomainObject>obj).hasChanges()) {
				this._setHasChanges(true);
			}
		}
		return obj;
	}
	detach(obj: IDomainObject, options?: ChangeOptions): IDomainObject {
		let that = this;
		that._objects.remove(obj, options);
		if (!obj.isGhost) {
			obj.unbind("change:localState", null, that);
			if ((<DomainObject>obj).hasChanges()) {
				that._calculateHasChanged();
			}
		}
		return obj;
	}
	private _onObjectChanged(obj: IDomainObject, newState: DomainObjectLocalState): void {
		// NOTE: the state of a single object can't be changed to zero. It's only possible as a result of
		// calling acceptState() or rollbackState()
		if (newState > 0) {
			this._setHasChanges(true);
		}
	}

	/**
	 * @observable-setter {Boolean}
	 */
	private _setHasChanges: lang.ObservableSetter<boolean>;

	private _calculateHasChanged(): void {
		let hasChanges = this._objects.some(function (obj: DomainObject) {
			return !obj.isGhost && obj.hasChanges();
		});
		this._setHasChanges(hasChanges);
	}

	hasChangesSince(stateName: string): boolean {
		return this._objects.some(function (obj: DomainObject) {
			return !obj.isGhost && obj.hasChangesSince(stateName);
		});
	}

	find(type: EntityNameTerm, id: string, options: { ghost: boolean, removed?: boolean }): IDomainObject|undefined;
	find(type: EntityNameTerm, id: string, options?: { removed?: boolean }): DomainObject|undefined;
	find(type: EntityNameTerm, id: string, options?: { ghost?: boolean, removed?: boolean }): IDomainObject|undefined {
		let obj = <DomainObjectInternal>this._objects.find(support.typeNameOf(type), id),
			found: boolean = obj &&
				((options && options.ghost) || !obj.isGhost) &&
				((options && options.removed) || obj._localState < obj.localStates.removed || (options && options.ghost && obj._localState === undefined));
		return found ? obj : undefined;
	}

	create<T extends DomainObject>(type: TypedNameTerm<T>, props?: lang.Map<any>): T {
		let that = this,
			obj = that.model.factory.createObject(that.model, support.typeNameOf(type)) as T;
		that._initNewObject(obj);
		that.attach(obj);

		// установим переданные свойства
		// NOTE: объект должен быть уже присоединен к UoW, так как при установке навигируемых
		// свойств возможна синхронизация с другими объектами.
		if (props) {
			obj.set(props);
		}

		return obj;
	}

	/**
	 * Required by lang.Observable. Don't use this overload;
	 */
	get(name: string): any;
	get(type: EntityNameTerm, id: string, options?): IDomainObject;
	/**
	 * Find an object by type and id. If an object is not found a ghost object will be created.
	 * @param {Class|String} type
	 * @param {String} id
	 * @param {Object} [options]
	 * @param {CreateInstanceCallback} [options.create] A function which creates the desired object, if it is not found in the UoW.
	 * @returns {*}
	 */
	get(type: EntityNameTerm, id?: string, options?): IDomainObject {
		let that = this,
			typeName = support.typeNameOf(type),
			obj = that._objects.find(typeName, id);
		if (!obj) {
			obj = options && options.create ?
				options.create(that.model, typeName, id) :
				that.model.factory.createGhost(that.model, typeName, id);
			that.attach(obj);
		}
		return obj;
	}

	remove(obj: DomainObject, options?: ChangeOptions): void;
	remove(obj: DomainObjectInternal, options?: ChangeOptions): void {
		let that = this;

		// объект уже может удаляться при каскадном удалении.
		// к объекту может вести несколько путей с каскадным удалением, поэтому полагаться на один флаг нельзя
		if (obj.__removing) { return; }
		// уже detached, либо
		if (!obj.uow) { return; }

		try {
			obj.__removing = true;

			options = options || {};
			// ищем свойства, которые ссылаются на тип удаляемого объекта
			let propRefs: PropertyMeta[] = support.propRefsTo(obj.meta);

			// удаляем все ссылки от существующих объектов
			let objectRefs: ReferenceToObject[] = that._objects.objectRefsTo(obj, propRefs),
				localStates = obj.localStates;
			for (let ref of objectRefs) {
				if (ref.prop.onDelete === "cascade") {
					// каскадное удаление
					that.remove(ref.object, options);
				} else if (ref.prop.onDelete === "removeRelation" ||
					options.norollback ||
					obj._localState === localStates.created ||
					(ref.object as DomainObjectInternal)._localState === localStates.created) {
					// разрываем связь для с removeRelation, а также если задана опция norollback или
					// если хотя бы один из двух объектов новый
					support.removeFromNavProp(ref.object, ref.prop, obj.id, options);
				}
			}

			// добавляем отложенные действия для объектов, которые могут быть загружены потом
			for (let prop of propRefs) {
				if (prop.onDelete === "cascade" ||
						prop.onDelete === "removeRelation" ||
						options.norollback) {
					that._objects.pendingRemove(prop, "*", obj.id, options);
				}
			}

			if (obj._localState === localStates.created) {
				// если объект был создан в последнем состоянии, то его можно выкинуть из UoW
				if (support.states.topUndoState(obj).localState === localStates.created) {
					that.detach(obj, options);
				}
				// новый объект становится невалидным после удаления
				support.setLocalState(obj, localStates.invalid, options);
			} else if (obj._localState === localStates.invalid) {
				// если объект стал невалидным в последнем состоянии, то его можно выкинуть из UoW
				if (support.states.topUndoState(obj).localState === localStates.invalid) {
					that.detach(obj, options);
				}
			} else {
				if (obj.isGhost) {
					// not-loaded, replace it with a empty loaded
					that.detach(obj, options);
					obj = <DomainObjectInternal>that.model.factory.createObject(that.model, obj.meta.name, obj.id);
					that.attach(obj, {norollback: true});
				}
				support.setLocalState(obj, localStates.removed, options);
			}
		} finally {
			delete obj.__removing;
		}
	}

	fromJson(json: DomainObjectData[], options?: FromJsonOptions): DomainObject[];
	fromJson(json: DomainObjectData, options?: FromJsonOptions): DomainObject;
	/**
	 * Наполняет текущую единицу работы данными одного или нескольких объектов в виде json.
	 * Если объект не существует в единице работы, то он добавляется.
	 * По умолчанию обновляются значения оригинальных свойств объекта (управляется опцией dirty);
	 * @param {Object|Array} json Данные объекта в виде json или массив таких данных
	 * @param {Object} [options] Дополнительные опции:
	 * @param {Boolean} [options.dirty] Признак недостоверных данных: true - обновляются текущие свойства объекта; false - оригинальные
	 * @return {DomainObject|Array}
	 */
	fromJson(json: DomainObjectData[]|DomainObjectData, options: FromJsonOptions = {}) {
		let that = this,
			propOptions: SetPropOptions = { original: !options.dirty, norollback: !options.dirty };

		return lang.select(json, jsonObj => that._fromJsonObject(jsonObj, options, propOptions));
	}

	/**
	 * Parses DataFacade.load's response and maps its to DomainObjects
	 * @param {Object} serverResponse Response from dataFacade.load
	 * @param {Object} [options] options for `DomainObject.fromJson`
	 * @return {DomainObject|Array}
	 */
	fromServerResponse(serverResponse: LoadResponse, options?: FromJsonOptions): DomainObject|DomainObject[] {
		options = lang.setValue(options, "norollback", true );
		if (serverResponse.more) {
			this.fromJson(serverResponse.more, options);
		}
		if (serverResponse.result) {
			return this.fromJson(serverResponse.result, options);
		}
		return [];
	}

	/**
	 * Наполняет текущую единицу работы данными объекта в виде json.
	 * Если объект не существует в единице работы, то он добавляется.
	 * По умолчанию обновляются значения оригинальных свойств объекта (управляется опцией dirty);
	 * @prototype
	 * @param {Object} json Данные объекта в виде json
	 * @param {Object} options Опции
	 * @param {Object} propOptions Дополнительные опции для установки свойств
	 * @return {DomainObject}
	 */
	protected _fromJsonObject(json: DomainObjectData, options: FromJsonOptions, propOptions: SetPropOptions): DomainObject {
		if (!json) { return null; }

		let that = this,
			local: IDomainObject = that.find(json.__metadata.type, json.id, { removed: true, ghost: true }),
			obj: DomainObject;

		if (local && !local.isGhost) {
			obj = (<DomainObject>local).fromJson(json, options, propOptions);
		} else {
			obj = that.model.factory.createObject(that.model, json.__metadata.type, json.id);

			if (json.__metadata.isNew) {
				that._initNewObject(obj);
			} else {
				// set default values for temp properties
				obj.clear({
					norollback: true,
					suppressEvents: true,
					propFilter: function (propMeta) {
						return propMeta.temp;
					}
				});
			}
			// NOTE: we have to attach the object before calling 'fromJson' method, otherwise navigation properties will not be synchronized
			that.attach(obj, propOptions);

			// fill the object
			obj.fromJson(json, options, propOptions);

			if (local) {
				// trigger 'load' for the ghost
				local.trigger("load", local, { loaded: obj });
			}
		}

		return obj;
	}

	/**
	 * Initialize just created new object
	 * @param obj
	 */
	protected _initNewObject(obj: DomainObject): void {
		obj.isLoaded = true;
		support.setLocalState(obj, obj.localStates.created);

		// set default values for all properties
		obj.clear({ norollback: true, suppressEvents: true });
	}

	/**
	 * Load an object by id.
	 * Guarantees that all specified preloads will be loaded (even if the dataFacade doesn't support preloads)
	 * @param {String} type Name of object type (entity)
	 * @param {String} id ObjectID
	 * @param {Object} [options]
	 * @param {Boolean} [options.reload] reload the object in any case otherwise it'll be loaded only if it's !isLoaded
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	load<T extends DomainObject>(type: TypedNameTerm<T>, id: string, options: LoadOptions = {}): lang.Promise<T> {
		let that = this;

		if (options.reload) {
			return that.reload(type, id, options);
		}

		let obj = that.find(type, id) || that._doLoad(type, id, options);
		return lang.async.then(obj, loaded => that.ensureLoaded(loaded, options));
	}

	/**
	 * Reload an object by id.
	 * Guarantees that all specified preloads will be reloaded (even if the dataFacade doesn't support preloads)
	 * @param {String} type EntityType
	 * @param {String} id ObjectId
	 * @param {Object} [options]
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	reload<T extends DomainObject>(type: TypedNameTerm<T>, id: string, options: LoadOptions = {}): lang.Promise<T> {
		let that = this,
			uow2: UnitOfWork;

		if (!options.preloads) {
			return that._doLoad(type, id, options);
		}

		// NOTE: it's difficult to determine whether a preload was really loaded from dataFacade or already was in UoW.
		// So load objects in a separate UoW (without 'reload' option) and merge results then.

		// NOTE (for commented code): it would be great to create an instance of the same class,
		// but we don't know arguments of its constructor (particularly, constructors of child classes
		// for concrete models get only one arguments - dataFacade)
		//uow2 = new that.constructor(that.model, that._dataFacade);
		uow2 = new UnitOfWork(that.model, that._dataFacade);

		delete options.reload; // should we clone options before?
		return lang.async.then(uow2.load(type, id, options), () => {
			let json: DomainObjectData[] = uow2.all().map(o => o.toJson());
			that.fromJson(json);
			return that.find(type, id) as T;
		}).always(() => {
			uow2.dispose();
		});
	}

	/**
	 * Ensures that the object and all preload (if any) will be loaded (even if the dataFacade doesn't support preloads).
	 * @param {DomainObject|NotLoadedObject} obj The real domain object or the ghost object.
	 * @param {Object} [options]
	 * @param {Boolean} [options.reload] reload the object in any case otherwise it'll be loaded only if it's !isLoaded
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	ensureLoaded<T extends DomainObject>(obj: IDomainObject, options: LoadOptions = {}): lang.Promise<T> {
		let that = this,
			objLocal: DomainObject,
			preloads = options.preloads,
			deferred: lang.Promise<T>;

		if (options.reload) {
			return that.reload(obj.meta.name, obj.id, options);
		}
		if (!obj.isLoaded) {
			objLocal = that.find(obj.meta.name, obj.id);
			if (objLocal) {
				obj = objLocal;
			}
		}
		deferred = lang.when(obj && obj.isLoaded ? obj as T : that._doLoad(obj.meta.name, obj.id, options));
		if (!preloads || !preloads.length) { return deferred; }

		return deferred.then((loaded: T) => {
			let preloadArray: string[] = typeof preloads === "string" ? preloads.split(/\s*,\s*/) : preloads;

			return lang.whenAll(preloadArray.map((path) => {
				return that._loadPath(loaded, path, options);
			})).then(() => {
				return loaded;
			});
		});
	}

	/**
	 * Load an object from DataFacade.
	 * @private
	 * @param {String} type Name of object type (entity)
	 * @param {String} id ObjectID
	 * @param {Object} options
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	protected _doLoad<T extends DomainObject>(type: EntityNameTerm, id: string, options: LoadOptions): lang.Promise<T> {
		let that = this,
			typeName = support.typeNameOf(type),
			query: LoadQuery = {
				source: {
					type: typeName,
					id: id
				},
				type: typeName
			};

		return that._dataLoad(query, options)
			.then(function (response: LoadResponse) {
				if (!response || !response.result) {
					return lang.rejected(support.errors.createObjectNotFound(typeName, id));
				}

				try {
					let result = that.fromServerResponse(response),
						obj = lang.isArray(result) ? support.findObjectByIdentity(result, typeName, id) : result;

					if (!obj) {
						return lang.rejected(support.errors.createObjectNotFound(typeName, id));
					}

					return obj;
				} catch (ex) {
					return lang.rejected(ex);
				}
			});
	}

	/**
	 * Load the value of the property (even if it is already loaded). The property can be navigation or simple.
	 * Take into account, that this method may not load all preloads if the dataFacade doesn't support preloads.
	 * @param {String} type Name of object type (entity)
	 * @param {String} id ObjectID
	 * @param {String} propName The name of the property
	 * @param {Object} [options]
	 * @param {String} [options.preloads]
	 * @param {Boolean} [options.reload]
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	loadProp(type: EntityNameTerm, id: string, propName: string, options: LoadOptions = {}): lang.Promise<any> {
		let that = this,
			typeName = support.typeNameOf(type),
			obj: DomainObject = !options.reload ? that.find(typeName, id) : undefined;
		if (obj) {
			return that.ensurePropLoaded(obj, propName, options);
		}
		let propMeta = that.model.meta.entities[typeName].props[propName];
		return that._doLoadProp(type, id, propMeta, options);
	}

	/**
	 * Ensures that the property is loaded.
	 * Take into account, that this method may not load all preloads if the dataFacade doesn't support preloads.
	 * @param {DomainObject} obj The domain object.
	 * @param {String} propName
	 * @param {Object} [options]
	 * @param {String} [options.preloads]
	 * @param {Boolean} [options.reload]
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	ensurePropLoaded(obj: DomainObject, propName: string, options: LoadOptions = {}): lang.Promise<any> {
		let that = this,
			propMeta = obj.getPropMeta(propName),
			v;

		if (!options.reload) {
			v = obj.get(propName);
			if ((v && v.isNotAuthorized) ||
				(propMeta.vt === "object" ? v === null || v.isLoaded : v !== undefined)) {
				return lang.resolved(v);
			}
		}
		if (obj.isInvalid()) {
			// prevent loading prop of an invalid object - set the prop value to null
			support.setPropRaw(obj, propMeta, null, {original: true});
			return lang.resolved(obj.get(propName));
		}

		return that._doLoadProp(obj.meta.name, obj.id, propMeta, options);
	}

	/**
	 * Load the value of the property from DataFacade.
	 * @private
	 * @param {String} type Name of object type (entity)
	 * @param {String} id ObjectID
	 * @param {String} propMeta The metadata of the navigation property
	 * @param {Object} options
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	protected _doLoadProp(type: EntityNameTerm, id: string, propMeta: PropertyMeta, options: LoadOptions): lang.Promise<any> {
		let that = this,
			typeName = support.typeNameOf(type),
			propName = propMeta.name,
			query: LoadQuery = {
				source: {
					type: typeName,
					id: id,
					propName: propName
				},
				type: (propMeta.vt === "object" && propMeta.ref.name) || typeName
			};
		if (propMeta.temp) {
			return lang.resolved(undefined);
		}
		return that._dataLoad(query, options)
			.then((response: LoadResponse) => {
				try {
					let parentObj = that.find(type, id, { removed: true }) as DomainObjectInternal,
						//parentJson: DomainObjectData,
						v;

					if (propMeta.vt !== "object") {
						v = response.result;
					} else {
						// NOTE: Next call of `fromServerResponse` may sync the value of the navigation property that
						// is loading now. If the property is not loaded now, pending actions will be created.
						// Set property value as null to prevent the creation of pending actions.
						// TOTHINK: `fromServerResponse` may update the property value because of the synchronization,
						// but that value will be overwritten later. How to prevent the synchronization (only for one
						// loading property)?
						if (parentObj && !parentObj.isGhost && support.getPropRaw(parentObj, propMeta) === undefined) {
							support.setPropRaw(parentObj, propMeta, null, { norollback: true, suppressEvents: true } );
						}

						let objects = that.fromServerResponse(response);
						if (!objects) {
							v = null;
						} else if (propMeta.many) {
							// collection prop
							v = lang.array(objects).map(o => o.id);
						} else {
							// scalar prop
							if (!lang.isArray(objects)) {
								v = objects.id;
							} else if (!objects.length) {
								v = null;
							} else if (objects.length === 1) {
								v = objects[0].id;
							} else{
								return lang.rejected(new Error("DataFacade returned more than one object as a value of scalar navigation prop"));
							}
						}
					}

					if (parentObj && !parentObj.isGhost) {
						// set the property value as if it is received from the server
						parentObj.fromJson({ [propName]: v }, { partial : true });
					}

					//return objects || parentObj.get(propName);
					return parentObj.get(propName);
				} catch (ex) {
					return lang.rejected(ex);
				}
			});
	}

	/**
	 * Load all objects of specified type.
	 * @param {String} type Name of object type (entity)
	 * @param {Object} [options]
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise}
	 */
	loadAll<T extends DomainObject>(type: TypedNameTerm<T>, options: LoadOptions = {}): lang.Promise<T[]> {
		let that = this,
			typeName = support.typeNameOf(type),
			query: LoadQuery = {
				source: {
					type: typeName
				},
				type: typeName
			};

		return that._dataLoad(query, options)
			.then(function (response) {
				if (!response || !response.result) {
					return [];
				}
				try {
					return that.fromServerResponse(response);
				} catch (ex) {
					return lang.rejected(ex);
				}
			});
	}

	/**
	 * Loads data via dataFacade.load
	 * @param query Base query for dataFacade. It is extended by options (preloads and params).
	 * @param options
	 * @returns {lang.Promise<LoadResponse>}
	 */
	protected _dataLoad(query: LoadQuery, options: LoadOptions): lang.Promise<LoadResponse> {
		// extend base query
		if (options.preloads) {
			query.preloads = options.preloads;
		}
		if (options.params) {
			query.params = options.params;
		}

		// extract interop options
		let interopOptions: interop.LoadOptions = lang.append(options.interop || {}, {
			caller: this,
			policy: options.policy
		});

		return this._dataFacade.load(query, interopOptions);
	}

	/**
	 * Loads all navigation properties specified in 'path'
	 * @param {DomainObject} obj The root object
	 * @param {String} path The chain of preloads
	 * @param {Object} options Original options passed to UnitOfWork.load method
	 */
	@lang.decorators.asyncSafe
	protected _loadPath(obj: DomainObject, path: string, options: LoadOptions): lang.Promise<DomainObject> {
		if (obj.isGhost) { throw new Error("An object must be loaded");	}
		if (!path || !path.length) { return; }

		let that = this,
			dotIndex: number = -1,
			prop: string,
			propMeta: PropertyMeta,
			nextPath: string,
			nextObj;
		// NOTE: path may contain valuable property from complex property (e.g. "address.locality.name")
		do {
			dotIndex = path.indexOf(".", dotIndex + 1);
			prop = dotIndex >= 0 ? path.slice(0, dotIndex) : path;
		}
		while (dotIndex > 0 && obj.meta.complex[prop]);

		propMeta = obj.getPropMeta(prop);
		nextPath = dotIndex >= 0 ? path.slice(dotIndex + 1) : "";
		nextObj = obj.get(prop);

		if (propMeta.vt !== "object") {
			if (nextPath.length) { throw new Error("The primitive property '" + prop + "' is not last in the preload chain"); }

			return obj.uow.ensurePropLoaded(obj, prop, lang.append({ preloads: nextPath }, options));
		}

		if (!nextObj || nextObj.isNotAuthorized) { return; }

		return nextObj.load(lang.append({ preloads: nextPath }, options))
			.then(function (loaded) {
				if (!loaded) { return loaded; }

				let objects = propMeta.many ? loaded.all() : [ loaded ],
					deferreds = objects.map(function (item) {
						return that._loadPath(item, nextPath, options);
					});
				return lang.when.apply(null, deferreds);
			});
	}

	protected _saveToJsonOptions: ToJsonOptions;

	/**
	 * Save all changes.
	 * @param {Object} [options]
	 * @param {Function} [options.onSuccess] Custom callback for handling save success
	 * @param {Function} [options.onError] Custom callback for handling save error
	 * @param {Function} [options.onPreprocess] a callback to call with json objects before calling DataFacade.save
	 * @param {Object} [options.interop] Advanced options for DataFacade.save
	 * @returns {*}
	 * @fires UnitOfWork#saving
	 * @fires UnitOfWork#saved
	 * @fires UnitOfWork#saveError
	 */
	save(options: SaveOptions = {}): lang.Promise<SaveResult> {
		// TODO: поддержка сохранения изменений внутри одного заданного состояния

		let that = this,
			saving: DomainObject[] = [],
			objects: DomainObject[] = [],
			created: DomainObject[] = [],
			deleted: DomainObject[] = [],
			jsonObjects: DomainObjectData[] = [],
			states: string[] = that._objects.getStateNames(),
			newStateName: string,
			deferredSave: lang.Promise<any>,
			saveOptions: interop.SaveOptions;

		that.forEach(function (obj: DomainObjectInternal): void {
			let localState: DomainObjectLocalState = obj._localState;
			if (localState && localState !== obj.localStates.invalid) {
				saving.push(obj);
			}
		});
		if (that._onSaving(saving)) {
			return lang.rejected(new Error("Operation was cancelled"));
		}

		saving.forEach(function (obj: DomainObjectInternal): void {
			let localState: DomainObjectLocalState = obj._localState,
				json: DomainObjectData = obj.toJson(that._saveToJsonOptions);
			// с опцией nullIfEmpty метода toJson вместо объектов без свойств вернуться null
			if (json) {
				objects.push(obj);
				if (localState === obj.localStates.created) { created.push(obj); }
				if (localState === obj.localStates.removed) { deleted.push(obj); }
				jsonObjects.push(json);
			}
		});

		// на время сохранения создаем дополнительное состояние
		newStateName = that.saveState();
		states.push(newStateName);

		if (!jsonObjects.length) {
			deferredSave = lang.resolved();
		} else {
			saveOptions = lang.append(options.interop || {}, {
				caller: that,
				policy: options.policy,
				hints: options.hints,
				suppressEventOnError: !!options.onError || options.suppressEventOnError,
				suppressEventOnSuccess: options.suppressEventOnSuccess,
				suppressProcessEvent: options.suppressProcessEvent
			});
			if (lang.isFunction(options.onPreprocess)) {
				options.onPreprocess(jsonObjects);
			}
			deferredSave = that._dataFacade.save(jsonObjects, saveOptions);
		}

		let deferredOut: lang.Deferred<SaveResult> = lang.Deferred(),
			resolve = function (jsonObjects: SavedObjectData[]): void {
				let result = that._onSaved(objects, created, deleted, states, jsonObjects);
				deferredOut.resolve(result);
			},
			reject = function (error): void {
				that._onSaveFailed(objects, error, states);
				deferredOut.reject(error);
			},
			onSaveDone = function (jsonObjects: SavedObjectData[]): void {
				if (options.onSuccess) {
					options.onSuccess({
						options: saveOptions,
						objects: jsonObjects,
						states: states,
						deferred: deferredOut,
						complete: resolve.bind(that, jsonObjects),
						resolve: resolve,
						reject: reject
					});
				} else {
					resolve(jsonObjects);
				}
			},
			onSaveFail = function (error) {
				if (options.onError) {
					options.onError({
						error: error,
						options: saveOptions,
						objects: jsonObjects,
						states: states,
						deferred: deferredOut,
						complete: reject.bind(that, error),
						resolve: resolve,
						reject: reject
					});
				} else {
					reject(error);
				}
			};
		deferredSave.then(onSaveDone, onSaveFail);

		return deferredOut.promise();
	}

	protected _onSaving(objects: DomainObject[]): boolean {
		let args: { objects: DomainObject[]; cancel?: boolean } = {
			objects: objects
		};
		this.onSaving(args);
		return args.cancel;
	}

	protected onSaving(args: { objects: DomainObject[]; cancel?: boolean }): void {
		this.trigger("saving", this, args);
	}

	protected _updateObjectWithNewValues(obj: DomainObject, json: SavedObjectData) {
		if (json.__newValues) {
			if (json.__newValues["__incrementTs"]) {
				obj.ts = obj.ts + 1;
			}
			lang.forEach(json.__newValues, function (v, name) {
				if (name === "id") {
					obj.setId(v);
				} else if (name === "__aux") {
					lang.extend(obj.aux, v);
				} else if (name !== "__incrementTs") {
					// update local object with values from server
					obj.set(name, v, { norollback: true });
				}
			});
		}
	}

	/**
	 * Handler on saving of own objects successfully completed.
	 * NOTE: its behavior deffers from `_onDataUpdate` handler which is called on saving other UoW's objects completed,
	 * In current case all objects are already updated, but they can be additionally changed on the server,
	 * So here we only copy data from __newValues.
	 * @param {Array<DomainObject>} objects Own objects which have been saved
	 * @param {Array<DomainObject>} created
	 * @param {Array<DomainObject>} deleted
	 * @param states
	 * @param {Array<SavedObjectData>} jsonObjects Json objects data returned from DataFacade (with newvalues)
	 * @returns {UnitOfWork.SaveResult}
	 * @private
	 */
	protected _onSaved(
		objects: DomainObject[], created: DomainObject[], deleted: DomainObject[],
		states: string[], jsonObjects: SavedObjectData[]): SaveResult
	{
		let that = this,
			result: SaveResult;

		if (jsonObjects && jsonObjects.length) {
			let processedObjects: lang.Map<boolean> = {};
			objects.forEach(function (obj) {
				for (let i: number = 0; i < jsonObjects.length; i++) {
					let json = jsonObjects[i];
					if (json.id === obj.id && json.__metadata.type === obj.meta.name) {
						obj.ts = json.__metadata.ts;
						// object can be changed on save
						if (json.__newValues) {
							that._updateObjectWithNewValues(obj, json);
						}
						// memorize the fact that we've processed the object
						processedObjects[i] = true;
						break;
					}
				}
			});

			// now process objects in 'jsonObjects' which were not sent from the client (absent in 'objects')
			// BUT they should be updated as well
			lang.forEach(jsonObjects, function (json, index) {
				if (processedObjects[index]) { return; }
				let type: string = json.__metadata && json.__metadata.type;
				let obj = that.find(type, json.id, { removed: true });
				if (obj) {
					that._updateObjectWithNewValues(obj, json);
				}
			});
		}

		// Accept all states except the latest one (which was created for saving)
		states.forEach(function (state, i) {
			if (i < states.length - 1) {
				that.acceptState(state);
			}
		});

		deleted.forEach(function (obj: DomainObject) {
			support.setLocalState(obj, obj.localStates.invalid, { norollback: true });
			that.detach(obj);
		});

		result = {
			objects: objects,
			created: created,
			deleted: deleted,
			stateName: lang.last(states)
		};
		if (objects.length) {
			that.onSaved(result);
		}
		return result;
	}

	protected onSaved(result: SaveResult): void {
		this.trigger("saved", this, result);
	}

	protected _onSaveFailed(objects: DomainObject[], error: Error, states: string[]): void {
		let that = this;

		// Смержим изменения до сохранения и изменения, сделанные во время сохранения.
		// Для этого нужно просто проаксептить состояние, сделанное на время сохранения
		// (это последнее из переданных состояний).
		that.acceptState(lang.last(states));

		// invalidate obsolete-deleted objects
		if (error) {
			if (eth.isOptimisticConcurrency(error)) {
				let deletedObjects = error.deletedObjects;
				if (deletedObjects && deletedObjects.length) {
					// NOTE: we're NOT detaching/removing obsolete objects here (comparing to onDataUpdate)
					that._onObsoleteDeleted(deletedObjects, false);
				}
			}
		}

		that.onSaveFailed({
			objects: objects,
			error: error
		});
	}

	protected onSaveFailed(args: { objects: DomainObject[]; error: Error }): void {
		this.trigger("saveError", this, args);
	}

	protected _changesToJsonOptions: ToJsonOptions;

	/**
	 * Returns id to json map of changed objects.
	 * @param {Object} [options] Options for `DomainObject.toJson` method. By default static object UnitOfWork._changesToJsonOptions is used.
	 * @param {boolean} [options.onlyChanged]
	 * @param {boolean} [options.onlyChangedOrInitial]
	 * @param {boolean} [options.onlyPersistent]
	 * @param {boolean} [options.nullIfEmpty]
	 * @param {boolean} [options.originalArrays]
	 * @param {boolean} [options.nometa]
	 * @returns {Object}
	 */
	getChanges(options?: ToJsonOptions): DomainObjectData[] {
		let changes: DomainObjectData[] = [];
		options = options ? lang.extend({}, this._changesToJsonOptions, options): this._changesToJsonOptions;
		this.forEach((obj: DomainObjectInternal) => {
			let json;
			if (obj._localState) {
				json = obj.toJson(options);
				// с опцией nullIfEmpty метода toJson вместо объектов без свойств вернуться null
				if (json) {
					changes.push(json);
				}
			}
		});
		return changes;
	}

	/**
	 * Return a map with all objects from current UnitOfWork.
	 * Each objects serialized with help of `toJson` with supplied options.
	 * @param {Object} options Serialization objects
	 * @param {boolean} [options.onlyChanged]
	 * @param {boolean} [options.onlyChangedOrInitial]
	 * @param {boolean} [options.onlyPersistent]
	 * @param {boolean} [options.nullIfEmpty]
	 * @param {boolean} [options.originalArrays]
	 * @param {boolean} [options.nometa]
	 * @returns {lang.Map<DomainObjectData>}
	 */
	toJson(options?: ToJsonOptions): lang.Map<DomainObjectData> {
		let that = this,
			result: lang.Map<DomainObjectData> = {};
		that.forEach(function (obj: DomainObjectInternal) {
			if (obj._localState) {
				let json = obj.toJson(options);
				// с опцией nullIfEmpty метода toJson вместо объектов без свойств вернуться null
				if (json) {
					result[obj.id] = json;
				}
			}
		});
		return result;
	}

	/**
	 * Return all changed object in JSON form and make rollback.
	 * NOTE: Before 1.34 the method was returning lang.Map<DomainObjectData>.
	 * @return {DomainObjectData[]}
	 */
	detachChanges(): DomainObjectData[] {
		let changes = this.getChanges();
		this._objects.rollbackAll();
		return changes;
	}

	/**
	 * Attach JSON objects as dirty into the current UnitOfWork.
	 * NOTE: Before 1.34 the method was accepting lang.Map<DomainObjectData>.
	 * @param {DomainObject[]} changes
	 */
	attachChanges(changes: lang.Map<DomainObjectData>| DomainObjectData[]): void {
		if (lang.isArray(changes)) {
			changes.forEach(json => {
				this.fromJson(json, { dirty: true });
			});
		} else {
			// before 1.34, deprecated
			console.warn("DEPRECATED: UnitOfWork.attachChanges(Map<DomainObjectData>) is deprecated, use attachChanges(DomainObjectData[])");
			Object.keys(changes).forEach((id) => {
				let json = changes[id];
				this.fromJson(json, { dirty: true });
			});
		}
	}

	saveState(stateName?: string): string {
		return this._objects.saveState(stateName);
	}
	acceptState(stateName?: string): void {
		this._objects.acceptState(stateName);
		this._calculateHasChanged();
	}
	rollbackState(stateName?: string): void {
		this._objects.rollbackState(stateName);
		this._calculateHasChanged();
	}
	hasState(stateName: string): boolean {
		return this._objects.hasState(stateName);
	}

	clear(): void {
		this._objects.all().forEach((obj) => {
			this.detach(obj);
		});
	}

	/**
	 * Replaces id of the object
	 * @param obj
	 * @param newId
	 */
	replaceId(obj: IDomainObject, newId: string): void {
		this._objects.replaceId(obj, newId);
	}

	findRefsTo(obj: IDomainObject): ReferenceToObject[] {
		return this._objects.objectRefsTo(obj);
	}

	protected _onDataUpdate(sender, args: DataUpdateEventArgs): void {
		let that = this,
			options = { partial: !args || args.reason !== "load" };
		// args.caller - это объект, инициировавший обращение к dataFacade. Если это текущая UoW, то никакой
		// дополнительной обработки не нужно: все данные будут обработаны в месте вызова методов dataFacade.
		if (!args || args.caller === that || that.isolated) { return; }

		if (args.objects && args.objects.length) {
			args.objects.forEach((json: SavedObjectData) => {
				let type: string = json.__metadata && json.__metadata.type,
					local: DomainObject = type && json.id && that.find(type, json.id, { removed: true }),
					newId: string;
				if (local) {
					local.fromJson(json, options);

					newId = json.__newValues && json.__newValues.id;
					if (newId) {
						local.setId(newId, { allowForSaved: true });
						// NOTE: other properties from __newValues should be already moved to json itself
					}
					if (json.__newValues && json.__newValues["__incrementTs"]) {
						local.ts = local.ts + 1;
					}
				}
			});
		}

		let deletedObjects = args.deletedObjects;
		if (deletedObjects && deletedObjects.length) {
			that._onObsoleteDeleted(deletedObjects, true);
		}
	}

	protected _onObsoleteDeleted(identities: ObjectIdentity[], remove: boolean): void {
		if (!identities || !identities.length) { return; }
		let that = this;
		for (let id of identities) {
			let local: DomainObject = id.type && id.id && this.find(id.type, id.id, { removed: false });
			if (local) {
				// found a non-deleted local object, which known as being deleted on the server
				support.setLocalState(local, local.localStates.invalid);
				if (remove) {
					that.remove(local);
					//that.detach(local);
				}
			}
		}
	}

	/**
	 * Remove objects with specified identities from UoW permanently with clearing all references. Objects become invalid.
	 * @param {Array} objectIdentities
	 * @returns {Promise}
	 */
	purgeWithCascade(objectIdentities: ObjectIdentity[]): lang.Promise<void> {
		let that = this;
		let tasks = [];
		let deletedObjects = [];
		objectIdentities.forEach((obsoleteId) => {
			let obsolete = that.find(obsoleteId.type, obsoleteId.id);
			if (obsolete) {
				deletedObjects.push(obsolete);
				let objectRefs = that.findRefsTo(obsolete);
				if (objectRefs.length) {
					objectRefs.forEach((obj) => {
						let dependant = obj.object;
						tasks.push(
							that.reload(dependant.meta.name, dependant.id, {interop: {suppressEventOnError: true}})
								.then(null, (err) => {
									// NOTE: важно не использовать fail, т.к. его результат игнорируется.
									if (eth.isObjectNotFound(err)) {
										// мы перегружали владельца ссылки на устаревший-удаленный (obsolete),
										// а он тоже удален
										// TODO: надо рекурсивно повторить: удалить dependant и все ссылки на него
										deletedObjects.push(dependant);
									}
									return lang.resolved();
								})
						);
					});
				}
			}
		});
		// we have an array of task of reload objects with references to deleted objects, wait for all to complete
		if (tasks.length) {
			return lang.whenAll(tasks)
				.done(() => {
					// all dependant objects were reloaded,
					// now really delete deleted object (with clearing refs and detach)
					deletedObjects.forEach((obj) => {
						support.setLocalState(obj, obj.localStates.invalid);
						that.remove(obj);
					});
				});
		}
		deletedObjects.forEach((obj) => {
			support.setLocalState(obj, obj.localStates.invalid);
			that.remove(obj);
		});
		return lang.resolved();
	}
}

UnitOfWork.mixin({
	hasChanges: lang.Observable.getter("hasChanges"),

	_setHasChanges: lang.Observable.setter("hasChanges"),

	_saveToJsonOptions: {
		onlyChangedOrInitial: true,
		onlyPersistent: true,
		nullIfEmpty: true,
		originalArrays: true
	},

	_changesToJsonOptions: {
		onlyChanged: true,
		onlyPersistent: true,
		nullIfEmpty: true
	},
});

namespace UnitOfWork {
	export interface Options {
		/**
		 * Subscribe on DataFacade's 'update' event
		 */
		connected?: boolean;
	}

	export interface SaveSuccessArgs {
		options: interop.SaveOptions;
		objects: SavedObjectData[];
		states: string[];
		deferred: lang.Deferred<SaveResult>;
		complete: () => void;
		resolve: (objects: SavedObjectData[]) => void;
		reject: (error?: Error) => void;
	}

	export interface SaveErrorArgs {
		error: Error;
		options: interop.SaveOptions;
		objects: DomainObjectData[];
		states: string[];
		deferred: lang.Deferred<SaveResult>;
		complete: () => void;
		resolve: (objects: SavedObjectData[]) => void;
		reject: (error?: Error) => void;
	}

	export interface SaveOptions {
		/**
		 * Custom callback for handling save success
		 */
		onSuccess?: (args: SaveSuccessArgs) => void;
		/**
		 * Custom callback for handling save error
		 */
		onError?: (args: SaveErrorArgs) => void;
		/**
		 * A callback to call with json objects before calling DataFacade.save
		 */
		onPreprocess?: (objects: DomainObjectData[]) => void;
		/**
		 * Advanced options for DataFacade.save
		 */
		interop?: interop.SaveOptions;

		/**
		 * @deprecated Use interop.suppressEventOnError
		 */
		suppressEventOnError?: boolean;
		/**
		 * @deprecated Use interop.suppressEventOnSuccess
		 */
		suppressEventOnSuccess?: boolean;
		/**
		 * @deprecated Use interop.suppressProcessEvent
		 */
		suppressProcessEvent?: boolean;
		/**
		 * @deprecated Use interop.hints
		 */
		hints?: string[]|string;
		/**
		 * @deprecated Use interop.policy
		 */
		policy?: any;
	}

	export interface SaveResult {
		objects: DomainObject[];
		created: DomainObject[];
		deleted: DomainObject[];
		stateName: string;
	}
}

export = UnitOfWork;
