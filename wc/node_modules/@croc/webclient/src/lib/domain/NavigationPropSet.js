define(["require", "exports", "underscore", "lib/core.lang", "./support", "./NavigationPropBase"], function (require, exports, _, lang, support, NavigationPropBase) {
    "use strict";
    var NavigationPropSet = (function (_super) {
        __extends(NavigationPropSet, _super);
        /**
         * Descriptor of a loaded collection navigation property of DomainObject.
         *
         * Множество доменных объектов, являющееся значением загруженного массивного навигируемого свойства
         * @constructs NavigationPropSet
         * @extends NavigationPropBase
         * @param {DomainObject} parent
         * @param propMeta
         */
        function NavigationPropSet(parent, propMeta) {
            var _this = _super.call(this, parent, propMeta) || this;
            var that = _this;
            that.all().forEach(function (obj) {
                that._initObj(obj);
            });
            that._parent.bind("change:" + that._propMeta.name, that._onPropChange, that);
            that._updateIsLoaded();
            return _this;
        }
        NavigationPropSet.prototype.dispose = function () {
            var that = this;
            that.all().forEach(function (obj) {
                that._cleanupObj(obj);
            });
            that._parent.unbind("change:" + that._propMeta.name, null, that);
            _super.prototype.dispose.call(this);
        };
        /**
         * @param {Object} [options]
         * @param {Boolean} [options.idsOnly] do not load all value objects (by default they are loaded)
         * @param {Boolean} [options.reload] force loading even if all data is already loaded
         * @param {String} [options.preloads] Preloads (will be passed to server controller)
         * @param {Object} [options.params] Params (will be passed to server controller)
         * @param {Object} [options.interop] Advanced options for DataFacade.load
         * @returns {Promise} NavigationPropSet
         */
        NavigationPropSet.prototype.load = function (options) {
            var that = this, deferred = that._deferredLoad;
            // NOTE: Previous loading is already in progress - we can return it if no options are specified.
            // But if there are some options, we should load again with these options.
            if (deferred && lang.isEmpty(options)) {
                return deferred;
            }
            support.throwIfDetached(that._parent);
            // NOTE: wait until the previous loading is completed,
            // maybe after it we will not have to call DataFacade at all.
            return lang.async.then(deferred, function () { return that._doLoad(options); });
        };
        NavigationPropSet.prototype._doLoad = function (options) {
            if (options === void 0) { options = {}; }
            var that = this, deferred;
            if (options.reload) {
                deferred = that._reload(options);
            }
            else if (options.idsOnly) {
                deferred = lang.resolved();
            }
            else {
                deferred = that._load(options);
            }
            return that._deferredLoad = deferred
                .then(function () { return that; })
                .always(function () { that._deferredLoad = undefined; });
        };
        NavigationPropSet.prototype._load = function (options) {
            var that = this, notLoadedItems = that.all().filter(function (obj) { return !obj.isLoaded; });
            if (!notLoadedItems.length) {
                // all items are already loaded - nothing to do
                // TODO: в options могут быть заданы прелоады, которые мы игнорируем!
                if (options.preloads) { }
                return lang.resolved(that);
            }
            if (that._parent.isNew()) {
                return that._loadMultiple(notLoadedItems, options);
            }
            if (notLoadedItems.length > 1) {
                // two or more items aren't loaded - load the whole property
                return that._loadProp(options);
            }
            // only one item isn't loaded - load it (we can reduce a traffic so)
            return notLoadedItems[0].load(options)
                .then(null, function () {
                // fallback: load the whole property
                return that._loadProp(options);
            });
        };
        NavigationPropSet.prototype._reload = function (options) {
            var that = this;
            return that._parent.isNew() ?
                that._loadMultiple(that.all(), options) :
                that._loadProp(options);
        };
        NavigationPropSet.prototype._loadMultiple = function (items, options) {
            var that = this, dataFacade = that._parent.uow._dataFacade;
            try {
                // NOTE: load several times in a batch
                dataFacade.beginBatch();
                var itemsDeferred = items.map(function (obj) {
                    return obj.load(options);
                });
                return lang.when.apply(null, itemsDeferred);
            }
            finally {
                dataFacade.completeBatch();
            }
        };
        NavigationPropSet.prototype._loadProp = function (options) {
            var that = this;
            return that._parent.uow.ensurePropLoaded(that._parent, that._propMeta.name, options);
        };
        /**
         * @deprecated Use `load` method instead
         */
        NavigationPropSet.prototype.loadItems = function (options) {
            return this.load(options);
        };
        NavigationPropSet.prototype.ids = function () {
            var ret = this._getIds();
            this._triggerGet({ prop: "ids", value: ret });
            return ret;
        };
        NavigationPropSet.prototype.count = function () {
            var ret = this._getIds().length;
            this._triggerGet({ prop: "count", value: ret });
            return ret;
        };
        NavigationPropSet.prototype.all = function () {
            var that = this, ret = that._getIds().map(that._getValueObject, that);
            ret.forEach(function (obj, i) {
                that._triggerGet({ prop: i.toString(), value: obj });
            });
            that._triggerGet({ prop: "all", value: ret });
            return ret;
        };
        NavigationPropSet.prototype.get = function (index) {
            var that = this, id = that._getIds()[index], ret = id ? that._getValueObject(id) : undefined;
            that._triggerGet({ prop: index.toString(), value: ret });
            return ret;
        };
        /**
        *
        * @param {String|Object} [type] наименование типа, если задан второй параметр - идентификатор, либо идентификатор объекта (тогда в качесте типа используется тип свойства)
        * @param {string} [type.type] наименование типа
        * @param {string} [type.id] идентификатор объекта
        * @param {string} [id] идентификатор объекта, если первый параметр типа string (имя типа)
        */
        NavigationPropSet.prototype.first = function (type, id) {
            var that = this, identity, ids, ret;
            if (arguments.length > 0) {
                if (arguments.length === 2) {
                    identity = { type: type, id: id };
                }
                else if (arguments.length === 1) {
                    identity = (typeof type === "string") ?
                        { type: that._propMeta.ref, id: type } :
                        type; // single non-string parameter - identity json, TODO: check fields
                }
                else {
                    throw new Error("first: Unexpected parameter count - " + arguments.length);
                }
                ret = that._parent.uow.get(identity.type, identity.id);
            }
            else {
                ids = that._getIds();
                ret = ids.length ? that._getValueObject(ids[0]) : null;
            }
            that._triggerGet({ prop: "first", value: ret });
            return ret;
        };
        NavigationPropSet.prototype.indexOf = function (obj) {
            var id = support.objectIdOf(obj);
            return this._getIds().indexOf(id);
        };
        NavigationPropSet.prototype.contains = function (obj) {
            return this.indexOf(obj) >= 0;
        };
        NavigationPropSet.prototype.add = function (item) {
            var _this = this;
            this._iterate(item, function (id) { return support.addToNavProp(_this._parent, _this._propMeta, id); });
        };
        NavigationPropSet.prototype.remove = function (item) {
            var _this = this;
            this._iterate(item, function (id) { return support.removeFromNavProp(_this._parent, _this._propMeta, id); });
        };
        NavigationPropSet.prototype.reset = function (items) {
            this.clear();
            this.add(items);
        };
        NavigationPropSet.prototype.clear = function () {
            var ids = this._getIds().slice();
            this.remove(ids);
        };
        NavigationPropSet.prototype.move = function (indexFrom, indexTo) {
            var that = this, ids = that._getIds().slice(), movedId = ids[indexFrom];
            ids.splice(indexFrom, 1);
            ids.splice(indexTo, 0, movedId);
            support.setPropRaw(that._parent, that._propMeta, ids);
        };
        /**
         * Iterating through all objects in the property.
         * Please note, that despite of signature of iterator it WON'T get `array` argument (array of objects).
         * @param iterator
         * @param [context]
         */
        NavigationPropSet.prototype.forEach = function (iterator, context) {
            var that = this, ids = that._getIds();
            ids.forEach(function (id, index) {
                var obj = that._getValueObject(id);
                iterator.call(context, obj, index);
            });
        };
        NavigationPropSet.prototype.find = function (predicate, context) {
            var that = this, ids = that._getIds();
            for (var i = 0, l = ids.length; i < l; i++) {
                var id = ids[i], obj = that._getValueObject(id);
                if (predicate.call(context, obj, i)) {
                    return obj;
                }
            }
            return undefined;
        };
        NavigationPropSet.prototype.toString = function () {
            return this.all()
                .map(function (obj) { return obj.toString(); })
                .join("; ");
        };
        NavigationPropSet.prototype._onPropChange = function (sender, value, oldValue) {
            var that = this, args = {};
            if (arguments.length >= 3) {
                args.added = _.difference(value || [], oldValue || []).map(that._getValueObject, that);
                args.removed = _.difference(oldValue || [], value || []).map(that._getValueObject, that);
                //args.changed = [];
            }
            that._triggerChange(args);
        };
        NavigationPropSet.prototype._onObjChange = function (sender, args) {
            var that = this;
            // TODO: обработка незагруженных объектов
            if (!args || !args.prop || !that._propMeta.opposite || that._propMeta.opposite.name !== args.prop) {
                if (that.isLoaded != sender.isLoaded) {
                    that._updateIsLoaded();
                }
                that.trigger("itemChange", that, { changed: [sender] });
            }
        };
        NavigationPropSet.prototype._onObjLoad = function (sender, args) {
            var that = this;
            if (!args || !args.loaded) {
                that._triggerChange({});
            }
            else if (args.loaded !== sender) {
                that._triggerChange({ added: [args.loaded], removed: [sender] });
            }
        };
        NavigationPropSet.prototype._iterate = function (items, iterator, context) {
            return lang.isArray(items) ? items.forEach(iterator, context) : iterator.call(context, items);
        };
        NavigationPropSet.prototype._getValueObject = function (id) {
            support.throwIfDetached(this._parent);
            return this._parent.uow.get(this._propMeta.ref, id);
        };
        NavigationPropSet.prototype._getIds = function () {
            return support.getPropRaw(this._parent, this._propMeta) || [];
        };
        NavigationPropSet.prototype._updateIsLoaded = function () {
            var that = this, items = that._getIds().map(that._getValueObject, that);
            that.isLoaded = items.every(function (obj) {
                return obj.isLoaded;
            });
        };
        NavigationPropSet.prototype._initObj = function (obj) {
            var that = this;
            obj.bind("change", that._onObjChange, that);
            if (obj.isGhost && !obj.isLoaded) {
                obj.bind("load", that._onObjLoad, that);
            }
        };
        NavigationPropSet.prototype._cleanupObj = function (obj) {
            var that = this;
            obj.unbind("change", null, that);
            obj.unbind("load", null, that);
        };
        NavigationPropSet.prototype._triggerGet = function (args) {
            this.trigger("get", this, args);
        };
        NavigationPropSet.prototype._triggerChange = function (args) {
            var that = this;
            if (args.added && args.added.length) {
                args.added.forEach(that._initObj, that);
            }
            if (args.removed && args.removed.length) {
                args.removed.forEach(that._cleanupObj, that);
            }
            that._updateIsLoaded();
            that.trigger("change", that, args);
        };
        __decorate([
            lang.decorators.constant(false)
        ], NavigationPropSet.prototype, "isGhost");
        return NavigationPropSet;
    }(NavigationPropBase));
    return NavigationPropSet;
});
//# sourceMappingURL=NavigationPropSet.js.map