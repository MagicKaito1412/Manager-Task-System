import lang = require("lib/core.lang");
import utils = require("lib/utils");
import support = require("./support");
import DomainObjectMap = require("./DomainObjectMap");

import domain = require(".domain");
import internals = require(".internals");
import IDomainObject = domain.IDomainObject;
import IDomainModel = domain.IDomainModel;
import DomainObject = domain.DomainObject;
import DomainObjectInternal = internals.DomainObjectInternal;
import DomainObjectUndoState = domain.DomainObject.UndoState;
import UnitOfWork = domain.UnitOfWork;
import PropertyMeta = domain.metadata.PropertyMeta;
import EntityNameTerm = domain.EntityNameTerm;
import ReferenceToObject = domain.ReferenceToObject;
import ChangeOptions = domain.ChangeOptions;
import SetPropOptions = domain.SetPropOptions;

import UndoState = DomainObjectRegistry.UndoState;
import PendingAction = DomainObjectRegistry.PendingAction;
import PendingVerb = DomainObjectRegistry.PendingVerb;

/**
 * DomainObjectRegistry - множество доменных объектов с поиском по типу и id.
 * Может содержать как сами доменные объекты, так и незагруженные ghost-объекты.
 * Используется в UnitOfWork.
 */
class DomainObjectRegistry {
	private _model: IDomainModel;
	private _uow: UnitOfWork;
	private _objects: DomainObjectMap<IDomainObject>;
	private _undostack: UndoState[];

	/**
	 * Конструктор
	 * @param model Доменная модель
	 * @param uow Родительская UnitOfWork
	 */
	constructor(model: IDomainModel, uow: UnitOfWork) {
		var that = this;
		that._model = model;
		that._uow = uow;
		that._objects = new DomainObjectMap<IDomainObject>(model);
		that._undostack = [ that.createState("") ];
	}

	add(obj: IDomainObject, options: ChangeOptions, noSyncState?: boolean): void;
	/**
	 * Добавляет объект ко множеству
	 */
	add(obj: DomainObjectInternal, options: ChangeOptions, noSyncState?: boolean): void {
		let that = this,
			state: UndoState;

		if (!obj.isGhost && obj.uow && obj.uow !== that._uow) {
			obj.purge();
		}
		obj.uow = that._uow;
		that._objects.add(obj, obj);

		if (obj.isGhost) { return; }

		// Синхронизируем текущие состояний объекта и UnitOfWork.
		if (!noSyncState) {
			// Accept-им все состояния, кроме первого.
			// После этого все оригинальные значения должны оказаться в первом (и единственном) состоянии
			while (obj._undostack.length > 1) {
				obj.acceptState();
			}

			// Количество и наименования состояний объекта должны соответствовать всему множеству:
			// добавляем недостающие состояния в _начало_ стека
			that._undostack.forEach((state, i) => {
				if (i === that._undostack.length - 1) {
					// последнее состояние просто переименовываем
					support.states.topUndoState<DomainObjectUndoState>(obj).name = state.name;
				} else {
					// остальные состояния добавляем перед последним
					obj._undostack.splice(i, 0, obj.createState(state.name));
				}
			});
		}

		// применяем отложенные действия
		that.applyPending(obj, options);

		if (!options || !options.norollback) {
			// фиксируем изменение в составе объектов
			state = support.states.topUndoState<UndoState>(that);
			if (!state.removed.remove(obj)) {
				state.added.add(obj, obj);
			}
		}

		that._uow.trigger("attach", that._uow, obj);
	}

	remove(obj: IDomainObject, options?: ChangeOptions): void;
	/**
	 * Удаляет объект из множества
	 */
	remove(obj: DomainObjectInternal, options?: ChangeOptions): void {
		var state;

		if (!obj.isGhost) {
			obj.purge();
		}
		if (obj.uow) {
			obj.uow = null;
		}
		if (!this._objects.remove(obj)) { return; }
		obj.trigger("detach");

		if (obj.isGhost) { return; }

		if (!options || !options.norollback) {
			// фиксируем изменение в составе объектов
			state = support.states.topUndoState(this);
			if (!state.added.remove(obj)) {
				state.removed.add(obj, obj);
			}
		}

		// TODO: удалять отложенные действия для объекта и ссылок на него

		this._uow.trigger("detach", this._uow, obj);
	}

	find(type: EntityNameTerm, id: string): IDomainObject {
		return this._objects.find(type, id);
	}
	all(): IDomainObject[] {
		return this._objects.all();
	}
	forEach(callback: (obj: IDomainObject) => void, context?): void {
		return this._objects.forEach(callback, context);
	}
	some(callback: (obj: IDomainObject) => boolean, context?): boolean {
		return this._objects.some(callback, context);
	}

	/**
	Получает объекты, ссылающиеся на другой объект.
	@returns Массив plain-объектов со свойствами:
	object - объект, ссылающийся на переданный объект
	prop - свойство, ссылающееся на переданный объект
	*/
	objectRefsTo(obj: IDomainObject, refProps?: PropertyMeta[]): ReferenceToObject[] {
		var that = this,
			refs: ReferenceToObject[] = [];
		refProps = refProps || support.propRefsTo(obj.meta);
		for (let propInfo of refProps) {
			let objects = that._objects.select(propInfo.entity.name);
			if (objects) {
				for (let refObj of objects) {
					if (!refObj.isGhost) {
						let value = support.getPropRaw(<DomainObjectInternal>refObj, propInfo),
							hasId = Array.isArray(value) ? value.indexOf(obj.id) >= 0 : value === obj.id;
						if (hasId) {
							refs.push({
								object: <DomainObjectInternal>refObj,
								prop: propInfo
							});
						}
					}
				}
			}
		}
		return refs;
	}

	pendingAdd(propMeta: PropertyMeta, id: string, valueId: string, options: SetPropOptions): void {
		this._pendingVerb("add", propMeta, id, valueId, options);
	}

	pendingRemove(propMeta: PropertyMeta, id: string, valueId: string, options: SetPropOptions): void {
		this._pendingVerb("remove", propMeta, id, valueId, options);
	}

	private _pendingVerb(verb: PendingVerb, propMeta: PropertyMeta, id: string, valueId: string, options: SetPropOptions): void {
		var state: UndoState = support.states.topUndoState<UndoState>(this),
			actions: PendingAction[] = state.pending.get(propMeta.entity.name, id, []);
		actions.push({
			verb: verb,
			prop: propMeta,
			id: valueId,
			original: options && options.original,
			norollback: options && options.norollback
		});
	}

	/**
	 * Применяет отложенные действия к объекту
	 * @param {DomainObject} obj Объект, к которому применяются действия
	 * @param {Object} [options]
	 */
	applyPending(obj: DomainObject, options: SetPropOptions) {
		if (!obj || obj.isGhost) {
			return;
		}

		let that = this;
		that._undostack.forEach(function (state: UndoState, index) {
			// применяем действия, заданные для конкретного объекта
			let actions: PendingAction[] = state.pending.findObj(obj);
			if (that._applyPending(obj, actions, index, options, /*deleteApplied*/ true)) {
				// если хоть одно действие было примено, то нужно удалить их
				// NOTE: вместо примененных действий в массиве будут undefined, т.к. мы указали параметр deleteApplied
				let pending = actions.filter(action => !!action);
				if (pending.length) {
					state.pending.add(obj, pending);
				} else {
					state.pending.remove(obj);
				}
			}


			// применяем действия, заданные для всех объектов
			actions = state.pending.find(obj.meta.name, "*");
			that._applyPending(obj, actions, index, options, /*deleteApplied*/ false);
			// NOTE: для * не нужно удалять примененные действия, так они могут потребоваться для других объектов
		});
	}

	/**
	 * Применяет отложенные действия к объекту
	 * @param {DomainObject} obj Объект, к которому применяются действия
	 * @param {Array} actions Массив отложенных действий, которые нужно применить
	 * @param {Number} undoIndex Индекс состояния в стеке отката, куда нужно скопировать исходное значение свойства
	 * @param {Object} options
	 * @param {boolean} deleteApplied
	 * @returns {boolean} true, если хотя бы одно действие было применено
	 */
	private _applyPending(
		obj: DomainObject, actions: PendingAction[], undoIndex: number,
		options: SetPropOptions, deleteApplied: boolean): boolean
	{
		if (!actions) { return; }

		let applied = false;
		actions.forEach((action: PendingAction, i) => {
			let propMeta = action.prop,
				actionOptions: support.SetPropRawOptions;
			// There is no sense to apply pending actions to the unloaded navigation set.
			// Indeed it will add the same pending action one more.
			if (propMeta.many && support.getPropRaw(obj, propMeta) === undefined) { return; }

			// Merge pending and runtime options
			actionOptions = options ? lang.clone(options) : {};
			actionOptions.original = action.original;
			actionOptions.norollback = action.norollback || action.original;
			actionOptions.undoIndex = undoIndex;

			if (action.verb === "add") {
				support.addToNavProp(obj, propMeta, action.id, actionOptions, /*noSync*/true);
			} else if (action.verb === "remove") {
				support.removeFromNavProp(obj, propMeta, action.id, actionOptions, /*noSync*/true);
			}

			applied = true;
			// delete applied actions (if not '*' only)
			if (deleteApplied) {
				actions[i] = undefined;
			}
		});
		return applied;
	}

	/**
	 * Сохраняет текущее состояние
	*/
	saveState(stateName?: string): string {
		var that = this,
			state = that.createState(stateName);
		// сохраняем состояния всех объектов
		that._objects.forEach(function (obj) {
			if (!obj.isGhost) {
				(<DomainObject>obj).saveState(state.name);
			}
		});
		that._undostack.push(state);
		return state.name;
	}

	/**
	 * Откатывает изменения, сделанные после вызова метода saveState с таким же наименованием состояния
	*/
	rollbackState(stateName?: string): void {
		var that = this,
			stateIndex: number,
			state: UndoState,
			nextState: UndoState;

		stateIndex = support.states.getUndoStateIndex(that, stateName);
		if (stateIndex === undefined) { return; }

		state = that._undostack[stateIndex];
		nextState = that._undostack[stateIndex + 1];

		// откатываем добавление объектов
		state.added.forEach(function (obj) {
			obj.rollbackState(state.name);
			if (nextState) {
				if (!nextState.removed.remove(obj)) {
					nextState.added.add(obj, obj);
				}
			} else {
				that.remove(obj, { norollback: true });
			}
		});
		// откатываем удаление объектов
		state.removed.forEach(function (obj) {
			obj.rollbackState(state.name);
			if (nextState) {
				if (!nextState.added.remove(obj)) {
					nextState.removed.add(obj, obj);
				}
			} else {
				that.add(obj, { norollback: true }, true);
			}
		});
		// NOTE: pending actions удалятся сами собой, так как они берутся в том числе из состояний в стеке

		// откатываем состояния всех объектов
		that._objects.forEach(function (obj) {
			if (!obj.isGhost) {
				(<DomainObject>obj).rollbackState(state.name);
			}
		});

		that.removeState(stateIndex);
	}

	rollbackAll(): void {
		var that = this,
			states = that._undostack.slice().reverse();
		states.forEach(function (state) {
			that.rollbackState(state.name);
		});
	}

	hasState(stateName: string): boolean {
		return support.states.getUndoStateIndex(this, stateName) >= 0;
	}

	/**
	 * Утверждает изменения, сделанные после вызова метода saveState с таким же наименованием состояния
	*/
	acceptState(stateName?: string): void {
		var that = this,
			stateIndex: number,
			state: UndoState,
			prevState: UndoState;

		stateIndex = support.states.getUndoStateIndex(that, stateName);
		if (stateIndex === undefined) { return; }

		state = that._undostack[stateIndex];
		prevState = that._undostack[stateIndex - 1];

		// перенесем pending actions
		if (prevState) {
			state.pending.forEach(function (stateActions, type, id) {
				var actions = prevState.pending.get(type, id, []);
				stateActions.forEach(function (action) {
					actions.push(action);
				});
			});
		}

		state.added.forEach(function (obj) {
			obj.acceptState(state.name);
			if (prevState && !prevState.removed.remove(obj)) {
				prevState.added.add(obj, obj);
			}
		});
		state.removed.forEach(function (obj) {
			obj.acceptState(state.name);
			if (prevState && !prevState.added.remove(obj)) {
				prevState.removed.add(obj, obj);
			}
		});

		// утверждаем состояния всех объектов
		that._objects.forEach(function (obj) {
			if (!obj.isGhost) {
				(<DomainObject>obj).acceptState(state.name);
			}
		});

		that.removeState(stateIndex);
	}
	/**
	 * Проверяет, есть ли сохраненные состояния (т.е. вызывался ли метод saveState без последующих
	 * вызовов acceptState или rollbackState).
	*/
	hasSavedStates(): boolean {
		// NOTE: первое состояние есть всегда, оно не считается сохраненным
		return this._undostack.length > 1;
	}

	/**
	 * Returns names of all states in the undo stack
	 * @returns {string[]}
	 */
	getStateNames(): string[] {
		return this._undostack.map(s => s.name);
	}

	/**
	 * Replaces id of the object
	 * @param obj
	 * @param newId
	 */
	replaceId(obj: IDomainObject, newId: string): void {
		var that = this,
			refProps: PropertyMeta[] = support.propRefsTo(obj.meta),
			found: boolean;

		refProps.forEach(function (propMeta: PropertyMeta) {
			that._replaceId(that._objects, propMeta, obj.id, newId);

			// also replace in undostack
			that._undostack.forEach(function (state: UndoState) {
				that._replaceId(state.removed, propMeta, obj.id, newId);
				that._replaceId(state.added, propMeta, obj.id, newId);

				// also replace in pending actions
				var entityActions: PendingAction[][] = state.pending.select(propMeta.entity.name);
				entityActions.forEach(function (actions: PendingAction[]) {
					actions.forEach(function (action: PendingAction) {
						if (action.prop === propMeta && action.id === obj.id) {
							action.id = newId;
						}
					})
				});
			});
		});

		found = that._objects.remove(obj);
		obj.id = newId;
		if (found) {
			that._objects.add(obj, obj);
		}
	}

	private _replaceId(objectMap: DomainObjectMap<IDomainObject>, propMeta: PropertyMeta, oldId: string, newId: string): void {
		var objects: IDomainObject[] = objectMap.select(propMeta.entity.name);
		if (objects) {
			objects.forEach(function (obj: DomainObjectInternal) {
				if (!obj.isGhost) {
					obj.replaceRefId(propMeta, oldId, newId);
				}
			});
		}
	}

	/**
	 * Создает "состояние" реестра, которое можно откатить или применить
	 * @param {String} stateName Наименование состояния (может быть не задано)
	 */
	private createState(stateName?: string): UndoState {
		var model: IDomainModel = this._model;
		return {
			name: stateName || stateName === "" ? stateName : "state_" + utils.generateGuid(),
			added: new DomainObjectMap<DomainObject>(model),
			removed: new DomainObjectMap<DomainObject>(model),
			pending: new DomainObjectMap<PendingAction[]>(model)
		};
	}

	/**
	 * Удаляет состояние из стека отката объекта
	 */
	private removeState(stateIndex: number) {
		var that = this;
		support.states.removeUndoState(that, stateIndex, function (stateName) {
			return that.createState(stateName);
		});
	}
}

namespace DomainObjectRegistry {
	export interface UndoState {
		name: string;
		added: DomainObjectMap<DomainObject>;
		removed: DomainObjectMap<DomainObject>;
		pending: DomainObjectMap<PendingAction[]>;
	}

	export type PendingVerb = "add" | "remove";

	export interface PendingAction {
		prop: PropertyMeta;
		id: string;
		verb: PendingVerb; // add|remove
		// subset of SetPropOptions:
		original: boolean;
		norollback: boolean;
	}
}

export = DomainObjectRegistry;
