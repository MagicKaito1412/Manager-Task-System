import _ = require("underscore");
import lang = require("lib/core.lang");
import support = require("./support");
import NavigationPropBase = require("./NavigationPropBase");

import domain = require(".domain");
import internals = require(".internals");
import DomainObject = domain.DomainObject;
import PropertyMeta = domain.metadata.PropertyMeta;
import LoadOptions = NavigationPropSet.LoadOptions;
import IDomainObject = domain.IDomainObject;
import INavigationPropSet = domain.INavigationPropSet;

class NavigationPropSet extends NavigationPropBase implements INavigationPropSet {
	isLoaded: boolean;

	@lang.decorators.constant(false)
	isGhost: boolean;

	private _deferredLoad: lang.Promise<this>;
	/**
	 * Descriptor of a loaded collection navigation property of DomainObject.
	 *
	 * Множество доменных объектов, являющееся значением загруженного массивного навигируемого свойства
	 * @constructs NavigationPropSet
	 * @extends NavigationPropBase
	 * @param {DomainObject} parent
	 * @param propMeta
	 */
	constructor(parent: DomainObject, propMeta: PropertyMeta) {
		super(parent, propMeta);

		let that = this;
		that.all().forEach(obj => {
			that._initObj(obj);
		});
		that._parent.bind("change:" + that._propMeta.name, that._onPropChange, that);

		that._updateIsLoaded();
	}
	dispose(): void {
		let that = this;
		that.all().forEach(obj => {
			that._cleanupObj(obj);
		});
		that._parent.unbind("change:" + that._propMeta.name, null, that);

		super.dispose();
	}

	/**
	 * @param {Object} [options]
	 * @param {Boolean} [options.idsOnly] do not load all value objects (by default they are loaded)
	 * @param {Boolean} [options.reload] force loading even if all data is already loaded
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise} NavigationPropSet
	 */
	load(options?: LoadOptions): lang.Promise<this> {
		let that = this,
			deferred = that._deferredLoad;

		// NOTE: Previous loading is already in progress - we can return it if no options are specified.
		// But if there are some options, we should load again with these options.
		if (deferred && lang.isEmpty(options)) {
			return deferred;
		}

		support.throwIfDetached(that._parent);

		// NOTE: wait until the previous loading is completed,
		// maybe after it we will not have to call DataFacade at all.
		return lang.async.then(deferred, () => that._doLoad(options));
	}

	protected _doLoad(options: LoadOptions = {}): lang.Promise<this> {
		let that = this,
			deferred: lang.Promise<any>;

		if (options.reload) {
			deferred = that._reload(options);
		} else if (options.idsOnly) {
			deferred = lang.resolved();
		} else {
			deferred = that._load(options);
		}
		return that._deferredLoad = deferred
			.then(() => that)
			.always(() => { that._deferredLoad = undefined; });
	}

	private _load(options: LoadOptions): lang.Promise<any> {
		let that = this,
			notLoadedItems: IDomainObject[] = that.all().filter(obj => !obj.isLoaded);

		if (!notLoadedItems.length) {
			// all items are already loaded - nothing to do
			// TODO: в options могут быть заданы прелоады, которые мы игнорируем!
			if (options.preloads) {}
			return lang.resolved(that);
		}
		if (that._parent.isNew()) {
			return that._loadMultiple(notLoadedItems, options);
		}
		if (notLoadedItems.length > 1) {
			// two or more items aren't loaded - load the whole property
			return that._loadProp(options);
		}
		// only one item isn't loaded - load it (we can reduce a traffic so)
		return notLoadedItems[0].load(options)
			.then(null, () => {
				// fallback: load the whole property
				return that._loadProp(options);
			});
	}

	private _reload(options: LoadOptions): lang.Promise<any> {
		let that = this;
		return that._parent.isNew() ?
			that._loadMultiple(that.all(), options) :
			that._loadProp(options);
	}

	private _loadMultiple(items: IDomainObject[], options: LoadOptions): lang.Promise<any> {
		let that = this,
			dataFacade = (that._parent.uow as internals.UnitOfWorkInternal)._dataFacade;

		try {
			// NOTE: load several times in a batch
			dataFacade.beginBatch();

			let itemsDeferred = items.map(function (obj) {
				return obj.load(options);
			});
			return lang.when.apply(null, itemsDeferred);
		} finally {
			dataFacade.completeBatch();
		}
	}

	private _loadProp(options: LoadOptions): lang.Promise<any> {
		let that = this;
		return that._parent.uow.ensurePropLoaded(
			that._parent,
			that._propMeta.name,
			options
		);
	}

	/**
	 * @deprecated Use `load` method instead
	 */
	loadItems(options?: LoadOptions): lang.Promise<INavigationPropSet> {
		return this.load(options);
	}

	ids(): string[] {
		let ret = this._getIds();
		this._triggerGet({ prop: "ids", value: ret });
		return ret;
	}

	count(): number {
		let ret = this._getIds().length;
		this._triggerGet({ prop: "count", value: ret });
		return ret;
	}

	all(): DomainObject[] {
		let that = this,
			ret = that._getIds().map(that._getValueObject, that);
		ret.forEach((obj, i) => {
			that._triggerGet({ prop: i.toString(), value: obj });
		});
		that._triggerGet({ prop: "all", value: ret });
		return ret;
	}

	get(index: number|string): DomainObject {
		let that = this,
			id = that._getIds()[index],
			ret = id ? that._getValueObject(id) : undefined;
		that._triggerGet({ prop: index.toString(), value: ret });
		return ret;
	}

	/**
	*
	* @param {String|Object} [type] наименование типа, если задан второй параметр - идентификатор, либо идентификатор объекта (тогда в качесте типа используется тип свойства)
	* @param {string} [type.type] наименование типа
	* @param {string} [type.id] идентификатор объекта
	* @param {string} [id] идентификатор объекта, если первый параметр типа string (имя типа)
	*/
	first(type?, id?: string): DomainObject {
		let that = this, identity, ids, ret;
		if (arguments.length > 0) {
			if (arguments.length === 2) {
				identity = { type: type, id: id };
			} else if (arguments.length === 1) {
				identity = (typeof type === "string") ?
					{ type: that._propMeta.ref, id: type } : // single string parameter - objectId
					type; // single non-string parameter - identity json, TODO: check fields
			} else {
				throw new Error("first: Unexpected parameter count - " + arguments.length);
			}
			ret = that._parent.uow.get(identity.type, identity.id);
		} else {
			ids = that._getIds();
			ret = ids.length ? that._getValueObject(ids[0]) : null;
		}
		that._triggerGet({ prop: "first", value: ret });
		return ret;
	}

	indexOf(obj: DomainObject|string): number {
		let id = support.objectIdOf(obj);
		return this._getIds().indexOf(id);
	}

	contains(obj: DomainObject|string): boolean {
		return this.indexOf(obj) >= 0;
	}

	add(item: DomainObject|DomainObject[]|string|string[]): void {
		this._iterate(item, id => support.addToNavProp(this._parent, this._propMeta, id));
	}

	remove(item: DomainObject|DomainObject[]|string|string[]): void {
		this._iterate(item, id => support.removeFromNavProp(this._parent, this._propMeta, id));
	}

	reset(items: string|string[]|DomainObject|DomainObject[]): void {
		this.clear();
		this.add(items);
	}

	clear(): void {
		let ids = this._getIds().slice();
		this.remove(ids);
	}

	move(indexFrom: number, indexTo: number): void {
		let that = this,
			ids = that._getIds().slice(),
			movedId = ids[indexFrom];

		ids.splice(indexFrom, 1);
		ids.splice(indexTo, 0, movedId);

		support.setPropRaw(that._parent, that._propMeta, ids);
	}

	/**
	 * Iterating through all objects in the property.
	 * Please note, that despite of signature of iterator it WON'T get `array` argument (array of objects).
	 * @param iterator
	 * @param [context]
	 */
	forEach(iterator: (item: DomainObject, index: number, array: DomainObject[]) => void, context?): void {
		let that = this,
			ids = that._getIds();
		ids.forEach((id, index) => {
			let obj = that._getValueObject(id);
			iterator.call(context, obj, index);
		});
	}

	find(predicate: (item: DomainObject, index: number) => boolean, context?): DomainObject {
		let that = this,
			ids = that._getIds();
		for (let i = 0, l = ids.length; i < l; i++) {
			let id = ids[i],
				obj = that._getValueObject(id);
			if (predicate.call(context, obj, i)) {
				return obj;
			}
		}
		return undefined;
	}

	toString(): string {
		return this.all()
			.map(function (obj) { return obj.toString(); })
			.join("; ");
	}

	private _onPropChange(sender, value: string[], oldValue: string[]): void {
		let that = this,
			args: lang.ObservableCollectionChangeArgs<DomainObject> = {};
		if (arguments.length >= 3) {
			args.added = _.difference(value || [], oldValue || []).map(that._getValueObject, that);
			args.removed = _.difference(oldValue || [], value || []).map(that._getValueObject, that);
			//args.changed = [];
		}
		that._triggerChange(args);
	}

	private _onObjChange(sender, args: lang.ObservableChangeArgs): void {
		let that = this;
		// TODO: обработка незагруженных объектов
		if (!args || !args.prop || !that._propMeta.opposite  || that._propMeta.opposite.name !== args.prop) {
			if (that.isLoaded != sender.isLoaded) {
				that._updateIsLoaded();
			}
			that.trigger("itemChange", that, { changed: [ sender ]});
		}
	}

	private _onObjLoad(sender: DomainObject, args?: lang.LoadArgs<DomainObject>): void {
		let that = this;
		if (!args || !args.loaded) {
			that._triggerChange({});
		} else if (args.loaded !== sender) {
			that._triggerChange({ added: [ args.loaded ], removed: [ sender ]});
		}
	}

	private _iterate(items: DomainObject|DomainObject[]|string|string[], iterator: (item: DomainObject|string, index?: number) => void, context?): void;
	private _iterate(items, iterator, context?) {
		return lang.isArray(items) ? items.forEach(iterator, context) : iterator.call(context, items);
	}

	private _getValueObject(id: string): DomainObject {
		support.throwIfDetached(this._parent);
		return this._parent.uow.get(this._propMeta.ref, id) as DomainObject;
	}

	private _getIds(): string[] {
		return support.getPropRaw(this._parent, this._propMeta) || [];
	}

	private _updateIsLoaded(): void {
		let that = this,
			items = that._getIds().map(that._getValueObject, that);
		that.isLoaded = items.every(function (obj) {
			return obj.isLoaded;
		});
	}

	private _initObj(obj: DomainObject): void {
		let that = this;
		obj.bind("change", that._onObjChange, that);
		if (obj.isGhost && !obj.isLoaded) {
			obj.bind("load", that._onObjLoad, that);
		}
	}

	private _cleanupObj(obj: DomainObject): void {
		let that = this;
		obj.unbind("change", null, that);
		obj.unbind("load", null, that);
	}

	private _triggerGet(args: lang.ObservableGetArgs): void {
		this.trigger("get", this, args);
	}

	private _triggerChange(args: lang.ObservableCollectionChangeArgs<DomainObject>): void {
		let that = this;
		if (args.added && args.added.length) {
			args.added.forEach(that._initObj, that);
		}
		if (args.removed && args.removed.length) {
			args.removed.forEach(that._cleanupObj, that);
		}
		that._updateIsLoaded();
		that.trigger("change", that, args);
	}
}

namespace NavigationPropSet {
	export interface LoadOptions extends domain.LoadOptions {
		idsOnly?: boolean;
	}
}

export =  NavigationPropSet;
