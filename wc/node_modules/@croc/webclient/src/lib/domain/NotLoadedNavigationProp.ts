import lang = require("lib/core.lang");
import support = require("./support");
import NavigationPropBase = require("./NavigationPropBase");
import resources = require("i18n!lib/nls/resources");

import domain = require(".domain");
import DomainObject = domain.DomainObject;
import PropertyMeta = domain.metadata.PropertyMeta;
import LoadOptions = domain.LoadOptions;
import IDomainObject = domain.IDomainObject;
import INavigationPropSet = domain.INavigationPropSet;

class NotLoadedNavigationProp extends NavigationPropBase {
	private _deferredLoad: lang.Promise<INavigationPropSet|IDomainObject>;

	@lang.decorators.constant(false)
	isLoaded: boolean;

	@lang.decorators.constant(true)
	isGhost: boolean;

	/**
	 * Результат обращения к незагруженному скалярному навигируемому свойству.
	 * @constructs NotLoadedNavigationProp
	 * @extends NavigationPropBase
	 * @param {DomainObject} parent
	 * @param propMeta
	 */
	constructor(parent: DomainObject, propMeta: PropertyMeta) {
		super(parent, propMeta);
	}

	/**
	 *
	 * @param {Object} [options]
	 * @param {Boolean} [options.idsOnly] do not load all value objects (by default they are loaded)
	 * @param {Boolean} [options.reload] force loading even if all data is already loaded
	 * @param {String} [options.preloads] Preloads (will be passed to server controller)
	 * @param {Object} [options.params] Params (will be passed to server controller)
	 * @param {Object} [options.interop] Advanced options for DataFacade.load
	 * @returns {Promise} DomainObject (for scalar) or NavigationPropSet (for set)
	 */
	load(options?: LoadOptions): lang.Promise<INavigationPropSet|IDomainObject> {
		let that = this,
			deferred = that._deferredLoad;

		// NOTE: Previous loading is already in progress - we can return it if no options are specified.
		// But if there are some options, we should load again with these options.
		if (deferred && lang.isEmpty(options)) {
			return deferred;
		}

		support.throwIfDetached(that._parent);
		if (that._parent.isGhost) {
			throw new Error("Object should be loaded");
		}

		// NOTE: wait until the previous loading is completed,
		// maybe after it we will not have to call DataFacade at all.
		return lang.async.then(deferred, () => {
			return that._doLoad(options);
		});
	}

	protected _doLoad(options?: LoadOptions): lang.Promise<INavigationPropSet|IDomainObject> {
		let that = this;
		return that._deferredLoad = that._parent.uow
			.ensurePropLoaded(that._parent, that._propMeta.name, options)
			.then(() => {
				// propOrObj - объект-значение скалярного свойства или описатель массивного навигируемого свойства
				let propOrObj = that._parent.get(that._propMeta.name);
				if (propOrObj && !propOrObj.isGhost || propOrObj === null) {
					that.trigger("load", that, { loaded: propOrObj });
				}
				return propOrObj;
			})
			.always(() => {
				// удаляем таск загрузки
				that._deferredLoad = undefined;
			});
	}

	/**
	 * @deprecated Use `load` method instead
	 */
	loadItems(options?: LoadOptions): lang.Promise<INavigationPropSet|IDomainObject> {
		if (!this._propMeta.many) {
			throw new Error("Метод loadItems не должен вызываться для скалярных навигируемых свойств.");
		}
		return this.load(options);
	}

	toString(): string {
		return resources.not_loaded;
	}
}

export = NotLoadedNavigationProp;
