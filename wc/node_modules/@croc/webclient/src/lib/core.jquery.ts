import $ = require("jquery");
import lang = require("lib/core.lang");
import html = require("lib/core.html");
import "xcss!lib/ui/styles/core.jquery.css";

declare global {
	export interface JQuery {
		smartresize(fn?: (e: JQueryEventObject) => any): JQuery;
		buttonClick(handler: (e: JQueryEventObject) => any): JQuery;
		blocked(blocked?: boolean): JQuery;
		within(container: JQuery|HTMLElement, position?: { top: number; left: number }): JQuery;
		textOverflow(): JQuery;
		stopBubbling(): JQuery;
		stopKeyboardBubbling(): JQuery;
	}
}

import keyCode = html.keyCode;

/**
 * @deprecated use core.html.windowResize
 * Source: http://paulirish.com/2009/throttled-smartresize-jquery-event-handler/
 * @param fn
 * @returns {*|function(this:string)}
 */
$.fn.smartresize = function (fn?: (e: JQueryEventObject) => any): JQuery {
	return fn ? this.bind("resize", lang.debounce(fn, 100)) : this.trigger("smartresize");
};

/**
* JQuery плагин для единообразной обработки клика мышкой и нажатии space или enter на элементах.
* При нажатии на пробел или Enter по умолчанию вызывается событие click, но клавишные
* события "поднимаются" выше. Это неудобно, если выше также есть обрабочик этих клавиш.
* Поэтому явно давится обработку пробела и Enter-а.
*
* @param {function} handler обработчик клика, нажатия space|enter
* @returns {Object} chained JQuery селектор
* @example
* $("#someButton").buttonClick(function(e) {
*			return false;
* });
*/
$.fn.buttonClick = function (handler: (e: JQueryEventObject) => any): JQuery {
	return this.each(function (): void {
		let $this: JQuery = $(this);

		$this.on("keydown keypress", function (e: JQueryEventObject): boolean {
			if (e.which === keyCode.ENTER || e.which === keyCode.SPACE) {
				return false;
			}
		});
		$this.on("keyup", function (e: JQueryEventObject): boolean {
			if (e.which === keyCode.ENTER || e.which === keyCode.SPACE) {
				e.preventDefault();
				this.click();
				return false;
			}
		});
		$this.on("click", handler);
		// TODO: use Fast Buttons (https://developers.google.com/mobile/articles/fast_buttons) or similar
	});
};

/**
 * Disable/enabled UI for each of the set of matched elements.
 * @param {Boolean} [blocked=true]
 */
$.fn.blocked = function (blocked: boolean = true): JQuery {
	// TODO: message or html to display over disabled element

	let that: JQuery = this;
	if (blocked) {
		// NOTE: add 'blocked' class to all non-static elements
		that.each(function (): void {
			let $this: JQuery = $(this),
				position = $this.css("position");
			if (!position || position === "static") {
				$this.addClass("blocked");
			}
		});
		that.append("<div class='blocked-overlay'></div>");
	} else {
		that.find(">div.blocked-overlay").remove();
		that.removeClass("blocked");
	}
	return that;
};

interface Box {
	top: number;
	left: number;
	bottom: number;
	right: number;
	height: number;
	width: number;
}

function elementBox($element: JQuery, position?: { top: number; left: number }): Box {
	let offset = position || $element.offset(),
		h = $element.outerHeight(),
		w = $element.outerWidth();
	return {
		top: offset.top,
		left: offset.left,
		bottom: offset.top + h - 1,
		right: offset.left + w - 1,
		height: h,
		width: w
	};
}

/**
 * Change offset of an element to ensure it is fully visible inside a container element
 * @param container
 * @param {Object} [position] Desired position of this element. If omitted current position is used.
 * @param {number} [position.top]
 * @param {number} [position.left]
 */
$.fn.within = function (container: JQuery|HTMLElement, position?: { top: number; left: number }): JQuery {
	let $container = $(container),
		containerBox = elementBox($container),
		box = elementBox(this, position),
		top,
		left;

	if (box.top < containerBox.top) {
		top = containerBox.top;
	} else if (box.bottom > containerBox.bottom) {
		top = Math.max(containerBox.top, containerBox.bottom - box.height + 1);
	} else if (position) {
		top = position.top;
	}

	if (box.left < containerBox.left) {
		left = containerBox.left;
	} else if (box.right > containerBox.right) {
		left = Math.max(containerBox.left, containerBox.right - box.width + 1);
	} else if (position) {
		left = position.left;
	}

	if (top !== undefined || left !== undefined) {
		this.offset({ top: top, left: left });
	}

	return this;
};


function textOverflow_onMouseEnter(): void {
	let $this: JQuery = $(this);
	if ($this.innerWidth() < this.scrollWidth) {
		$this.attr("title", $.trim($this.text()));
	} else {
		$this.removeAttr("title");
	}
}

/**
 * Cuts too long text of every element and sets it as a title.
 * @returns {jQuery} the original jQuery set (this)
 */
$.fn.textOverflow = function (): JQuery {
	return this.addClass("text-overflow").mouseenter(textOverflow_onMouseEnter);
};

/**
 * Prevent bubbling of mouse and keyboard events outside of the element
 * @returns {jQuery} the original jQuery set (this)
 */
$.fn.stopBubbling = function (): JQuery {
	return this.on("click mousedown keydown keyup keypress show.bs.dropdown domChanged", e => {
		e.stopPropagation();
	});
};

/**
 * Prevent bubbling of keyboard events outside of the element
 * @returns {jQuery} the original jQuery set (this)
 */
$.fn.stopKeyboardBubbling = function (): JQuery {
	return this.on("keydown keyup keypress", e => {
		e.stopPropagation();
	});
};

if (!$.fn.zIndex) {
	// zIndex was removed in jQuery 1.11, it's copy-paste from jquery-ui#1.10.4
	$.fn.zIndex = function (zIndex?: number) {
		if (zIndex !== undefined) {
			return this.css("zIndex", zIndex);
		}

		if (this.length) {
			let elem = $(this[0]), position, value;
			while (elem.length && <Node>elem[0] !== document) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css("position");
				if (position === "absolute" || position === "relative" || position === "fixed") {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt(elem.css("zIndex"), 10);
					if (!isNaN(value) && value !== 0) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	};
}

export = $;
