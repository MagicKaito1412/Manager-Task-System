import lang = require("lib/core.lang");
import support = require("./domain/support");
import DomainObject = require("./domain/DomainObject");
import UnitOfWork = require("./domain/UnitOfWork");
import NotLoadedObject = require("./domain/NotLoadedObject");
import ComplexValue = require("lib/domain/ComplexValue");
import validation = require("lib/validation");
import formatters = require("lib/formatters");

import { IDomainModel, IDomainObject, IDomainObjectFactory, DomainObjectConstructor, metadata } from "./domain/.domain";
import { IDataFacade } from "lib/interop/.interop";

import ModelMeta = metadata.ModelMeta;
import ModelMetaSpec = metadata.ModelMetaSpec;
import EntityMeta = metadata.EntityMeta;
import EntityMetaSpec = metadata.EntityMetaSpec;
import ComplexTypeMeta = metadata.ComplexTypeMeta;
import ComplexTypeMetaSpec = metadata.ComplexTypeMetaSpec;
import PropertyMetaBase = metadata.PropertyMetaBase;
import PropertyMeta = metadata.PropertyMeta;
import PropertyMetaSpec = metadata.PropertyMetaSpec;
import ComplexPropertyMeta = metadata.ComplexPropertyMeta;
import ComplexPropertyMetaSpec = metadata.ComplexPropertyMetaSpec;
import EnumMeta = metadata.EnumMeta;
import EnumMetaSpec = metadata.EnumMetaSpec;
import EnumMember = metadata.EnumMember;
import EnumMemberSpec = metadata.EnumMemberSpec;
import EntityMetaBase = metadata.EntityMetaBase;
import EnumPropertyMeta = metadata.EnumPropertyMeta;
import ParseResult = validation.ParseResult;
import Rule = validation.Rule;

const enumMetaMethods = {
	parse(this: EnumMeta, v: any): any {
		let parser = validation.getParser(this.vt || "i4");
		if (parser) {
			let res = parser.tryParse(this, v);
			if (res.errorMsg) {
				// NOTE: errorMsg can be string or SafeHtml
				throw res.errorMsg;
				//throw new Error(res.errorMsg);
			}
			v = res.parsedValue;
		}
		return v;
	},

	getMember(this: EnumMeta, v: any): EnumMember {
		for (let memberName in this.members) {
			let member = this.members[memberName];
			if (member.value === v) {
				return member;
			}
			if (typeof v === "object" && v && v.toString() === member.value.toString()) {
				return member;
			}
		}
		return null;
	},

	getMembers(this: EnumMeta, v: any): EnumMember[] {
		let members: EnumMember[] = [];
		for (let memberName in this.members) {
			let member = this.members[memberName];
			if (v === 0 && member.value === 0) {
				return [member];
			}
			if (v !== 0 && member.value !== 0 && (v & member.value) === member.value) {
				members.push(member);
			}
		}
		return members;
	},

	formatValue(this: EnumMeta, v: any): any {
		let result = v;

		if (!this.flags) {
			if (typeof v === "number") {
				let member = this.getMember(v);
				if (member) {
					result = (member.descr || member.name);
				}
			}
		} else {
			if (typeof v === "number") {
				result = "";
				let members = this.getMembers(v);
				for (let member of members) {
					if (result)
						result += ", ";
					result += (member.descr || member.name);
				}
			}
		}

		return result;
	}
};

/**
 * @typedef {Object} DomainModelMeta
 * @description Domain model json metadata. It's a json object generated by JsDomainEngineer tool.
 * @global
 * @property {Object} enums
 * @property {Object} complex
 * @property {Object} entities
 */

/**
 * @typedef {Object} DomainModel
 * @description Domain model. It's runtime representation of model initialized from json (`DomainModelMeta`)
 * @global
 * @property {DomainModelMeta} meta
 * @property {ObjectFactory} factory
 * @property {Class} DomainObject
 * @property {Class} UnitOfWork
 */

/**
 * @class MetadataGenerator
 */
class MetadataGenerator {
	protected raw: ModelMetaSpec;
	protected meta: ModelMeta;

	/**
	 * Generate runtime representation of domain model.
	 * @param {ModelMetaSpec} rawMetadata
	 * @returns {ModelMeta}
	 */
	generate(rawMetadata: ModelMetaSpec): ModelMeta {
		this.raw = rawMetadata || {};
		this.meta = {
			enums: {},
			complex: {},
			entities: {}
		};
		this.preprocess();
		this.postprocess();
		return this.meta;
	}

	protected preprocess(): void {
		let that = this;
		if (that.raw.enums) {
			lang.forEach(that.raw.enums, that.preprocessEnum, that);
		}
		if (that.raw.complex) {
			lang.forEach(that.raw.complex, that.preprocessComplex, that);
		}
		if (that.raw.entities) {
			lang.forEach(that.raw.entities, that.preprocessEntity, that);
		}
	}

	protected preprocessEnum(enumRaw: EnumMetaSpec, enumName: string): void {
		let enumeration: EnumMeta = lang.appendEx({
				name: enumName,
				/** @obsolete use kind */
				type: "enum",
				kind: "enum",
				model: this.meta,
				descr: enumRaw.descr || enumName,
				members: {},
			}, enumMetaMethods, <any>enumRaw, {except: ["members"]});

		if (enumeration.flags) {
			enumeration.fullMask = 0;
		}

		if (enumRaw.members) {
			lang.forEach(enumRaw.members, (memberRaw: EnumMemberSpec, memberName: string) => {
				if (memberRaw.value === null || memberRaw.value === undefined) {
					throw new Error("Для члена '" + memberName + "'перечисления '" + enumName + "' не задан атрибут value");
				}

				let member = lang.append({
					name: memberName,
					parent: enumeration,
					descr: memberRaw.descr || memberName
				}, memberRaw);

				if (enumeration.flags) {
					enumeration.fullMask = enumeration.fullMask | member.value;
				}

				enumeration.members[memberName] = member;
			});
		}

		this.meta.enums[enumName] = enumeration;
	}

	protected preprocessComplex(complexRaw: ComplexTypeMetaSpec, complexName: string): void {
		let complex = lang.append({
			name: complexName,
			kind: "complexType",
			/** @obsolete use kind */
			type: "complex",
			model: this.meta,
			descr: complexRaw.descr || complexName,
			props: {}
		}, <any>complexRaw);

		if (complexRaw.props) {
			lang.forEach(complexRaw.props, (propRaw: PropertyMetaBase, propName: string) => {
				if (!propRaw.vt) {
					throw new Error("Для свойства '" + propName + "' в составном типе '" + complexName + "' не задан атрибут vt ");
				}

				let prop = lang.append({
					name: propName,
					parent: complex,
					descr: propRaw.descr || propName
				}, propRaw);
				complex.props[propName] = prop;
			});
		}
		this.meta.complex[complexName] = complex;
	}

	protected preprocessEntity(entityRaw: EntityMetaSpec, entityName: string): void {
		let entity: EntityMeta = lang.append({
				name: entityName,
				/** @obsolete use kind */
				type: "entity",
				kind: "entity",
				model: this.meta,
				descr: entityRaw.descr || entityName,
				formatters: entityRaw.formatters || {},
				props: {},    // описатели всех значимых свойств типа, включая унаследованные и значиные свойства комплексных типов
				declared: {}, // описатели значимых свойств, объявленных непосредственно в классе
				complex: {},  // описатели комплексных свойств
				derived: {}	  // описатели непосредственных классов-наследников
			}, <any>entityRaw);

		if (entityRaw.props) {
			lang.forEach(entityRaw.props, (propRaw: PropertyMetaSpec|ComplexPropertyMetaSpec, propName: string) => {
				if (!propRaw.vt) {
					throw new Error("Для свойства '" + propName + "' в типе '" + entityName + "' не задан атрибут vt ");
				}

				let prop: PropertyMeta = lang.append({
					name: propName,
					parent: entity,
					entity: entity,
					descr: propRaw.descr || propName
				}, <any>propRaw);
				if (propRaw.vt === "complex") {
					entity.complex[propName] = <ComplexPropertyMeta><any>prop;
				} else {
					entity.props[propName] = prop;
					entity.declared[propName] = prop;
				}
			});
		}

		this.meta.entities[entityName] = entity ;
	}

	protected postprocess(): void {
		let that = this;
		// post-process complex types
		lang.forEach(that.meta.complex, complex => {
			that.postprocessComplex(complex);
		});
		// post-process entities
		lang.forEach(that.meta.entities, entity => {
			that.postprocessEntity(entity);
		});
		// post-process hierarchies
		lang.forEach(that.meta.entities, entity => {
			// NOTE: при пост-обработке дочерних сущностей родительские сущности уже должны быть обработаны.
			// Поэтому здесь запускаем пост-обработку только корневых сущностей в иерархиях наследования,
			// дочерние сущности будут обработаны рекурсивно.
			if (!entity.base) {
				that.postprocessEntityInheritance(entity);
			}
		});
		// set up types default formatters
		lang.forEach(that.meta.entities, entity => {
			that.setupFormatter(entity);
		});
	}

	protected postprocessComplex(complex: ComplexTypeMeta): void {
		lang.forEach(complex.props, prop => {
			// modify text references to objects
			this.postprocessPropRefs(prop);
		});
	}

	protected postprocessEntity(entity: EntityMeta): void {
		let that = this;

		// set reference to base entity
		if (entity.base) {
			// NOTE: в данный момент entity - нечто среднее между EntityMeta и EntityMetaSpec
			entity.base = that.meta.entities[entity.base as any as string];
			entity.base.derived[entity.name] = entity;
		}

		// process complex properties
		lang.forEach(entity.complex, (prop: ComplexPropertyMeta) => {
			// modify text references to objects
			that.postprocessPropRefs(prop);
			// flatten complex properties (copy their valuable properties to entity)
			that.postprocessComplexProp(prop);
		});

		// обрабатываем значимые свойства
		lang.forEach(entity.declared, (prop: PropertyMeta) => {
			// modify text references to objects
			that.postprocessPropRefs(prop);

			// set up property format parsers
			if (!prop.tryParse) {
				let parser = validation.getParser(prop.vt);
				if (parser) {
					prop.tryParse = function (this: PropertyMeta, value: any, skipValidation: boolean): ParseResult {
						if (value === null || value === undefined) {
							return undefined; // не меняем значение
						}
						if (value === "") {
							return { parsedValue: null };
						}
						return parser.tryParse(this, value, skipValidation);
					};
				}
			}

			// set up property formatter
			if (!prop.formatter) {
				let formatter = formatters.getDefaultFormatter(prop);
				if (formatter) {
					prop.formatter = function (this: PropertyMeta, value: any): string {
						return formatter(prop, value);
					};
				}
			}

			// we want not-null facet to execute first
			let rules: Rule[] = [];
			if (!prop.nullable) {
				rules.push(validation.facets.nullable);
			}
			// set up property facets
			for (let facetName of Object.keys(validation.facets)) {
				if (facetName === "nullable") { continue; }
				if (prop.hasOwnProperty(facetName) || prop.vt === facetName) {
					rules.push(validation.facets[facetName]);
				}
			}
			prop.rules = rules.concat(prop.rules || []);

			prop["clone"] = function (this: PropertyMeta): PropertyMeta {
				return lang.extend({}, this);
			};
		});
	}

	protected setupFormatter(entity: EntityMeta): void {
		if (!entity.formatters["default"]) {
			// try to use a first not null string property's value as default presentation
			let firstStringProp = lang.find(entity.props, prop => {
				return prop.vt === "string" && !prop.nullable;
			});
			if (firstStringProp) {
				let formatter = function (this: DomainObject): string {
					let result = this.get(firstStringProp.name);
					if (result === support.values.NotAuthorizedPropValue) {
						result = undefined;
					}
					return result;
				};
				entity.formatters["default"] = formatter;
			}
		}
	}

	protected postprocessPropRefs(prop: PropertyMeta|ComplexPropertyMeta): void {
		// заменим строковое имя типа комплексного свойства на ссылку на метаописатель типа
		if (prop.vt === "complex" && prop.ref && typeof prop.ref === "string") {
			let typeRef = this.meta.complex[prop.ref as string];
			if (!typeRef) {
				throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown complex type '" + prop.ref + "'");
			}
			prop.ref = typeRef;
		}
		// заменим строковое имя типа навигируемого свойства на ссылку на метаописатель типа
		if (prop.vt === "object" && prop.ref && typeof prop.ref === "string") {
			let typeRef = this.meta.entities[prop.ref as string];
			if (!typeRef) {
				throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown entity type '" + prop.ref + "'");
			}
			prop.ref = typeRef;
		}
		// заменим строковое имя обратного свойства на ссылку на метаописатель свойства
		if (prop.vt === "object" && prop.opposite && typeof prop.opposite === "string") {
			let propOpposite = (prop.ref as EntityMeta).props[prop.opposite as string];
			if (!propOpposite) {
				throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown opposite property '" + prop.opposite + "' of type '" + prop.ref.name + "'");
			}
			prop.opposite = propOpposite;
		}
		// заменим строковое имя типа перечисления свойства на ссылку на метаописатель перечисления
		if (prop.vt === "enum" && prop.ref && typeof prop.ref === "string") {
			let typeRef = this.meta.enums[prop.ref as string];
			if (!typeRef) {
				throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown enumeration '" + prop.ref + "'");
			}
			prop.ref = typeRef;
		}
	}

	protected postprocessComplexProp(complexProp: ComplexPropertyMeta): void {
		let entity: EntityMeta = complexProp.entity,
			complex: ComplexTypeMeta = complexProp.ref;
		lang.forEach(complex.props, (prop: PropertyMeta|ComplexPropertyMeta) => {
			let clonedProp = lang.append({
				name: complexProp.name + "." + prop.name,
				descr: complexProp.descr + "." + prop.descr,
				complex: complexProp, // исходное комплексное свойство
				entity: complexProp.entity,
				parent: complexProp.parent,
				// новое свойство должно быть nullable, если исходное комплексное свойство nullable
				nullable: complexProp.nullable || prop.nullable
			}, prop);
			if (prop.vt !== "complex") {
				entity.props[clonedProp.name] = clonedProp as PropertyMeta;
				entity.declared[clonedProp.name] = clonedProp as PropertyMeta;
			} else {
				entity.complex[clonedProp.name] = clonedProp as ComplexPropertyMeta;
				// рекурсивно разворачиваем вложенные комплексные свойства
				this.postprocessComplexProp(clonedProp as ComplexPropertyMeta);
			}
		});
	}

	protected postprocessEntityInheritance(entity: EntityMeta): void {
		// копируем свойства из базового класса
		if (entity.base) {
			lang.forEach(entity.base.props, (prop: PropertyMeta) => {
				if (!entity.props[prop.name]) {
					entity.props[prop.name] = prop;
				}
				// NOTE: if an entity contains the same prop as its parent it means that the entity overrides it
			});
			lang.forEach(entity.base.complex, (prop: ComplexPropertyMeta) => {
				entity.complex[prop.name] = prop;
			});
		}
		// рекурсивно обрабатываем все дочерние сущности
		lang.forEach(entity.derived, this.postprocessEntityInheritance, this);
	}
}

/**
 * @class ObjectFactory
 */
class ObjectFactory implements IDomainObjectFactory {
	/**
	 * Creates a typed instance of domain object
	 * @param {Object} model Domain model
	 * @param {String} typeName name of type
	 * @param {String} [id] identifier
	 * @returns {Object}
	 */
	createObject(model: IDomainModel, typeName: string, id?: string): DomainObject {
		// get factory function
		let ImplClass = model[typeName];
		if (!ImplClass)
			throw new Error("createObject: unknown type: " + typeName);
		return new ImplClass(id);
	}

	/**
	 * Creates a stub for an empty domain object
	 * @param {Object} model Domain model
	 * @param {String} typeName name of type
	 * @param {String} id identifier
	 * @returns {Object}
	 */
	createGhost(model: IDomainModel, typeName: string, id: string): IDomainObject {
		let meta = model.meta.entities[typeName];
		return new NotLoadedObject(meta, id);
	}

	/**
	 * Creates a stub for not authorized domain object
	 * @param {Object} model Domain model
	 * @param {String} typeName name of type
	 * @param {String} id identifier
	 * @returns {Object}
	 */
	createNotAuthorized(model: IDomainModel, typeName: string, id: string): IDomainObject {
		let ImplClass = model[typeName] as DomainObjectConstructor,
			notAuthTypeName = typeName + ".NotAuthorized",
			NotAuthClass = model[notAuthTypeName];
		if (!NotAuthClass) {
			NotAuthClass = class extends ImplClass {
				isNotAuthorized: boolean;

				constructor(id?: string) {
					super(id);

					let that = this;
					that.isLoaded = true;
					that.isGhost = true;
					that.isNotAuthorized = true;

					let raw = support.values.NotAuthorizedPropValue.toJson();
					for (let name of Object.keys(that.meta.props)) {
						that._propValues[name] = raw;
					}
				}

				toString(): string {
					return support.values.NotAuthorizedPropValue.toString();
				}
			};

			model[notAuthTypeName] = NotAuthClass;
		}
		return new NotAuthClass(id);
	}

	// TODO:
	// createNull(model: IDomainModel, typeName: string, id: string): null {
	// 	return null;
	// }

	/**
	 * Creates a typed instance of complex property's value
	 * @param model
	 * @param obj
	 * @param propMeta
	 */
	createComplex(model: IDomainModel, obj: DomainObject, propMeta: ComplexPropertyMeta): ComplexValue {
		// get factory function
		let typeName = propMeta.ref.name;
		let ImplClass = model[typeName];
		if (!ImplClass)
			throw new Error("createComplex: unknown type: " + typeName);
		//return new ComplexValue(obj, propMeta);
		return new ImplClass(obj, propMeta);
	}
}

/**
 * @class ModelGenerator
 */
class ModelGenerator {
	protected model: IDomainModel;

	/**
	 * Generate runtime representation of domain model from json metadata (`DomainModelMeta`).
	 * @param {DomainModelMeta} meta
	 * @returns {IDomainModel}
	 */
	generate(meta: ModelMeta): IDomainModel {
		let that = this;
		/**
		 *
		 * @type {IDomainModel}
		 */
		that.model = /** @lends IDomainModel */{
			/**
			 * @type {DomainModelMeta}
			 */
			meta: meta,
			/**
			 * @type {ObjectFactory}
			 */
			factory: new ObjectFactory(),
			// NOTE: для DomainObject и UnitOfWork создаем наследников, чтобы свободно определять дополнительные
			// методы, не рискуя пересечься с какой-нибудь другой моделью (возможно в тестах).
			DomainObject: class extends DomainObject {
				/**
				 * @constructs DomainObjectEx
				 * @extends DomainObject
				 */
				constructor(id?: string) {
					super(id);
					this.init();
				}
				/**
				 * Extension point. Method for adding custom initialization logic.
				 */
				init(): void {
					// переопределяется для добавления кастомной логики в конструктор
				}
			},

			UnitOfWork: class extends UnitOfWork {
				/**
				 * @param {IDataFacade} dataFacade
				 * @param {Object} [options]
				 * @param {boolean} [options.connected] Subscribe on DataFacade's 'update' event
				 * @class UnitOfWorkEx
				 * @extends UnitOfWork
				 */
				constructor(dataFacade: IDataFacade, options: UnitOfWork.Options) {
					super(that.model, dataFacade, options);
					this.init();
				}
				/**
				 * Extension point. Method for adding custom initialization logic.
				 */
				init(): void {
					// переопределяется для добавления кастомной логики в конструктор
				}
			}
		};

		lang.forEach(meta.entities, (entity: EntityMeta) => {
			// NOTE: при генерации дочерних классов базовые классы уже должны быть сгенерированы.
			// Поэтому здесь запускаем генерацию только корневых классов в иерархиях наследования,
			// дочерние классы будут сгенерированы рекурсивно.
			if (!entity.base) {
				that.genDomainClass(entity);
			}

			let name = entity.name;
			that.model.UnitOfWork.prototype["create" + name] = function (this: UnitOfWork, props?: lang.Map<any>): DomainObject {
				return this.create(name, props);
			};
		});

		lang.forEach(meta.complex, (complex: ComplexTypeMeta) => {
			that.genComplexClass(complex);
		});

		lang.forEach(meta.enums, (enumeration: EnumMeta) => {
			that.genDomainEnum(enumeration);
		});

		// Добавим специальные статические значения
		lang.extend(that.model, support.values);

		return that.model;
	}

	protected genDomainClass(entity: EntityMeta, BaseClass?: DomainObjectConstructor): void {
		BaseClass = BaseClass || this.model.DomainObject;

		let names = {};
		if (entity.complex) {
			Object.keys(entity.complex).forEach(function (name) {
				names[name] = name;
			});
		}
		Object.keys(entity.props).forEach((name) => {
			names[name] = name;
		});

		// generate class
		class DomainClass extends BaseClass {
			static meta: EntityMeta = entity;
			static NAMES = names;
		}
		DomainClass.prototype.meta = entity;
		//DomainClass.prototype.NAMES = names;

		// generate properties (as get/set methods)
		lang.forEach(entity.declared, (prop: PropertyMeta) => {
			this.genPropAccessor(DomainClass, prop.name);
		});
		lang.forEach(entity.complex, (prop: ComplexPropertyMeta) => {
			if (prop.entity === entity) {
				this.genPropAccessor(DomainClass, prop.name);
			}
		});

		this.model[entity.name] = DomainClass;

		// process derived classes
		lang.forEach(entity.derived, (derivedEntity: EntityMeta) => {
			this.genDomainClass(derivedEntity, DomainClass);
		});
	}

	protected genComplexClass(complex: ComplexTypeMeta): void {
		class ComplexClass extends ComplexValue {
			static meta: ComplexTypeMeta = complex;
		}

		// generate properties (as get/set methods)
		lang.forEach(complex.props, (prop: PropertyMeta) => {
			this.genPropAccessor(ComplexClass, prop.name);
		});

		this.model[complex.name] = ComplexClass;
	}

	protected genDomainEnum(enumeration: EnumMeta): void {
		let domainEnum = {
			meta: enumeration
		};
		lang.forEach(enumeration.members, (member: EnumMember) => {
			domainEnum[member.name] = member.value;
		});

		this.model[enumeration.name] = domainEnum;
	}

	protected genPropAccessor<T extends (DomainObject|ComplexValue)>(
		Class: new(...args: any[]) => T, name: string): void
	{
		Class.prototype[name] = function (this: T, v?: any): any {
			return !arguments.length
				? this.get(name)
				: this.set(name, v);
		};
	}
}

function localizeType(name: string, type: EntityMeta|ComplexTypeMeta, resources: lang.Map<string>): void {
	let t = resources["model." + name];
	if (t) { type.descr = t; }
	lang.forEach(type.props, (prop, propName) => {
		let t = resources["model." + name + "." + propName];
		if (t) { prop.descr = t; }
	});
}

/**
 * Builds runtime domain model.
 * @param {Object} rawMetadata Json metadata
 * @returns {IDomainModel}
 */
export function buildModel(rawMetadata: ModelMetaSpec): IDomainModel {
	let metaGen = new MetadataGenerator(),
		meta = metaGen.generate(rawMetadata),
		modelGen = new ModelGenerator();
	return modelGen.generate(meta);
}

export function localize(meta: ModelMeta, resources: lang.Map<string>): void {
	lang.forEach(meta.entities, (type, name) => {
		localizeType(name, type, resources);
	});
	lang.forEach(meta.complex, (type, name) => {
		localizeType(name, type, resources);
	});

	lang.forEach(meta.enums, (type) => {
		let t = resources["model." + type.name];
		if (t) {
			type.descr = t;
		}
		lang.forEach(type.members, (prop) => {
			let t = resources["model." + type.name + "." + prop.name];
			if (t) {
				prop.descr = t;
			}
		});
	});
}
