import core = require("core");

import { IDataSource, LoadQuery, LoadQuerySpec, LoadQueryParams, LoadOptions, LoadResponse } from "lib/interop/.interop";
import { ObjectListColumn } from "lib/ui/list/.list";
import { metadata } from "lib/domain/.domain";
import lang = core.lang;
import Promise = lang.Promise;
import Application = core.Application;
import EntityMeta = metadata.EntityMeta;
import Options = DataSource.Options;

class DataSource extends lang.CoreClass implements IDataSource {
	app: Application;
	name: string;
	supportQuery: boolean;
	isDomain: boolean;
	entityType: string;
	columns: ObjectListColumn[];
	protected preloads: string|string[];
	protected params: LoadQueryParams;

	/**
	 * @constructs DataSource
	 * @article [DataSource](docs:datasource)
	 * @param {Application} app
	 * @param {Object} options
	 * @param {String} options.name DataSource's name, it is also used as entityType's name if it isn't specified
	 * @param {String} options.entityType EntityType's name
	 * @param {String|Array} [options.preloads]
	 * @param {String|Array} [options.orderBy] Requests objects in specific order. Each element of array is a property name with optional ' asc' or ' desc'.
	 * E.g. ["created desc", "title"] or "created desc, title".
	 * @param {Boolean} [options.supportQuery] server controller supports querying (uses UnitOfWork.QueryObjects facilities)
	 * @param {Boolean} [options.isDomain] Indicates that DataSource returns domain objects data. This options is ignored if 'supportQuery' or 'entityType' options are specified.
	 * @param {Array} [options.columns] Array of columns descriptions
	 * @param {Object} [options.params] static parameters for DataFacade.load
	 */
	constructor(app: Application, options?: Options) {
		super();

		let that = this,
			orderBy,
			entityType: EntityMeta;
		options = options || <any>{};
		that.app = app;
		that.name = options.name || options.entityType;
		that.supportQuery = options.supportQuery;
		that.preloads = options.preloads;
		that.columns = options.columns || [];
		that.params = options.params || {};

		orderBy = options.orderBy;
		if (orderBy) {
			that.params.$orderby = lang.isArray(orderBy) ? orderBy.join(",") : orderBy;
		}

		entityType = (options.entityType && app.model.meta.entities[options.entityType]) ||
					(options.name && app.model.meta.entities[options.name]);
		if (entityType) {
			that.entityType = entityType.name;
			if (options.supportQuery !== false) {
				// by default, a DS with name equals to entityType or unnamed is treated as 'domain ds' (i.e. supports querying)
				if (!options.name || options.name === that.entityType) {
					that.supportQuery = true;
				}
			}
		}

		// by default isDomain = true
		that.isDomain = !!lang.coalesce(options.isDomain, true);

		if (options.columns) {
			if (!Array.isArray(options.columns)) {
				throw new Error("DataSource: options.columns should be Array");
			}
			// enrich columns with props attributes
			if (entityType) {
				lang.forEach(that.columns, (column) => {
					let prop;
					if (column.name) {
						prop = entityType.props[column.name];
						if (prop) {
							if (!column.title) {
								column.title = prop.descr;
							}
							if (!column.vt) {
								column.vt = prop.vt;
							}
						}
					}
				});
			}
		} else if (that.supportQuery && entityType) {
			// no columns, but domain ds
			lang.forEach(entityType.props, (prop) => {
				// dy default we'll skip binary and array props
				if (prop.vt !== "binary" && !prop.many) {
					that.columns.push({
						name: prop.name,
						title: prop.descr,
						vt: prop.vt
					});
				}
			});
		}
	}

	protected _prepareParams(json: LoadQueryParams): LoadQueryParams {
		if (!this.supportQuery || !json) { return json; }

		let params: LoadQueryParams = {},
			filter = json.$filter || {};
		lang.forEach(json, (v, name) => {
			// service params starts with $, don't wrap them in $filter
			if (lang.stringStartsWith(name, "$")) {
				params[name] = v;
			} else {
				filter[name] = v;
			}
		});

		if (!lang.isEmpty(filter)) {
			params.$filter = filter;
		}

		return params;
	}

	buildQuery(querySpec: LoadQuerySpec): LoadQuery {
		let that = this,
			query = lang.extend({
				source: that.name,
				type: that.entityType,
				preloads: that.preloads
			}, querySpec);
		if (!that.isDomain && !query.route) {
			query.route = "_plain";
		}
		query.params = that._prepareParams(lang.extendEx({}, that.params, querySpec.params, {deep: true}));
		return query;
	}

	/**
	 * Load data via DataFacade.
	 * @param {Object} [query] see `DataFacade.load` (query.params will be combined with current DataSource's restrictions in 'params' field)
	 * @param {Object} [options] options for DataFacade.load method.
	 * @returns {Promise} An object with result field
	 */
	load(query?: LoadQuerySpec, options?: LoadOptions): Promise<LoadResponse> {
		let that = this;
		query = query || <any>{};

		if (arguments.length === 3 || lang.isString(arguments[1])) {
			// old API: ([object]params, [string]opId, [object]options)
			return that._loadOld.apply(that, arguments);
		} else if (query.hasOwnProperty("params") || query.hasOwnProperty("preloads")) {
			// new API (since 0.11): ([object]query, [object]options)
			return that._load(query, options);
		} else if (arguments.length === 2 && lang.isObject(options)) {
			// new API (since 0.11): ([object]query, [object]options), but query is empty
			return that._load(query, options);
		} else {
			// old API: (params, opId, options)
			return that._loadOld.apply(that, arguments);
		}
	}

	protected _load(querySpec: LoadQuerySpec, options?: LoadOptions): Promise<LoadResponse> {
		let that = this,
			query = that.buildQuery(querySpec);
		return that.app.dataFacade.load(query, options);
	}

	protected _loadOld(params: LoadQueryParams, opId: string, options?: LoadOptions): Promise<LoadResponse> {
		// TODO: remove in future versions
		let that = this,
			querySpec = { params: params },
			query = that.buildQuery(querySpec);
		options = lang.extend({opId: opId}, options);
		return that.app.dataFacade.load(query, options);
	}

	/**
	 * Initialize cancellation of load via DataFacade.cancel.
	 * @param {String} opId Identified (guid) of operation to cancel
	 * @returns {Promise}
	 */
	cancel(opId: string): Promise<void> {
		return this.app.dataFacade.cancel(opId);
	}
}

namespace DataSource {
	export interface Options {
		name?: string;
		entityType?: string;
		supportQuery?: boolean;
		isDomain?: boolean;
		preloads?: string|string[];
		columns?: ObjectListColumn[];
		params?: LoadQueryParams;
		orderBy?: string|string[];
	}
}

core.data = core.data || <any>{};
core.data.DataSource = DataSource;

export = DataSource;
