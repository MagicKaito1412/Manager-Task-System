import core = require("core");
import DataStoreBase = require("lib/data/DataStoreBase");

import domain = require("lib/domain/.domain");
import interop = require("lib/interop/.interop");
import lang = core.lang;
import Promise = lang.Promise;
import PropertyMeta = domain.metadata.PropertyMeta;
import ModelMeta = domain.metadata.ModelMeta;
import Identity = interop.Identity;
import DomainObjectData = interop.DomainObjectData;
import SavedObjectData = interop.SavedObjectData;
import StoredResponse = DataStoreBase.StoredResponse;
import StoredObjectFilter = DataStoreBase.StoredObjectFilter;
import LoadQuery = interop.LoadQuery;
import LoadQuerySource = interop.LoadQuerySource;
import LoadQueryParams = interop.LoadQueryParams;
import LoadResponse = DataStoreBase.LoadResponse;
import FromStoreOptions = DataStoreBase.FromStoreOptions;
import ToStoreOptions = DataStoreBase.ToStoreOptions;
import IObjectStore = DataStoreBase.IObjectStore;
import { Promisable } from "../core.lang";

interface IObjectStoreIterator<T> extends DataStoreBase.IObjectStoreIterator<T> {}

interface StoredObjectData extends DataStoreBase.StoredObjectData {
	__originalUndefined?: string[];
}

class DataStoreLocalStorage extends DataStoreBase {
	storage: typeof core.localStorage;

	protected _prefix: string;
	protected _objPrefix: string;
	protected _queryPrefix: string;
	protected _initializing: boolean;
	protected _initialized: boolean;

	/**
	 * @constructs DataStoreLocalStorage
	 * @extends DataStoreBase
	 * @param name
	 * @param version
	 * @param domainModelMeta
	 * @param options
	 */
	constructor(name: string, version: number, domainModelMeta: ModelMeta, options?: DataStoreBase.Options) {
		super(name, version, domainModelMeta, options);

		let that = this;
		that._prefix = "store/" + name + "/";
		that._objPrefix = that._prefix + "obj/";
		that._queryPrefix = that._prefix + "query/";

		if (that.options.recreate) {
			that.recreate();
		} else {
			that._init();
		}
	}

	test(): Promise<void> {
		return lang.resolved();
	}
	recreate(): Promise<void> {
		let that = this;
		return lang.async.attempt(() => {
			let keys = [];

			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._prefix)) {
					keys.push(key);
				}
			});
			keys.forEach((key) => {
				that.storage.removeItem(key);
			});

			return that._init();
		});
	}

	protected _init(): Promise<void> {
		let that = this,
			sysVersionKey = that._prefix + "__x_sys_version",
			versionKey = that._prefix + "__x_version",
			oldSysVersion,
			oldVersion,
			deferred;

		that._initializing = true;

		oldSysVersion = parseInt(that.storage.getItem(sysVersionKey), 10) || 0;
		oldVersion = parseInt(that.storage.getItem(versionKey), 10) || 0;

		deferred = lang.resolved();
		if (oldSysVersion < that.systemVersion) {
			deferred = deferred.then(() => {
				return that._onsysupgrade(oldSysVersion, that.systemVersion);
			}).then(() => {
				that.storage.setItem(sysVersionKey, that.systemVersion.toString());
			});
		}
		if (oldVersion < that.version) {
			deferred = deferred.then(() => {
				return that._onappupgrade(oldVersion, that.version);
			}).then(() => {
				that.storage.setItem(versionKey, that.version.toString());
			});
		}
		return deferred.always(() => {
			that._initializing = false;
		}).done(() => {
			that._initialized = true;
		});
	}
	protected _onsysupgrade(oldSystemVersion: number, newSystemVersion: number): Promisable<void> {
	}
	protected _onappupgrade(oldVersion: number, newVersion: number): Promise<void> {
		let that = this,
			deferred;

		// custom code
		deferred = that.onversionchange(oldVersion, newVersion);

		// delete objects missed in the domain model
		return lang.when(deferred).done(() => {
			let keysToRemove = [];
			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._objPrefix)) {
					let type = obj.__metadata.type;
					if (!that.storedTypes[type]) {
						keysToRemove.push(key);
					}
				}
			});
			keysToRemove.forEach((key) => {
				that.storage.removeItem(key);
			});
		});
	}
	protected _throwIfNotInited(): void {
		if (!this._initialized && !this._initializing) {
			throw new Error("DataStoreLocalStorage wasn't properly initialized");
		}
	}
	protected _throwIfTypeInvalid(type: string): void {
		let that = this;
		if (!that._initializing) {
			super._throwIfTypeInvalid(type);
			return;
		}

		if (!type) {
			throw new ReferenceError("Type is not specified");
		}
	}

	/**
	 * Load an object
	 * @param type
	 * @param id
	 * @param options
	 * @param {Boolean} options.raw Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	load(type: string, id: string, options?: FromStoreOptions): Promise<DomainObjectData> {
		let that = this;
		return lang.async.attempt(() => {
			let obj;
			that._throwIfNotInited();
			that._throwIfTypeInvalid(type);

			obj = that._getObj(type, id);
			return that._toUser(obj, options);
		});
	}

	/**
	 * Load several objects
	 * @param identities
	 * @param options
	 * @param {Boolean} options.raw Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	loadMany(identities: Identity[], options?: FromStoreOptions): Promise<DomainObjectData[]> {
		let that = this;
		return lang.async.attempt(() => {
			that._throwIfNotInited();
			identities.forEach((identity) => {
				that._throwIfTypeInvalid(identity.type);
			});

			return that._getMany(identities).map((obj) => {
				return that._toUser(obj, options);
			});
		});
	}
	/**
	 * Load all objects of specified type
	 * @param {Object|String} filter String value will be interpreted as a type
	 * @param {String} filter.type Type of objects to load
	 * @param {Boolean} [filter.hasChanges] Load objects with changes. Calling with hasChanges = false returns object without any changes.
	 * @param {Boolean} [filter.isRemoved] Load removed objects. Calling with isRemoved = false returns object which are not removed.
	 * @param [options]
	 * @param {Boolean} [options.raw] Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	select(filter: StoredObjectFilter|string, options?: FromStoreOptions): Promise<DomainObjectData[]> {
		let that = this;
		return lang.async.attempt(() => {
			let objects = [],
				objFilter: StoredObjectFilter = lang.isString(filter) ? { type: <string>filter } : <StoredObjectFilter>filter;
			that._throwIfNotInited();
			that._throwIfTypeInvalid(objFilter.type);

			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._objPrefix + objFilter.type + "/")) {
					if (obj.__metadata.type !== objFilter.type) {
						console.warn("DataStoreLocalStorage: " + key + ": the type in key isn't equal the type in value (" + obj.__metadata.type + ")");
						return;
					}

					if (!that._matchFilter(obj, objFilter)) {
						return;
					}

					obj = that._fromDB(obj);
					obj = that._toUser(obj, options);
					objects.push(obj);
				}
			});
			return objects;
		});
	}
	/**
	 * Load all objects from the store. Use for debug only!
	 * @param options
	 * @param {Boolean} options.raw Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	all(options?: FromStoreOptions): Promise<DomainObjectData[]> {
		let that = this;
		return lang.async.attempt(() => {
			let objects = [];
			that._throwIfNotInited();

			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._objPrefix)) {
					obj = that._fromDB(obj);
					obj = that._toUser(obj, options);
					objects.push(obj);
				}
			});
			return objects;
		});
	}

	getChanges(): Promise<DomainObjectData[]> {
		let that = this;
		return lang.async.attempt(() => {
			let objects = [];
			that._throwIfNotInited();

			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._objPrefix) && obj.__hasChanges) {
					obj = that._fromDB(obj);
					obj = that._getObjChanges(obj);
					objects.push(obj);
				}
			});
			return objects;
		});
	}
	hasChanges(): Promise<boolean> {
		let that = this;
		return lang.async.attempt(() => {
			that._throwIfNotInited();

			return that.storage.some((obj, key) => {
				return lang.stringStartsWith(key, that._objPrefix) && obj.__hasChanges;
			});
		});
	}

	/**
	 * Remove objects of specific 'type' which don't have unsaved changes
	 * @param {String} type
	 * @returns {*}
	 */
	clear(type: string): Promise<void> {
		let that = this;
		return lang.async.attempt(() => {
			that._throwIfNotInited();
			that._throwIfTypeInvalid(type);

			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._objPrefix + type + "/")) {
					obj = that._fromDB(obj);
					if (obj && !obj.__hasChanges) {
						that.storage.removeItem(key);
					}
				}
			});
		});
	}
	/**
	 * Remove objects from DataStore
	 * @param options
	 * @param {Boolean} options.includePending Remove or not objects with unsaved changes
	 * @returns {*}
	 */
	clearAll(options?: { includePending?: boolean }): Promise<void> {
		let that = this;
		return lang.async.attempt(() => {
			that._throwIfNotInited();
			options = options || {};

			that.storage.forEach((obj, key) => {
				if (lang.stringStartsWith(key, that._objPrefix)) {
					if (options.includePending) {
						that.storage.removeItem(key);
					} else {
						obj = that._fromDB(obj);
						if (obj && !obj.__hasChanges) {
							that.storage.removeItem(key);
						}
					}
				}
			});
		});
	}

	cacheQuery(query: LoadQuery, response: LoadResponse): Promise<void> {
		let that = this;
		return lang.async.attempt(() => {
			if (!query || !query.source) {
				throw new Error("DataStore.cacheQuery: query.source should be specified");
			}
			if (!response) {
				throw new Error("DataStore.cacheQuery: response should be specified");
			}

			let source = that._getQuerySource(query);

			if (source.propName) {
				return that._cacheQueryProp(source, response); // can throw
			}
			if (source.id) {
				return;
			}
			that._throwIfNotInited();

			let identities = that._identity(response.result), // can throw
				data: StoredResponse = {
					__timestamp: Date.now(),
					result: identities,
					hints: response.hints
				},
				key = that._getQueryKey(source, query.params),
				type = that._getQueryType(query, data);
			if (type) {
				data.__type = type;
			}
			that.storage.setObject(key, data);
		});
	}
	query(query: LoadQuery): Promise<LoadResponse> {
		let that = this;
		return lang.async.attempt(() => {
			let source = that._getQuerySource(query),
				response;

			if (!source) {
				throw new Error("DataStore.query: query.source should be specified");
			}
			that._throwIfNotInited();

			if (source.propName) {
				response = that._queryProp(source.type, source.id, source.propName);
			} else if (source.id) {
				response = that._queryObject(source.type, source.id);
			} else {
				response = that._queryObjects(source, query.params);
			}
			return response;
		});
	}

	protected _queryObject(type: string, id: string): LoadResponse {
		let that = this,
			obj;
		that._throwIfTypeInvalid(type);

		obj = that._getObj(type, id);
		return that._queryResponse(obj);
	}
	protected _queryObjects(source: LoadQuerySource, params: LoadQueryParams): LoadResponse {
		let that = this,
			key = that._getQueryKey(source, params),
			data = that.storage.getObject(key),
			result,
			response;

		if (!data || !data.result) {
			return that._queryResponse();
		}

		result = lang.isArray(data.result) ?
				that._getMany(data.result) :
				that._getObj(data.result.type, data.result.id);
		response = that._queryResponse(result, data.__timestamp);
		response.hints = data.hints;
		return response;
	}
	protected _queryProp(type: string, id: string, prop: string): LoadResponse {
		let that = this,
			propMeta = that.meta.entities[type].props[prop],
			obj = that._getObj(type, id),
			v, isObject, identities, objects, result;

		if (!obj || !propMeta || (v = obj[prop]) === undefined) {
			result = undefined;
		} else if (propMeta.vt !== "object") {
			result = v;
		} else if (v === null) {
			result = propMeta.many ? [] : null;
		} else if (!propMeta.many) {
			isObject = true;
			result = that._getObj(propMeta.ref.name, v);
		} else {
			isObject = true;
			identities = lang.select(v, (id) => {
				return { type: propMeta.ref.name, id: id };
			});
			objects = that._getMany(identities);
			result = objects.length === identities.length ? objects : undefined;
		}

		return isObject ?
			that._queryResponse(result, obj && obj.__timestamp) :
			that._queryValueResponse(result, obj && obj.__timestamp);
	}
	protected _getQueryKey(source: LoadQuerySource, params: LoadQueryParams): string {
		return this._queryPrefix + JSON.stringify(source) + "/" + JSON.stringify(this._getParamsForCache(params) || "");
	}

	protected _update(
		objects:  DomainObjectData[]|DomainObjectData,
		iterator: IObjectStoreIterator<DomainObjectData>): void
	{
		let that = this,
			objectsByType = that._groupByType(objects); // can throw
		that._iterate(objectsByType, iterator);
	}

	protected _iterate<T extends DomainObjectData>(
		objectsByType: core.lang.Map<T[]>,
		iterator: IObjectStoreIterator<T>): void
	{
		let that = this;
		that._throwIfNotInited();

		lang.forEach(objectsByType, (objectsOfType, type) => {
			let store = that._store(type);
			lang.forEach(objectsOfType, (obj) => {
				let existent = that._getObj(type, obj.id);
				iterator.call(that, store, obj, existent);
			});
		});
	}

	protected _commit(
		changes: SavedObjectData[]|SavedObjectData,
		iterator: IObjectStoreIterator<SavedObjectData>): void
	{
		let that = this,
			objectsByType = that._groupByType(changes), // can throw
			types = that._getAncestors(Object.keys(objectsByType));

		that._iterate(objectsByType, iterator);
		that.storage.forEach((query, key) => {
			if (lang.stringStartsWith(key, that._queryPrefix) &&
					query.__type && types.indexOf(query.__type) >= 0) {
				// NOTE: don't set to 0, because this is falsy value and will be ignored
				query.__timestamp = -1; // outdated
				that.storage.setObject(key, query);
			}
		});
	}

	protected _store(type: string): IObjectStore {
		let that = this;
		return {
			"put": function (v: StoredObjectData): void {
				that._put(v);
			},
			"delete": function (id: string): void {
				that._delete(type, id);
			}
		};
	}
	protected _getObj(type: string, id: string): StoredObjectData {
		let that = this,
			obj;
		that._throwIfNotInited();
		that._throwIfTypeInvalid(type);

		obj = that.storage.getObject(that._objPrefix + type + "/" + id);
		return that._fromDB(obj);
	}
	protected _getMany(identities: Identity[]): StoredObjectData[] {
		let that = this,
			objects = [];
		that._throwIfNotInited();

		identities.forEach((identity) => {
			that._throwIfTypeInvalid(identity.type);

			let obj = that._getObj(identity.type, identity.id);
			if (obj && !obj.__metadata.isRemoved) {
				objects.push(obj);
			}
		});
		return objects;
	}
	protected _put(object: StoredObjectData): void {
		let that = this;
		that._throwIfNotInited();
		that._throwIfNotValid(object);

		that.storage.setObject(that._objPrefix + object.__metadata.type + "/" + object.id, object);
	}
	protected _delete(type: string, id: string): void {
		let that = this;
		that._throwIfNotInited();
		that._throwIfTypeInvalid(type);

		that.storage.removeItem(that._objPrefix + type + "/" + id);
	}
	protected _toDB(obj: StoredObjectData, options?: ToStoreOptions): StoredObjectData {
		obj = super._toDB(obj, options);
		if (!obj) { return obj; }

		// NOTE: undefined values aren't serialized to JSON, so serialize their names explictly
		let originalUndefined = [];
		if (obj.__original) {
			lang.forEach(obj.__original, (v, name) => {
				if (v === undefined) {
					originalUndefined.push(name);
				}
			});
		}
		if (originalUndefined.length) {
			obj.__originalUndefined = originalUndefined;
		}

		return obj;
	}
	protected _fromDB(obj: StoredObjectData): StoredObjectData {
		obj = super._fromDB(obj);
		if (!obj) { return obj; }

		// NOTE: set explictly serialized undefined values
		if (obj.__originalUndefined) {
			obj.__original = obj.__original || {};
			lang.forEach(obj.__originalUndefined, (name) => {
				obj.__original[name] = undefined;
			});
			delete obj.__originalUndefined;
		}

		return obj;
	}
}

DataStoreLocalStorage.mixin({
	isSupported: core.platform.modernizr.localstorage,
	systemVersion: 2,
	storage: core.localStorage,
});

export = DataStoreLocalStorage;
