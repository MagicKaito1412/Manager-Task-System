import lang = require("lib/core.lang");
import support = require("lib/domain/support");

import domain = require("lib/domain/.domain");
import interop = require("lib/interop/.interop");
import Promise = lang.Promise;
import ModelMeta = domain.metadata.ModelMeta;
import EntityMeta = domain.metadata.EntityMeta;
import PropertyMeta = domain.metadata.PropertyMeta;
import Identity = interop.Identity;
import DomainObjectData = interop.DomainObjectData;
import SavedObjectData = interop.SavedObjectData;
import StoredObjectData = DataStoreBase.StoredObjectData;
import StoredResponse = DataStoreBase.StoredResponse;
import StoredObjectFilter = DataStoreBase.StoredObjectFilter;
import LoadQuery = interop.LoadQuery;
import LoadQuerySource = interop.LoadQuerySource;
import LoadQueryParams = interop.LoadQueryParams;
import LoadResponse = DataStoreBase.LoadResponse;
import Options = DataStoreBase.Options;
import CacheOptions = DataStoreBase.CacheOptions;
import FromStoreOptions = DataStoreBase.FromStoreOptions;
import ToStoreOptions = DataStoreBase.ToStoreOptions;

interface IObjectStoreIterator<T> extends DataStoreBase.IObjectStoreIterator<T> {}

// max age - 1000 years
const MAX_AGE = 1000 * 365 * 24 * 60 * 60 * 1000;

abstract class DataStoreBase extends lang.Observable {
	public isSupported: boolean;
	public systemVersion: number;
	public version: number;
	public name: string;
	public storedTypes: lang.Map<boolean>;
	protected meta: ModelMeta;
	protected options: Options;

	/**
	 * @constructs DataStoreBase
	 * @extends Observable
	 * @description Base implementation of local data cache
	 * On errors all async methods must return the rejected deferred (instead of throwing an exception).
	 * @param {String} name
	 * @param {Number} version
	 * @param {Object} domainModelMeta
	 * @param {Object} [options]
	 */
	constructor(name: string, version: number, domainModelMeta: ModelMeta, options?: Options) {
		super();

		if (!name)
			throw new Error("DataStore.ctor: database name should be specified");
		if (!version)
			throw new Error("DataStore.ctor: database version should be specified");
		if (!domainModelMeta)
			throw new Error("DataStore.ctor: domain metadata should be specified");

		this.name = name;
		this.version = version;
		this.meta = domainModelMeta;
		this.options = options || {};

		this.storedTypes = {};
		lang.forEach(this.meta.entities, (entity, name) => {
			// only persistent entities
			if (entity && !entity.temp) {
				this.storedTypes[name] = true;
			}
		});
	}

	protected onversionchange(oldVersion: number, newVersion: number): void|Promise<void> {
		let that = this;
		if (lang.isFunction(that.options.onversionchange)) {
			return that.options.onversionchange.call(that, that, oldVersion, newVersion);
		}
	}

	/**
	 * @abstract
	 */
	abstract test(): Promise<any>;

	/**
	 * @abstract
	 */
	abstract recreate(): Promise<any>;

	/**
	 * Load an object
	 * @abstract
	 * @param type
	 * @param id
	 * @param options
	 */
	abstract load(type: string, id: string, options?: FromStoreOptions): Promise<DomainObjectData>;

	/**
	 * Load several objects
	 * @abstract
	 * @param identities
	 * @param options
	 */
	abstract loadMany(identities: Identity[], options?: FromStoreOptions): Promise<DomainObjectData[]>;

	/**
	 * Load all objects of specified type
	 * @abstract
	 * @param filter
	 * @param options
	 */
	abstract select(filter: StoredObjectFilter|string, options?: FromStoreOptions): Promise<DomainObjectData[]>;

	/**
	 * Load all objects from the store. Use for debug only!
	 * @abstract
	 * @param options
	 */
	abstract all(options?: FromStoreOptions): Promise<DomainObjectData[]>;

	/**
	 * @abstract
	 */
	abstract getChanges(): Promise<DomainObjectData[]>;

	/**
	 * @abstract
	 */
	abstract hasChanges(): Promise<boolean>;

	/**
	 * Remove objects of specific 'type' which don't have unsaved changes
	 * @abstract
	 * @param type
	 */
	abstract clear(type: string): Promise<void>;

	/**
	 * Remove objects from DataStore
	 * @abstract
	 * @param options
	 */
	abstract clearAll(options?: { includePending?: boolean }): Promise<void>;

	/**
	 * @abstract
	 * @param query
	 * @param response
	 */
	abstract cacheQuery(query: LoadQuery, response: LoadResponse): Promise<void>;

	/**
	 * @abstract
	 * @param query
	 */
	abstract query(query: LoadQuery): Promise<LoadResponse>;

	/**
	 * @method
	 * @params {Array} objects Objects to save (create or update local objects with client-side changes)
	 * @returns {Promise}
	 */
	save(objects: DomainObjectData[]|DomainObjectData): Promise<void> {
		return this._update(objects, (store, obj, existent) => {
			if (!existent) {
				existent = {
					__metadata: { type: obj.__metadata.type },
					id: obj.id
				};
			}

			if (obj.__metadata.isNew) {	existent.__metadata.isNew = true; }
			if (obj.__metadata.isRemoved) {	existent.__metadata.isRemoved = true; }

			existent.__original = existent.__original || {};
			lang.forEach(obj, (v, name) => {
				if (this._isSpecialPropName(name)) { return; }

				let old = existent[name];
				if (lang.isEqual(v, old)) { return; }

				if (!obj.__metadata.isNew) {
					if (!existent.__original.hasOwnProperty(name)) {
						existent.__original[name] = old;
					} else if (lang.isEqual(v, existent.__original[name])) {
						delete existent.__original[name];
					}
				}
				existent[name] = v;
			});

			if (!obj.__metadata.isNew ) {
				lang.append(existent.__original, obj.__original);
			}

			if (obj.__metadata.ts && obj.__metadata.ts !== existent.__metadata.ts) {
				if (existent.__metadata.ts) {
					lang.extendEx(existent.__original, { __metadata: { ts: existent.__metadata.ts }}, { deep: true });
				}
				existent.__metadata.ts = obj.__metadata.ts;
			}

			store.put(this._toDB(existent));
		});
	}

	/**
	 * Commit specified changes which makes objects in Store trustworthy.
	 * Usually it is called after that objects were saved on the server.
	 * @method
	 * @param {Array} changes
	 * @returns {Promise}
	 */
	commit(changes: SavedObjectData[]|SavedObjectData): Promise<void> {
		let that = this;

		// Set values of navigation props with changed IDs to __newValues
		//
		// NOTE: Id may change for new objects only and all references to new objects must be in the same datagram.
		// Therefore we should update references in the committing objects (datagram) only, no need to update other objects in DataStore.
		// NOTE: This can be done in DataFacade._updateSaved, but DataFacade doesn't have access to domain metadata.
		that._updateRefIds(lang.array(changes));

		return that._commit(changes, (store, obj, existent) => {
			if (!existent) { return; }

			if (obj.__metadata.isRemoved) {
				store["delete"](obj.id);
				return;
			}

			if (obj.__newValues && obj.__newValues.id) {
				store["delete"](obj.id);
			}

			existent = that._commitObj(obj, existent);

			if (obj.__metadata.ts > (existent.__metadata.ts || 0)) {
				existent.__metadata.ts = obj.__metadata.ts;
			} else if (obj.__metadata.ts === undefined &&
						existent.__metadata.ts != undefined &&
						obj.__newValues["__incrementTs"]) {
				// an additional object which was updated on the server
				existent.__metadata.ts = existent.__metadata.ts + 1;
			}

			store.put(that._toDB(existent, { updateTs: true }));
		});
	}

	/**
	 * Remove specified changes and restore previous data (if it exists).
	 * @method
	 * @param {Array} changes
	 * @returns {Promise}
	 */
	rollback(changes: DomainObjectData[]|DomainObjectData): Promise<DomainObjectData[]> {
		let that = this,
			updated: DomainObjectData[] = [];
		return lang.when(that._update(changes, (store, obj, existent) => {
			if (!existent) { return; }

			if (obj.__metadata.isNew) {
				updated.push({__metadata: lang.extend({}, obj.__metadata, {isRemoved: true}), id: obj.id});
				store["delete"](obj.id);
				return;
			}

			// TOTHINK: а если isRemoved появился после getChanges?
			if (obj.__metadata.isRemoved) {	delete existent.__metadata.isRemoved; }

			existent.__original = existent.__original || {};
			let checkForEmpty = false;
			lang.forEach(obj, (v, name) => {
				if (that._isSpecialPropName(name)) { return; }

				if (!existent.hasOwnProperty(name) || lang.isEqual(v, existent[name])) {
					// prop wasn't changed after getChanges
					if (existent.__original.hasOwnProperty(name)) {
						existent[name] = existent.__original[name];
					} else {
						delete existent[name];		// TODO: это когда такое может быть?!
					}
					if (existent[name] === undefined) {
						delete existent[name];
						checkForEmpty = true;
					}
					delete existent.__original[name];
				}
			});

			// restore ts
			if (obj.__metadata.ts && existent.__original.__metadata && existent.__original.__metadata.ts) {
				existent.__metadata.ts = existent.__original.__metadata.ts;
				delete existent.__original.__metadata; // NOTE: nothing except of ts in __original.__metadata
			}

			updated.push(that._toUser(lang.extend({}, existent), {keepFlags: true}));

			if (checkForEmpty) {
				// if object has no prop (except for special) then remove it from store
				if (Object.keys(existent).every(that._isSpecialPropName)) {
					store["delete"](obj.id);
					return;
				}
			}
			store.put(that._toDB(existent));
		})).then(() => {
			return updated;
		});
	}

	/**
	 * Put specified objects into Store, possibly replace existing objects.
	 * @method
	 * @param {Array} objects
	 * @returns {Promise}
	 */
	overwrite(objects: DomainObjectData[]|DomainObjectData): Promise<void> {
		return this._update(objects, (store, obj, existent) => {
			obj = lang.cloneEx(obj, { deep: true, exact: true });
			store.put(this._toDB(obj));
		});
	}

	/**
	 * Remove specified objects from Store.
	 * @method
	 * @param {Array} objects
	 * @returns {Promise}
	 */
	remove(objects: DomainObjectData[]|DomainObjectData): Promise<void> {
		return this._update(objects, (store, obj, existent) => {
			store["delete"](obj.id);
		});
	}

	/**
	 * Put objects into Store as trustworthy data.
	 * @method
	 * @param {Array} objects json domain objects
	 * @param {Object} [options]
	 * @param {Boolean} [options.actualize] Update source objects with data from Store
	 * @param {Boolean} [options.skipMissing] Ignore objects which can not be found in Store
	 * @param {Boolean} [options.partial] Json data doesn't contains all properties loaded by default.
	 * In this case the timestamp will not be updated and obsolete properties will not be removed.
	 * @returns {Promise}
	 */
	cache(objects: DomainObjectData[]|DomainObjectData, options?: CacheOptions): Promise<void> {
		let that = this;
		options = options || {};
		return that._update(objects, (store, obj, existent) => {
			if (!existent && options.skipMissing) { return; }

			if (obj.__metadata.isRemoved) {
				store["delete"](obj.id);
				return;
			}

			existent = that._cacheObj(obj, existent);

			// NOTE: `obj.__metadata.ts` may be less than `existent.__metadata.ts`
			// (e.g. because of server database was restored from a backup - see WC-1456)
			let ts = obj.__metadata.ts;
			if (ts && ts !== (existent.__metadata.ts || 0)) {
				if (!that._hasObjChanges(existent)) {
					existent.__metadata.ts = ts;
				} else {
					lang.extendEx(existent.__original, { __metadata: { ts: ts }}, { deep: true });
				}

				// delete obsolete props
				if (!options.partial) {
					lang.forEach(existent, (v, name) => {
						if (that._isSpecialPropName(name)) { return; }

						if (!obj.hasOwnProperty(name) && !existent.__original.hasOwnProperty(name)) {
							delete existent[name];
						}
					});
				}
			}

			// __aux are not merged, always overwrite them
			if (obj.__aux) {
				existent.__aux = lang.clone(obj.__aux);
			} else {
				delete existent.__aux;
			}

			// TODO: remove the code below (inside begin/end comments) when #XFW-269 will be fixed:
			// --- begin workaround ---
			//
			// TS isn't update while updating many-to-many navigation props on server (see #XFW-269).
			// So we can't be sure that those props weren't changed (even if ts is the same).
			// We have to delete them, if they aren't set in new cached objects.
			if (!options.partial) {
				let typeMeta = that.meta.entities[existent.__metadata.type];
				lang.forEach(existent, (v, name) => {
					if (that._isSpecialPropName(name)) { return; }

					let propMeta = typeMeta.props[name];
					if (propMeta && propMeta.many && !obj.hasOwnProperty(name) && !existent.__original.hasOwnProperty(name)) {
						delete existent[name];
					}
				});
			}
			// --- end workaround ---

			if (options.actualize) {
				that._actualize(obj, existent);
			}

			store.put(that._toDB(existent, { updateTs: !options.partial }));
		});
	}

	/**
	 * @protected
	 * @abstract
	 */
	protected abstract _update(
		objects: DomainObjectData[]|DomainObjectData,
		iterator: IObjectStoreIterator<DomainObjectData>): any;

	/**
	 * Set values of navigation props with changed IDs to __newValues
	 * @param changes
	 * @protected
	 */
	protected _updateRefIds(changes: SavedObjectData[]): void {
		changes.forEach((obj) => {
			let newId = obj.__newValues && obj.__newValues.id;
			if (!newId) { return; }

			let typeMeta: EntityMeta = this.meta.entities[obj.__metadata.type],
				propRefs: PropertyMeta[] = support.propRefsTo(typeMeta);
			changes.forEach((objRef) => {
				propRefs.forEach((propRef: PropertyMeta) => {
					if (objRef.__metadata.type !== propRef.entity.name) { return; }

					let val: string[]|string = objRef[propRef.name],
						newVal: string[]|string,
						idx: number;

					if (propRef.many && lang.isArray(val) && (idx = val.indexOf(obj.id)) >= 0) {
						newVal = (<string[]>val).slice();
						newVal[idx] = newId;
					} else if (!propRef.many && val === obj.id) {
						newVal = newId;
					}

					if (newVal) {
						objRef.__newValues = objRef.__newValues || {};
						objRef.__newValues[propRef.name] = newVal;
					}
				});
			});
		});
	}

	/**
	 * @protected
	 * @abstract
	 */
	protected abstract _commit(
		changes: SavedObjectData[]|SavedObjectData,
		iterator: IObjectStoreIterator<SavedObjectData>): any;

	protected _commitObj(obj: SavedObjectData, existent: StoredObjectData): StoredObjectData {
		if (!existent) {
			existent = lang.cloneEx(obj, { deep: true, exact: true });
			if (obj.__newValues) {
				lang.forEach(obj.__newValues, (v, name) => {
					if (this._isSpecialPropName(name)) { return; }
					existent[name] = v;
				});
				delete (<SavedObjectData>existent).__newValues;
			}
		} else {
			existent.__original = existent.__original || {};
			lang.forEach(obj, (v, name) => {
				if (this._isSpecialPropName(name)) { return; }
				let newVal = v;
				if (obj.__newValues && obj.__newValues.hasOwnProperty(name)) {
					newVal = obj.__newValues[name];
				}
				this._applyProp(name, existent, newVal, v);
			});
			if (obj.__newValues) {
				lang.forEach(obj.__newValues, (newVal, name) => {
					if (this._isSpecialPropName(name)) { return; }
					if (!obj.hasOwnProperty(name)) {
						this._applyProp(name, existent, newVal, newVal);
					}
				});
			}
		}

		if (obj.__newValues) {
			// update aux-objects
			if (obj.__newValues.__aux) {
				existent.__aux = lang.extend(existent.__aux || {}, obj.__newValues.__aux);
			}
			// update id
			if (obj.__newValues.id) {
				existent.id = obj.__newValues.id;
			}
		}

		//delete existent.__newValues;
		delete existent.__metadata.isNew;
		return existent;
	}
	protected _cacheObj(obj: DomainObjectData, existent: StoredObjectData): StoredObjectData {
		if (!existent) {
			existent = lang.cloneEx(obj, { deep: true, exact: true });
		} else {
			existent.__original = existent.__original || {};
			lang.forEach(obj, (v, name) => {
				if (this._isSpecialPropName(name)) { return; }
				this._applyProp(name, existent, v, v);
			});
		}

		return existent;
	}
	protected _applyProp(name: string, existent: StoredObjectData, newVal: any, curVal: any): void {
		if (!existent.__original.hasOwnProperty(name)) {
			existent[name] = newVal;
		} else if (!existent.hasOwnProperty(name) || lang.isEqual(curVal, existent[name])) {
			existent[name] = newVal;
			delete existent.__original[name];
		} else {
			// prop was changed after getChanges
			existent.__original[name] = newVal;
		}
	}
	protected _actualize(obj: DomainObjectData, existent: StoredObjectData): void {
		if (!existent) { return; }

		if (existent.__metadata.ts) {
			obj.__metadata.ts = existent.__metadata.ts;
		}

		if (existent.__metadata.isRemoved) {
			obj.__metadata.isRemoved = true;
		}

		lang.forEach(existent, (v, name) => {
			if (this._isSpecialPropName(name)) { return; }
			obj[name] = v;
		});

		// NOTE: __aux should not be actualized from cache
	}
	protected _isSpecialPropName(name: string): boolean {
		return name === "id" || lang.stringStartsWith(name, "__");
	}
	protected _hasObjChanges(obj: DomainObjectData): boolean {
		if (!obj) { return false; }
		return obj.__metadata.isNew || obj.__metadata.isRemoved || lang.some(obj.__original, (v, name) => {
			return !this._isSpecialPropName(name);
		});
	}
	protected _getObjChanges(obj: DomainObjectData): DomainObjectData {
		let that = this,
			ret: DomainObjectData = {
				__metadata: obj.__metadata,
				id: obj.id
			},
			typeMeta;

		if (!obj.__metadata.isRemoved) {
			typeMeta = that.meta.entities && that.meta.entities[obj.__metadata.type];
			lang.forEach(obj, (v, name) => {
				let propMeta;
				if (that._isSpecialPropName(name)) { return; }
				if (obj.__metadata.isNew || (obj.__original && obj.__original.hasOwnProperty(name))) {
					ret[name] = v;

					if (!obj.__metadata.isNew) {
						// copy original values of navigation sets
						propMeta = typeMeta && typeMeta.props && typeMeta.props[name];
						if (propMeta && propMeta.vt === "object" && propMeta.many) {
							ret.__original = ret.__original || {};
							ret.__original[name] = obj.__original[name];
						}
					}
				}
			});
		}

		return that._toUser(ret, { raw: true });
	}
	protected _toUser(obj: StoredObjectData, options?: FromStoreOptions): DomainObjectData {
		if (!obj) { return obj; }

		delete obj.__hasChanges;
		delete obj.__timestamp;

		if (!options || !options.raw) {
			delete obj.__original;
		}
		if (!options || !(options.keepFlags || options.raw)) {
			if (obj.__metadata.isNew) {
				// before returning new object set nulls for all empty props:
				let meta = this.meta.entities[obj.__metadata.type];
				lang.forEach(meta.props, (propMeta) => {
					if (obj[propMeta.name] === undefined) {
						obj[propMeta.name] = null;
					}
				});
				//propMeta = .props[source.propName];
			}
			delete obj.__metadata.isNew;
			delete obj.__metadata.isRemoved;
		}
		return obj;
	}
	/**
	 * Convert object for storing in DB.
	 * @param {Object} obj json object with data
	 * @param {Object} options
	 * @param {Boolean} [options.updateTs=false] true to update __timestamp field
	 * @returns {Object} object for storing in DB (can be used as parameter for 'put' method)
	 */
	protected _toDB(obj: StoredObjectData, options?: ToStoreOptions): StoredObjectData {
		if (!obj) { return obj; }

		obj.__hasChanges = this._hasObjChanges(obj) ? 1 : 0;
		if (options && options.updateTs) {
			obj.__timestamp = Date.now();
		}

		return obj;
	}
	protected _fromDB(obj: StoredObjectData): StoredObjectData {
		return obj;
	}
	protected _identity(obj: DomainObjectData[]): Identity[];
	protected _identity(obj: DomainObjectData): Identity;
	protected _identity(obj: DomainObjectData[]|DomainObjectData): any {
		if (!obj) { return obj; }
		return lang.select(obj, (o: DomainObjectData) => {
			this._throwIfNotValid(o);
			return { type: o.__metadata.type, id: o.id };
		});
	}
	protected _cacheQueryProp(source: LoadQuerySource, response: LoadResponse): Promise<void> {
		let that = this,
			propMeta: PropertyMeta,
			obj: SavedObjectData;

		if (!source.type || !source.id || !source.propName) { return lang.resolved(); }

		propMeta = that.meta.entities[source.type].props[source.propName];
		if (!propMeta) { return lang.resolved(); }

		obj = { __metadata: { type: source.type }, id: source.id };
		obj[source.propName] = lang.select(response.result, (o) => {
			if (propMeta.vt !== "object") { return o; }
			that._throwIfNotValid(o);
			return o.id;
		});
		return that.cache(obj, { skipMissing: true, partial: true });
	}
	protected _queryResponse(objects?: StoredObjectData[]|StoredObjectData, timestamp?: number): LoadResponse {
		if (!objects) {
			return { found: false };
		}
		let processObj = (obj: StoredObjectData): DomainObjectData => {
				if (!timestamp) {
					timestamp = obj.__timestamp;
				} else if (obj.__timestamp < timestamp) {
					timestamp = obj.__timestamp;
				}
				return this._toUser(obj);
			};
		let result: DomainObjectData = lang.select(objects, processObj);

		return {
			found: true,
			age: timestamp === -1 ? MAX_AGE : Date.now() - timestamp,
			result: result
		};
	}
	protected _queryValueResponse(v: any, timestamp: number): LoadResponse {
		if (v === undefined) {
			return { found: false };
		}

		return {
			found: true,
			age: timestamp === -1 ? MAX_AGE : Date.now() - timestamp,
			result: v
		};
	}
	protected _throwIfNotValid(obj: DomainObjectData): void {
		if (!obj) {
			throw new ReferenceError("Object is empty");
		}
		if (!obj.id) {
			throw  new Error("Attribute 'id' must be specified");
		}
		if (!obj.__metadata || !obj.__metadata.type) {
			throw new Error("Property '__metadata.type' must be specified");
		}
		this._throwIfTypeInvalid(obj.__metadata.type);
	}
	protected _throwIfTypeInvalid(type: string): void {
		if (!type) {
			throw new ReferenceError("Type is not specified");
		}
		if (!this.storedTypes[type]) {
			throw new Error("Type '" + type + "' can't be stored. It doesn't exists in the domain model or it is temporary.");
		}
	}
	protected _groupByType<T extends DomainObjectData>(objects: T[]|T): lang.Map<T[]> {
		let objectsArray: T[] = objects && lang.array(objects);
		if (!objectsArray || !objectsArray.length) { return {}; }

		return lang.groupBy(objectsArray, (obj) => {
			this._throwIfNotValid(obj);
			return obj.__metadata.type;
		});
	}
	protected _matchFilter(obj: StoredObjectData, filter: StoredObjectFilter): boolean {
		if ((filter.hasChanges !== undefined) && !filter.hasChanges !== !obj.__hasChanges) { return false; }
		if ((filter.isRemoved !== undefined) && !filter.isRemoved !== !obj.__metadata.isRemoved) { return false; }
		return true;
	}
	protected _getParamsForCache(params: LoadQueryParams): LoadQueryParams {
		if (!params || !params.$hints) {
			return params;
		}
		params = lang.clone(params);
		delete params.$hints;
		return params;
	}
	protected _getQueryType(query: LoadQuery, data: StoredResponse): string {
		return query.type || ((<Identity[]>data.result).length ? data.result[0].type : (<Identity>data.result).type);
	}
	protected _getQuerySource(query: LoadQuery): LoadQuerySource {
		let source = query.source;
		if (!source) { throw new Error("query.source should be specified"); }
		return lang.isString(source) ? { type: <string>source } : <LoadQuerySource>source;
	}
	/**
	 * @param {Array} types names of domain types
	 * @returns {Array} A string array: original types + ancestors
	 * @private
	 */
	protected _getAncestors(types: string[]): string[] {
		let map = {};
		types.forEach((type) => {
			map[type] = true;

			let meta = this.meta.entities[type];
			while (meta) {
				map[meta.name] = true;
				meta = meta.base;
			}
		});
		return Object.keys(map);
	}
}

// Wrap all public methods by `lang.async.wrap`. So they always return a Promise object
// and return rejected Promise instead of throwing error.
[ "save", "commit", "rollback", "overwrite", "remove", "cache" ].forEach((name) => {
	DataStoreBase.prototype[name] = lang.async.wrap(DataStoreBase.prototype[name]);
});

namespace DataStoreBase {
	export interface Options {
		recreate?: boolean;
		onversionchange?: (store: DataStoreBase, oldVersion: number, newVersion: number) => Promise<void>|void;
	}

	export interface StoredObjectData extends DomainObjectData {
		__hasChanges?: number;
		__timestamp?: number;

		__original?: {
			__metadata?: {
				type: string;
				ts?: number;
			};
			[key: string]: any
		};
	}

	export interface StoredResponse {
		result: Identity[]|Identity;
		hints?: lang.Map<any>;
		__timestamp?: number;
		__type?: string;
	}

	export interface StoredObjectFilter {
		/**
		 * Load objects with changes. Calling with hasChanges = false returns object without any changes.
		 */
		hasChanges?: boolean;
		/**
		 * Load removed objects. Calling with isRemoved = false returns object which are not removed.
		 */
		isRemoved?: boolean;
		/**
		 * Type of objects.
 		 */
		type?: string;
	}

	export interface LoadResponse extends interop.LoadResponse {
		found?: boolean | "unsync";
		age?: number;
	}

	export interface CacheOptions {
		/**
		 * Update source objects with data from Store
		 */
		actualize?: boolean;
		/**
		 * Ignore objects which can not be found in Store
		 */
		skipMissing?: boolean;
		/**
		 * Json data doesn't contains all properties loaded by default
		 */
		partial?: boolean;
	}

	export interface FromStoreOptions {
		/**
		 * Keep raw properties (__original, isNew, isRemoved)
		 */
		raw?: boolean;
		/**
		 * Keep boolean flags (isNew, isRemoved)
		 */
		keepFlags?: boolean;
	}

	export interface ToStoreOptions {
		/**
		 * Update __timestamp field
		 */
		updateTs?: boolean;
	}

	export interface IObjectStore {
		put(obj: StoredObjectData): void;
		delete(id: string): void;
	}

	export interface IObjectStoreIterator<T> {
		(store: IObjectStore, obj: T, existent: StoredObjectData): void;
	}
}

export = DataStoreBase;
