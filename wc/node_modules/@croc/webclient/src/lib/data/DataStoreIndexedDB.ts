import lang = require("lib/core.lang");
import DataStoreBase = require("lib/data/DataStoreBase");
import resources = require("i18n!lib/nls/resources");

import domain = require("lib/domain/.domain");
import interop = require("lib/interop/.interop");
import Deferred = lang.Deferred;
import Promise = lang.Promise;
import PropertyMeta = domain.metadata.PropertyMeta;
import ModelMeta = domain.metadata.ModelMeta;
import Identity = interop.Identity;
import DomainObjectData = interop.DomainObjectData;
import SavedObjectData = interop.SavedObjectData;
import StoredObjectData = DataStoreBase.StoredObjectData;
import StoredResponse = DataStoreBase.StoredResponse;
import StoredObjectFilter = DataStoreBase.StoredObjectFilter;
import LoadQuery = interop.LoadQuery;
import LoadQuerySource = interop.LoadQuerySource;
import LoadQueryParams = interop.LoadQueryParams;
import LoadResponse = DataStoreBase.LoadResponse;
import FromStoreOptions = DataStoreBase.FromStoreOptions;
import IObjectStore = DataStoreBase.IObjectStore;

interface IObjectStoreIterator<T> extends DataStoreBase.IObjectStoreIterator<T> {}

// NOTE: в TS 2.4 использование IDBTransactionMode обязательно, но в TS 2.2 он не определен, поэтому определим (это не мешает в 2.4):
type IDBTransactionMode = "readonly" | "readwrite" | "versionchange";

namespace indexedDBUtils {
	export const isSupported: boolean = !!window.indexedDB;

	function _deferredRequest(dbRequest: IDBRequest): Deferred<any> {
		let	deferred = lang.deferred();
		if (dbRequest.readyState === "done") {
			if (dbRequest.error) {
				deferred.reject(dbRequest.error);
			} else {
				deferred.resolve(dbRequest.result);
			}
		} else {
			on(dbRequest, "error", (e) => {
				// otherwise an error will appears in Mozilla Firefox
				e.preventDefault();

				let target: IDBRequest = <IDBRequest>e.target,
					error = (target.readyState === "done" && target.error) || e.type,
					tx = target.transaction;
				if (tx) {
					try {
						tx.abort();
					} catch (ex) {
					}
				}
				deferred.reject(error);
			});
		}
		return deferred;
	}

	function _execRequest(dbRequest: IDBRequest): Deferred<any> {
		let deferred = _deferredRequest(dbRequest);
		if (deferred.state() === "pending") {
			on(dbRequest, "success", (e) => {
				deferred.resolve((<IDBRequest>e.target).result);
			});
		}
		return deferred;
	}

	function _openRequest(openDbRequest: IDBOpenDBRequest): Deferred<any> {
		// NOTE: we can define 'onblocked' callback here, but what should we do in that callback?
		// 'blocked' isn't an error, it is just a notification of temporary lock
		return _execRequest(openDbRequest);
	}

	export function exec(dbRequest: IDBRequest): Promise<any> {
		let deferred = _execRequest(dbRequest);
		return deferred.promise();
	}

	/**
	 * Executes IDBRequest and waits for completion of its transaction
	 * @param dbRequest
	 * @param con
	 * @returns {Promise<any>}
	 */
	export function complete(dbRequest: IDBRequest, con: IDBConnection): Promise<any> {
		return _execRequest(dbRequest).then(result => {
			return con
				.completeTx(dbRequest.transaction)
				.then(() => result);
		});
	}

	/**
	 * Opens cursor, read all data from it and waits for completion of the request's transaction.
	 * @param cursorRequest
	 * @param con
	 * @returns {Promise<void>}
	 */
	export function fetch(cursorRequest: IDBRequest, con: IDBConnection): Promise<void> {
		let deferred = _deferredRequest(cursorRequest);
		if (deferred.state() === "pending") {
			on(cursorRequest, "success", (e) => {
				let cursor: IDBCursorWithValue = (<IDBRequest>e.target).result;
				if (cursor) {
					deferred.notify(cursor.value, cursor.primaryKey);
					cursor["continue"]();
				} else {
					con.completeTx(cursorRequest.transaction).then(() => {
						deferred.resolve();
					});
				}
			});
		}
		return deferred.promise();
	}

	/**
	 * Opens one or many cursors, read all data from them and waits for completion of all transactions.
	 * @param cursorRequests
	 * @param con
	 * @returns {Promise<void>}
	 */
	export function fetchMany(cursorRequests: IDBRequest[], con: IDBConnection): Promise<void> {
		let done = cursorRequests.length;
		if (done === 0) { return lang.resolved(); }
		if (done === 1) { return fetch(cursorRequests[0], con); }

		let deferred = lang.deferred<void>();
		for (let cursorRequest of cursorRequests) {
			fetch(cursorRequest, con)
				.done(() => {
					done--;
					if (!done) {
						deferred.resolve();
					}
				}).fail(function () {
					deferred.reject.apply(deferred, arguments);
				}).progress(function () {
					deferred.notify.apply(deferred, arguments);
				});
		}
		return deferred.promise();
	}

	export function openDB(name: string, version: number, onversionchange: Function): Promise<any> {
		var openDbRequest = window.indexedDB.open(name, version),
			deferred = _openRequest(openDbRequest);

		if (onversionchange) {
			on(openDbRequest, "upgradeneeded", function (e: IDBVersionChangeEvent) {
				onversionchange((<IDBOpenDBRequest>e.target).transaction, e.oldVersion, e.newVersion);
			});
			return deferred.promise();
		}
	}

	export function closeDB(db: IDBDatabase): void {
		db.close();
	}

	export function deleteDB(name: string): Promise<void> {
		let openDbRequest = window.indexedDB.deleteDatabase(name),
			deferred = _openRequest(openDbRequest);
		return deferred.promise();
	}

	export function completeTx(tx: IDBTransaction): Promise<void> {
		let deferred = lang.deferred<void>();
		on(tx, "complete", () => {
			deferred.resolve();
		});
		on(tx, "error abort", (e) => {
			e.preventDefault();
			deferred.reject((<IDBTransaction>e.target).error);
		});
		return deferred.promise();
	}

	export function on(target: IDBRequest|IDBTransaction, events: string, callback: EventListener): void {
		events.split(/\s+/).forEach((name) => {
			target.addEventListener(name, callback);
		});
	}
}

interface IDBConnection extends lang.IDisposable {
	db: Promise<IDBDatabase>;
	/**
	 *
	 * @param storeNames
	 * @param {"readonly" | "readwrite" | "versionchange"} mode
	 */
	beginTx(storeNames: string[], mode: IDBTransactionMode): Promise<IDBTransaction>;
	completeTx(tx: IDBTransaction): Promise<void>;
}

class DBConnection implements IDBConnection {
	store: DataStoreIndexedDB;
	db: Promise<IDBDatabase>;
	timeoutID: number;

	constructor(store: DataStoreIndexedDB, timeout?: number) {
		let that = this;
		that.store = store;
		that.db = indexedDBUtils.openDB(store.name, store.getFullVersion(), store._onupgrade.bind(store));
		that.dispose = DBConnection.prototype.dispose.bind(that);

		that.db.fail((error) => {
			that.store.onError(error);
		});

		// autoclose after timeout
		timeout = lang.isNumber(timeout) ? timeout : store.defaultTimeout;
		if (timeout > 0) {
			that.timeoutID = window.setTimeout(that.dispose, timeout);
		}
	}
	beginTx(storeNames: string[], mode: IDBTransactionMode): Promise<IDBTransaction> {
		return this.db.then((db) => {
			try {
				let tx = db.transaction(storeNames, mode);
				indexedDBUtils.on(tx, "error abort", (e) => {
					e.preventDefault();
					this.store.onError((<IDBTransaction>e.target).error);
				});
				return tx;
			} catch (ex) {
				this.store.onError(ex);
				return lang.rejected(ex);
			}
		});
	}
	completeTx(tx: IDBTransaction): Promise<void> {
		return indexedDBUtils.completeTx(tx);
	}
	dispose(): void {
		let that = this;
		if (that.db) {
			that.db.done(indexedDBUtils.closeDB);
			that.db = null;
		}
		if (that.timeoutID) {
			window.clearTimeout(that.timeoutID);
			that.timeoutID = null;
		}
	}
}

/**
 * Connection bound to specified transaction
 * @type {*}
 */
class TxDBConnection implements IDBConnection {
	tx: IDBTransaction;
	db: Promise<IDBDatabase>;

	constructor(store: DataStoreIndexedDB, tx: IDBTransaction) {
		this.tx = tx;
		this.db = lang.resolved(tx.db);

		indexedDBUtils.on(tx, "error abort", (e) => {
			store.onError((<IDBTransaction>e.target).error);
		});
	}
	beginTx(): Promise<IDBTransaction> {
		return lang.resolved(this.tx);
	}
	completeTx(tx: IDBTransaction): Promise<void> {
		if (tx !== this.tx) {
			throw new Error("TxDBConnection.completeTx get transaction different from its own");
		}
		return lang.resolved();
	}
	dispose(): void {
		this.db = null;
		this.tx = null;
	}
}

class DataStoreIndexedDB extends DataStoreBase {
	utils: typeof indexedDBUtils;
	queryStoreName: string;
	defaultTimeout: number;

	/**
	 * @constructs DataStoreIndexedDB
	 * @extends DataStoreBase
	 * @param {String} name DB name
	 * @param {String} version DB version
	 * @param {Object} domainModelMeta Domain model metadata
	 * @param {Object} [options]
	 */
	constructor(name: string, version: number, domainModelMeta: ModelMeta, options?: DataStoreBase.Options) {
		super(name, version, domainModelMeta, options);

		if (!this.isSupported)
			throw new Error("DataStore.ctor: indexedDB is not supported");

		if (this.options.recreate) {
			this.recreate();
		}
	}

	test(timeout?: number): Promise<IDBDatabase> {
		let con = this._createConnection(timeout);
		return con.db.always(con.dispose);
	}
	recreate(): Promise<IDBDatabase> {
		let that = this;
		return that.utils.deleteDB(that.name)
			.then(() => that.test(0)) // infinite timeout
			.fail(error => that.onError(error));
	}
	getFullVersion(): number {
		return (this.systemVersion << 24) + this.version; // high byte is systemVersion
	}
	/*protected*/ _onupgrade(tx, oldFullVersion, newFullVersion): void {
		let oldSystemVersion = oldFullVersion >> 24, // high byte
			newSystemVersion = newFullVersion >> 24, // high byte
			oldVersion = oldFullVersion & 0xFFFFFF, // 3 low bytes
			newVersion = newFullVersion & 0xFFFFFF; // 3 low bytes
		// upgrade system version
		if (newSystemVersion > oldSystemVersion) {
			this._onsysupgrade(tx, oldSystemVersion, newSystemVersion);
		}
		// upgrade application version
		if (newVersion > oldVersion) {
			this._onappupgrade(tx, oldVersion, newVersion);
		}
	}
	protected _onsysupgrade(tx: IDBTransaction, oldSystemVersion: number, newSystemVersion: number): void {
		let that = this,
			storeNames = Array.prototype.slice.call(tx.db.objectStoreNames),
			store, indexNames;

		if (storeNames.indexOf(that.queryStoreName) < 0) {
			store = tx.db.createObjectStore(that.queryStoreName);
		} else {
			store = tx.objectStore(that.queryStoreName);
		}

		indexNames = Array.prototype.slice.call(store.indexNames);
		if (indexNames.indexOf(that) < 0) {
			store.createIndex("__type", "__type");
		}
	}

	private _upgradingTx: IDBTransaction;

	protected _onappupgrade(tx: IDBTransaction, oldVersion: number, newVersion: number): Promise<void> {
		let that = this,
			dbStores = Array.prototype.slice.call(tx.db.objectStoreNames),
			modelStores = Object.keys(that.storedTypes),
			storesToDelete = lang.difference(dbStores, modelStores),
			storesToCreate = lang.difference(modelStores, dbStores),
			originalStoredTypes = that.storedTypes;

		// create new stores
		storesToCreate.forEach((name) => {
			let store = tx.db.createObjectStore(name, { keyPath: "id" });
			store.createIndex("__hasChanges", "__hasChanges");
		});

		// onversionchange callback should be executed into the same transaction.
		that._upgradingTx = tx;
		// add types from db
		that.storedTypes = lang.clone(originalStoredTypes);
		lang.forEach(tx.db.objectStoreNames, function (name) {
			if (name !== that.queryStoreName) {
				that.storedTypes[name] = true;
			}
		});

		let deferred = that.onversionchange(oldVersion, newVersion);
		return lang.when(deferred)
			// restore original values
			.always(function () {
				that._upgradingTx = undefined;
				that.storedTypes = originalStoredTypes;
			})
			// delete unused stores
			.done(function () {
				// NOTE: is IE10 skip store deletion because of bug:
				// https://connect.microsoft.com/IE/feedback/details/783672/indexeddb-getting-an-aborterror-exception-when-trying-to-delete-objectstore-inside-onupgradeneeded
				if (navigator.userAgent.match(/MSIE/i) != null) { return; }

				storesToDelete.forEach(function (name) {
					if (name !== that.queryStoreName) {
						tx.db.deleteObjectStore(name);
					}
				});
			});
	}

	/**
	 * Load an object
	 * @param type
	 * @param id
	 * @param options
	 * @param {Boolean} options.raw Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	load(type: string, id: string, options?: FromStoreOptions): Promise<DomainObjectData> {
		let that = this;
		that._throwIfTypeInvalid(type);

		let con = that._createConnection();
		return lang.async.chain(that._getObj(con, type, id))
			.always(con.dispose)
			.then((obj: StoredObjectData) => {
				return that._toUser(obj, options);
			})
			.value();
	}
	/**
	 * Load several objects
	 * @param identities
	 * @param options
	 * @param {Boolean} options.raw Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	loadMany(identities: Identity[], options?: FromStoreOptions): Promise<DomainObjectData[]> {
		let that = this;
		identities.forEach((identity) => {
			that._throwIfTypeInvalid(identity.type);
		});

		let con = that._createConnection();
		return lang.async.chain(that._getMany(con, identities))
			.always(con.dispose)
			.then(function (objects: StoredObjectData[]) {
				return objects.map((obj) => {
					return that._toUser(obj, options);
				});
			})
			.value();
	}
	/**
	 * Load all objects of specified type
	 * @param {Object|String} filter String value will be interpreted as a type
	 * @param {String} filter.type Type of objects to load
	 * @param {Boolean} [filter.hasChanges] Load objects with changes. Calling with hasChanges = false returns object without any changes.
	 * @param {Boolean} [filter.isRemoved] Load removed objects. Calling with isRemoved = false returns object which are not removed.
	 * @param [options]
	 * @param {Boolean} [options.raw] Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	select(filter: StoredObjectFilter|string, options?: FromStoreOptions): Promise<DomainObjectData[]> {
		let that = this,
			objects: DomainObjectData[] = [],
			objFilter: StoredObjectFilter = lang.isString(filter) ? { type: <string>filter } : <StoredObjectFilter>filter,
			con: IDBConnection;

		that._throwIfTypeInvalid(objFilter.type);

		con = that._createConnection();
		return lang.async.chain(con.beginTx([ objFilter.type ], "readonly"))
			.then((tx: IDBTransaction) => {
				let store = tx.objectStore(objFilter.type),
					cursorRequest = objFilter.hasChanges === undefined ?
						store.openCursor() :
						store.index("__hasChanges").openCursor(IDBKeyRange.only(objFilter.hasChanges ? 1 : 0));
				return that.utils.fetch(cursorRequest, con);
			})
			.progress((obj) => {
				if (!that._matchFilter(obj, objFilter)) { return; }

				obj = that._fromDB(obj);
				obj = that._toUser(obj, options);
				objects.push(obj);
			})
			.always(con.dispose)
			.then(() => {
				return objects;
			})
			.value();
	}

	/**
	 * Load all objects from the store. Use for debug only!
	 * @param options
	 * @param {Boolean} options.raw Keep raw properties (__original, isNew, isRemoved)
	 * @return {*}
	 */
	all(options?: FromStoreOptions): Promise<DomainObjectData[]> {
		let that = this,
			types = Object.keys(that.storedTypes),
			objects: DomainObjectData[] = [],
			con: IDBConnection = that._createConnection();

		return lang.async.chain(con.beginTx(types, "readonly"))
			.then((tx: IDBTransaction) => {
				let requests = types.map(function (type) {
					return tx.objectStore(type).openCursor();
				});
				return that.utils.fetchMany(requests, con);
			})
			.progress((obj) => {
				obj = that._fromDB(obj);
				obj = that._toUser(obj, options);
				objects.push(obj);
			})
			.always(con.dispose)
			.then(() => {
				return objects;
			})
			.value();
	}

	getChanges(): Promise<DomainObjectData[]> {
		let that = this,
			types = Object.keys(that.storedTypes),
			objects: DomainObjectData[] = [],
			con = that._createConnection();
		return lang.async.chain(con.beginTx(types, "readonly"))
			.then((tx: IDBTransaction) => {
				var requests = types.map(function (type) {
					var store = tx.objectStore(type),
						index = store.index("__hasChanges");
					return index.openCursor(IDBKeyRange.only(1));
					//return index.openCursor(1);
				});
				return that.utils.fetchMany(requests, con);
			})
			.progress((obj) => {
				obj = that._fromDB(obj);
				obj = that._getObjChanges(obj);
				objects.push(obj);
			})
			.always(con.dispose)
			.then(() => {
				return objects;
			})
			.value();
	}
	hasChanges(): Promise<boolean> {
		var that = this,
			types = Object.keys(that.storedTypes),
			count = 0,
			con = that._createConnection();
		return lang.async.chain(con.beginTx(types, "readonly"))
			.then((tx: IDBTransaction) => {
				var deferreds = types.map(function (type) {
					var store = tx.objectStore(type),
						index = store.index("__hasChanges");
					return that.utils.exec(index.count(1)).done(function (n) {
						count += n;
					});
				});
				return lang.when.apply(lang, deferreds)
					.then(() => con.completeTx(tx));
			})
			.always(con.dispose)
			.then(() => {
				return !!count;
			})
			.value();
	}

	/**
	 * Remove objects of specific 'type' which don't have unsaved changes
	 * @param {String} type
	 * @returns {*}
	 */
	clear(type: string): Promise<void> {
		this._throwIfTypeInvalid(type);
		let con = this._createConnection();
		return this._clear(con, type).always(con.dispose);
	}
	/**
	 * Remove objects from DataStore
	 * @param options
	 * @param {Boolean} options.includePending Remove or not objects with unsaved changes
	 * @returns {*}
	 */
	clearAll(options?: { includePending?: boolean }): Promise<void> {
		let types = Object.keys(this.storedTypes),
			con = this._createConnection(),
			tasks = types.map((type) => {
				return this._clear(con, type, options);
			});
		return lang.when.apply(lang, tasks).always(con.dispose);
	}

	cacheQuery(query: LoadQuery, response: LoadResponse): Promise<void> {
		if (!query || !query.source) { throw new Error("DataStore.cacheQuery: query.source should be specified"); }
		if (!response) { throw new Error("DataStore.cacheQuery: response should be specified"); }

		let that = this,
			source = that._getQuerySource(query),
			identities: Identity[],
			con: IDBConnection;

		if (source.propName) {
			return this._cacheQueryProp(source, response); // can throw
		}
		if (source.id) {
			return lang.resolved();
		}

		identities = that._identity(response.result); // can throw
		con = that._createConnection();

		return lang.async.chain(con.beginTx([ that.queryStoreName ], "readwrite"))
			.then((tx: IDBTransaction) => {
				let data: StoredResponse = {
						__timestamp: Date.now(),
						result: identities,
						hints: response.hints
					},
					key = that._getQueryKey(source, query.params),
					type = that._getQueryType(query, data),
					store = tx.objectStore(that.queryStoreName);
				if (type) {
					data.__type = type;
				}
				return that.utils.complete(store.put(data, key), con);
			})
			.always(con.dispose)
			.value();
	}

	query(query: LoadQuery): Promise<LoadResponse> {
		let that = this,
			source: LoadQuerySource = that._getQuerySource(query),
			con,
			deferred;

		con = that._createConnection();
		if (source.propName) {
			deferred = that._queryProp(con, source.type, source.id, source.propName);
		} else if (source.id) {
			deferred = that._queryObject(con, source.type, source.id);
		} else {
			deferred = that._queryObjects(con, source, query.params);
		}

		return lang.async.always(deferred, con.dispose);
	}

	_queryObject(con: IDBConnection, type: string, id: string): Promise<LoadResponse> {
		this._throwIfTypeInvalid(type);
		return this._getObj(con, type, id)
			.then((obj) => {
				return this._queryResponse(obj);
			});
	}
	_queryObjects(con: IDBConnection, source: LoadQuerySource, params: LoadQueryParams): Promise<LoadResponse> {
		let that = this,
			timestamp: number,
			hints: lang.Map<any>;

		return lang.async.chain(con.beginTx([ that.queryStoreName ], "readonly"))
			.then((tx: IDBTransaction) => {
				let store = tx.objectStore(that.queryStoreName),
					key = that._getQueryKey(source, params);
				return that.utils.complete(store.get(key), con);
			})
			.then((data: StoredResponse): Promise<StoredObjectData[]|StoredObjectData> => {
				let result = data && data.result;
				if (!result) {
					return undefined;
				}

				timestamp = data.__timestamp;
				hints = data.hints;
				return lang.isArray(result) ?
					that._getMany(con, result) :
					that._getObj(con, result.type, (<Identity>result).id);
			})
			.then((result: StoredObjectData[]|StoredObjectData) => {
				let response = that._queryResponse(result, timestamp);
				response.hints = hints;
				return response;
			})
			.value();
	}
	_queryProp(con: IDBConnection, type: string, id: string, prop: string): Promise<LoadResponse> {
		let that = this,
			timestamp: number,
			isObject: boolean;
		that._throwIfTypeInvalid(type);

		return lang.async.chain(that._getObj(con, type, id))
			.then((obj: StoredObjectData) => {
				var v,
					propMeta: PropertyMeta = that.meta.entities[type].props[prop],
					identities: Identity[];
				if (!obj || !propMeta || (v = obj[prop]) === undefined) { return undefined;	}

				timestamp = obj.__timestamp;
				if (propMeta.vt !== "object") {	return v; }
				if (v === null) { return propMeta.many ? [] : null;	}

				isObject = true;
				if (!propMeta.many) {
					return that._getObj(con, propMeta.ref.name, v);
				} else {
					//identities = lang.select(v, function (id) {
					//	return { type: propMeta.ref.name, id: id };
					//});
					identities = (<string[]>v).map(function (id) {
						return { type: propMeta.ref.name, id: id };
					});
					return that._getMany(con, identities)
						.then((objects) => {
							return objects.length === identities.length ? objects : undefined;
						});
				}
			})
			.then((result: StoredObjectData[]|StoredObjectData) => {
				return isObject ?
					that._queryResponse(result, timestamp) :
					that._queryValueResponse(result, timestamp);
			})
			.value();
	}
	_getQueryKey(source: LoadQuerySource, params: LoadQueryParams): string {
		// NOTE: IE10 doesn't support array keys
//			return [
//				JSON.stringify(source),
//				JSON.stringify(params || "")
//			];
		return JSON.stringify({
			source: source,
			params: this._getParamsForCache(params)
		});
	}
	_clear(con: IDBConnection, type: string, options?: { includePending?: boolean }): Promise<void> {
		return lang.async.then(
			con.beginTx([ type ], "readwrite"),
			(tx) => {
				let store = tx.objectStore(type);
				if (options && options.includePending) {
					return this.utils.complete(store.clear(), con);
				} else {
					let index = store.index("__hasChanges");
					return this.utils.fetch(index.openCursor(0), con)
						.progress((obj, key) => {
							this.utils.exec(store["delete"](key));
						});
				}
			});
	}
	protected _getObj(con: IDBConnection, type: string, id: string): Promise<StoredObjectData> {
		this._throwIfTypeInvalid(type);
		return lang.async.chain(con.beginTx([ type ], "readonly"))
			.then((tx: IDBTransaction) => {
				let store = tx.objectStore(type);
				return this.utils.complete(store.get(id), con);
			})
			.then((obj: StoredObjectData) => {
				return this._fromDB(obj);
			})
			.value();
	}
	protected _getMany(con: IDBConnection, identities: Identity[]): Promise<StoredObjectData[]> {
		let result: StoredObjectData[] = [],
			objectsByType = lang.groupBy(identities, (identity) => {
				this._throwIfTypeInvalid(identity.type);
				return identity.type;
			});

		return this._iterate(con, objectsByType, (store, obj, existent) => {
			if (existent && !existent.__metadata.isRemoved) {
				result.push(existent);
			}
		}).then(() => {
			return result;
		});
	}
	protected _update(
		objects: DomainObjectData[]|DomainObjectData,
		iterator: IObjectStoreIterator<DomainObjectData>): Promise<void>
	{
		let objectsByType = this._groupByType(objects), // can throw
			con = this._createConnection();
		return this._iterate(con, objectsByType, iterator, "readwrite").always(con.dispose);
	}
	protected _iterate<T extends { id: string }>(
		con: IDBConnection,
		objectsByType: lang.Map<T[]>,
		iterator: IObjectStoreIterator<T>,
		txMode?: IDBTransactionMode): Promise<void>
	{
		let that = this,
			types = Object.keys(objectsByType);
		if (!types.length) { return lang.resolved(); }

		return lang.async.then(
			con.beginTx(types, txMode || "readonly"),
			(tx) => {
				lang.forEach(objectsByType, (objectsOfType, type) => {
					let store = tx.objectStore(type);
					lang.forEach(objectsOfType, function (obj) {
						that.utils
							.exec(store.get(obj.id))
							// NOTE to commented: iterator can start IDBRequests, but they must be executed
							// inside the transaction. And the transcation will complete only when all its requests
							// will be completed. So we must not explicitly wait for result of the iterator.
							//
							//.then(function (existent) {
							//	existent = that._fromDB(existent);
							//	var dbRequest = iterator.call(that, store, obj, existent);
							//	return dbRequest && that.utils.exec(dbRequest);
							//})
							.done((existent) => {
								existent = that._fromDB(existent);
								iterator.call(that, store, obj, existent);
							});
					});
				});
				return con.completeTx(tx);
			});
	}
	protected _commit(
		changes: SavedObjectData[]|SavedObjectData,
		iterator: IObjectStoreIterator<SavedObjectData>): Promise<void>
	{
		var that = this,
			objectsByType = that._groupByType(changes), // can throw
			types = that._getAncestors(Object.keys(objectsByType)),
			con;
		if (!types.length) { return lang.resolved(); }

		con = that._createConnection();
		return lang.async.chain(that._iterate(con, objectsByType, iterator, "readwrite"))
			.then(() => {
				return con.beginTx(that.queryStoreName, "readwrite");
			})
			.then((tx: IDBTransaction) => {
				let store = tx.objectStore(that.queryStoreName),
					index = store.index("__type"),
					requests = types.map(function (type) {
						//return index.openCursor(type);
						return index.openCursor(IDBKeyRange.only(type));
					});
				return that.utils.fetchMany(requests, con)
					.progress(function (query, key) {
						// NOTE: don't set to 0, because this is falsy value and will be ignored
						query.__timestamp = -1; // outdated
						return that.utils.exec(store.put(query, key));
					});
			})
			.always(con.dispose)
			.value();
	}
	_createConnection(timeout?: number): IDBConnection {
		return this._upgradingTx ?
			new TxDBConnection(this, this._upgradingTx) :
			new DBConnection(this, timeout);
	}

	/**
	 * @method
	 * @param {Object} error
	 * @param {String} error.name
	 * @param {String} error.message
	 * @param {Number} error.code
	 * @fires DataStoreIndexedDB#error
	 * @async-debounce throttle=100
	 */
	onError(error: any/*DOMError|DOMException|Error*/): void {
		let message: string,
			newError: Error;

		message = resources["datastore.error.raw"];
		if (error.message) {
			message += ": " + error.message;
		} else if (error.name) {
			message += " (" + error.name + ")";
		} else if (error.code) {
			message += " (code = " + error.code + ")";
		}

		newError = new Error(message);
		newError.name = error.name || "Error";

		console.error(newError);

		/**
		 * Error happened.
		 * @event DataStoreIndexedDB#error
		 * @type {Error}
		 * @property {String} name Error name
		 * @property {String} message Error description
		 */
		this.trigger("error", newError);
	}
}

DataStoreIndexedDB.mixin({
	utils: indexedDBUtils,
	isSupported: indexedDBUtils.isSupported,
	queryStoreName: "__x_query",
	systemVersion: 2,
	defaultTimeout: 30000
});

[
	"test", "recreate", "load", "loadMany", "select", "all",
	"getChanges", "hasChanges", "clear", "clearAll", "cacheQuery", "query", "_get"
].forEach((name) => {
	DataStoreIndexedDB.prototype[name] = lang.async.wrap(DataStoreIndexedDB.prototype[name]);
});

DataStoreIndexedDB.prototype.onError = lang.debounce(DataStoreIndexedDB.prototype.onError);

export = DataStoreIndexedDB;
