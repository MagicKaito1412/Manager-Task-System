define(["require", "exports", "lib/core.lang", "./domain/support", "./domain/DomainObject", "./domain/UnitOfWork", "./domain/NotLoadedObject", "lib/domain/ComplexValue", "lib/validation", "lib/formatters"], function (require, exports, lang, support, DomainObject, UnitOfWork, NotLoadedObject, ComplexValue, validation, formatters) {
    "use strict";
    exports.__esModule = true;
    var enumMetaMethods = {
        parse: function (v) {
            var parser = validation.getParser(this.vt || "i4");
            if (parser) {
                var res = parser.tryParse(this, v);
                if (res.errorMsg) {
                    // NOTE: errorMsg can be string or SafeHtml
                    throw res.errorMsg;
                    //throw new Error(res.errorMsg);
                }
                v = res.parsedValue;
            }
            return v;
        },
        getMember: function (v) {
            for (var memberName in this.members) {
                var member = this.members[memberName];
                if (member.value === v) {
                    return member;
                }
                if (typeof v === "object" && v && v.toString() === member.value.toString()) {
                    return member;
                }
            }
            return null;
        },
        getMembers: function (v) {
            var members = [];
            for (var memberName in this.members) {
                var member = this.members[memberName];
                if (v === 0 && member.value === 0) {
                    return [member];
                }
                if (v !== 0 && member.value !== 0 && (v & member.value) === member.value) {
                    members.push(member);
                }
            }
            return members;
        },
        formatValue: function (v) {
            var result = v;
            if (!this.flags) {
                if (typeof v === "number") {
                    var member = this.getMember(v);
                    if (member) {
                        result = (member.descr || member.name);
                    }
                }
            }
            else {
                if (typeof v === "number") {
                    result = "";
                    var members = this.getMembers(v);
                    for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
                        var member = members_1[_i];
                        if (result)
                            result += ", ";
                        result += (member.descr || member.name);
                    }
                }
            }
            return result;
        }
    };
    /**
     * @typedef {Object} DomainModelMeta
     * @description Domain model json metadata. It's a json object generated by JsDomainEngineer tool.
     * @global
     * @property {Object} enums
     * @property {Object} complex
     * @property {Object} entities
     */
    /**
     * @typedef {Object} DomainModel
     * @description Domain model. It's runtime representation of model initialized from json (`DomainModelMeta`)
     * @global
     * @property {DomainModelMeta} meta
     * @property {ObjectFactory} factory
     * @property {Class} DomainObject
     * @property {Class} UnitOfWork
     */
    /**
     * @class MetadataGenerator
     */
    var MetadataGenerator = (function () {
        function MetadataGenerator() {
        }
        /**
         * Generate runtime representation of domain model.
         * @param {ModelMetaSpec} rawMetadata
         * @returns {ModelMeta}
         */
        MetadataGenerator.prototype.generate = function (rawMetadata) {
            this.raw = rawMetadata || {};
            this.meta = {
                enums: {},
                complex: {},
                entities: {}
            };
            this.preprocess();
            this.postprocess();
            return this.meta;
        };
        MetadataGenerator.prototype.preprocess = function () {
            var that = this;
            if (that.raw.enums) {
                lang.forEach(that.raw.enums, that.preprocessEnum, that);
            }
            if (that.raw.complex) {
                lang.forEach(that.raw.complex, that.preprocessComplex, that);
            }
            if (that.raw.entities) {
                lang.forEach(that.raw.entities, that.preprocessEntity, that);
            }
        };
        MetadataGenerator.prototype.preprocessEnum = function (enumRaw, enumName) {
            var enumeration = lang.appendEx({
                name: enumName,
                /** @obsolete use kind */
                type: "enum",
                kind: "enum",
                model: this.meta,
                descr: enumRaw.descr || enumName,
                members: {}
            }, enumMetaMethods, enumRaw, { except: ["members"] });
            if (enumeration.flags) {
                enumeration.fullMask = 0;
            }
            if (enumRaw.members) {
                lang.forEach(enumRaw.members, function (memberRaw, memberName) {
                    if (memberRaw.value === null || memberRaw.value === undefined) {
                        throw new Error("Для члена '" + memberName + "'перечисления '" + enumName + "' не задан атрибут value");
                    }
                    var member = lang.append({
                        name: memberName,
                        parent: enumeration,
                        descr: memberRaw.descr || memberName
                    }, memberRaw);
                    if (enumeration.flags) {
                        enumeration.fullMask = enumeration.fullMask | member.value;
                    }
                    enumeration.members[memberName] = member;
                });
            }
            this.meta.enums[enumName] = enumeration;
        };
        MetadataGenerator.prototype.preprocessComplex = function (complexRaw, complexName) {
            var complex = lang.append({
                name: complexName,
                kind: "complexType",
                /** @obsolete use kind */
                type: "complex",
                model: this.meta,
                descr: complexRaw.descr || complexName,
                props: {}
            }, complexRaw);
            if (complexRaw.props) {
                lang.forEach(complexRaw.props, function (propRaw, propName) {
                    if (!propRaw.vt) {
                        throw new Error("Для свойства '" + propName + "' в составном типе '" + complexName + "' не задан атрибут vt ");
                    }
                    var prop = lang.append({
                        name: propName,
                        parent: complex,
                        descr: propRaw.descr || propName
                    }, propRaw);
                    complex.props[propName] = prop;
                });
            }
            this.meta.complex[complexName] = complex;
        };
        MetadataGenerator.prototype.preprocessEntity = function (entityRaw, entityName) {
            var entity = lang.append({
                name: entityName,
                /** @obsolete use kind */
                type: "entity",
                kind: "entity",
                model: this.meta,
                descr: entityRaw.descr || entityName,
                formatters: entityRaw.formatters || {},
                props: {},
                declared: {},
                complex: {},
                derived: {} // описатели непосредственных классов-наследников
            }, entityRaw);
            if (entityRaw.props) {
                lang.forEach(entityRaw.props, function (propRaw, propName) {
                    if (!propRaw.vt) {
                        throw new Error("Для свойства '" + propName + "' в типе '" + entityName + "' не задан атрибут vt ");
                    }
                    var prop = lang.append({
                        name: propName,
                        parent: entity,
                        entity: entity,
                        descr: propRaw.descr || propName
                    }, propRaw);
                    if (propRaw.vt === "complex") {
                        entity.complex[propName] = prop;
                    }
                    else {
                        entity.props[propName] = prop;
                        entity.declared[propName] = prop;
                    }
                });
            }
            this.meta.entities[entityName] = entity;
        };
        MetadataGenerator.prototype.postprocess = function () {
            var that = this;
            // post-process complex types
            lang.forEach(that.meta.complex, function (complex) {
                that.postprocessComplex(complex);
            });
            // post-process entities
            lang.forEach(that.meta.entities, function (entity) {
                that.postprocessEntity(entity);
            });
            // post-process hierarchies
            lang.forEach(that.meta.entities, function (entity) {
                // NOTE: при пост-обработке дочерних сущностей родительские сущности уже должны быть обработаны.
                // Поэтому здесь запускаем пост-обработку только корневых сущностей в иерархиях наследования,
                // дочерние сущности будут обработаны рекурсивно.
                if (!entity.base) {
                    that.postprocessEntityInheritance(entity);
                }
            });
            // set up types default formatters
            lang.forEach(that.meta.entities, function (entity) {
                that.setupFormatter(entity);
            });
        };
        MetadataGenerator.prototype.postprocessComplex = function (complex) {
            var _this = this;
            lang.forEach(complex.props, function (prop) {
                // modify text references to objects
                _this.postprocessPropRefs(prop);
            });
        };
        MetadataGenerator.prototype.postprocessEntity = function (entity) {
            var that = this;
            // set reference to base entity
            if (entity.base) {
                // NOTE: в данный момент entity - нечто среднее между EntityMeta и EntityMetaSpec
                entity.base = that.meta.entities[entity.base];
                entity.base.derived[entity.name] = entity;
            }
            // process complex properties
            lang.forEach(entity.complex, function (prop) {
                // modify text references to objects
                that.postprocessPropRefs(prop);
                // flatten complex properties (copy their valuable properties to entity)
                that.postprocessComplexProp(prop);
            });
            // обрабатываем значимые свойства
            lang.forEach(entity.declared, function (prop) {
                // modify text references to objects
                that.postprocessPropRefs(prop);
                // set up property format parsers
                if (!prop.tryParse) {
                    var parser_1 = validation.getParser(prop.vt);
                    if (parser_1) {
                        prop.tryParse = function (value, skipValidation) {
                            if (value === null || value === undefined) {
                                return undefined; // не меняем значение
                            }
                            if (value === "") {
                                return { parsedValue: null };
                            }
                            return parser_1.tryParse(this, value, skipValidation);
                        };
                    }
                }
                // set up property formatter
                if (!prop.formatter) {
                    var formatter_1 = formatters.getDefaultFormatter(prop);
                    if (formatter_1) {
                        prop.formatter = function (value) {
                            return formatter_1(prop, value);
                        };
                    }
                }
                // we want not-null facet to execute first
                var rules = [];
                if (!prop.nullable) {
                    rules.push(validation.facets.nullable);
                }
                // set up property facets
                for (var _i = 0, _a = Object.keys(validation.facets); _i < _a.length; _i++) {
                    var facetName = _a[_i];
                    if (facetName === "nullable") {
                        continue;
                    }
                    if (prop.hasOwnProperty(facetName) || prop.vt === facetName) {
                        rules.push(validation.facets[facetName]);
                    }
                }
                prop.rules = rules.concat(prop.rules || []);
                prop["clone"] = function () {
                    return lang.extend({}, this);
                };
            });
        };
        MetadataGenerator.prototype.setupFormatter = function (entity) {
            if (!entity.formatters["default"]) {
                // try to use a first not null string property's value as default presentation
                var firstStringProp_1 = lang.find(entity.props, function (prop) {
                    return prop.vt === "string" && !prop.nullable;
                });
                if (firstStringProp_1) {
                    var formatter = function () {
                        var result = this.get(firstStringProp_1.name);
                        if (result === support.values.NotAuthorizedPropValue) {
                            result = undefined;
                        }
                        return result;
                    };
                    entity.formatters["default"] = formatter;
                }
            }
        };
        MetadataGenerator.prototype.postprocessPropRefs = function (prop) {
            // заменим строковое имя типа комплексного свойства на ссылку на метаописатель типа
            if (prop.vt === "complex" && prop.ref && typeof prop.ref === "string") {
                var typeRef = this.meta.complex[prop.ref];
                if (!typeRef) {
                    throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown complex type '" + prop.ref + "'");
                }
                prop.ref = typeRef;
            }
            // заменим строковое имя типа навигируемого свойства на ссылку на метаописатель типа
            if (prop.vt === "object" && prop.ref && typeof prop.ref === "string") {
                var typeRef = this.meta.entities[prop.ref];
                if (!typeRef) {
                    throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown entity type '" + prop.ref + "'");
                }
                prop.ref = typeRef;
            }
            // заменим строковое имя обратного свойства на ссылку на метаописатель свойства
            if (prop.vt === "object" && prop.opposite && typeof prop.opposite === "string") {
                var propOpposite = prop.ref.props[prop.opposite];
                if (!propOpposite) {
                    throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown opposite property '" + prop.opposite + "' of type '" + prop.ref.name + "'");
                }
                prop.opposite = propOpposite;
            }
            // заменим строковое имя типа перечисления свойства на ссылку на метаописатель перечисления
            if (prop.vt === "enum" && prop.ref && typeof prop.ref === "string") {
                var typeRef = this.meta.enums[prop.ref];
                if (!typeRef) {
                    throw new Error("Error in domain model: property '" + prop.name + "' of type '" + prop.parent.name + "' refers to unknown enumeration '" + prop.ref + "'");
                }
                prop.ref = typeRef;
            }
        };
        MetadataGenerator.prototype.postprocessComplexProp = function (complexProp) {
            var _this = this;
            var entity = complexProp.entity, complex = complexProp.ref;
            lang.forEach(complex.props, function (prop) {
                var clonedProp = lang.append({
                    name: complexProp.name + "." + prop.name,
                    descr: complexProp.descr + "." + prop.descr,
                    complex: complexProp,
                    entity: complexProp.entity,
                    parent: complexProp.parent,
                    // новое свойство должно быть nullable, если исходное комплексное свойство nullable
                    nullable: complexProp.nullable || prop.nullable
                }, prop);
                if (prop.vt !== "complex") {
                    entity.props[clonedProp.name] = clonedProp;
                    entity.declared[clonedProp.name] = clonedProp;
                }
                else {
                    entity.complex[clonedProp.name] = clonedProp;
                    // рекурсивно разворачиваем вложенные комплексные свойства
                    _this.postprocessComplexProp(clonedProp);
                }
            });
        };
        MetadataGenerator.prototype.postprocessEntityInheritance = function (entity) {
            // копируем свойства из базового класса
            if (entity.base) {
                lang.forEach(entity.base.props, function (prop) {
                    if (!entity.props[prop.name]) {
                        entity.props[prop.name] = prop;
                    }
                    // NOTE: if an entity contains the same prop as its parent it means that the entity overrides it
                });
                lang.forEach(entity.base.complex, function (prop) {
                    entity.complex[prop.name] = prop;
                });
            }
            // рекурсивно обрабатываем все дочерние сущности
            lang.forEach(entity.derived, this.postprocessEntityInheritance, this);
        };
        return MetadataGenerator;
    }());
    /**
     * @class ObjectFactory
     */
    var ObjectFactory = (function () {
        function ObjectFactory() {
        }
        /**
         * Creates a typed instance of domain object
         * @param {Object} model Domain model
         * @param {String} typeName name of type
         * @param {String} [id] identifier
         * @returns {Object}
         */
        ObjectFactory.prototype.createObject = function (model, typeName, id) {
            // get factory function
            var ImplClass = model[typeName];
            if (!ImplClass)
                throw new Error("createObject: unknown type: " + typeName);
            return new ImplClass(id);
        };
        /**
         * Creates a stub for an empty domain object
         * @param {Object} model Domain model
         * @param {String} typeName name of type
         * @param {String} id identifier
         * @returns {Object}
         */
        ObjectFactory.prototype.createGhost = function (model, typeName, id) {
            var meta = model.meta.entities[typeName];
            return new NotLoadedObject(meta, id);
        };
        /**
         * Creates a stub for not authorized domain object
         * @param {Object} model Domain model
         * @param {String} typeName name of type
         * @param {String} id identifier
         * @returns {Object}
         */
        ObjectFactory.prototype.createNotAuthorized = function (model, typeName, id) {
            var ImplClass = model[typeName], notAuthTypeName = typeName + ".NotAuthorized", NotAuthClass = model[notAuthTypeName];
            if (!NotAuthClass) {
                NotAuthClass = (function (_super) {
                    __extends(class_1, _super);
                    function class_1(id) {
                        var _this = _super.call(this, id) || this;
                        var that = _this;
                        that.isLoaded = true;
                        that.isGhost = true;
                        that.isNotAuthorized = true;
                        var raw = support.values.NotAuthorizedPropValue.toJson();
                        for (var _i = 0, _a = Object.keys(that.meta.props); _i < _a.length; _i++) {
                            var name_1 = _a[_i];
                            that._propValues[name_1] = raw;
                        }
                        return _this;
                    }
                    class_1.prototype.toString = function () {
                        return support.values.NotAuthorizedPropValue.toString();
                    };
                    return class_1;
                }(ImplClass));
                model[notAuthTypeName] = NotAuthClass;
            }
            return new NotAuthClass(id);
        };
        // TODO:
        // createNull(model: IDomainModel, typeName: string, id: string): null {
        // 	return null;
        // }
        /**
         * Creates a typed instance of complex property's value
         * @param model
         * @param obj
         * @param propMeta
         */
        ObjectFactory.prototype.createComplex = function (model, obj, propMeta) {
            // get factory function
            var typeName = propMeta.ref.name;
            var ImplClass = model[typeName];
            if (!ImplClass)
                throw new Error("createComplex: unknown type: " + typeName);
            //return new ComplexValue(obj, propMeta);
            return new ImplClass(obj, propMeta);
        };
        return ObjectFactory;
    }());
    /**
     * @class ModelGenerator
     */
    var ModelGenerator = (function () {
        function ModelGenerator() {
        }
        /**
         * Generate runtime representation of domain model from json metadata (`DomainModelMeta`).
         * @param {DomainModelMeta} meta
         * @returns {IDomainModel}
         */
        ModelGenerator.prototype.generate = function (meta) {
            var that = this;
            /**
             *
             * @type {IDomainModel}
             */
            that.model = {
                /**
                 * @type {DomainModelMeta}
                 */
                meta: meta,
                /**
                 * @type {ObjectFactory}
                 */
                factory: new ObjectFactory(),
                // NOTE: для DomainObject и UnitOfWork создаем наследников, чтобы свободно определять дополнительные
                // методы, не рискуя пересечься с какой-нибудь другой моделью (возможно в тестах).
                DomainObject: (function (_super) {
                    __extends(class_2, _super);
                    /**
                     * @constructs DomainObjectEx
                     * @extends DomainObject
                     */
                    function class_2(id) {
                        var _this = _super.call(this, id) || this;
                        _this.init();
                        return _this;
                    }
                    /**
                     * Extension point. Method for adding custom initialization logic.
                     */
                    class_2.prototype.init = function () {
                        // переопределяется для добавления кастомной логики в конструктор
                    };
                    return class_2;
                }(DomainObject)),
                UnitOfWork: (function (_super) {
                    __extends(class_3, _super);
                    /**
                     * @param {IDataFacade} dataFacade
                     * @param {Object} [options]
                     * @param {boolean} [options.connected] Subscribe on DataFacade's 'update' event
                     * @class UnitOfWorkEx
                     * @extends UnitOfWork
                     */
                    function class_3(dataFacade, options) {
                        var _this = _super.call(this, that.model, dataFacade, options) || this;
                        _this.init();
                        return _this;
                    }
                    /**
                     * Extension point. Method for adding custom initialization logic.
                     */
                    class_3.prototype.init = function () {
                        // переопределяется для добавления кастомной логики в конструктор
                    };
                    return class_3;
                }(UnitOfWork))
            };
            lang.forEach(meta.entities, function (entity) {
                // NOTE: при генерации дочерних классов базовые классы уже должны быть сгенерированы.
                // Поэтому здесь запускаем генерацию только корневых классов в иерархиях наследования,
                // дочерние классы будут сгенерированы рекурсивно.
                if (!entity.base) {
                    that.genDomainClass(entity);
                }
                var name = entity.name;
                that.model.UnitOfWork.prototype["create" + name] = function (props) {
                    return this.create(name, props);
                };
            });
            lang.forEach(meta.complex, function (complex) {
                that.genComplexClass(complex);
            });
            lang.forEach(meta.enums, function (enumeration) {
                that.genDomainEnum(enumeration);
            });
            // Добавим специальные статические значения
            lang.extend(that.model, support.values);
            return that.model;
        };
        ModelGenerator.prototype.genDomainClass = function (entity, BaseClass) {
            var _this = this;
            BaseClass = BaseClass || this.model.DomainObject;
            var names = {};
            if (entity.complex) {
                Object.keys(entity.complex).forEach(function (name) {
                    names[name] = name;
                });
            }
            Object.keys(entity.props).forEach(function (name) {
                names[name] = name;
            });
            // generate class
            var DomainClass = (function (_super) {
                __extends(DomainClass, _super);
                function DomainClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                DomainClass.meta = entity;
                DomainClass.NAMES = names;
                return DomainClass;
            }(BaseClass));
            DomainClass.prototype.meta = entity;
            //DomainClass.prototype.NAMES = names;
            // generate properties (as get/set methods)
            lang.forEach(entity.declared, function (prop) {
                _this.genPropAccessor(DomainClass, prop.name);
            });
            lang.forEach(entity.complex, function (prop) {
                if (prop.entity === entity) {
                    _this.genPropAccessor(DomainClass, prop.name);
                }
            });
            this.model[entity.name] = DomainClass;
            // process derived classes
            lang.forEach(entity.derived, function (derivedEntity) {
                _this.genDomainClass(derivedEntity, DomainClass);
            });
        };
        ModelGenerator.prototype.genComplexClass = function (complex) {
            var _this = this;
            var ComplexClass = (function (_super) {
                __extends(ComplexClass, _super);
                function ComplexClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ComplexClass.meta = complex;
                return ComplexClass;
            }(ComplexValue));
            // generate properties (as get/set methods)
            lang.forEach(complex.props, function (prop) {
                _this.genPropAccessor(ComplexClass, prop.name);
            });
            this.model[complex.name] = ComplexClass;
        };
        ModelGenerator.prototype.genDomainEnum = function (enumeration) {
            var domainEnum = {
                meta: enumeration
            };
            lang.forEach(enumeration.members, function (member) {
                domainEnum[member.name] = member.value;
            });
            this.model[enumeration.name] = domainEnum;
        };
        ModelGenerator.prototype.genPropAccessor = function (Class, name) {
            Class.prototype[name] = function (v) {
                return !arguments.length
                    ? this.get(name)
                    : this.set(name, v);
            };
        };
        return ModelGenerator;
    }());
    function localizeType(name, type, resources) {
        var t = resources["model." + name];
        if (t) {
            type.descr = t;
        }
        lang.forEach(type.props, function (prop, propName) {
            var t = resources["model." + name + "." + propName];
            if (t) {
                prop.descr = t;
            }
        });
    }
    /**
     * Builds runtime domain model.
     * @param {Object} rawMetadata Json metadata
     * @returns {IDomainModel}
     */
    function buildModel(rawMetadata) {
        var metaGen = new MetadataGenerator(), meta = metaGen.generate(rawMetadata), modelGen = new ModelGenerator();
        return modelGen.generate(meta);
    }
    exports.buildModel = buildModel;
    function localize(meta, resources) {
        lang.forEach(meta.entities, function (type, name) {
            localizeType(name, type, resources);
        });
        lang.forEach(meta.complex, function (type, name) {
            localizeType(name, type, resources);
        });
        lang.forEach(meta.enums, function (type) {
            var t = resources["model." + type.name];
            if (t) {
                type.descr = t;
            }
            lang.forEach(type.members, function (prop) {
                var t = resources["model." + type.name + "." + prop.name];
                if (t) {
                    prop.descr = t;
                }
            });
        });
    }
    exports.localize = localize;
});
//# sourceMappingURL=domain.js.map