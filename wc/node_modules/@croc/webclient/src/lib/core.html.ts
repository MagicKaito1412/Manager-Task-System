import $ = require("jquery");
import lang = require("lib/core.lang");
import "vendor/jquery.scrollTo";

/**
 * @exports "core.html"
 */

export const $document = $(document);
export const $window = $(window);
export const $body = $(document.body);

export let isMobileDevice = undefined;	// NOTE: assigned in core.js after core.Platform initialized

declare global {
	export interface Window {
		preventWindowUnload(): void;
	}
}

let ignoreWindowUnload: boolean;
// NOTE: In Chrome a click on a "mailto:" link raises window's beforeunload/unload events.
// That's terrible as in beforeunload we unload all areas and regions.
// So here's a hack especially for Chrome:
// `preventWindowUnload` method sets a special flag (it should be called in mailto's onclick handler)
// and a beforeunload handler checks it later.
// We cannot just set and leave the flag as in other browsers
// (or even in Chrome if it changes its behavior later) it'll prevent our logic in beforeunload from execution.
// So we clear it via setTimeout.
window.preventWindowUnload = function () {
	ignoreWindowUnload = true;
	window.setTimeout(function () {
		ignoreWindowUnload = false;
	});
};

$window.bind("beforeunload", function (e) {
	if (ignoreWindowUnload) {
		e.stopImmediatePropagation();
		e.preventDefault();
		ignoreWindowUnload = false;
	}
});

// prevent opening dragged files in window
$document.on("drop dragover", function (e) {
	e.preventDefault();
});

function _isDisplayed (element): boolean {
	// fast-forward check for the current element
	if (element.style && element.style.display === "none")
		return false;

	let display = findEffectiveStyleProperty(element, "display");
	if (display === "none") return false;
	if (!element.parentNode) {
		// reach the root, if it's document that 'visible' otherwise it's a detached element (i.e. 'not-visible)
		return element === element.ownerDocument;
	}
	if (element.parentNode.style) {
		return _isDisplayed(element.parentNode);
	}
	return true;
}

export function isVisible (element: HTMLElement|JQuery): boolean;
/**
 * Determines if the specified element is visible.
 * An element can be rendered invisible by setting the CSS "visibility"
 * property to "hidden", or the "display" property to "none", either for the
 * element itself or one if its ancestors.  This method will fail if
 * the element is not present.
 * @description Code was borrowed from Selenium (http://svn.openqa.org/svn/selenium-on-rails/selenium-on-rails/selenium-core/scripts/selenium-api.js)
 * @param {HTMLElement|JQuery} element an HTMLDOMElement or jquery selector
 * @return {Boolean} true if the specified element is visible, false otherwise
 */
export function isVisible (element): boolean {
	let htmlElement = element.nodeType ? element : element[0];

	// DGF if it's an input tag of type "hidden" then it's not visible
	if (htmlElement.tagName && htmlElement.type) {
		if (htmlElement.tagName.toLowerCase() == "input" && (htmlElement as HTMLInputElement).type.toLowerCase() == "hidden") {
			return false;
		}
	}

	if (!_isDisplayed(htmlElement))
		return false;
	var visibility = findEffectiveStyleProperty(htmlElement, "visibility");
	return (visibility != "hidden");
}

export function findEffectiveStyleProperty (element: HTMLElement, property: string);
export function findEffectiveStyleProperty (element, property: string) {
	let effectiveStyle = findEffectiveStyle(element);
	let propertyValue = effectiveStyle[property];
	if (propertyValue === "inherit" && element.parentNode && element.parentNode.style) {
		return findEffectiveStyleProperty(element.parentNode, property);
	}
	return propertyValue;
}

export function findEffectiveStyle (element: HTMLElement): CSSStyleDeclaration {
	if (element.style == undefined) {
		return undefined; // not a styled element
	}
	if (window.getComputedStyle) {
		// DOM-Level-2-CSS
		return window.getComputedStyle(element, null);
	}
	if (element["currentStyle"]) {
		// non-standard IE alternative
		return element["currentStyle"];
		// TODO: this won't really work in a general sense, as
		//   currentStyle is not identical to getComputedStyle()
		//   ... but it's good enough for "visibility"
	}

	if (window.document.defaultView && window.document.defaultView.getComputedStyle) {
		return window.document.defaultView.getComputedStyle(element, null);
	}

	throw new Error("cannot determine effective stylesheet in this browser");
}

/**
 * Concatenates string and className using space as separator. Doesn't check for duplicates.
 * @param s
 * @param className
 * @returns {string}
 */
export function appendCssClass (s: string, className: string): string {
	return s ? s + " " + className : className;
}

/**
 * Concatenates string and className using space as separator. Doesn't modify input string if it already contains className.
 * @param s
 * @param className
 * @returns {string}
 */
export function addCssClass (s: string, className: string): string {
	if (!s) { return className; }
	let classes = s.split(" ");
	return classes.indexOf(className) >= 0 ? s : s + " " + className;
}

export function removeCssClass (s: string, className: string): string {
	if (!s) { return s; }
	let classes = s.split(" ");
	return lang.arrayRemove(classes, className) ? classes.join(" ") : s;
}

let _viewport = { height: 0, width: 0 };	// cache object for getDisplayViewport
/**
 * Return display viewport (display viewport defers from layout viewport on mobile device)
 * @returns {{height: Number, width: Number}}
 */
export function getDisplayViewport (): { height: number; width: number; } {
	_viewport.height = isMobileDevice ? window.innerHeight : this.$window.height();
	_viewport.width =  isMobileDevice ? window.innerWidth : this.$window.width();
	return _viewport;
}

let scrollAlignModes = {
	"top": "top",
	"bottom": "bottom",
	"center": "center"
};
/**
 * Scroll document to element
 * @param {Object|HTMLElement|jQuery} options an options or HTMLElement (see. options.element)
 * @param {HTMLElement|jQuery} options.element An element to scroll to
 * @param {String} [options.align="top"] align mode: "top", "bottom", "center"
 * @param {Number} [options.margin=0] margin for top/bottom align
 * @param {{top:Number,height:Number}} [options.viewport]
 * @param {Function} [options.onAfter] Function to be called after the scrolling ends
 */
export function scrollToElement (options: HTMLElement|JQuery|scrollToElement.Options): void {
	if (!options) return;

	let opts: scrollToElement.Options;
	if (options instanceof $ || options["nodeType"] !== undefined) {
		opts = { element: options as any };
	} else {
		opts = options as any;
	}

	if (!opts.element) return;

	let align = opts.align || "top";
	if (!scrollAlignModes[align]) throw new Error("html.scrollToElement: unknown align mode: " + align);

	let $element = $(opts.element),
		elementTop = $element.offset().top,
		elementHeight = $element.outerHeight(),
		viewportTop = this.$window.scrollTop(),
		viewportBottom = viewportTop + this.$window.height(),
		scrollTo: number;

	if (elementTop < viewportTop || elementTop + elementHeight > viewportBottom || opts.force) {
		// element is out of viewport, we need to scroll document to it
		if (align === "center") {
			scrollTo = elementTop  -
				((viewportBottom + viewportTop)/2 - viewportTop) + // the relative position of viewPort centre
				elementHeight/2;
		} else if (align === "top") {
			scrollTo = elementTop;
		} else if (align === "bottom") {
			scrollTo = elementTop + elementHeight - (viewportBottom-viewportTop);
		}

		$.scrollTo(scrollTo, 100, { easing: "swing", onAfter: opts.onAfter });
	} else if (opts.onAfter) {
		opts.onAfter();
	}
}
export namespace scrollToElement {
	export interface Options {
		element?: HTMLElement|JQuery;
		align?: "top" | "bottom" | "center";
		onAfter?: () => void;
		/**
		 * Scroll even if the element is visible in viewport
		 */
		force?: boolean;
	}
}

/**
 * Check whether document's root is wider than browser screen, i.e. there should be horizontal scrollbar (if "overflow-x:auto")
 * @returns {Boolean}
 */
export function isDocumentHScrollable(): boolean {
	if (isMobileDevice) {
		// "zoom" on mobile means viewports are not equals (see http://www.quirksmode.org/mobile/viewports2.html)
		return document.documentElement.clientWidth !== window.innerWidth;
	}
	try {
		// Taken from: http://stackoverflow.com/questions/6605367/how-do-i-detect-if-there-are-scrollbars-on-a-browser-window
		let root = document.compatMode === "BackCompat" ? document.body : document.documentElement;
		return root.scrollWidth > root.clientWidth;
	} catch (e) {}

	return false;
}

/**
 * Find focused DOM element
 * @returns {HTMLElement} focused DOM element or null
 */
export function focused(): Element {
	let element = document.activeElement;
	return (element && element.tagName !== "BODY" && (!document.hasFocus || document.hasFocus())) ? element : null;
}

/**
 * Collection of keyboard constants with some support functions
 */
export const keyCode = {
	BACKSPACE: 	8,
	TAB: 		9,

	ENTER: 	13,
	ESCAPE: 27,
	SPACE: 	32,

	PAGE_UP: 	33,
	PAGE_DOWN: 	34,
	END: 		35,
	HOME: 		36,

	LEFT: 	37,
	UP: 	38,
	RIGHT: 	39,
	DOWN:	40,

	INSERT:	45,
	DELETE:	46,

	NUM_0:	48,
	NUM_1:	49,
	NUM_2:	50,
	NUM_3:	51,
	NUM_4:	52,
	NUM_5:	53,
	NUM_6:	54,
	NUM_7:	55,
	NUM_8:	56,
	NUM_9:	57,

	C: 67,
	D: 68,
	F: 70,

	NUMPAD_MULTIPLY: 106,
	NUMPAD_ADD:		 107,
	NUMPAD_ENTER:	 108,
	NUMPAD_SUBTRACT: 109,
	NUMPAD_DECIMAL:	 110,
	NUMPAD_DIVIDE:	 111,

	COMMA:	188,
	PERIOD:	190,

	F1: 112,
	F2: 113,
	F3: 114,
	F4: 115,
	F5: 116,
	F6: 117,
	F7: 118,
	F8: 119,
	F9: 120,
	F10: 121,
	F11: 122,
	F12: 123,

	/**
	 * Return true if key in keyboard event is keyboard navigation
	 * @param {Object} keyEvent - jQuery event
	 * @returns {boolean} true if key in event is keyboard navigation
	 */
	isNavigationKey: function(keyEvent: JQueryKeyEventObject): boolean {
		if (!keyEvent) { return false; }

		return [
			keyCode.TAB,
			keyCode.PAGE_UP,
			keyCode.PAGE_DOWN,
			keyCode.END,
			keyCode.HOME,
			keyCode.LEFT,
			keyCode.UP,
			keyCode.RIGHT,
			keyCode.DOWN
		].indexOf(keyEvent.which) >= 0;
	},

	isDigit: function(keyEvent: JQueryKeyEventObject): boolean {
		if (!keyEvent) { return false; }

		return [
			keyCode.NUM_0,
			keyCode.NUM_1,
			keyCode.NUM_2,
			keyCode.NUM_3,
			keyCode.NUM_4,
			keyCode.NUM_5,
			keyCode.NUM_6,
			keyCode.NUM_7,
			keyCode.NUM_8,
			keyCode.NUM_9
		].indexOf(keyEvent.which) >= 0;
	},

	isF: function(keyEvent:JQueryKeyEventObject): boolean {
		if (!keyEvent) { return false; }

		return [
			keyCode.F1,
			keyCode.F2,
			keyCode.F3,
			keyCode.F4,
			keyCode.F5,
			keyCode.F6,
			keyCode.F7,
			keyCode.F8,
			keyCode.F9,
			keyCode.F10,
			keyCode.F11,
			keyCode.F12
		].indexOf(keyEvent.which) >= 0;
	}
};

/**
 * Appends overlayer element (popup, dropdown ect.) to DOM in order to show it over other elements
 * @param {HTMLElement|jQuery} overlayer an element to overlay
 * @param {HTMLElement|jQuery} [owner] an element in main markup, which owns the overlayer (e.g. input element for dropdown)
 * @returns {jQuery} a target element where the 'overlayer' is appended to (if any) or an empty jQuery set.
 */
export function overlay (overlayer: JQuery|HTMLElement, owner?: JQuery|HTMLElement): JQuery {
	let $overlayer = $(overlayer),
		$owner,
		$target,
		zindexTarget,
		zindexOverlay;

	if (owner) {
		$owner = $(owner);
		// find any of html.overlay.targets
		$target = $owner.closest(overlay.targets.join(","));
	}

	if (!$target || !$target.length) {
		$overlayer.appendTo("body");
		return $(); // empty jQuery set
	}

	$overlayer.appendTo($target);

	// increase z-index
	zindexTarget = parseInt($target.css("z-index"), 10);
	zindexOverlay = parseInt($overlayer.css("z-index"), 10);
	if (!isNaN(zindexTarget) && !isNaN(zindexOverlay)) {
		$overlayer.css("z-index", zindexTarget + zindexOverlay);
	}

	return $target;
}

export declare namespace overlay {
	export let targets: string[];
}
/**
 * The extensible list of selectors which can host overlayers
 * @type {Array}
 */
overlay.targets = [];

export function notifyDOMChanged (element?: JQuery|HTMLElement): void {
	// NOTE: currently we're just firing the custom event on the document.
	// It can be changed in the future: firing the event on the source element itself and then bubbling to the document.
	if (element) {
		$(element).trigger("domChanged");
	} else {
		$document.trigger("domChanged");
	}
}

export interface DOMChangedEventData {
	binding?: boolean;
}

class WindowResizeEvent extends lang.Event {
	private _onResizeDebounced: (e: any) => void;

	constructor() {
		super($window);
	}

	onResize (e): void {
		this.trigger(e);
	}

	onFirstBind (): void {
		let that = this;
		that._onResizeDebounced = lang.debounce(that.onResize.bind(that), 100);
		$window.bind("resize", that._onResizeDebounced);
	}

	onLastUnbind (): void {
		$window.unbind("resize", this._onResizeDebounced);
	}
}
/**
 * Global debounced event 'window.resize'
 */
export const windowResize = new WindowResizeEvent();

export function isExternalClick (e: JQueryEventObject): boolean {
	if (e.currentTarget && (e.currentTarget as HTMLElement).tagName === "A" &&
		(e.ctrlKey || e.shiftKey || e.altKey || e.which > 1)) {
		// if user clicks a link with ctrl/shift/alt/wheel then let the browser to process the click
		// NOTE: left mouse button = 1, but in IE8 it's always 0!
		let href = $(e.currentTarget).attr("href");
		if (href && href !== "#") {
			return true;
		}
	}
	return false;
}
